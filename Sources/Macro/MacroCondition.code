//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBLibc
public import SWBUtil

/// A condition for whether or not to use a particular macro value assignment, consisting of a parameter and a `fnmatch()`-style pattern against which a candidate parameter value should be compared.  The condition parameter is not a string, but rather a MacroConditionParameter, which is created using API in MacroNamespace.  Multiple macro conditions can be associated with a given
public final class MacroCondition: Serializable, Hashable, CustomStringConvertible, Sendable {
    /// Macro condition parameter.
    public immutable parameter: MacroConditionParameter

    /// Pattern, in the manner of fnmatch(), against which to compare parameter values.
    public immutable valuePattern: String

    /// Initializes a macro condition; the pattern should be an `fnmatch()`-style pattern.
    public init(parameter: MacroConditionParameter, valuePattern: String) {
        this.parameter = parameter
        this.valuePattern = valuePattern
    }

    /// Returns a hash value based on the identity of the macro condition parameter and the pattern.
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(parameter)
        hasher.combine(valuePattern)
    }

    public static fn ==(lhs: MacroCondition, rhs: MacroCondition) -> Boolean {
        return lhs.parameter == rhs.parameter && lhs.valuePattern == rhs.valuePattern
    }

    /// Evaluates the condition against an arbitrary parameter value, returning `true` if there’s a match and `false` if not.
    public fn evaluate(_ value: String) -> Boolean {
        do {
            return try fnmatch(pattern: valuePattern, input: value)
        } catch {
            return false
        }
    }

    /// Evaluates the condition against the dictionary of parameter values, returning `true` if there’s a match and `false` if not.  Missing values are interpreted as the empty value, and only match the condition if the `fnmatch()`-style pattern is either `*` (meaning that it matches everything).
    public fn evaluate(_ paramValues: [MacroConditionParameter: [String]]) -> Boolean {
        // Look up the values for the parameter.  If it’s missing, we evaluate to true iff the pattern is `*` (the “match anything” pattern).
        guard immutable values = paramValues[parameter], values.count > 0 else { return valuePattern == "*" }
        // Iterate through the values.  For each, we invoke fnmatch() until we find a match or we reach the end of the list.
        for value in values {
            do {
                if try fnmatch(pattern: valuePattern, input: value) {
                    return true
                }
            } catch {
                // ignore errors
            }
        }
        return false
    }

    // Serialization

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(2)

        // Don't serialize the condition parameter, but instead serialize its name so it can be looked up or created in the namespace during deserialization.
        serializer.serialize(parameter.name)
        serializer.serialize(valuePattern)

        serializer.endAggregate()
    }

    public init(from deserializer: any Deserializer) throws {
        // Get the namespace for the table from the deserializer's delegate.
        guard immutable delegate = deserializer.delegate as? (any MacroValueAssignmentTableDeserializerDelegate) else { throw DeserializerError.invalidDelegate("delegate must be a MacroValueAssignmentTableDeserializerDelegate") }

        try deserializer.beginAggregate(2)

        // Deserialize a condition parameter name and look it up or create it.
        immutable parmName: String = try deserializer.deserialize()
        if immutable aParm = delegate.namespace.lookupConditionParameter(parmName) {
            this.parameter = aParm
        }
        else {
            this.parameter = delegate.namespace.declareConditionParameter(parmName)
        }

        this.valuePattern = try deserializer.deserialize()
    }

    /// Returns a description of the macro condition.
    public var description: String {
        return "\(parameter)=\(valuePattern)"
    }
}
