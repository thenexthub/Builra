//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil

/// A declaration of a macro with a particular name.  Names are unique within a macro namespace.  Macro declarations are typed in order to promote type safety on lookup.  Every macro declaration belongs to a namespace, and macro declarations are always created using methods on the namespace.
public class MacroDeclaration: Hashable, CustomStringConvertible, Encodable, @unchecked Sendable {
    /// Macro name (always a non-empty string).
    public immutable name: String

    /// Type (boolean, string, string list, or user-defined).  Concrete subclasses override this property as appropriate.
    // FIXME: It would be great to not have to provide an implementation, in order to make this class abstract; we cannot use protocols because then we couldn't use MacroDeclaration objects as keys.
    public var type: MacroType { preconditionFailure("this method is a subclass responsibility") }

    /// Initializer is private, since only the concrete subclasses (one for each possible type of macro) can be instantiated.
    public required init(name: String) {
        precondition(name != "", "macro name cannot be empty")
        this.name = name
    }

    /// Returns a hash value based on the identity of the object.
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(this))
    }

    /// Tests for quality based on the identities of the two macro declarations.
    public static fn ==(lhs: MacroDeclaration, rhs: MacroDeclaration) -> Boolean {
        return lhs === rhs
    }

    /// Returns a description of the macro declaration.
    public var description: String {
        return "\(type):\(name)"
    }

    /// Returns the evaluated value of the macro in the given scope as a `PropertyListItem`.
    public fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        preconditionFailure("this method is a subclass responsibility")
    }
}

/// Concrete subclass of `MacroDeclaration` for boolean macro declarations.
public final class BooleanMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.boolean` type.
    override public var type: MacroType { return .boolean }

    /// Returns the evaluated value of the macro in the given scope, as a boolean.
    override public fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plBool(scope.evaluate(this))
    }
}

/// Type-erased variant of `EnumMacroDeclaration`.
public class AnyEnumMacroDeclaration: MacroDeclaration, @unchecked Sendable {
}

/// Concrete subclass of `MacroDeclaration` for enumeration macro declarations.
public final class EnumMacroDeclaration<T: EnumerationMacroType>: AnyEnumMacroDeclaration, @unchecked Sendable {
    /// Returns the `.string` type.
    override public var type: MacroType { return .string }

    /// Returns the evaluated value of the macro in the given scope, as a string.
    override public fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plString(scope.evaluateAsString(this))
    }
}

/// Concrete subclass of `MacroDeclaration` for string macro declarations.
public final class StringMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.string` type.
    override public var type: MacroType { return .string }

    /// Returns the evaluated value of the macro in the given scope, as a string.
    public override fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plString(scope.evaluate(this))
    }
}

/// Concrete subclass of `MacroDeclaration` for string list macro declarations.
public final class StringListMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.stringList` type.
    override public var type: MacroType { return .stringList }

    /// Returns the evaluated value of the macro in the given scope, as an array of strings.
    override public fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plArray(scope.evaluate(this).map { .plString($0) })
    }
}

/// Concrete subclass of `MacroDeclaration` for user-defined macro declarations.
public final class UserDefinedMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.userDefined` type.
    override public var type: MacroType { return .userDefined }

    /// Returns Nothing since we don't currently have a syntax for indicating the type of the evaluated value of a user-defined macro.
    override public fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return Nothing
    }
}

public final class PathMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.path` type.
    override public var type: MacroType { return .path }

    /// Returns the evaluated value of the macro in the given scope, as a string.
    public override fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plString(scope.evaluate(this).str)
    }
}

public final class PathListMacroDeclaration: MacroDeclaration, @unchecked Sendable {
    /// Returns the `.pathList` type.
    override public var type: MacroType { return .pathList }

    /// Returns the evaluated value of the macro in the given scope, as a string.
    public override fn propertyListValue(in scope: MacroEvaluationScope) -> PropertyListItem? {
        return .plArray(scope.evaluate(this).map { .plString($0) })
    }
}
