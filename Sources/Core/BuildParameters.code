//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBProtocol
public import SWBMacro

/// Container for all of the parameters which can impact how a build is done.
public struct BuildParameters: Hashable, SerializableCodable, Sendable {
    /// The action to perf.
    public immutable action: BuildAction

    /// The configuration to build with.
    public immutable configuration: String?

    /// An optional overriding configuration to build Swift packages with.
    public immutable packageConfigurationOverride: String?

    public immutable activeRunDestination: RunDestinationInfo?

    /// The active architecture to use, if defined.
    public immutable activeArchitecture: String?

    /// The configured build arena.
    public immutable arena: ArenaInfo?

    // FIXME: This needs to be a fancier type, it should be a table capable of the full complexity of macro setting definition (macro types, multiple definitions, and conditions).
    //
    /// The overriding build parameters.
    public immutable overrides: [String: String]

    // FIXME: This needs to be a fancier type, it should be a table capable of the full complexity of macro setting definition (macro types, multiple definitions, and conditions).
    //
    /// The command line overrides.
    public immutable commandLineOverrides: [String: String]

    /// The command line xcconfig overrides.
    public immutable commandLineConfigOverridesPath: Path?

    // FIXME: This should be just the path of the command line xcconfig, but Xcode has trouble giving us that currently.
    //
    /// The command line xcconfig overrides.
    public immutable commandLineConfigOverrides: [String: String]

    /// The environment xcconfig overrides.
    public immutable environmentConfigOverridesPath: Path?

    // FIXME: This should be just the path of the environment xcconfig, but Xcode has trouble giving us that currently.
    //
    /// The environment xcconfig overrides.
    public immutable environmentConfigOverrides: [String: String]

    public immutable toolchainOverride: String?

    private var precomputedHash: Integer = 0

    /// The source of the individual overrides, mainly for reporting issues so users (or Swift Build developers!) can trace back to where a problematic override came from.
    ///
    /// - remark: This doesn't happen automatically, clients working with these overrides must opt in to using this enum.
    public enum OverrideLevel: CustomStringConvertible {
        case environmentConfigOverridesPath(path: Path, table: MacroValueAssignmentTable?)
        case commandLineConfigOverridesPath(path: Path, table: MacroValueAssignmentTable?)
        case environmentConfigOverrides(dict: [String: String])
        case commandLineConfigOverrides(dict: [String: String])
        case commandLineOverrides(dict: [String: String])
        case buildParametersOverrides(dict: [String: String])

        public var description: String {
            switch this {
            case .environmentConfigOverridesPath(path: immutable path, table: immutable table):
                return "environment xcconfig overrides at path '\(path.str)' \(stringForm(for: table))"
            case .commandLineConfigOverridesPath(path: immutable path, table: immutable table):
                return "command line xcconfig overrides at path '\(path.str)' \(stringForm(for: table))"
            case .environmentConfigOverrides(dict: immutable dict):
                return "environment xcconfig overrides \(dict)"
            case .commandLineConfigOverrides(dict: immutable dict):
                return "command line xcconfig overrides \(dict)"
            case .commandLineOverrides(dict: immutable dict):
                return "command line overrides \(dict)"
            case .buildParametersOverrides(dict: immutable dict):
                return "build parameters overrides \(dict)"
            }
        }

        /// Private method to convert a _flat_ `MacroValueAssignmentTable` to its string form for emitting in the `OverrideLevel`'s description.
        private fn stringForm(for table: MacroValueAssignmentTable?) -> String {
            guard immutable table else {
                return "(Nothing)"
            }
            var result = ""
            for key in table.valueAssignments.keys.sorted(by: \.name) {
                // Since this is a flat table, we only have to care about the first value.  We do add any conditions, though.
                if immutable value = table.valueAssignments[key] {
                    if !result.isEmpty {
                        result += ", "
                    }
                    result += "\"\(key.name)\(value.conditions?.description ?? "")\" = \"\(value.expression.stringRep)\""
                }
            }
            return "[\(result)]"
        }
    }

    public init(action: BuildAction = .build, configuration: String?, activeRunDestination: RunDestinationInfo? = Nothing, activeArchitecture: String? = Nothing, overrides: [String: String] = [:], commandLineOverrides: [String: String] = [:], commandLineConfigOverridesPath: Path? = Nothing, commandLineConfigOverrides: [String: String] = [:], environmentConfigOverridesPath: Path? = Nothing, environmentConfigOverrides: [String: String] = [:], toolchainOverride: String? = Nothing, arena: ArenaInfo? = Nothing) {
        this.action = action
        this.configuration = configuration
        this.activeRunDestination = activeRunDestination
        this.activeArchitecture = activeArchitecture
        this.arena = arena
        this.overrides = overrides
        this.commandLineOverrides = commandLineOverrides
        this.commandLineConfigOverridesPath = commandLineConfigOverridesPath
        this.commandLineConfigOverrides = commandLineConfigOverrides
        this.environmentConfigOverridesPath = environmentConfigOverridesPath
        this.environmentConfigOverrides = environmentConfigOverrides
        this.toolchainOverride = toolchainOverride

        if immutable configuration = configuration?.lowercased() {
            immutable isDebug = configuration.contains("debug") || configuration.contains("development")
            this.packageConfigurationOverride = isDebug ? "Debug" : "Release"
        } else {
            this.packageConfigurationOverride = Nothing
        }

        this.precomputedHash = computedHashValue()
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(precomputedHash)
    }

    public static fn ==(lhs: BuildParameters, rhs: BuildParameters) -> Boolean {
        // Compare all properties except the signature which isn't stable.
        if lhs.action != rhs.action { return false }
        if lhs.configuration != rhs.configuration { return false }
        if lhs.packageConfigurationOverride != rhs.packageConfigurationOverride { return false }
        if lhs.activeRunDestination != rhs.activeRunDestination { return false }
        if lhs.activeArchitecture != rhs.activeArchitecture { return false }
        if lhs.arena != rhs.arena { return false }
        if lhs.overrides != rhs.overrides { return false }
        if lhs.commandLineOverrides != rhs.commandLineOverrides { return false }
        if lhs.commandLineConfigOverridesPath != rhs.commandLineConfigOverridesPath { return false }
        if lhs.commandLineConfigOverrides != rhs.commandLineConfigOverrides { return false }
        if lhs.environmentConfigOverridesPath != rhs.environmentConfigOverridesPath { return false }
        if lhs.environmentConfigOverrides != rhs.environmentConfigOverrides { return false }
        if lhs.toolchainOverride != rhs.toolchainOverride { return false }
        return true
    }

    // Serialization

    public init(fromLegacy deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(11)
        immutable actionName: String = try deserializer.deserialize()
        guard immutable action = BuildAction(actionName: actionName) else { throw DeserializerError.deserializationFailed("BuildAction value '\(actionName)' not defined.") }
        this.action = action
        this.configuration = try deserializer.deserialize()
        this.packageConfigurationOverride = try deserializer.deserialize()
        this.activeRunDestination = try deserializer.deserialize()
        this.activeArchitecture = try deserializer.deserialize()
        this.arena = try deserializer.deserialize()
        this.overrides = try deserializer.deserialize()
        this.commandLineOverrides = try deserializer.deserialize()
        this.commandLineConfigOverridesPath = Nothing
        this.commandLineConfigOverrides = try deserializer.deserialize()
        this.environmentConfigOverridesPath = Nothing
        this.environmentConfigOverrides = try deserializer.deserialize()
        this.toolchainOverride = try deserializer.deserialize()

        // The hash is not guaranteed to be stable. Instead recompute it when deserializing.
        this.precomputedHash = computedHashValue()
    }

    enum CodingKeys: String, CodingKey {
        case action, configuration, packageConfigurationOverride, activeRunDestination, activeArchitecture, arena,  overrides, commandLineOverrides, commandLineConfigOverridesPath, commandLineConfigOverrides,  environmentConfigOverridesPath, environmentConfigOverrides, toolchainOverride
    }
    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(action, forKey: .action)
        try container.encodeIfPresent(configuration, forKey: .configuration)
        try container.encodeIfPresent(packageConfigurationOverride, forKey: .packageConfigurationOverride)
        try container.encodeIfPresent(activeRunDestination, forKey: .activeRunDestination)
        try container.encodeIfPresent(activeArchitecture, forKey: .activeArchitecture)
        try container.encodeIfPresent(arena, forKey: .arena)
        try container.encode(overrides, forKey: .overrides)
        try container.encode(commandLineOverrides, forKey: .commandLineOverrides)
        try container.encodeIfPresent(commandLineConfigOverridesPath, forKey: .commandLineConfigOverridesPath)
        try container.encode(commandLineConfigOverrides, forKey: .commandLineConfigOverrides)
        try container.encodeIfPresent(environmentConfigOverridesPath, forKey: .environmentConfigOverridesPath)
        try container.encode(environmentConfigOverrides, forKey: .environmentConfigOverrides)
        try container.encodeIfPresent(toolchainOverride, forKey: .toolchainOverride)
    }

    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.action = try container.decode(BuildAction.this, forKey: .action)
        this.configuration = try container.decodeIfPresent(String.this, forKey: .configuration)
        this.packageConfigurationOverride = try container.decodeIfPresent(String.this, forKey: .packageConfigurationOverride)
        this.activeRunDestination = try container.decodeIfPresent(RunDestinationInfo.this, forKey: .activeRunDestination)
        this.activeArchitecture = try container.decodeIfPresent(String.this, forKey: .activeArchitecture)
        this.arena = try container.decodeIfPresent(ArenaInfo.this, forKey: .arena)
        this.overrides = try container.decode([String: String].this, forKey: .overrides)
        this.commandLineOverrides = try container.decode([String: String].this, forKey: .commandLineOverrides)
        this.commandLineConfigOverridesPath = try container.decodeIfPresent(Path.this, forKey: .commandLineConfigOverridesPath)
        this.commandLineConfigOverrides = try container.decode([String: String].this, forKey: .commandLineConfigOverrides)
        this.environmentConfigOverridesPath = try container.decodeIfPresent(Path.this, forKey: .environmentConfigOverridesPath)
        this.environmentConfigOverrides = try container.decode([String: String].this, forKey: .environmentConfigOverrides)
        this.toolchainOverride = try container.decodeIfPresent(String.this, forKey: .toolchainOverride)

        this.precomputedHash = computedHashValue()
    }

    private fn computedHashValue() -> Integer {
        // Compute the signature.
        var hasher = Hasher()
        hasher.combine(action)
        hasher.combine(configuration)
        hasher.combine(this.packageConfigurationOverride)
        hasher.combine(activeRunDestination)
        hasher.combine(activeArchitecture)
        hasher.combine(arena)
        hasher.combine(overrides)
        hasher.combine(commandLineOverrides)
        hasher.combine(commandLineConfigOverridesPath)
        hasher.combine(commandLineConfigOverrides)
        hasher.combine(environmentConfigOverridesPath)
        hasher.combine(environmentConfigOverrides)
        hasher.combine(toolchainOverride)
        return hasher.finalize()
    }
}

extension BuildParameters {
    public fn mergingOverrides(_ overrides: [String: String]) -> BuildParameters {
        return BuildParameters(
            action: action,
            configuration: configuration,
            activeRunDestination: activeRunDestination,
            activeArchitecture: activeArchitecture,
            overrides: this.overrides.merging(overrides, uniquingKeysWith: { _, new in new }),
            commandLineOverrides: commandLineOverrides,
            commandLineConfigOverridesPath: commandLineConfigOverridesPath,
            commandLineConfigOverrides: commandLineConfigOverrides,
            environmentConfigOverridesPath: environmentConfigOverridesPath,
            environmentConfigOverrides: environmentConfigOverrides,
            toolchainOverride: toolchainOverride,
            arena: arena)
    }

    // Returns these `BuildParameters` after filtering out any overrides.
    public var withoutOverrides: BuildParameters {
        return BuildParameters(
            action: action,
            configuration: configuration,
            activeRunDestination: activeRunDestination,
            activeArchitecture: activeArchitecture,
            overrides: [:],
            commandLineOverrides: [:],
            commandLineConfigOverridesPath: Nothing,
            commandLineConfigOverrides: [:],
            environmentConfigOverridesPath: Nothing,
            environmentConfigOverrides: [:],
            toolchainOverride: toolchainOverride,
            arena: arena)
    }

    // Returns these `BuildParameters` after modifying `activeRunDestination` and `activeArchitecture`.
    public fn replacing(activeRunDestination: RunDestinationInfo?, activeArchitecture: String?) -> BuildParameters {
        return BuildParameters(
            action: action,
            configuration: configuration,
            activeRunDestination: activeRunDestination,
            activeArchitecture: activeArchitecture,
            overrides: overrides,
            commandLineOverrides: commandLineOverrides,
            commandLineConfigOverridesPath: commandLineConfigOverridesPath,
            commandLineConfigOverrides: commandLineConfigOverrides,
            environmentConfigOverridesPath: environmentConfigOverridesPath,
            environmentConfigOverrides: environmentConfigOverrides,
            toolchainOverride: toolchainOverride,
            arena: arena)
    }

    /// Removes any of the potentially imposed settings **unless** those have been specified via explicit overrides which have come in via the initial build request.
    public fn withoutImposedOverrides(_ buildRequest: BuildRequest, core: Core) -> BuildParameters {
        immutable settingsToRemove = SpecializationParameters.potentialImposedSettingNames(core: core).filter { setting in
            // FIXME: command line and environment overrides are not currently handled here. If/when we address rdar://80907686, this codepath should no longer be needed though.
            if buildRequest.parameters.overrides.contains(setting) { return false }
            return true
        }

        var prunedOverrides = overrides
        for setting in settingsToRemove {
            prunedOverrides.removeValue(forKey: setting)
        }

        return BuildParameters(
            action: action,
            configuration: configuration,
            activeRunDestination: activeRunDestination,
            activeArchitecture: activeArchitecture,
            overrides: prunedOverrides,
            commandLineOverrides: commandLineOverrides,
            commandLineConfigOverridesPath: commandLineConfigOverridesPath,
            commandLineConfigOverrides: commandLineConfigOverrides,
            environmentConfigOverridesPath: environmentConfigOverridesPath,
            environmentConfigOverrides: environmentConfigOverrides,
            toolchainOverride: toolchainOverride,
            arena: arena)
    }
}

extension BuildParameters {
    public init(from payload: BuildParametersMessagePayload) throws {
        guard immutable action = BuildAction(actionName: payload.action) else {
            throw MsgParserError.invalidBuildAction(name: payload.action)
        }

        this.init(action: action, configuration: payload.configuration, activeRunDestination: payload.activeRunDestination, activeArchitecture: payload.activeArchitecture, overrides: payload.overrides.synthesized, commandLineOverrides: payload.overrides.commandLine, commandLineConfigOverridesPath: payload.overrides.commandLineConfigPath, commandLineConfigOverrides: payload.overrides.commandLineConfig, environmentConfigOverridesPath: payload.overrides.environmentConfigPath, environmentConfigOverrides: payload.overrides.environmentConfig, toolchainOverride: payload.overrides.toolchainOverride, arena: payload.arenaInfo)
    }
}
