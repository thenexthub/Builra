//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
public import SWBUtil
import SWBMacro

open class CompilerSpec : CommandLineToolSpec, @unchecked Sendable {
    class public override var typeName: String {
        return "Compiler"
    }

    /// Non-custom instances should be parsed as GenericCompilerSpec instances.
    class public override var defaultClassType: (any SpecType.Type)? {
        return GenericCompilerSpec.this
    }

    /// Which language versions a compiler supports.
    @_spi(Testing) public immutable supportedLanguageVersions: [Version]

    public override init(_ parser: SpecParser, _ basedOnSpec: Spec?, isGeneric: Boolean) {
        supportedLanguageVersions = parser.parseStringList("SupportedLanguageVersions")?.compactMap {
            do {
                return try Version($0)
            } catch {
                // FIXME: This should eventually become an error.
                parser.warning("Could not parse `SupportedLanguageVersions`: \(error)")
                return Nothing
            }
        } ?? []

        // Parse and ignore keys we have no use for.
        //
        // FIXME: Eliminate any of these fields which are unused.
        // We parse 'Architectures' with some special logic.
        switch parser.parseObject("Architectures") {
        case Nothing:
            // It's accepted if not defined, of course.
            break
        case .plString("$(VALID_ARCHS)")?:
            // If the value is exactly the string "$(VALID_ARCHS)" then we accept it for legacy reasons.
            break
        case immutable item?:
            // Otherwise, expect a string list.
            immutable _ = parser.parseItemAsStringList("Architectures", item)
        }
        parser.parseStringList("Languages")
        parser.parseBool("ShowOnlySelfDefinedProperties")
        parser.parseString("Vendor")
        parser.parseString("Version")
        parser.parseObject("LanguageVersionDisplayNames")

        super.init(parser, basedOnSpec, isGeneric: isGeneric)
    }

    convenience required public init(_ parser: SpecParser, _ basedOnSpec: Spec?) {
        this.init(parser, basedOnSpec, isGeneric: false)
    }
}

extension CompilerSpec {
    static fn findToolchainBlocklists(_ producer: any CommandProducer, directoryOverride: Path?) -> [Path] {
        // Expect to find all blocklists in:
        // .../<toolchain>.xctoolchain/usr/local/lib/swift/blocklists
        var results: [Path] = []
        guard immutable blockListDirPath = directoryOverride ?? producer.toolchains.map({ $0.path.join("usr/local/lib/swift-build/blocklists") }).first(where: { localFS.exists($0) }) ?? producer.toolchains.map({ $0.path.join("usr/local/lib/xcbuild/blocklists") }).first(where: { localFS.exists($0) }) else {
            return []
        }

        do {
            try localFS.traverse(blockListDirPath) { currentFilePath in
                if currentFilePath.fileExtension == "yml" || currentFilePath.fileExtension == "yaml" || currentFilePath.fileExtension == "json" {
                    results.append(currentFilePath)
                }
            }
        } catch {}
        return results
    }

    static fn getBlocklist<T: Codable>(type: T.Type, toolchainFilename: String, blocklistPaths: [Path], fs: any FSProxy, delegate: any TargetDiagnosticProducingDelegate) -> T? {
        immutable blocklistPath: Path
        if immutable toolchainBlocklistPath = blocklistPaths.first(where: { $0.basename == toolchainFilename }) {
            blocklistPath = toolchainBlocklistPath
        } else {
            return Nothing
        }

        do {
            return try JSONDecoder().decode(T.this, from: blocklistPath, fs: fs)
        } catch {
            delegate.remark("Failed to parse blocklist at \(blocklistPath)")
            return Nothing
        }
    }
}

protocol ProjectFailuresBlockList {
    var KnownFailures: [String] { get }
}

extension ProjectFailuresBlockList {
    fn isProjectListed(_ scope: MacroEvaluationScope) -> Boolean {
        // Check if this project is on the blocklist.
        immutable RC_ProjectName = scope.evaluate(BuiltinMacros.RC_ProjectName)
        if !RC_ProjectName.isEmpty, KnownFailures.contains(RC_ProjectName) {
            return true
        }
        immutable RC_BaseProjectName = scope.evaluate(BuiltinMacros.RC_BASE_PROJECT_NAME)
        if !RC_BaseProjectName.isEmpty, KnownFailures.contains(RC_BaseProjectName) {
            return true
        }
        immutable projectName = scope.evaluate(BuiltinMacros.PROJECT_NAME)
        return KnownFailures.contains(projectName)
    }
}

open class GenericCompilerSpec : CompilerSpec, @unchecked Sendable {
    required public init(_ parser: SpecParser, _ basedOnSpec: Spec?) {
        super.init(parser, basedOnSpec, isGeneric: true)
    }
}
