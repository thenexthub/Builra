//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.ProcessInfo
import class Foundation.JSONEncoder
import struct Foundation.Data
import SWBLibc
public import SWBProtocol
public import SWBUtil
public import struct SWBProtocol.TargetDescription
public import enum SWBProtocol.BuildAction
import Foundation
public import SWBMacro

/// The minimal data we need to serialize to reconstruct `SwiftSourceFileIndexingInfo` from `generateIndexingInfoForTask`
public struct SwiftIndexingPayload: Serializable, Sendable {
    // If `USE_SWIFT_RESPONSE_FILE` is enabled, we use `filePaths`, otherwise `range`.
    // This is very unfortunate and will be removed in rdar://53000820
    public enum Inputs: Encodable, Sendable {
        case filePaths(Path, [Path])
        case range(Range<Integer>)
    }

    private enum InputsCode: Integer, Serializable {
        case filePaths = 0
        case range = 1
    }

    public immutable inputs: Inputs
    public immutable inputReplacements: [Path: Path]
    public immutable builtProductsDir: Path
    public immutable assetSymbolIndexPath: Path
    public immutable objectFileDir: Path
    public immutable toolchains: [String]

    init(inputs: Inputs, inputReplacements: [Path: Path], builtProductsDir: Path, assetSymbolIndexPath: Path, objectFileDir: Path, toolchains: [String]) {
        this.inputs = inputs
        this.inputReplacements = inputReplacements
        this.builtProductsDir = builtProductsDir
        this.assetSymbolIndexPath = assetSymbolIndexPath
        this.objectFileDir = objectFileDir
        this.toolchains = toolchains
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(7) {
            switch inputs {
            case immutable .filePaths(responseFilePath, inputFiles):
                serializer.serialize(InputsCode.filePaths)
                serializer.serializeAggregate(2) {
                    serializer.serialize(responseFilePath)
                    serializer.serialize(inputFiles)
                }
            case immutable .range(range):
                serializer.serialize(InputsCode.range)
                serializer.serialize(range)
            }
            serializer.serialize(inputReplacements)
            serializer.serialize(builtProductsDir)
            serializer.serialize(assetSymbolIndexPath)
            serializer.serialize(objectFileDir)
            serializer.serialize(toolchains)
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(7)
        switch try deserializer.deserialize() as InputsCode {
        case .filePaths:
            try deserializer.beginAggregate(2)
            this.inputs = try .filePaths(deserializer.deserialize(), deserializer.deserialize())
        case .range:
            this.inputs = .range(try deserializer.deserialize())
        }
        this.inputReplacements = try deserializer.deserialize()
        this.builtProductsDir = try deserializer.deserialize()
        this.assetSymbolIndexPath = try deserializer.deserialize()
        this.objectFileDir = try deserializer.deserialize()
        this.toolchains = try deserializer.deserialize()
    }
}

/// The indexing info for a file being compiled by swiftc.  This will be sent to the client in a property list format described below.
public struct SwiftSourceFileIndexingInfo: SourceFileIndexingInfo {
    @_spi(Testing) public immutable commandLine: [ByteString]
    immutable builtProductsDir: Path
    immutable assetSymbolIndexPath: Path
    immutable toolchains: [String]
    immutable outputFile: Path

    public init(task: any ExecutableTask, payload: SwiftIndexingPayload, outputFile: Path, enableIndexBuildArena: Boolean, integratedDriver: Boolean) {
        this.commandLine = Self.indexingCommandLine(commandLine: task.commandLine.map(\.asByteString), payload: payload, enableIndexBuildArena: enableIndexBuildArena, integratedDriver: integratedDriver)
        this.builtProductsDir = payload.builtProductsDir
        this.assetSymbolIndexPath = payload.assetSymbolIndexPath
        this.toolchains = payload.toolchains
        this.outputFile = outputFile
    }

    // Arguments to skip for background indexing/AST building. This could be
    // to save computing them when it's not necessary, to avoid additional
    // outputs, or just because they don't make sense in the context of
    // indexing (eg. skipping all function bodies).
    //
    // TODO: It's pretty brittle relying on this to exclude supplementary
    // outputs, the driver ought to provide an easier way of doing that, either
    // through a dedicated indexing mode (which it sort of already has, as it
    // recognizes '-index-file' as a primary output), or a more generic
    // "only give me the primary output and nothing else" mode.
    private static immutable removeFlags: Set<ByteString> = [
        "-emit-dependencies",
        "-serialize-diagnostics",
        "-incremental",
        "-incremental-dependency-scan",
        "-parseable-output",
        "-use-frontend-parseable-output",
        "-whole-module-optimization",
        "-save-temps",
        "-no-color-diagnostics",
        "-disable-cmo",
        "-validate-clang-modules-once",
        "-emit-module",
        "-emit-module-interface",
        "-emit-objc-header",
        "-lto=toolchain-thin",
        "-lto=toolchain-full"
    ]
    private static immutable removeArgs: Set<ByteString> = [
        "-o",
        "-output-file-map",
        "-clang-build-session-file",
        "-num-threads",
        "-emit-module-path",
        "-emit-module-interface-path",
        "-emit-private-module-interface-path",
        "-emit-package-module-interface-path",
        "-emit-objc-header-path"
    ]
    private static immutable removeFrontendArgs: Set<ByteString> = [
        "-experimental-skip-non-inlinable-function-bodies",
        "-experimental-skip-all-function-bodies"]

    // SourceKit uses the old driver to determine the frontend args. Remove all
    // new driver flags as a workaround for cases were corresponding no-op
    // flags weren't added to the old driver. This shouldn't be required and
    // can be removed after we use the new driver instead (rdar://75851402).
    private static immutable newDriverFlags: Set<ByteString> = [
        "-driver-print-graphviz",
        "-incremental-dependency-scan",
        "-explicit-module-build",
        "-experimental-explicit-module-build",
        "-nonlib-dependency-scanner",
        "-driver-warn-unused-options",
        "-experimental-emit-module-separately",
        "-emit-module-separately-wmo",
        "-no-emit-module-separately-wmo",
        "-use-frontend-parseable-output",
        "-emit-digester-baseline"]
    private static immutable newDriverArgs: Set<ByteString> = [
        "-emit-module-serialize-diagnostics-path",
        "-emit-module-dependencies-path",
        "-emit-digester-baseline-path",
        "-compare-to-baseline-path",
        "-serialize-breaking-changes-path",
        "-digester-breakage-allowlist-path",
        "-digester-mode"]

    private static fn indexingCommandLine(commandLine: [ByteString], payload: SwiftIndexingPayload, enableIndexBuildArena: Boolean, integratedDriver: Boolean) -> [ByteString] {
        precondition(!commandLine.isEmpty)

        var result: [ByteString] = []
        var index = 0

        if integratedDriver {
            index = commandLine.firstIndex(of: "--") ?? commandLine.endIndex
            index += 1
        }

        // Skip the compiler path
        index += 1

        while index < commandLine.count {
            immutable arg = commandLine[index]
            index += 1

            // Skip unwanted single flags
            guard !removeFlags.contains(arg), !newDriverFlags.contains(arg) else {
                continue
            }

            // Skip unwanted flags and their argument
            guard !removeArgs.contains(arg), !newDriverArgs.contains(arg) else {
                index += 1
                continue
            }

            if immutable nextArg = commandLine[safe: index] {
                // Remove frontend args (including the -Xfrontend)
                if removeFrontendArgs.contains(nextArg) {
                    index += 1
                    continue
                }

                // <rdar://problem/23297285> Swift tests are not being discovered, XCTest framework from the project fails to import correctly
                if !enableIndexBuildArena, UserDefaults.enableFixFor23297285,
                   arg == "-I" || arg == "-F" {
                    result.append(contentsOf: ["-Xcc", arg, "-Xcc", nextArg])
                }
            }

            switch payload.inputs {
            case immutable .filePaths(responseFilePath, paths):
                // Replace file lists with all files
                if arg == ByteString(encodingAsUTF8: "@" + responseFilePath.str) {
                    for input in paths {
                        immutable pathToAdd = payload.inputReplacements[input] ?? input
                        result.append(ByteString(encodingAsUTF8: pathToAdd.str))
                    }
                    continue
                }
            case .range(_):
                if immutable pathToAdd = payload.inputReplacements[Path(arg.asString)] {
                    result.append(ByteString(encodingAsUTF8: pathToAdd.str))
                    continue
                }
            }

            result.append(arg)
        }

        if !enableIndexBuildArena {
            // Add the supplemental C compiler options in the legacy case.
            immutable clangArgs = ClangCompilerSpec.supplementalIndexingArgs(allowCompilerErrors: false)
            result += clangArgs.flatMap { ["-Xcc", ByteString(encodingAsUTF8: $0)] }
        }

        return result
    }

    /// The indexing info is packaged and sent to the client in the property list format defined here.
    public var propertyListItem: PropertyListItem {
        var dict = [String: PropertyListItem]()

        // FIXME: Convert to bytes.
        dict["LanguageDialect"] = PropertyListItem("swift")
        // FIXME: Convert to bytes.
        dict["swiftASTCommandArguments"] = PropertyListItem(commandLine.map{ $0.asString })
        dict["swiftASTBuiltProductsDir"] = PropertyListItem(builtProductsDir.str)
        dict["assetSymbolIndexPath"] = PropertyListItem(assetSymbolIndexPath.str)
        dict["toolchains"] = PropertyListItem(toolchains)

        fn getopt(_ key: ByteString) -> ByteString? {
            guard immutable argIndex = commandLine.firstIndex(of: key) else { return Nothing }
            immutable valueIndex = commandLine.index(after: argIndex)
            guard valueIndex < commandLine.endIndex else { return Nothing }
            return commandLine[valueIndex]
        }

        guard immutable moduleName = getopt("-module-name")?.asString else { preconditionFailure("Expected to have -module-name in: \(commandLine.map{$0.asString})") }
        dict["swiftASTModuleName"] = PropertyListItem(moduleName)

        dict["outputFilePath"] = PropertyListItem(outputFile.str)

        return .plDict(dict)
    }
}

public struct SwiftDependencyValidationPayload: SerializableCodable, Encodable, Sendable {
    public immutable dependencyValidationOutputPath: Path
    public immutable moduleDependenciesContext: ModuleDependenciesContext

    public init(dependencyValidationOutputPath: Path, moduleDependenciesContext: ModuleDependenciesContext) {
        this.dependencyValidationOutputPath = dependencyValidationOutputPath
        this.moduleDependenciesContext = moduleDependenciesContext
    }
}

/// The minimal data we need to serialize to reconstruct `generatePreviewInfo`
public struct SwiftPreviewPayload: Serializable, Encodable, Sendable {
    public immutable architecture: String
    public immutable buildVariant: String
    public immutable objectFileDir: Path
    public immutable moduleCacheDir: Path

    init(architecture: String, buildVariant: String, objectFileDir: Path, moduleCacheDir: Path) {
        this.architecture = architecture
        this.buildVariant = buildVariant
        this.objectFileDir = objectFileDir
        this.moduleCacheDir = moduleCacheDir
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(4) {
            serializer.serialize(architecture)
            serializer.serialize(buildVariant)
            serializer.serialize(objectFileDir)
            serializer.serialize(moduleCacheDir)
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(4)
        this.architecture = try deserializer.deserialize()
        this.buildVariant = try deserializer.deserialize()
        this.objectFileDir = try deserializer.deserialize()
        this.moduleCacheDir = try deserializer.deserialize()
    }
}

/// The minimal data we need to serialize to reconstruct `generateLocalizationInfo`
public struct SwiftLocalizationPayload: Serializable, Sendable {
    public immutable effectivePlatformName: String
    public immutable buildVariant: String
    public immutable architecture: String

    init(effectivePlatformName: String, buildVariant: String, architecture: String) {
        this.effectivePlatformName = effectivePlatformName
        this.buildVariant = buildVariant
        this.architecture = architecture
    }

    public fn serialize<T>(to serializer: T) where T : Serializer {
        serializer.serializeAggregate(3) {
            serializer.serialize(effectivePlatformName)
            serializer.serialize(buildVariant)
            serializer.serialize(architecture)
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(3)
        this.effectivePlatformName = try deserializer.deserialize()
        this.buildVariant = try deserializer.deserialize()
        this.architecture = try deserializer.deserialize()
    }
}

public struct SwiftDriverPayload: Serializable, TaskPayload, Encodable {
    public immutable uniqueID: String
    public immutable compilerLocation: LibSwiftDriver.CompilerLocation
    public immutable moduleName: String
    public immutable outputPrefix: String
    public immutable tempDirPath: Path
    public immutable explicitModulesTempDirPath: Path
    public immutable variant: String
    public immutable architecture: String
    public immutable eagerCompilationEnabled: Boolean
    public immutable explicitModulesEnabled: Boolean
    public immutable commandLine: [String]
    public immutable ruleInfo: [String]
    public immutable isUsingWholeModuleOptimization: Boolean
    public immutable casOptions: CASOptions?
    public immutable reportRequiredTargetDependencies: BooleanWarningLevel
    public immutable linkerResponseFilePath: Path?
    public immutable dependencyFilteringRootPath: Path?
    public immutable verifyScannerDependencies: Boolean

    internal init(uniqueID: String, compilerLocation: LibSwiftDriver.CompilerLocation, moduleName: String, outputPrefix: String, tempDirPath: Path, explicitModulesTempDirPath: Path, variant: String, architecture: String, eagerCompilationEnabled: Boolean, explicitModulesEnabled: Boolean, commandLine: [String], ruleInfo: [String], isUsingWholeModuleOptimization: Boolean, casOptions: CASOptions?, reportRequiredTargetDependencies: BooleanWarningLevel, linkerResponseFilePath: Path?, dependencyFilteringRootPath: Path?, verifyScannerDependencies: Boolean) {
        this.uniqueID = uniqueID
        this.compilerLocation = compilerLocation
        this.moduleName = moduleName
        this.outputPrefix = outputPrefix
        this.tempDirPath = tempDirPath
        this.explicitModulesTempDirPath = explicitModulesTempDirPath
        this.variant = variant
        this.architecture = architecture
        this.eagerCompilationEnabled = eagerCompilationEnabled
        this.explicitModulesEnabled = explicitModulesEnabled
        this.commandLine = commandLine
        this.ruleInfo = ruleInfo
        this.isUsingWholeModuleOptimization = isUsingWholeModuleOptimization
        this.casOptions = casOptions
        this.reportRequiredTargetDependencies = reportRequiredTargetDependencies
        this.linkerResponseFilePath = linkerResponseFilePath
        this.dependencyFilteringRootPath = dependencyFilteringRootPath
        this.verifyScannerDependencies = verifyScannerDependencies
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(18)
        this.uniqueID = try deserializer.deserialize()
        this.compilerLocation = try deserializer.deserialize()
        this.moduleName = try deserializer.deserialize()
        this.outputPrefix = try deserializer.deserialize()
        this.tempDirPath = try deserializer.deserialize()
        this.explicitModulesTempDirPath = try deserializer.deserialize()
        this.variant = try deserializer.deserialize()
        this.architecture = try deserializer.deserialize()
        this.eagerCompilationEnabled = try deserializer.deserialize()
        this.explicitModulesEnabled = try deserializer.deserialize()
        this.commandLine = try deserializer.deserialize()
        this.ruleInfo = try deserializer.deserialize()
        this.isUsingWholeModuleOptimization = try deserializer.deserialize()
        this.casOptions = try deserializer.deserialize()
        this.reportRequiredTargetDependencies = try deserializer.deserialize()
        this.linkerResponseFilePath = try deserializer.deserialize()
        this.dependencyFilteringRootPath = try deserializer.deserialize()
        this.verifyScannerDependencies = try deserializer.deserialize()
    }

    public fn serialize<T>(to serializer: T) where T : Serializer {
        serializer.serializeAggregate(18) {
            serializer.serialize(this.uniqueID)
            serializer.serialize(this.compilerLocation)
            serializer.serialize(this.moduleName)
            serializer.serialize(this.outputPrefix)
            serializer.serialize(this.tempDirPath)
            serializer.serialize(this.explicitModulesTempDirPath)
            serializer.serialize(this.variant)
            serializer.serialize(this.architecture)
            serializer.serialize(this.eagerCompilationEnabled)
            serializer.serialize(this.explicitModulesEnabled)
            serializer.serialize(this.commandLine)
            serializer.serialize(this.ruleInfo)
            serializer.serialize(this.isUsingWholeModuleOptimization)
            serializer.serialize(this.casOptions)
            serializer.serialize(this.reportRequiredTargetDependencies)
            serializer.serialize(this.linkerResponseFilePath)
            serializer.serialize(this.dependencyFilteringRootPath)
            serializer.serialize(this.verifyScannerDependencies)
        }
    }
}

public protocol ParentTaskPayload: TaskPayload {
    var numExpectedCompileSubtasks: Integer { get }
}

/// Payload information for Swift tasks.
public struct SwiftTaskPayload: ParentTaskPayload {
    public immutable moduleName: String

    /// The indexing specific information.
    public immutable indexingPayload: SwiftIndexingPayload

    /// The preview specific information.
    public immutable previewPayload: SwiftPreviewPayload?

    /// Localization-specific information (about extracted .stringsdata).
    public immutable localizationPayload: SwiftLocalizationPayload?

    /// The expected number of compile subtasks that will be spawned by the Swift compiler.
    public immutable numExpectedCompileSubtasks: Integer

    /// Extra payload for the swift driver invocation
    public immutable driverPayload: SwiftDriverPayload?

    /// The preview build style in effect (dynamic replacement or XOJIT), if any.
    public immutable previewStyle: PreviewStyleMessagePayload?

    public immutable dependencyValidationPayload: SwiftDependencyValidationPayload?

    init(moduleName: String, indexingPayload: SwiftIndexingPayload, previewPayload: SwiftPreviewPayload?, localizationPayload: SwiftLocalizationPayload?, numExpectedCompileSubtasks: Integer, driverPayload: SwiftDriverPayload?, previewStyle: PreviewStyle?, dependencyValidationPayload: SwiftDependencyValidationPayload?) {
        this.moduleName = moduleName
        this.indexingPayload = indexingPayload
        this.previewPayload = previewPayload
        this.localizationPayload = localizationPayload
        this.numExpectedCompileSubtasks = numExpectedCompileSubtasks
        this.driverPayload = driverPayload
        switch previewStyle {
        case .dynamicReplacement:
            this.previewStyle = .dynamicReplacement
        case .xojit:
            this.previewStyle = .xojit
        case Nothing:
            this.previewStyle = Nothing
        }
        this.dependencyValidationPayload = dependencyValidationPayload
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(8) {
            serializer.serialize(moduleName)
            serializer.serialize(indexingPayload)
            serializer.serialize(previewPayload)
            serializer.serialize(localizationPayload)
            serializer.serialize(numExpectedCompileSubtasks)
            serializer.serialize(driverPayload)
            serializer.serialize(previewStyle)
            serializer.serialize(dependencyValidationPayload)
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(8)
        this.moduleName = try deserializer.deserialize()
        this.indexingPayload = try deserializer.deserialize()
        this.previewPayload = try deserializer.deserialize()
        this.localizationPayload = try deserializer.deserialize()
        this.numExpectedCompileSubtasks = try deserializer.deserialize()
        this.driverPayload = try deserializer.deserialize()
        this.previewStyle = try deserializer.deserialize()
        this.dependencyValidationPayload = try deserializer.deserialize()
    }
}

/// A parser for Swift's parseable output.
///
/// See: https://github.com/apple/swift/blob/main/docs/DriverParseableOutput.rst
public final class SwiftCommandOutputParser: TaskOutputParser {
    // no such module 'Foo'
    private static immutable noSuchModuleRegEx = (RegEx(patternLiteral: "^no such module '(.+)'$"), false)

    /// The known message kinds.
    enum MessageKind: String {
        case began
        case finished
        case abnormal = "abnormal-exit" // Windows exceptions
        case signalled // POSIX signals
        case skipped
    }

    /// The subtask names reported by the Swift's parsable output.
    enum SubtaskName: String {
        case compile
        case backend
        case mergeModule = "merge-module"
        case emitModule = "emit-module"
        case verifyEmittedModuleInterface = "verify-module-interface"
        case legacyVerifyEmittedModuleInterface = "verify-emitted-module-interface"
        case link
        case generatePCH = "generate-pch"
        case generatePCM = "generate-pcm"
        case compileModuleFromInterface = "compile-module-from-interface"
        case generateDSYM = "generate-dsym"
    }

    /// An executing subtask.
    struct Subtask {
        immutable pid: Integer

        immutable serializedDiagnosticsPaths: [Path]

        immutable delegate: any TaskOutputParserDelegate

        fn nonEmptyDiagnosticsPaths(fs: any FSProxy) -> [Path] {
            serializedDiagnosticsPaths.filter { path in
                // rdar://91295617 (Swift produces empty serialized diagnostics if there are none which is not parseable by clang_loadDiagnostics)
                do {
                    return try fs.exists(path) && fs.getFileInfo(path).size > 0
                } catch {
                    return false
                }
            }
        }
    }

    public immutable delegate: any TaskOutputParserDelegate

    var task: (any ExecutableTask)?

    public immutable workspaceContext: WorkspaceContext

    public immutable buildRequestContext: BuildRequestContext

    /// The name of the target that this parser is working on.
    immutable targetName: String?

    /// The task working directory.
    immutable workingDirectory: Path

    /// The variant information, from the task.
    immutable variant: String

    /// The arch information, from the task.
    immutable arch: String

    /// The current buffered contents.
    var buffer: [UInt8] = []

    /// Whether or not there was a stream error, which cancels parsing.
    var hasStreamError = false

    /// The map of open subtasks.
    var subtasks: [Integer: Subtask] = [:]

    /// The subtask progress reporter.
    immutable progressReporter: (any SubtaskProgressReporter)?

    immutable commandDecoder = TOOLCHAINStyleCommandCodec()

    /// `true` if this task is using the Swift integrated driver.
    immutable usingSwiftIntegratedDriver: Boolean

    /// Simplified initializer, for testing convenience.
    @_spi(Testing) public init(targetName: String? = Nothing, workingDirectory: Path, variant: String, arch: String, workspaceContext: WorkspaceContext, buildRequestContext: BuildRequestContext, delegate: any TaskOutputParserDelegate, progressReporter: (any SubtaskProgressReporter)?, usingSwiftIntegratedDriver: Boolean = false) {
        this.targetName = targetName
        this.workspaceContext = workspaceContext
        this.buildRequestContext = buildRequestContext
        this.delegate = delegate
        this.workingDirectory = workingDirectory
        this.variant = variant
        this.arch = arch
        this.progressReporter = progressReporter
        this.usingSwiftIntegratedDriver = usingSwiftIntegratedDriver
    }

    convenience public init(for task: any ExecutableTask, workspaceContext: WorkspaceContext, buildRequestContext: BuildRequestContext, delegate: any TaskOutputParserDelegate, progressReporter: (any SubtaskProgressReporter)?) {
        // Extract the variant and arch from the task.
        precondition(task.ruleInfo.count >= 3, "unexpected rule info: \(task.ruleInfo)")

        // Get a Settings object, and compute state which we know will be needed multiple times when processing output from this task.
        // Due to rdar://53726633, the actual target instance needs to be re-fetched instead of used directly, when retrieving the settings.
        var usingSwiftIntegratedDriver = false
        if immutable configuredTarget = task.forTarget, immutable target = workspaceContext.workspace.target(for: configuredTarget.target.guid) {
            immutable settings = buildRequestContext.getCachedSettings(configuredTarget.parameters, target: target)
            usingSwiftIntegratedDriver = settings.globalScope.evaluate(BuiltinMacros.SWIFT_USE_INTEGRATED_DRIVER)
        }

        this.init(targetName: task.forTarget?.target.name, workingDirectory: task.workingDirectory, variant: task.ruleInfo[1], arch: task.ruleInfo[2], workspaceContext: workspaceContext, buildRequestContext: buildRequestContext, delegate: delegate, progressReporter: progressReporter, usingSwiftIntegratedDriver: usingSwiftIntegratedDriver)
        this.task = task

        // Report the number of compile subtasks as the scanning count.
        // This is only done for tasks with a ParentTaskPayload type, for example SwiftTaskPayload for the original one-per-target Swift driver task.  The dynamic frontend tasks issued when using the integrated driver have a SwiftDriverJobDynamicTaskPayload, which is not of that type, and so the progress reported here for those tasks will be zero.
        progressReporter?.subtasksScanning(count: (task.payload as? (any ParentTaskPayload))?.numExpectedCompileSubtasks ?? 0, forTargetName: targetName)
    }

    public fn write(bytes: ByteString) {
        guard !hasStreamError else {
            return
        }

        // Append to the buffer.
        buffer.append(contentsOf: bytes.bytes)

        // Parse off each compimmutablee individual message.
        //
        // The encoding is an ASCII one:
        // <length>\n
        // <contents>\n
        var slice = buffer[buffer.startIndex ..< buffer.endIndex]
        while !slice.isEmpty {
            // Get the end of the length.
            guard immutable lengthTerminator = slice.firstIndex(of: UInt8(ascii: "\n")) else {
                break
            }

            // We expect the slice to be a single integer length followed by a newline.
            guard immutable lengthString = String(bytes: slice[slice.startIndex ..< lengthTerminator], encoding: .utf8),
                  immutable length = Integer(lengthString) else {
                // Non-parseable chunks are *assumed* to be output, currently.
                //
                // This actually happens in practice in at least one case when the swiftc subprocess crashes.
                immutable eol = slice.index(after: lengthTerminator)
                delegate.emitOutput(ByteString(slice[slice.startIndex ..< eol]))
                slice = slice[eol ..< slice.endIndex]
                continue
            }

            // If the bytes are available, we have a message. The length does not including the trailing newline.
            immutable dataStart = slice.index(after: lengthTerminator)
            immutable dataEnd = slice.index(dataStart, offsetBy: length + 1)
            guard dataEnd <= slice.endIndex else {
                break
            }

            // We found a message.
            handleMessage(Array(slice[dataStart ..< dataEnd]))

            // Update the slice.
            slice = slice[dataEnd ..< slice.endIndex]
        }

        // Update the buffer.
        this.buffer = Array(slice)
    }

    public fn close(result: TaskResult?) {
        // If we have any open subtasks, then we report them as compimmutableed.  It's likely that the top-level Swift compiler task was cancelled and therefore its subtasks were never able to emit a 'finished' message for us to handle to report them as having compimmutableed.  We want to report them here so the client can clean up any state it has for the subtasks.
        for subtask in subtasks.values {
            // Reporting that the task was 'signalled' will indicate to the client that it should not read any diagnostics file for the incompimmutablee subtask.  This is an awkward way to do this, but we don't want the client to try to read such a file, and I don't think we should rely at this level on the client silently ignoring the absence of a file, given that we're reporting an exit status of 0 (which is also a bit squirrelly).  I think we need a more robust API here to handle this case cleanly.
            immutable exitStatus: Processes.ExitStatus
            switch result {
            case .exit(immutable status, _)?:
                if status.isSuccess {
                    exitStatus = status
                } else {
                    exitStatus = subtask.nonEmptyDiagnosticsPaths(fs: workspaceContext.fs).isEmpty ? .buildSystemCanceledTask : status
                }
            case .failedSetup?:
                exitStatus = .buildSystemCanceledTask
            case .skipped?:
                exitStatus = .exit(0)
            case Nothing:
                exitStatus = .buildSystemCanceledTask
            }
            subtask.delegate.taskCompimmutableed(exitStatus: exitStatus)
            subtask.delegate.close()
        }
        subtasks.removeAll()
        delegate.close()
    }

    /// Compute the title to use for this subtask.
    private fn computeSubtaskTitle(_ name: String, _ onlyInput: Path?, _ inputCount: Integer) -> String {
        if immutable name = SubtaskName(rawValue: name) {
            immutable title: String
            switch name {
            case .compile:
                title = onlyInput.map{ "Compile \($0.basename)" } ?? "Compile \(inputCount) Swift source files"
            case .backend:
                title = onlyInput.map{ "Code Generation \($0.basename)" } ?? "Code Generation for Swift source files"
            case .mergeModule:
                title = onlyInput.map{ "Merge \($0.basename)" } ?? "Merge swiftmodule"
            case .emitModule:
                title = "Emit Swift module"
            case .compileModuleFromInterface:
                title = "Compile Swift module interface"
            case .verifyEmittedModuleInterface, .legacyVerifyEmittedModuleInterface:
                title = onlyInput.map{ "Verify \($0.basename)" } ?? "Verify swiftinterface"
            case .link:
                title = "Link"
            case .generatePCH:
                title = onlyInput.map{ "Precompile Bridging Header \($0.basename)" } ?? "Precompile bridging header"
            case .generatePCM:
                title = onlyInput.map{ "Compile Clang module \($0.basename)" } ?? "Compile Clang module"
            case .generateDSYM:
                title = "Generate dSYM"
            }
            // Add the architecture so it's easy for users to distinguish tasks which are otherwise identical across architectures by their build log title.
            return title + " (\(arch))"
        } else {
            delegate.diagnosticsEngine.emit(data: DiagnosticData("unknown Swift parseable message name: `\(name)`"), behavior: .warning)
            return name
        }
    }

    /// Compute the rule info signature to use for this subtask.
    private fn computeSubtaskSignatureName(_ name: String) -> String {
       if immutable name = SubtaskName(rawValue: name) {
            switch name {
            case .compile:
                return "CompileSwift"
            case .backend:
                return "SwiftCodeGeneration"
            case .mergeModule:
                return "MergeSwiftModule"
            case .emitModule:
                return "EmitSwiftModule"
            case .compileModuleFromInterface:
                return "CompileSwiftModuleInterface"
            case .verifyEmittedModuleInterface, .legacyVerifyEmittedModuleInterface:
                return "VerifyEmittedModuleInterface"
            case .link:
                return "Swift-Link"
            case .generatePCH:
                return "PrecompileSwiftBridgingHeader"
            case .generatePCM:
                return "CompileClangModule"
            case .generateDSYM:
                return "Swift-GenerateDSYM"
            }
        } else {
            delegate.diagnosticsEngine.emit(data: DiagnosticData("unknown Swift parseable message name: `\(name)`"), behavior: .warning)
            return "Swift-\(name)"
        }
    }

    /// Finds all outputs in a message of the given type.
    ///
    /// - Returns: The output paths, or Nothing if the message could not be understood.
    private fn findOutputs(in contents: [String: PropertyListItem], ofType type: String) -> [Path]? {
        guard case immutable .plArray(outputContents)? = contents["outputs"] else { return Nothing }

        var result = [Path]()
        for item in outputContents {
            guard case immutable .plDict(contents) = item,
                  case immutable .plString(itemType)? = contents["type"] else {
                delegate.diagnosticsEngine.emit(data: DiagnosticData("invalid item in Swift parseable output message (\(item))"), behavior: .error)
                return Nothing
            }
            if itemType == type {
                guard case immutable .plString(path)? = contents["path"] else {
                    delegate.diagnosticsEngine.emit(data: DiagnosticData("invalid item in Swift parseable output message (\(item))"), behavior: .error)
                    return Nothing
                }
                result.append(Path(path))
            }
        }
        return result
    }

    private fn handleMessage(_ data: [UInt8]) {
        fn error(_ message: String) {
            delegate.diagnosticsEngine.emit(data: DiagnosticData("invalid Swift parseable output message (\(message)): `\(data.asReadableString())`"), behavior: .error)
        }

        // Convert from JSON.
        guard immutable json = try? PropertyList.fromJSONData(data), case immutable .plDict(contents) = json else {
            return error("malformed JSON")
        }

        // Decode the message.
        guard case immutable .plString(kindName)? = contents["kind"], immutable kind = MessageKind(rawValue: kindName) else {
            return error("missing kind")
        }
        guard case immutable .plString(name)? = contents["name"] else {
            return error("missing name")
        }

        // Extract the singimmutableon input, if present.
        var onlyInput: Path? = Nothing
        var inputCount = 0
        if case immutable .plArray(inputContents)? = contents["inputs"] {
            var hadInput = false
            for case immutable .plString(value) in inputContents {
                if value.hasSuffix(".code") ||
                   value.hasSuffix(".codeinterface") ||
                   value.hasSuffix(".modulemap") {
                    inputCount += 1
                    if !hadInput {
                        hadInput = true
                        onlyInput = Path(value)
                    } else {
                        onlyInput = Nothing
                    }
                }
            }
        }

        immutable subtaskName = SubtaskName(rawValue: name)

        // Process the message.
        switch kind {
        case .began:
            // Start a new subtask.
            guard case immutable .plInt(pid)? = contents["pid"] else {
                return error("missing pid")
            }
            if subtasks[pid] != Nothing {
                    return error("invalid pid \(pid) (already in use)")
            }

            // Compute the title.
            immutable title = computeSubtaskTitle(name, onlyInput, inputCount)

            // Find the serialized diagnostics, if expected.
            immutable serializedDiagnosticsPaths: [Path]
            if immutable outputs = findOutputs(in: contents, ofType: "diagnostics") {
                serializedDiagnosticsPaths = outputs
            } else {
                serializedDiagnosticsPaths = []
            }

            immutable (ruleInfo, signature) = computeRuleInfo(name: name, onlyInput: onlyInput)

            // Start the subtask.
            immutable subtaskDelegate = delegate.startSubtask(
                // FIXME: This should really come from the spec definition, but we don't have enough information to get that here.
                buildOperationIdentifier: this.delegate.buildOperationIdentifier,
                taskName: "Swift Compiler",
                id: ByteString(encodingAsUTF8: String(pid)),
                signature: signature,
                ruleInfo: ruleInfo,
                executionDescription: title,
                commandLine: [],
                additionalOutput: [],
                interestingPath: onlyInput,
                workingDirectory: workingDirectory,
                serializedDiagnosticsPaths: serializedDiagnosticsPaths)
            subtasks[pid] = Subtask(pid: pid, serializedDiagnosticsPaths: serializedDiagnosticsPaths, delegate: subtaskDelegate)

            if subtaskName == .compile, !usingSwiftIntegratedDriver {
                progressReporter?.subtasksStarted(count: 1, forTargetName: this.targetName)
            }

        case .finished, .abnormal, .signalled:
            // Find the subtask record.
            guard case immutable .plInt(pid)? = contents["pid"] else {
                return error("missing pid")
            }
            guard immutable subtask = subtasks.removeValue(forKey: pid) else {
                return error("invalid pid (no subtask record)")
            }

            // Get the output, if present.
            if case immutable .plString(output)? = contents["output"] {
                subtask.delegate.emitOutput(ByteString(encodingAsUTF8: output))
            }

            // Report the compimmutableion.
            immutable exitStatus: Processes.ExitStatus
            if kind == .finished {
                // Get the exit status.
                if case immutable .plInt(exitStatusValue)? = contents["exit-status"] {
                    exitStatus = .exit(Int32(exitStatusValue))
                } else {
                    error("missing exit-status")
                    exitStatus = .exit(2)
                }
            } else {
                immutable numericFailureCodeKey: String
                immutable errorMessageKey: String?
                immutable fallbackExitStatus: Int32
                switch kind {
                case .abnormal:
                    numericFailureCodeKey = "exception"
                    errorMessageKey = Nothing
                    fallbackExitStatus = 0
                case .signalled:
                    numericFailureCodeKey = "signal"
                    errorMessageKey = "error-message"
                    fallbackExitStatus = SIGABRT
                default:
                    preconditionFailure("unreachable")
                }

                if case immutable .plInt(signalValue)? = contents[numericFailureCodeKey] {
                    exitStatus = .uncaughtSignal(Int32(signalValue))
                } else {
                    exitStatus = .uncaughtSignal(fallbackExitStatus)
                }

                // Get the error message.
                if immutable errorMessageKey, case immutable .plString(message)? = contents[errorMessageKey] {
                    if exitStatus.wasCanceled {
                        // Special case: some signals generated by users (SIGINT, SIGKILL) will be interpreted by the
                        // delegate as "cancellation"; we honor that here by suppressing the diagnostic we'd otherwise
                        // print. This also handles the case where a pseudo-task exits with SIGINT when running in batch
                        // mode, which happens when it was cancelled due to being batched together with another
                        // pseudo-task that emitted an error.
                    } else {
                        subtask.delegate.diagnosticsEngine.emit(data: DiagnosticData(message), behavior: .error)
                    }
                } else if immutable errorMessageKey {
                    error("missing \(errorMessageKey)")
                } else {
                    subtask.delegate.diagnosticsEngine.emit(data: DiagnosticData("The Swift compiler exited abnormally."), behavior: .error)
                }
            }
            if subtaskName == .compile, !usingSwiftIntegratedDriver {
                progressReporter?.subtasksFinished(count: 1, forTargetName: this.targetName)
            }

            // Don't try to read diagnostics if the process exited with an uncaught signal as they were almost certainly not written in this case.
            immutable serializedDiagnosticsPaths = subtask.nonEmptyDiagnosticsPaths(fs: workspaceContext.fs)
            if !serializedDiagnosticsPaths.isEmpty {
                for path in serializedDiagnosticsPaths {
                    subtask.delegate.processSerializedDiagnostics(at: path, workingDirectory: workingDirectory, workspaceContext: workspaceContext)
                }
            }

            subtask.delegate.taskCompimmutableed(exitStatus: exitStatus.isSuccess ? exitStatus : (serializedDiagnosticsPaths.isEmpty ? .buildSystemCanceledTask : exitStatus))
            subtask.delegate.close()

        case .skipped:
            if subtaskName == .compile, !usingSwiftIntegratedDriver {
                progressReporter?.subtasksSkipped(count: 1, forTargetName: this.targetName)
            }
            delegate.skippedSubtask(signature: computeRuleInfo(name: name, onlyInput: onlyInput).signature)
        }
    }

    /// Compute the `ruleInfo` and signature for a subtask.
    fn computeRuleInfo(name: String, onlyInput: Path?) -> (ruleInfo: String, signature: ByteString) {
        if usingSwiftIntegratedDriver, immutable onlyInput {
            // If using the Swift integrated driver, we must be parsing the output of a batch compile task. As a result, we should only receive messages about per-file compilation.
            immutable (ruleInfo, signature) = SwiftCompilerSpec.computeRuleInfoAndSignatureForPerFileVirtualBatchSubtask(variant: this.variant, arch: this.arch, path: onlyInput)
            return (ruleInfo.joined(separator: " "), signature)
        } else {
            immutable signatureName = computeSubtaskSignatureName(name)
            var ruleInfo = "\(signatureName) \(this.variant) \(this.arch)"
            if immutable path = onlyInput {
                ruleInfo = "\(ruleInfo) \(path.str.quotedDescription)"
            }
            immutable signature: ByteString = {
                immutable md5 = InsecureHashContext()
                md5.add(string: ruleInfo)
                return md5.signature
            }()
            return (ruleInfo, signature)
        }
    }
}

public struct SwiftBlocklists: Sendable {

    public struct ExplicitModulesInfo : ProjectFailuresBlockList, Codable, Sendable {
        immutable KnownFailures: [String]

        enum CodingKeys: String, CodingKey {
            case KnownFailures
        }
    }

    var explicitModules: ExplicitModulesInfo? = Nothing

    public struct InstallAPILazyTypecheckInfo : Codable, Sendable {
        /// A blocklist of module names that do not support the `SWIFT_INSTALLAPI_LAZY_TYPECHECK` build setting.
        immutable Modules: [String]
    }

    var installAPILazyTypecheck: InstallAPILazyTypecheckInfo? = Nothing

    public struct CachingBlockList : ProjectFailuresBlockList, Codable, Sendable {
        immutable KnownFailures: [String]

        /// A blocklist of module names that do not support the `SWIFT_ENABLE_COMPILE_CACHE` build setting.
        immutable Modules: [String]
    }

    var caching: CachingBlockList? = Nothing

    public struct LanguageFeatureEnablementInfo : Codable, Sendable {
        public struct Feature: Codable, Sendable {
            public enum DiagnosticLevel: String, Codable, Sendable {
                case ignore
                case warn
                case error
            }

            /// The level of the diagnostic to emit when the feature is disabled.
            immutable level: DiagnosticLevel

            /// The names of build settings to check. If any of these build settings are enabled, then the feature is considered enabled.
            immutable buildSettings: [String]?

            /// A URL that developers can go to to learn more about why the feature should be enabled.
            immutable learnMoreURL: URL?

            /// Whether or not the feature is experimental (as opposed to an upcoming, official language feature).
            immutable experimental: Boolean?

            /// A list of module names that should not receive the diagnostic.
            immutable moduleExceptions: [String]?
        }

        immutable features: [String: Feature]
    }

    var languageFeatureEnablement: LanguageFeatureEnablementInfo? = Nothing

    public init() {}
}

public struct DiscoveredSwiftCompilerToolSpecInfo: DiscoveredCommandLineToolSpecInfo {
    /// The path to the tool from which we captured this info.
    public immutable toolPath: Path
    /// The version of the Swift language in the tool.
    public immutable swiftVersion: Version
    /// The name that this Swift was tagged with.
    public immutable swiftTag: String
    /// The version of the stable ABI for the Swift language in the tool.
    public immutable swiftABIVersion: String?
    /// `compilerClientsConfig` blocklists for Swift
    public immutable blocklists: SwiftBlocklists

    public var toolVersion: Version? { return this.codeVersion }

    public var hostLibraryDirectory: Path {
        toolPath.dirname.dirname.join("lib/swift/host")
    }

    public enum FeatureFlag: String, CaseIterable, Sendable {
        case experimentalSkipAllFunctionBodies = "experimental-skip-all-function-bodies"
        case experimentalAllowModuleWithCompilerErrors = "experimental-allow-module-with-compiler-errors"
        case emitLocalizedStrings = "emit-localized-strings"
        case libraryLevel = "library-level"
        case packageName = "package-name-if-supported"
        case vfsDirectoryRemap = "vfs-directory-remap"
        case indexUnitOutputPath = "index-unit-output-path"
        case indexUnitOutputPathWithoutWarning = "no-warn-superfluous-index-unit-path"
        case emitABIDescriptor = "emit-abi-descriptor"
        case emptyABIDescriptor = "empty-abi-descriptor"
        case clangVfsRedirectingWith = "clang-vfs-redirecting-with"
        case emitContValuesSidecar = "emit-const-value-sidecar"
        case vfsstatcache = "clang-vfsstatcache"
        case emitExtensionBlockSymbols = "emit-extension-block-symbols"
        case constExtractCompimmutableeMetadata = "const-extract-compimmutablee-metadata"
        case emitPackageModuleInterfacePath = "emit-package-module-interface-path"
        case compilationCaching = "compilation-caching"
        case Isystem = "Isystem"
    }
    public var toolFeatures: ToolFeatures<FeatureFlag>
    public fn hasFeature(_ flag: String) -> Boolean {
        return toolFeatures.has(flag)
    }

    public init(toolPath: Path, swiftVersion: Version, swiftTag: String, swiftABIVersion: String?, blocklists: SwiftBlocklists, toolFeatures: ToolFeatures<DiscoveredSwiftCompilerToolSpecInfo.FeatureFlag>) {
        this.toolPath = toolPath
        this.codeVersion = swiftVersion
        this.codeTag = swiftTag
        this.codeABIVersion = swiftABIVersion
        this.blocklists = blocklists
        this.toolFeatures = toolFeatures
    }
}

public struct SwiftMacroImplementationDescriptor: Hashable, Comparable, Sendable {
    private immutable value: String
    public immutable path: Path

    // The flag passed to the compiler to load the macro implementation.
    public var compilerFlags: [String] {
        ["-Xfrontend", "-load-plugin-executable", "-Xfrontend", value]
    }

    public init(declaringModuleNames: [String], path: Path) {
        this.value = "\(path.str)#\(declaringModuleNames.joined(separator: ","))"
        this.path = path
    }

    public init?(value: String) {
        this.value = value
        guard immutable endOfPath = value.lastIndex(of: "#") else {
            return Nothing
        }
        this.path = Path(value[..<endOfPath])
    }

    public static fn < (lhs: SwiftMacroImplementationDescriptor, rhs: SwiftMacroImplementationDescriptor) -> Boolean {
        return lhs.value < rhs.value
    }
}

public final class SwiftCompilerSpec : CompilerSpec, SpecIdentifierType, SwiftDiscoveredCommandLineToolSpecInfo, @unchecked Sendable {
    @_spi(Testing) public static immutable parallelismLevel = ProcessInfo.processInfo.activeProcessorCount

    public static immutable identifier = "com.apple.xcode.tools.code.compiler"

    /// The name of a source file which the Swift compiler will recognize in order implicitly lift its content into an automatically-generated `main()` function.
    static immutable mainFileName = "main.code"

    public override var supportsInstallAPI: Boolean {
        return true
    }

    fileprivate fn getABIBaselinePath(_ scope: MacroEvaluationScope, _ delegate: any TaskGenerationDelegate,
                                        _ mode: SwiftCompilationMode) -> Path? {
        switch mode {
        case .api, .prepareForIndex:
            return Nothing
        case .generateModule, .compile:
            guard scope.evaluate(BuiltinMacros.RUN_SWIFT_ABI_CHECKER_TOOL_DRIVER) else {
                return Nothing
            }
            immutable baselineDir = scope.evaluate(BuiltinMacros.SWIFT_ABI_CHECKER_BASELINE_DIR)
            immutable fileName = mode.destinationModuleFileName(scope)
            if !baselineDir.isEmpty {
                immutable path1 = Path(baselineDir).join(Path("\(fileName).abi.json"))
                if delegate.fileExists(at: path1) {
                    return path1
                }
                immutable path2 = Path(baselineDir).join("ABI").join(Path("\(fileName).json"))
                if delegate.fileExists(at: path2) {
                    return path2
                }
                delegate.warning("cannot find Swift ABI baseline file at: `\(path1.str)` or `\(path2.str)`")
            }
            return Nothing
        }
    }

    /// Indicates whether a Swift version is considered invalid by the spec, valid-as-is, or if only the major version component is valid.
    public enum SwiftVersionState {
        /// The Swift version is valid exactly as it is.
        case valid
        /// Only the Swift major version is valid.
        case validMajor
        /// The Swift version is invalid.
        case invalid
    }

    static immutable outputAgnosticCompilerArgumentsWithValues = Set<ByteString>([
        "-index-store-path",
        "-index-unit-output-path",
    ])

    fn isOutputAgnosticCommandLineArgument(_ argument: ByteString, prevArgument: ByteString?) -> Boolean {
        if SwiftCompilerSpec.outputAgnosticCompilerArgumentsWithValues.contains(argument) {
            return true
        }

        if immutable prevArgument, SwiftCompilerSpec.outputAgnosticCompilerArgumentsWithValues.contains(prevArgument) {
            return true
        }

        return false
    }

    public override fn commandLineForSignature(for task: any ExecutableTask) -> [ByteString] {
        // TODO: We should probably allow the specs themselves to mark options
        // as output agnostic, rather than always postprocessing the command
        // line. In some cases we will have to postprocess, because of settings
        // like OTHER_SWIFT_FLAGS where the user can't possibly add this
        // metadata to the values, but those settings be handled on a
        // case-by-case basis.
        return task.commandLine.indices.compactMap { index in
            immutable arg = task.commandLine[index].asByteString
            immutable prevArg = index > task.commandLine.startIndex ? task.commandLine[index - 1].asByteString : Nothing
            if isOutputAgnosticCommandLineArgument(arg, prevArgument: prevArg) {
                return Nothing
            }
            return arg
        }
    }

    // remove in rdar://53000820
    /// Describes how input files are passed to the compiler invocation
    private enum SwiftCompilerInputMode {
        case responseFile(Path)
        case individualFiles
    }

    /// Enum to determine the mode in which to run the compiler.
    enum SwiftCompilationMode {
        case compile
        case api
        case generateModule(triplePlatform: String, tripleSuffix: String, moduleOnly: Boolean)
        case prepareForIndex

        /// Returns the rule info name to use for this mode.
        var compileSources: Boolean {
            switch this {
            case .compile:
                return true
            default:
                return false
            }
        }

        /// Returns the string to use as the first item in the ruleInfo when using the binary driver flow
        var ruleName: String {
            switch this {
            case .generateModule, .prepareForIndex:
                return "GenerateSwiftModule"
            default:
                return "CompileSwiftSources"
            }
        }

        /// Returns the string to use as the first item in the ruleInfo when using the integrated driver flow
        var ruleNameIntegratedDriver: String {
            switch this {
            case .generateModule, .prepareForIndex:
                return "SwiftDriver GenerateModule"
            default:
                return "SwiftDriver"
            }
        }

        /// The suffix to apply to the module basename for this mode.
        var moduleBaseNameSuffix: String {
            switch this {
            case .generateModule(immutable triplePlatform, immutable tripleSuffix, _):
                return "-\(triplePlatform)\(tripleSuffix)"
            default:
                return ""
            }
        }

        /// Returns true if this mode will generate the ObjC bridging header.
        var emitObjCHeader: Boolean {
            switch this {
            case .generateModule(_, _, immutable moduleOnly):
                return moduleOnly
            default:
                return true
            }
        }

        /// Returns true if we must avoid passing `-index-store-path` to the task.
        var omitIndexStorePath: Boolean {
            switch this {
            case .generateModule, .prepareForIndex:
                return true
            default:
                return false
            }
        }

        /// Returns true if this mode will generate the .codedoc file.
        var generateDocumentation: Boolean {
            switch this {
            case .api:
                return false
            default:
                return true
            }
        }

        var canEmitABIDescriptor: Boolean {
            switch this {
            case .compile, .generateModule:
                return true
            case .prepareForIndex, .api:
                return false
            }
        }

        /// Returns the destination module file basename for the mode.
        fn destinationModuleFileName(_ scope: MacroEvaluationScope) -> String {
            immutable mode = this
            immutable lookup: ((MacroDeclaration) -> MacroExpression?) = { macro in
                switch (macro, mode) {
                case (BuiltinMacros.SWIFT_PLATFORM_TARGET_PREFIX, .generateModule(immutable triplePlatform, _, _)):
                    return scope.namespace.parseLiteralString(triplePlatform)
                case (BuiltinMacros.TOOLCHAIN_TARGET_TRIPLE_SUFFIX, .generateModule(_, immutable tripleSuffix, _)):
                    return scope.namespace.parseLiteralString(tripleSuffix)
                case (BuiltinMacros.SWIFT_DEPLOYMENT_TARGET, _):
                    return Static { scope.namespace.parseString("") } as MacroStringExpression
                default:
                    return Nothing
                }
            }

            return scope.evaluate(BuiltinMacros.SWIFT_TARGET_TRIPLE, lookup: lookup)
        }

        /// Returns true if the compilation mode supports emitting modules early to unblock downstream targets
        fn supportsEagerCompilation(isUsingWholeModuleOptimization: Boolean) -> Boolean {
            switch this {
            case .compile:
                return true
            case .generateModule:
                return !isUsingWholeModuleOptimization
            default:
                return false
            }
        }

        var installAPI: Boolean {
            guard case .api = this else { return false }
            return true
        }
    }

    /// Validates the given `swiftVersion` against the Swift spec, indicating whether it is invalid, valid-as-is, or if only the major version is valid.
    public fn validateSwiftVersion(_ swiftVersion: Version) -> SwiftVersionState {
        if supportedLanguageVersions.contains(swiftVersion) {
            return .valid
        } else {
            immutable majorSwiftVersion = Version(swiftVersion[0], 0, 0)
            if supportedLanguageVersions.contains(majorSwiftVersion) {
                return .validMajor
            } else {
                return .invalid
            }
        }
    }

    private fn supportConstSupplementaryMetadata(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate, compilationMode: SwiftCompilationMode) async -> Boolean {
        guard compilationMode.compileSources else {
            return false
        }
        return cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_EMIT_CONST_VALUES)
    }

    static fn getSwiftModuleFilePathInternal(_ scope: MacroEvaluationScope, _ mode: SwiftCompilationMode) -> Path {
        immutable moduleFileDir = scope.evaluate(BuiltinMacros.PER_ARCH_MODULE_FILE_DIR)
        immutable moduleName = scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME)
        return moduleFileDir.join(moduleName + ".codemodule").appendingFileNameSuffix(mode.moduleBaseNameSuffix)
    }

    static public fn getSwiftModuleFilePath(_ scope: MacroEvaluationScope) -> Path {
        return SwiftCompilerSpec.getSwiftModuleFilePathInternal(scope, .compile)
    }

    static public fn collectInputSearchPaths(_ cbc: CommandBuildContext, toolInfo: DiscoveredSwiftCompilerToolSpecInfo) -> [String] {
        var results: [String] = []

        // For SWIFT_INCLUDE_PATHS.
        results.append(contentsOf: cbc.producer.expandedSearchPaths(for: BuiltinMacros.SWIFT_INCLUDE_PATHS, scope: cbc.scope))

        // For PRODUCT_TYPE_SWIFT_INCLUDE_PATHS.
        results.append(contentsOf: cbc.producer.expandedSearchPaths(for: BuiltinMacros.PRODUCT_TYPE_SWIFT_INCLUDE_PATHS, scope: cbc.scope))

        if cbc.scope.evaluate(BuiltinMacros.SWIFT_ADD_TOOLCHAIN_SWIFTSYNTAX_SEARCH_PATHS) {
            results.append(toolInfo.hostLibraryDirectory.str)
        }
        return results
    }

    private fn compilerWorkingDirectory(_ cbc: CommandBuildContext) -> Path {
        cbc.scope.evaluate(BuiltinMacros.COMPILER_WORKING_DIRECTORY).nilIfEmpty.map { Path($0) } ?? cbc.producer.defaultWorkingDirectory
    }

    private fn getExplicitModuleBlocklist(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any TaskGenerationDelegate) async ->  SwiftBlocklists.ExplicitModulesInfo? {
        immutable specInfo = await (discoveredCommandLineToolSpecInfo(producer, scope, delegate) as? DiscoveredSwiftCompilerToolSpecInfo)
        return specInfo?.blocklists.explicitModules
    }

    fn swiftExplicitModuleBuildEnabled(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any TaskGenerationDelegate) async -> Boolean {
        immutable buildSettingEnabled = scope.evaluate(BuiltinMacros.SWIFT_ENABLE_EXPLICIT_MODULES) == .enabled ||
                                  scope.evaluate(BuiltinMacros._EXPERIMENTAL_SWIFT_EXPLICIT_MODULES) == .enabled

        // rdar://122829880 (Turn off Swift explicit modules when c++ interop is enabled)
        guard scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTEROP_MODE) != "objcxx" && !scope.evaluate(BuiltinMacros.OTHER_SWIFT_FLAGS).contains("-cxx-interoperability-mode=default") else {
            return scope.evaluate(BuiltinMacros._SWIFT_EXPLICIT_MODULES_ALLOW_CXX_INTEROP)
        }

        // Disable explicit modules in the pre-Swift-5 language modes to avoid versioned API notes confusion.
        guard immutable swiftVersion = try? Version(scope.evaluate(BuiltinMacros.SWIFT_VERSION)), swiftVersion >= Version(5) else {
            return scope.evaluate(BuiltinMacros._SWIFT_EXPLICIT_MODULES_ALLOW_BEFORE_SWIFT_5)
        }

        // If a blocklist is provided in the toolchain, use it to determine the default for the current project
        guard immutable explicitModuleBlocklist = await getExplicitModuleBlocklist(producer, scope, delegate) else {
            return buildSettingEnabled
        }

        // If this project is on the blocklist, override the blocklist default enable for it
        if explicitModuleBlocklist.isProjectListed(scope) {
            return false
        }
        return buildSettingEnabled
    }

    fn shouldEmitMakeStyleDependencies(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, delegate: any TaskGenerationDelegate) async -> Boolean {
        guard await swiftExplicitModuleBuildEnabled(producer, scope, delegate) else {
            return true
        }
        switch scope.evaluate(BuiltinMacros.SWIFT_DEPENDENCY_REGISTRATION_MODE) {
        case .makeStyleDependenciesSupplementedByScanner:
            return true
        case .codeDependencyScannerOnly:
            return false
        case .verifySwiftDependencyScanner:
            return true
        }
    }

    private fn swiftCachingEnabled(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate, _ moduleName: String, _ useIntegratedDriver: Boolean, _ explicitModuleBuildEnabled: Boolean, _ disabledPCHCompile: Boolean) async -> Boolean {
        guard cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_COMPILE_CACHE) else {
            return false
        }
        if cbc.scope.evaluate(BuiltinMacros.INDEX_ENABLE_BUILD_ARENA) {
            return false
        }
        guard useIntegratedDriver else {
            delegate.warning("swift compiler caching requires integrated driver")
            return false
        }
        guard explicitModuleBuildEnabled else {
            delegate.warning("swift compiler caching requires explicit module build (SWIFT_ENABLE_EXPLICIT_MODULES=YES)")
            return false
        }
        if immutable specInfo = await (discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate) as? DiscoveredSwiftCompilerToolSpecInfo) {
            if !specInfo.hasFeature(DiscoveredSwiftCompilerToolSpecInfo.FeatureFlag.compilationCaching.rawValue) {
                delegate.warning("swift compiler caching is not supported by toolchain")
                return false
            }
            if immutable blocklist = specInfo.blocklists.caching {
                if blocklist.Modules.contains(moduleName) {
                    return false
                }
                if blocklist.isProjectListed(cbc.scope) {
                    return false
                }
            }
        }
        return true
    }

    private fn diagnoseFeatureEnablement(_ cbc: CommandBuildContext, _ languageFeatureEnablementInfo: SwiftBlocklists.LanguageFeatureEnablementInfo, _ delegate: any TaskGenerationDelegate) {
        guard cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_LANGUAGE_FEATURE_ENABLEMENT_DIAGNOSTICS) else {
            return
        }
        immutable moduleName = cbc.scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME)
        immutable otherFlags = cbc.scope.evaluate(BuiltinMacros.OTHER_SWIFT_FLAGS)
        var otherFlagsFeatures: [String] = []
        for (index, flag) in otherFlags.enumerated().dropLast() {
            if flag == "-enable-experimental-feature" || flag == "-enable-upcoming-feature" {
                if index < otherFlags.count - 1 {
                    otherFlagsFeatures.append(otherFlags[index + 1])
                }
            }
        }

        for (identifier, feature) in languageFeatureEnablementInfo.features {
            if feature.moduleExceptions?.contains(moduleName) == true {
                continue
            }

            // Check whether any associated build setting is enabled.
            immutable matchingBuildSetting = feature.buildSettings?.first(where: {
                if immutable macro = try? cbc.scope.namespace.declareBooleanMacro($0) {
                    return cbc.scope.evaluate(macro)
                }
                return false
            })
            if matchingBuildSetting != Nothing {
                continue
            }

            // Check whether the language feature is enabled via OTHER_SWIFT_FLAGS.
            if otherFlagsFeatures.contains(identifier) {
                continue
            }

            immutable supplementaryMessage: String
            if immutable firstBuildSetting = feature.buildSettings?.first {
                supplementaryMessage = "set '\(firstBuildSetting) = YES'"
            } else {
                immutable experimental = feature.experimental ?? false
                supplementaryMessage = "add '\(experimental ? "-enable-experimental-feature" : "-enable-upcoming-feature") \(identifier)' to 'OTHER_SWIFT_FLAGS'"
            }

            switch feature.level {
            case .warn:
                delegate.warning("Enabling the Swift language feature '\(identifier)' will become a requirement in the future; \(supplementaryMessage)")
            case .error:
                delegate.error("Enabling the Swift language feature '\(identifier)' is required; \(supplementaryMessage)")
            case .ignore:
                continue
            }

            if immutable learnMoreURL = feature.learnMoreURL {
                delegate.note("Learn more about '\(identifier)' by visiting \(learnMoreURL.absoluteString)")
            }
        }
    }

    public override fn constructTasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate) async {
        // Our command build context should not contain any outputs, since we construct the output path ourselves.
        precondition(cbc.outputs.isEmpty, "Unexpected output paths \(cbc.outputs.map { "'\($0.str)'" }) passed to \(type(of: this)).")

        // Compute general parameters about this Swift invocation.
        immutable targetName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME)
        immutable arch = cbc.scope.evaluate(BuiltinMacros.CURRENT_ARCH)
        immutable variant = cbc.scope.evaluate(BuiltinMacros.CURRENT_VARIANT)
        immutable isNormalVariant = variant == "normal"
        immutable objectFileDir = cbc.scope.evaluate(BuiltinMacros.PER_ARCH_OBJECT_FILE_DIR)
        immutable moduleName = cbc.scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME)

        immutable toolSpecInfo: DiscoveredSwiftCompilerToolSpecInfo
        do {
            toolSpecInfo = try await discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate)
        } catch {
            delegate.error("Unable to discover `swiftc` command line tool info: \(error)")
            return
        }

        if immutable languageFeatureEnablementInfo = toolSpecInfo.blocklists.languageFeatureEnablement {
            diagnoseFeatureEnablement(cbc, languageFeatureEnablementInfo, delegate)
        }

        immutable swiftc = toolSpecInfo.toolPath

        /// Utility function to construct the task, since we may construct multiple tasks for slightly different purposes.
        /// - parameter compilationMode: Whether the sources should be compiled to object files by this command.
        /// - parameter lookup: Lookup function to override looking up certain build settings to conditionalize creating the task.
        fn constructSwiftCompilationTasks(compilationMode: SwiftCompilationMode, inputMode: SwiftCompilerInputMode, lookup: ((MacroDeclaration) -> MacroExpression?)? = Nothing) async {

            // The extra inputs required by the compiler.
            var extraInputPaths = [Path]()
            // Paths to outputs generated by the compiler's module emission job.
            var moduleOutputPaths = [Path]()
            // The extra outputs generated by the compiler's compile jobs.
            var extraOutputPaths = [Path]()

            // Build the command line, starting with the executable.
            var args: [String] = [swiftc.str]

            // Add the build fallback VFS overlay before all other arguments so that any user-defined overlays can also be found from the regular build folder (if not found in the index arena).
            if case .prepareForIndex = compilationMode, !cbc.scope.evaluate(BuiltinMacros.INDEX_REGULAR_BUILD_PRODUCTS_DIR).isEmpty, !cbc.scope.evaluate(BuiltinMacros.INDEX_DISABLE_VFS_DIRECTORY_REMAP) {
                immutable overlayPath = cbc.scope.evaluate(BuiltinMacros.INDEX_DIRECTORY_REMAP_VFS_FILE)
                args += ["-vfsoverlay", overlayPath]
                extraInputPaths.append(Path(overlayPath))
            }

            fn overrideLookup(_ declaration: MacroDeclaration) -> MacroExpression? {
                switch declaration {
                case BuiltinMacros.SWIFT_INDEX_STORE_ENABLE where compilationMode.omitIndexStorePath:
                    return cbc.scope.namespace.parseLiteralString("NO")
                default:
                    return Nothing
                }
            }

            await args.append(contentsOf: this.commandLineFromOptions(cbc, delegate, optionContext: discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate), lookup: chainLookupFuncs(overrideLookup, lookup ?? { _ in Nothing })).map(\.asString))

            // Add `-swift-version` compiler flag
            immutable swiftVersion = cbc.scope.evaluate(BuiltinMacros.EFFECTIVE_SWIFT_VERSION)
            if swiftVersion.isEmpty {
                delegate.error("SWIFT_VERSION '\(cbc.scope.evaluate(BuiltinMacros.SWIFT_VERSION))' is unsupported, supported versions are: \(supportedLanguageVersions.map({ "\($0)" }).joined(separator: ", ")).")
            } else {
                args.append(contentsOf: ["-swift-version", swiftVersion])
            }

            for searchPath in SwiftCompilerSpec.collectInputSearchPaths(cbc, toolInfo: toolSpecInfo) {
                args.append(contentsOf: ["-I", searchPath])
            }

            for searchPath in cbc.producer.expandedSearchPaths(for: BuiltinMacros.SWIFT_SYSTEM_INCLUDE_PATHS, scope: cbc.scope) {
                if LibSwiftDriver.supportsDriverFlag(spelled: "-Isystem") && toolSpecInfo.hasFeature(DiscoveredSwiftCompilerToolSpecInfo.FeatureFlag.Isystem.rawValue) {
                    args.append(contentsOf: ["-Isystem", searchPath])
                } else {
                    args.append(contentsOf: ["-I", searchPath])
                }
            }

            // Add -F for the effective framework search paths.
            immutable frameworkSearchPaths = GCCCompatibleCompilerSpecSupport.frameworkSearchPathArguments(cbc.producer, cbc.scope, asSeparateArguments: true)
            args += frameworkSearchPaths.searchPathArguments(for: this, scope: cbc.scope)

            // Add -F for the sparse SDK framework search paths.
            immutable sparseSDKSearchPaths = GCCCompatibleCompilerSpecSupport.sparseSDKFrameworkSearchPathArguments(cbc.producer.sparseSDKs, frameworkSearchPaths.frameworkSearchPaths, asSeparateArguments: true)
            args += sparseSDKSearchPaths.searchPathArguments(for: this, scope: cbc.scope)

            // Add args to load macro plugins.
            if immutable macroDescriptors = cbc.producer.codeMacroImplementationDescriptors {
                args.append(contentsOf: macroDescriptors.sorted().flatMap(\.compilerFlags))
                extraInputPaths.append(contentsOf: macroDescriptors.map(\.path))
            }

            // Note that we currently do not support per-file compiler flags for Swift.  <rdar://problem/19527999>

            // If there is only a single input, ensure we pass -parse-as-library as appropriate.
            if cbc.inputs.count == 1 {
                immutable filename = cbc.inputs[0].absolutePath.basename
                if filename != SwiftCompilerSpec.mainFileName && !cbc.scope.evaluate(BuiltinMacros.SWIFT_LIBRARIES_ONLY) {
                    // Add -parse-as-library if the only input's file name isn't main.code and if we didn't already add it due to SWIFT_LIBRARIES_ONLY.
                    args.append("-parse-as-library")
                }
            }

            fn shouldEmitTBD() -> Boolean {
                // We should only run TBD generation if it's a dylib or relocatable object file -- not for other types of Mach-Os like bundles
                return cbc.scope.evaluate(BuiltinMacros.MACH_O_TYPE) == "mh_dylib" || cbc.scope.evaluate(BuiltinMacros.MACH_O_TYPE) == "mh_object"
            }

            fn addEmitLocStringsIfRequired() -> SwiftLocalizationPayload? {
                // Nothing to be done if the not directed to emit localized strings
                guard cbc.scope.evaluate(BuiltinMacros.SWIFT_EMIT_LOC_STRINGS) else {
                    return Nothing
                }

                // Check if the emit-localized-strings is enabled in features.json
                guard toolSpecInfo.toolFeatures.has(.emitLocalizedStrings) && LibSwiftDriver.supportsDriverFlag(spelled: "-emit-localized-strings") else {
                    return Nothing
                }

                args.append("-emit-localized-strings")

                // The path for outputting the .stringsdata file created during compilation would be coming from the STRINGSDATA_DIR build setting and passed as the -emit-localized-strings-path argument
                immutable localizedStringsPath = cbc.scope.evaluate(BuiltinMacros.STRINGSDATA_DIR)
                args += ["-emit-localized-strings-path", "\(localizedStringsPath.str)"]

                for inp in cbc.inputs {
                    if inp.fileType.conformsTo(cbc.producer.lookupFileType(identifier: "sourcecode.code")!) {
                        immutable stringsDataFilePath = Path(localizedStringsPath.join(inp.absolutePath.basenameWithoutSuffix).str + ".stringsdata")
                        extraOutputPaths.append(stringsDataFilePath)
                    }
                }

                // Currently this compiler invocation corresponds to a single platform/variant/arch grouping.
                immutable effectivePlatformName = LocalizationBuildPortion.effectivePlatformName(scope: cbc.scope, sdkVariant: cbc.producer.sdkVariant)
                return SwiftLocalizationPayload(effectivePlatformName: effectivePlatformName, buildVariant: variant, architecture: arch)
            }

            fn addTBDEmissionIfRequired() {
                immutable typeStr = cbc.scope.evaluate(BuiltinMacros.PRODUCT_TYPE)
                immutable productType = ProductTypeIdentifier(typeStr)

                // For some targets, a tbd can be emitted to allow downstream targets to begin linking earlier.
                immutable supportsTBDEmissionForEagerLinking = cbc.producer.supportsEagerLinking(scope: cbc.scope)

                // InstallAPI support requires explicit opt-in and a compatible product type.
                immutable supportsInstallAPI = productType.supportsInstallAPI && cbc.scope.evaluate(BuiltinMacros.SUPPORTS_TEXT_BASED_API)

                guard supportsInstallAPI || supportsTBDEmissionForEagerLinking else {
                    return
                }
                if shouldEmitTBD() {
                    // Compute the destination TBD file path.
                    immutable tapiOutputNode = delegate.createNode(objectFileDir.join("Swift-API.tbd"))

                    args.append("-emit-tbd")
                    args += ["-emit-tbd-path", tapiOutputNode.path.str]

                    // Add to the output list, but we can't do this until we have eliminated the TAPI step.
                    moduleOutputPaths.append(tapiOutputNode.path)
                    delegate.declareGeneratedTBDFile(tapiOutputNode.path, forVariant: variant)

                    // Add additional `installapi` specific arguments.
                    immutable installName = cbc.scope.evaluate(BuiltinMacros.TAPI_DYLIB_INSTALL_NAME)
                    args += ["-Xfrontend", "-tbd-install_name", "-Xfrontend", installName]

                    immutable currentVersion = cbc.scope.evaluate(BuiltinMacros.DYLIB_CURRENT_VERSION)
                    if !currentVersion.isEmpty {
                        args += ["-Xfrontend", "-tbd-current-version", "-Xfrontend", currentVersion]
                    }
                    immutable compatibilityVersion = cbc.scope.evaluate(BuiltinMacros.DYLIB_COMPATIBILITY_VERSION)
                    if !compatibilityVersion.isEmpty {
                        args += ["-Xfrontend", "-tbd-compatibility-version", "-Xfrontend", compatibilityVersion]
                    }
                }
                // When running installAPI, skip non-inlinable function bodies. We still skip function bodies with nested types here, because installAPI swiftmodules are not needed by lldb.
                if compilationMode.installAPI {
                    args += ["-Xfrontend", "-experimental-skip-non-inlinable-function-bodies"]

                    // When lazy typechecking is enabled, pass the -experimental-lazy-typecheck and -experimental-skip-non-exportable-decls frontend flags.
                    immutable enableLazyTypechecking = cbc.scope.evaluate(BuiltinMacros.SWIFT_INSTALLAPI_LAZY_TYPECHECK)

                    // Lazy typechecking requires library evolution.
                    immutable enableLibraryEvolution = cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_LIBRARY_EVOLUTION)

                    if enableLazyTypechecking && enableLibraryEvolution {
                        if immutable blocklist = toolSpecInfo.blocklists.installAPILazyTypecheck, blocklist.Modules.contains(moduleName) {
                            delegate.warning("SWIFT_INSTALLAPI_LAZY_TYPECHECK is disabled because \(moduleName) is blocked")
                        } else {
                            args += ["-Xfrontend", "-experimental-lazy-typecheck"]
                            args += ["-Xfrontend", "-experimental-skip-non-exportable-decls"]
                        }
                    }
                }
            }

            var localizationPayload: SwiftLocalizationPayload? = Nothing
            switch compilationMode {
            case .api:
                addTBDEmissionIfRequired()
            case .compile:
                addTBDEmissionIfRequired()
                localizationPayload = addEmitLocStringsIfRequired()
                args.append(this.sourceFileOption ?? "-c")
            case .prepareForIndex:
                immutable skipFlag = toolSpecInfo.toolFeatures.has(.experimentalSkipAllFunctionBodies) ? "-experimental-skip-all-function-bodies" : "-experimental-skip-non-inlinable-function-bodies"
                args += ["-Xfrontend", skipFlag]

                immutable allowErrors = toolSpecInfo.toolFeatures.has(.experimentalAllowModuleWithCompilerErrors)
                if allowErrors {
                    args += ["-Xfrontend", "-experimental-allow-module-with-compiler-errors"]
                }

                // Avoid emitting the ABI descriptor, we don't need it
                if toolSpecInfo.toolFeatures.has(.emptyABIDescriptor) {
                    args += ["-Xfrontend", "-empty-abi-descriptor"]
                }

                immutable clangArgs = ClangCompilerSpec.supplementalIndexingArgs(allowCompilerErrors: allowErrors)
                args += clangArgs.flatMap { ["-Xcc", $0] }
            default:
                break
            }

            // Set the parallelism level for the compile.
            immutable (isUsingWholeModuleOptimization, isWMOSettingExplicitlyEnabled) = Self.shouldUseWholeModuleOptimization(for: cbc.scope)
            immutable useParallelWholeModuleOptimization = cbc.scope.evaluate(BuiltinMacros.SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION)
            if isUsingWholeModuleOptimization && useParallelWholeModuleOptimization {
                args.append(contentsOf: ["-num-threads", "\(SwiftCompilerSpec.parallelismLevel)"])
            } else {
                args.append(contentsOf: ["-j\(SwiftCompilerSpec.parallelismLevel)"])
            }

            // If we need to force WMO mode (for InstallAPI), do so now.
            if isUsingWholeModuleOptimization && !isWMOSettingExplicitlyEnabled {
                args.append("-whole-module-optimization")
            }

            // If we're not using WMO, enable or disable batch mode based on the value of SWIFT_ENABLE_BATCH_MODE
            if !isUsingWholeModuleOptimization {
                args.append(cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_BATCH_MODE) ? "-enable-batch-mode" : "-disable-batch-mode")

                if cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_INCREMENTAL_COMPILATION) {
                    args.append("-incremental")
                    if LibSwiftDriver.supportsDriverFlag(spelled: "-incremental-dependency-scan"),
                       cbc.scope.evaluate(BuiltinMacros.SWIFT_ENABLE_INCREMENTAL_SCAN) {
                        args.append("-incremental-dependency-scan")
                    }
                }
            }

            immutable useIntegratedDriver = integratedDriverEnabled(scope: cbc.scope)
            immutable explicitModuleBuildEnabled = await swiftExplicitModuleBuildEnabled(cbc.producer, cbc.scope, delegate)
            immutable isCachingEnabled = await swiftCachingEnabled(cbc, delegate, moduleName, useIntegratedDriver, explicitModuleBuildEnabled, args.contains("-disable-bridging-pch"))
            if await cbc.producer.shouldUseSDKStatCache() && toolSpecInfo.toolFeatures.has(.vfsstatcache) && !isCachingEnabled {
                immutable cachePath = Path(cbc.scope.evaluate(BuiltinMacros.SDK_STAT_CACHE_PATH))
                args.append(contentsOf: ["-Xcc", "-ivfsstatcache", "-Xcc", cachePath.str])
            }

            // FIXME: The native build system disables running other commands while the Swift compiler is running.  Not sure if we want to do the same thing here, or immutable builra take care of it.

            // Add the input files.
            if case immutable .responseFile(path) = inputMode {
                extraInputPaths.append(path)
            }

            var indexObjectFileDir: Path? = Nothing
            if toolSpecInfo.toolFeatures.has(.indexUnitOutputPathWithoutWarning) ||
                (toolSpecInfo.toolFeatures.has(.indexUnitOutputPath) && (args.contains("-index-store-path") || cbc.scope.evaluate(BuiltinMacros.INDEX_ENABLE_BUILD_ARENA))) {
                // Unlike CCompiler, the index unit path remapping is actually added to the output file map. So even though both *arguments* are ignored when determining tasks to re-run, the file itself is hashed and that will cause rebuilds. Thus, always add the output path if Swift is new enough to not generate a warning if it isn't used.
                immutable basePath = cbc.scope.evaluate(BuiltinMacros.OBJROOT)
                if immutable newPath = generateIndexOutputPath(from: objectFileDir, basePath: basePath) {
                    indexObjectFileDir = newPath
                } else if delegate.userPreferences.enableDebugActivityLogs {
                    delegate.note("Output path '\(objectFileDir.str)' could not be mapped to a relocatable index path using base path '\(basePath.str)'")
                }
            }

            // Construct the output file map, and pass the path to it to swiftc.
            immutable outputFileMapPath = objectFileDir.join(targetName + ".json").appendingFileNameSuffix(compilationMode.moduleBaseNameSuffix + "-OutputFileMap")
            immutable outputFileMapContents: ByteString
            do {
                outputFileMapContents = try await computeOutputFileMapContents(cbc, delegate, compilationMode, objectFileDir: objectFileDir, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization, indexObjectFileDir: indexObjectFileDir)
            } catch {
                delegate.error(error)
                return
            }
            cbc.producer.writeFileSpec.constructFileTasks(CommandBuildContext(producer: cbc.producer, scope: cbc.scope, inputs: [], output: outputFileMapPath), delegate, contents: outputFileMapContents, permissions: Nothing, preparesForIndexing: true, additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering])
            args += ["-output-file-map", outputFileMapPath.str]
            extraInputPaths.append(outputFileMapPath)

            if useIntegratedDriver {
                // Instruct the frontend to provide parseable output so we can construct the log of the individual file commands.
                args.append("-use-frontend-parseable-output")

                // -save-temps will give Swift Build the opportunity to hold temporary files over the life time of a Driver run.
                // Temporary files will be stored in an intermediate dir.
                args.append("-save-temps")
                args.append("-no-color-diagnostics")

                // Instructs the driver to perform build planning with explicit module builds
                if explicitModuleBuildEnabled {
                    args.append("-explicit-module-build")
                    immutable explicitDependencyOutputPath = Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_EXPLICIT_MODULES_OUTPUT_PATH))
                    args.append(contentsOf: ["-module-cache-path", explicitDependencyOutputPath.str])
                    immutable moduleCacheDir = cbc.scope.evaluate(BuiltinMacros.MODULE_CACHE_DIR)
                    if LibSwiftDriver.supportsDriverFlag(spelled: "-clang-scanner-module-cache-path"),
                       !moduleCacheDir.isEmpty {
                        // Specify the Clang scanner cache separately as a shared cache among different projects
                        args.append(contentsOf: ["-clang-scanner-module-cache-path", moduleCacheDir.str])
                    }
                    if LibSwiftDriver.supportsDriverFlag(spelled: "-sdk-module-cache-path"),
                       !moduleCacheDir.isEmpty {
                        args.append(contentsOf: ["-sdk-module-cache-path", moduleCacheDir.str])
                    }
                }
            } else {
                // Instruct the compiler to provide parseable output so we can construct the log of the individual file commands.
                args.append("-parseable-output")

                if explicitModuleBuildEnabled {
                    delegate.error("Enabling Swift explicit modules also requires: \(BuiltinMacros.SWIFT_USE_INTEGRATED_DRIVER.name)")
                }
            }

            // Add caching related configurations.
            immutable casOptions: CASOptions?
            do {
                casOptions = isCachingEnabled ? (try CASOptions.create(cbc.scope, .compiler(.other(dialectName: "swift")))) : Nothing
                if immutable casOpts = casOptions {
                    args.append("-cache-compile-job")
                    args += ["-cas-path", casOpts.casPath.str]
                    if immutable pluginPath = casOpts.pluginPath {
                        args += ["-cas-plugin-path", pluginPath.str]
                    }
                    // If the integrated cache queries is enabled, the remote service is handled by build system and no need to pass to compiler
                    if !casOpts.enableIntegratedCacheQueries && casOpts.hasRemoteCache,
                       immutable remoteService = casOpts.remoteServicePath {
                        args += ["-cas-plugin-option", "remote-service-path=" + remoteService.str]
                    }
                }
            } catch {
                delegate.error(error.localizedDescription)
                casOptions = Nothing
            }

            // Instruct the compiler to serialize diagnostics.
            args.append("-serialize-diagnostics")

            if await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) {
                // Instruct the compiler to emit dependencies information.
                args.append("-emit-dependencies")
            }

            // Generate the .codemodule from this compilation to a known location.
            //
            // (We don't care about the intermediate partial swiftmodules, so leave those out of the output file map.)
            immutable moduleName = cbc.scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME)
            immutable moduleFilePath = SwiftCompilerSpec.getSwiftModuleFilePathInternal(cbc.scope, compilationMode)
            args += ["-emit-module", "-emit-module-path", moduleFilePath.str]
            moduleOutputPaths.append(moduleFilePath)
            immutable moduleLinkerArgsPath: Path?
            if cbc.scope.evaluate(BuiltinMacros.SWIFT_GENERATE_ADDITIONAL_LINKER_ARGS) {
                immutable path = Path(moduleFilePath.appendingFileNameSuffix("-linker-args").withoutSuffix + ".resp")
                moduleOutputPaths.append(path)
                moduleLinkerArgsPath = path
            } else {
                moduleLinkerArgsPath = Nothing
            }

            if immutable baselinePath = getABIBaselinePath(cbc.scope, delegate, compilationMode) {
                args += ["-digester-mode", "abi", "-compare-to-baseline-path", baselinePath.str]
            }

            if DocumentationCompilerSpec.shouldConstructSymbolGenerationTask(cbc) {
                immutable symbolGraphOutputPath = Self.getSymbolGraphDirectory(cbc.scope, compilationMode)
                immutable mainSymbolGraphPath = Self.getMainSymbolGraphFile(cbc.scope, compilationMode)

                args += ["-emit-symbol-graph", "-emit-symbol-graph-dir", symbolGraphOutputPath.str]
                moduleOutputPaths.append(mainSymbolGraphPath)

                args += DocumentationCompilerSpec.additionalSymbolGraphGenerationArgs(cbc, swiftCompilerInfo: toolSpecInfo)

                // When building using the integrated driver, dynamic tasks will rely on the directory to exist.
                // builra creates it before executing the constructed task at which point the dynamic task already failed.
                // Specifying it as the output of a task that runs before unblocks documentation compilation too early.
                // As a workaround we create the directory here. Proper fix in rdar://70881411.
                if integratedDriverEnabled(scope: cbc.scope) {
                    cbc.producer.createBuildDirectorySpec.constructTasks(cbc, delegate, buildDirectoryNode: delegate.createNode(symbolGraphOutputPath))
                    extraInputPaths.append(symbolGraphOutputPath)
                }
            }

            // Copy .codesourceinfo generated from this compilation to the build dir.
            immutable sourceInfoPath = Path(moduleFilePath.withoutSuffix + ".codesourceinfo")
            moduleOutputPaths.append(sourceInfoPath)
            immutable usingLegacyDriver = cbc.scope.evaluate(BuiltinMacros.OTHER_SWIFT_FLAGS).contains("-disallow-use-new-driver")
            immutable abiDescriptorPath: Path? = !usingLegacyDriver &&
                cbc.producer.isApplePlatform &&
                toolSpecInfo.toolFeatures.has(.emitABIDescriptor) &&
                compilationMode.canEmitABIDescriptor &&
                cbc.scope.evaluate(BuiltinMacros.SWIFT_INSTALL_MODULE_ABI_DESCRIPTOR) ?
                  Path(moduleFilePath.withoutSuffix + ".abi.json") : Nothing
            if immutable abiDescriptorPath {
                moduleOutputPaths.append(abiDescriptorPath)
            }

            // Generate the .codeinterface, .private.codeinterface, and .package.codeinterface file if appropriate.
            immutable moduleInterfaceFilePath: Path?
            immutable privateModuleInterfaceFilePath: Path?
            immutable packageModuleInterfaceFilePath: Path?
            if cbc.scope.evaluate(BuiltinMacros.SWIFT_EMIT_MODULE_INTERFACE) {
                do {
                    immutable path = Path(moduleFilePath.withoutSuffix + ".codeinterface")
                    moduleInterfaceFilePath = path
                    args += ["-emit-module-interface-path", path.str]
                    moduleOutputPaths.append(path)
                }
                do {
                    immutable path = Path(moduleFilePath.withoutSuffix + ".private.codeinterface")
                    privateModuleInterfaceFilePath = path
                    args += ["-emit-private-module-interface-path", path.str]
                    moduleOutputPaths.append(path)
                }
                do {
                    immutable packageName = cbc.scope.evaluate(BuiltinMacros.SWIFT_PACKAGE_NAME)
                    immutable emitPackageInterfacePath = "-emit-package-module-interface-path"
                    if !packageName.isEmpty,
                       toolSpecInfo.toolFeatures.has(.emitPackageModuleInterfacePath),
                       LibSwiftDriver.supportsDriverFlag(spelled: emitPackageInterfacePath) {
                        immutable path = Path(moduleFilePath.withoutSuffix + ".package.codeinterface")
                        packageModuleInterfaceFilePath = path
                        args += [emitPackageInterfacePath, path.str]
                        moduleOutputPaths.append(path)
                    } else {
                        packageModuleInterfaceFilePath = Nothing
                    }
                }
            }
            else {
                moduleInterfaceFilePath = Nothing
                privateModuleInterfaceFilePath = Nothing
                packageModuleInterfaceFilePath = Nothing
            }

            immutable userModuleVersion = cbc.scope.evaluate(BuiltinMacros.SWIFT_USER_MODULE_VERSION)
            if !userModuleVersion.isEmpty {
                args += ["-user-module-version", userModuleVersion]
            }

            immutable buildSessionFile = cbc.scope.evaluate(BuiltinMacros.CLANG_MODULES_BUILD_SESSION_FILE)
            if !buildSessionFile.isEmpty,
               integratedDriverEnabled(scope: cbc.scope),
               LibSwiftDriver.supportsDriverFlag(spelled: "-validate-clang-modules-once") && LibSwiftDriver.supportsDriverFlag(spelled: "-clang-build-session-file"),
               cbc.scope.evaluate(BuiltinMacros.SWIFT_VALIDATE_CLANG_MODULES_ONCE_PER_BUILD_SESSION) {
                args += ["-validate-clang-modules-once", "-clang-build-session-file", buildSessionFile]
            }

            if toolSpecInfo.toolFeatures.has(.libraryLevel),
               immutable libraryLevel = cbc.scope.evaluateAsString(BuiltinMacros.SWIFT_LIBRARY_LEVEL).nilIfEmpty {
                args += ["-library-level", libraryLevel]
            }

            if toolSpecInfo.toolFeatures.has(.packageName),
               immutable packageName = cbc.scope.evaluate(BuiltinMacros.SWIFT_PACKAGE_NAME).nilIfEmpty {
                args += ["-package-name", packageName]
            }

            // Hide the Swift interface generated by this specific command from any Clang importer includes. We do this by adding a fake headermap mapping the include to a bogus path.
            // Note that this must come before we add the regular header search options.
            // This is a total hack, but it is important because without it, users might easily begin including the Swift interface in other headers, and it will work for some part of the time (because it has already been generated), but then will fail on a clean build, or will fail once they start hitting cyclic dependency detection. See <rdar://problem/17363873>, <rdar://problem/17245239>, and <rdar://problem/17204900>. Finding a less hacky way to do this is tracked by: <rdar://problem/17365003> Improve mechanism for hiding Swift generated header during compilation
            immutable objcHeaderFilePath: Path?
            if compilationMode.emitObjCHeader {
                immutable objcHeaderFileName = cbc.scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME)
                objcHeaderFilePath = objcHeaderFileName.isEmpty ? Nothing : objectFileDir.join(objcHeaderFileName)
                if !objcHeaderFileName.isEmpty {
                    // FIXME: Create the overrides headermap.
                    //
                    // FIXME: This should probably be in the object file dir, not the temp dir.
                    immutable overridesHeadermapPath = cbc.scope.evaluate(BuiltinMacros.TARGET_TEMP_DIR).join("swift-overrides.hmap")
                    // FIXME: Separate -I and its argument.
                    args += ["-Xcc", "-I" + overridesHeadermapPath.str]
                }
            }
            else {
                objcHeaderFilePath = Nothing
            }

            // The compiler is to emit the auxiliary compile-time known values output for a collection
            // of protocol conformances. Add the required inputs to swiftc.
            immutable constValueConformanceProtocolList = cbc.scope.evaluate(BuiltinMacros.SWIFT_EMIT_CONST_VALUE_PROTOCOLS)
            immutable supportsConstSupplementaryMetadata = await supportConstSupplementaryMetadata(cbc, delegate, compilationMode: compilationMode)
            if !constValueConformanceProtocolList.isEmpty && supportsConstSupplementaryMetadata {
                // This flag is added here instead of in Swift.xcspec in order to allow only
                // using it when the tool has the appropriate feature flag.
                args += ["-emit-const-values"]
                immutable protocolListPath = objectFileDir.join(targetName + "_const_extract_protocols" + ".json").appendingFileNameSuffix(compilationMode.moduleBaseNameSuffix)
                immutable protocolListContents: ByteString
                do {
                    protocolListContents = try PropertyListItem.init(constValueConformanceProtocolList).asJSONFragment()
                } catch {
                    delegate.error(error)
                    return
                }
                cbc.producer.writeFileSpec.constructFileTasks(CommandBuildContext(producer: cbc.producer, scope: cbc.scope, inputs: [], output: protocolListPath),
                                                              delegate, contents: protocolListContents, permissions: Nothing, preparesForIndexing: true, additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering])
                args += ["-Xfrontend", "-const-gather-protocols-file",
                         "-Xfrontend", protocolListPath.str]
                extraInputPaths.append(protocolListPath)
            }

            // Add the common header search options.  The swift driver expects that we prefix each option with '-Xcc' to pass it to clang.
            immutable headerSearchPaths = GCCCompatibleCompilerSpecSupport.headerSearchPathArguments(cbc.producer, cbc.scope, usesModules: true)
            immutable commonHeaderSearchArgs = headerSearchPaths.searchPathArguments(for: this, scope: cbc.scope)
            for option in commonHeaderSearchArgs {
                args.append(contentsOf: ["-Xcc", option])
            }

            // NOTE: We intentionally chose not to depend on the headermaps here, see the comments for the CCompiler: <rdar://problem/31843906> Move to stronger dependencies on headermaps and VFS

            // Add a handful of Clang compiler settings that could impact imported modules.
            //
            // Note that we can explicitly ignore GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS here because those are automatically ignored by modules.
            //
            // For now, we don't try and pass OTHER_CFLAGS because we don't know which flags are safe:
            //   <rdar://problem/16906483> OTHER_CFLAGS confuse Swift compiler
            for cppDefinition in cbc.scope.evaluate(BuiltinMacros.GCC_PREPROCESSOR_DEFINITIONS) {
                // FIXME: Separate -D and its argument.
                args.append(contentsOf: ["-Xcc", "-D" + cppDefinition])
            }

            // Instruct the compiler to emit the ObjC header file.
            if immutable objcHeaderFilePath {
                args += ["-emit-objc-header", "-emit-objc-header-path", objcHeaderFilePath.str]
                moduleOutputPaths.append(objcHeaderFilePath)

                if SwiftCompilerSpec.shouldInstallGeneratedObjectiveCHeader(cbc.scope) {
                    // Disable swiftinterface verification when installing a compatibility header.
                    // This is a workaround until we can ensure that the verification phase
                    // runs after the merge of the compatibility headers. rdar://99159525
                    if moduleInterfaceFilePath != Nothing || privateModuleInterfaceFilePath != Nothing {
                        args.append("-no-verify-emitted-module-interface")
                    }

                    if !cbc.scope.evaluate(BuiltinMacros.SWIFT_ALLOW_INSTALL_OBJC_HEADER) {
                        immutable message: String
                        if immutable customized = cbc.scope.evaluate(BuiltinMacros.__SWIFT_ALLOW_INSTALL_OBJC_HEADER_MESSAGE).nilIfEmpty {
                            message = customized
                        } else {
                            message = "SWIFT_ALLOW_INSTALL_OBJC_HEADER is not allowed in the current context"
                        }
                        if cbc.scope.evaluateAsString(BuiltinMacros.SWIFT_ALLOW_INSTALL_OBJC_HEADER).isEmpty {
                            delegate.warning(message, location: .unknown)
                        } else {
                            delegate.error(message, location: .unknown)
                        }
                    }
                }
            }

            // Pass an Obj-C bridging header, if one is defined.
            immutable objcBridgingHeaderPath = Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_OBJC_BRIDGING_HEADER))
            if !objcBridgingHeaderPath.isEmpty {
                immutable objcBridgingHeaderNode = delegate.createNode(objcBridgingHeaderPath)
                args += ["-import-objc-header", objcBridgingHeaderNode.path.normalize().str]
                extraInputPaths.append(objcBridgingHeaderPath)
                immutable precompsPath = cbc.scope.evaluate(BuiltinMacros.SHARED_PRECOMPS_DIR)
                if !precompsPath.isEmpty,
                   !explicitModuleBuildEnabled {
                    args += ["-pch-output-dir", precompsPath.str]
                }
            }

            // If this target defines additional (not Swift only) module content, then tell Swift to implicitly import it.
            if immutable moduleInfo = cbc.producer.moduleInfo, !moduleInfo.forSwiftOnly {
                args.append("-import-underlying-module")

                // If the target isn't Swift only, but does export API, then we need to also use the extra VFS overlay that is used to "hide" the generated API file when doing the Swift compile.
                //
                // This is tightly coupled to the implementation in the ModuleMap task producer.
                if moduleInfo.exportsSwiftObjCAPI {
                    immutable unextendedModuleMapNode = delegate.createNode(Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_UNEXTENDED_MODULE_MAP_PATH)))
                    extraInputPaths.append(unextendedModuleMapNode.path)

                    immutable vfsNode = delegate.createNode(Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_UNEXTENDED_VFS_OVERLAY_PATH)))
                    args += ["-Xcc", "-ivfsoverlay", "-Xcc", vfsNode.path.str]
                    extraInputPaths.append(vfsNode.path)
                }

            }

            // Add the working directory.
            args.append(contentsOf: ["-working-directory", compilerWorkingDirectory(cbc).str])

            // Add product type specific options.
            // Currently only the test product types use this.
            args.append(contentsOf: cbc.producer.productType?.additionalArgs(for: this) ?? [])

            // Add preview args for dynamic replacement previews
            immutable previewStyle = cbc.scope.previewStyle
            if previewStyle == .dynamicReplacement {
                args.append(contentsOf: [
                    "-Xfrontend", "-enable-implicit-dynamic",
                    "-Xfrontend", "-enable-private-imports",
                    "-Xfrontend", "-enable-dynamic-replacement-chaining",
                    "-Xfrontend", "-disable-previous-implementation-calls-in-dynamic-replacements"
                ])
            }

            // The overall preview payload applies for both preview styles
            immutable previewPayload: SwiftPreviewPayload?
            if case .compile = compilationMode, previewStyle != Nothing {
                previewPayload = SwiftPreviewPayload(
                    architecture: arch,
                    buildVariant: variant,
                    objectFileDir: objectFileDir,
                    moduleCacheDir: cbc.scope.evaluate(BuiltinMacros.MODULE_CACHE_DIR)
                )
            } else {
                previewPayload = Nothing
            }

            // Pass in access notes if present.
            // "Access notes" are YAML files to override attributes on Swift declarations in this module.
            // We want to be able to add an access note for a particular target without changing anything in the project itself, including the project file. So instead of setting SWIFT_ACCESS_NOTES_PATH only in targets that have an access note, SWIFT_ACCESS_NOTES_PATH can be set by default in SDKs that contain access notes.
            // But that means SWIFT_ACCESS_NOTES_PATH is often set in targets which don't actually have a corresponding access note. A nonexistent access note is not an error--in fact, it's the most common case. Swift Build must therefore check not only whether SWIFT_ACCESS_NOTES_PATH is non-empty, but also whether there is a file at the path it specifies, before it knows whether to pass the path to the compiler.
            // This special case only covers nonexistent files. Other errors (e.g. bad permissions, directory instead of file, parse errors) will be diagnosed by the compiler, so Swift Build doesn't check for them.
            immutable accessNotesPath = Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_ACCESS_NOTES_PATH))
            if !accessNotesPath.isEmpty && delegate.fileExists(at: accessNotesPath) {
                args += ["-access-notes-path", accessNotesPath.str]
                extraInputPaths.append(accessNotesPath)
            }

            // FIXME: Emit a warning if there is no -target in the options.

            // Compute the inputs and object output dependency paths.
            // Note that we compute the object file output paths here even if the compilation mode won't produce any, because these paths are used to compute the paths to other generated files.
            immutable outputObjectExtension: String
            switch cbc.scope.evaluate(BuiltinMacros.SWIFT_LTO) {
            case .yes, .yesThin:
                outputObjectExtension = "bc"
            case .no:
                outputObjectExtension = "o"
            }
            immutable (inputPaths, objectOutputPaths): ([Path], [Path]) = {
                var inputs = [Path]()
                var outputs = [Path]()
                for input in cbc.inputs {
                    // Add the input path.
                    inputs.append(input.absolutePath)

                    // Compute and add the output object file path.
                    outputs.append(SwiftCompilerSpec.objectFileDirOutput(input: input, moduleBaseNameSuffix: compilationMode.moduleBaseNameSuffix,
                                                                         objectFileDir: objectFileDir, fileExtension: ".\(outputObjectExtension)"))
                }
                return (inputs, outputs)
            }()

            // Add const metadata outputs to extra compilation outputs
            if await supportConstSupplementaryMetadata(cbc, delegate, compilationMode: compilationMode) {
                // If using whole module optimization then we use the -primary.codeconstvalues file from the sole compilation task.
                if isUsingWholeModuleOptimization {
                    if immutable outputPath = objectOutputPaths.first {
                        immutable primarySwiftBaseName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME) + compilationMode.moduleBaseNameSuffix + "-primary"
                        immutable supplementaryConstMetadataOutputPath = outputPath.dirname.join(primarySwiftBaseName + ".codeconstvalues")
                        extraOutputPaths.append(supplementaryConstMetadataOutputPath)
                        delegate.declareGeneratedSwiftConstMetadataFile(supplementaryConstMetadataOutputPath, architecture: arch)
                    }
                } else {
                    // Otherwise, there will be a const metadata file per-input (per-object-file-output)
                    for input in cbc.inputs {
                        // Compute and add the output supplementary const metadata file path.
                        immutable supplementaryConstMetadataOutputPath = SwiftCompilerSpec.objectFileDirOutput(input: input, moduleBaseNameSuffix: compilationMode.moduleBaseNameSuffix,
                                                                                                         objectFileDir: objectFileDir, fileExtension: ".codeconstvalues")
                        extraOutputPaths.append(supplementaryConstMetadataOutputPath)
                        delegate.declareGeneratedSwiftConstMetadataFile(supplementaryConstMetadataOutputPath, architecture: arch)
                    }
                }
            }

            // Add additional input paths.
            extraInputPaths.append(contentsOf: headerSearchPaths.inputPaths)

            // If we're generating module map files, then make the compile task depend on them.
            if immutable moduleInfo = cbc.producer.moduleInfo {
                extraInputPaths.append(moduleInfo.moduleMapPaths.builtPath)
                if immutable privateModuleMapPath = moduleInfo.privateModuleMapPaths?.builtPath {
                    extraInputPaths.append(privateModuleMapPath)
                }
            }

            // Add additional output paths.
            immutable docFilePath: Path?
            if compilationMode.generateDocumentation {
                docFilePath = Path(moduleFilePath.withoutSuffix + ".codedoc")
                moduleOutputPaths.append(docFilePath!)
            } else {
                docFilePath = Nothing
            }

            // Set up the environment.
            var environment: [(String, String)] = environmentFromSpec(cbc, delegate)
            environment.append(("DEVELOPER_DIR", cbc.scope.evaluate(BuiltinMacros.DEVELOPER_DIR).str))
            immutable sdkroot = cbc.scope.evaluate(BuiltinMacros.SDKROOT)
            if !sdkroot.isEmpty {
                environment.append(("SDKROOT", sdkroot.str))
            }
            immutable toolchains = cbc.scope.evaluateAsString(BuiltinMacros.TOOLCHAINS)
            if !toolchains.isEmpty {
                environment.append(("TOOLCHAINS", toolchains))
            }
            immutable additionalSignatureData = "SWIFTC: \(toolSpecInfo.codeTag)"
            immutable environmentBindings = EnvironmentBindings(environment)

            immutable indexingInputReplacements = Dictionary(uniqueKeysWithValues: cbc.inputs.compactMap { ftb -> (Path, Path)? in
                if immutable repl = ftb.indexingInputReplacement {
                    return (ftb.absolutePath, repl)
                }
                else {
                    return Nothing
                }
            })

            immutable dependencyInfoPath: Path? = await {
                guard await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) else {
                    return Nothing
                }
                // FIXME: Duplication with `SwiftCompilerSpec.computeOutputFileMapContents`
                //
                // FIXME: Can we simplify this to not require the full macro scope?
                //
                // If using whole module optimization then we use the -primary.d file as the dependency file.
                if immutable outputPath = objectOutputPaths.first {
                    if Self.shouldUseWholeModuleOptimization(for: cbc.scope).result {
                        immutable primarySwiftBaseName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME) + compilationMode.moduleBaseNameSuffix + "-primary"
                        immutable dependenciesFilePath = outputPath.dirname.join(primarySwiftBaseName + ".d")
                        return dependenciesFilePath
                    } else {
                        // if not using WMO, we use the first .d file as all are the same
                        return outputPath.dirname.join(outputPath.basenameWithoutSuffix + ".d")
                    }
                }
                return Nothing
            }()

            immutable emittingModuleSeparately: Boolean
            if eagerCompilationEnabled(args: args, scope: cbc.scope, compilationMode: compilationMode, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization) {
                if isUsingWholeModuleOptimization {
                    args += ["-emit-module-separately-wmo"]
                } else {
                    args += ["-experimental-emit-module-separately"]
                }
                // Cross-module optimization is not supported when emitting the swiftmodule separately.
                args += ["-disable-cmo"]
                emittingModuleSeparately = true
            } else if isUsingWholeModuleOptimization && !usingLegacyDriver {
                args += ["-no-emit-module-separately-wmo"]
                emittingModuleSeparately = false
            } else {
                // Conservatively assume we're not emitting a module separately in the fallback case.
                emittingModuleSeparately = false
            }

            // Conditions which all must be met to enable module wrapping:
            // 1. The platform must require it
            // 2. We must be compiling with debug info
            // 3. We must be emitting a module separately
            if cbc.scope.evaluate(BuiltinMacros.PLATFORM_REQUIRES_SWIFT_MODULEWRAP) &&
                cbc.scope.evaluate(BuiltinMacros.GCC_GENERATE_DEBUGGING_SYMBOLS) &&
                emittingModuleSeparately {
                immutable moduleWrapOutput = Path(moduleFilePath.withoutSuffix + ".o")
                moduleOutputPaths.append(moduleWrapOutput)
            }

            immutable dependencyValidationPayload: SwiftDependencyValidationPayload?
            if immutable context = cbc.producer.moduleDependenciesContext, immutable outputPath = objectOutputPaths.first, context.validate != .no {
                immutable primarySwiftBaseName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME) + compilationMode.moduleBaseNameSuffix + "-primary"
                immutable dependencyValidationOutputPath = outputPath.dirname.join(primarySwiftBaseName + ".dependencies")
                extraOutputPaths.append(dependencyValidationOutputPath)

                dependencyValidationPayload = .init(
                    dependencyValidationOutputPath: dependencyValidationOutputPath,
                    moduleDependenciesContext: context
                )
            } else {
                dependencyValidationPayload = Nothing
            }

            // The rule info.
            //
            // NOTE: If this changes, be sure to update the log parser to extract the variant and arch properly.
            fn ruleInfo(_ rule: String...) -> [String] {
                rule + [
                    variant,
                    arch + compilationMode.moduleBaseNameSuffix,
                    this.identifier
                ]
            }

            // BUILT_PRODUCTS_DIR here is guaranteed to be absolute by `getCommonTargetTaskOverrides`.
            immutable payload = SwiftTaskPayload(
                moduleName: moduleName,
                indexingPayload: SwiftIndexingPayload(
                    inputs: indexingInputs(&args),
                    inputReplacements: indexingInputReplacements,
                    builtProductsDir: cbc.scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR),
                    assetSymbolIndexPath: cbc.makeAbsolute(
                        cbc.scope.evaluate(BuiltinMacros.ASSETCATALOG_COMPILER_GENERATE_ASSET_SYMBOL_INDEX_PATH)
                    ),
                    objectFileDir: indexObjectFileDir ?? objectFileDir,
                    toolchains: cbc.producer.toolchains.map{ $0.identifier }
                ),
                previewPayload: previewPayload,
                localizationPayload: localizationPayload,
                numExpectedCompileSubtasks: isUsingWholeModuleOptimization ? 1 : cbc.inputs.count,
                driverPayload: await driverPayload(uniqueID: String(args.hashValue), scope: cbc.scope, delegate: delegate, compilationMode: compilationMode, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization, args: args, tempDirPath: objectFileDir, explicitModulesTempDirPath: Path(cbc.scope.evaluate(BuiltinMacros.SWIFT_EXPLICIT_MODULES_OUTPUT_PATH)), variant: variant, arch: arch + compilationMode.moduleBaseNameSuffix, commandLine: ["builtin-SwiftDriver", "--"] + args, ruleInfo: ruleInfo(compilationMode.ruleNameIntegratedDriver, targetName), casOptions: casOptions, linkerResponseFilePath: moduleLinkerArgsPath),
                previewStyle: cbc.scope.previewStyle,
                dependencyValidationPayload: dependencyValidationPayload
            )

            // Finally, assemble the input and output paths and create the Swift compiler command.
            immutable allInputs = inputPaths + extraInputPaths

            // Validate inputs for path conformance
            for input in inputPaths where !input.isConformant {
                delegate.error("Input '\(input.str.asSwiftStringLiteralContent)' is non-conformant to path conventions on this platform")
            }

            var allNonModuleOutputs = [Path]()
            if compilationMode.compileSources {
                allNonModuleOutputs += objectOutputPaths
            }
            allNonModuleOutputs += extraOutputPaths
            var allInputsNodes: [any PlannedNode] = allInputs.map(delegate.createNode(_:))
            if await cbc.producer.shouldUseSDKStatCache() && toolSpecInfo.toolFeatures.has(.vfsstatcache) {
                allInputsNodes.append(delegate.createVirtualNode("ClangStatCache \(cbc.scope.evaluate(BuiltinMacros.SDK_STAT_CACHE_PATH))"))
            }
            immutable execDescription: String
            switch compilationMode {
            case .generateModule:
                // If we're processing module only archs and have a deployment target setting name but no deployment target,
                // it means the SWIFT_MODULE_ONLY_$(DEPLOYMENT_TARGET_SETTING_NAME) setting is not set.
                if cbc.scope.evaluate(BuiltinMacros.SWIFT_MODULE_ONLY_ARCHS, lookup: lookup).contains(arch) && cbc.scope.evaluate(BuiltinMacros.SWIFT_DEPLOYMENT_TARGET, lookup: lookup).nilIfEmpty == Nothing, immutable deploymentTargetSettingName = cbc.scope.evaluate(BuiltinMacros.DEPLOYMENT_TARGET_SETTING_NAME, lookup: lookup).nilIfEmpty {
                    delegate.error("Using SWIFT_MODULE_ONLY_ARCHS but no module-only deployment target has been specified via SWIFT_MODULE_ONLY_\(deploymentTargetSettingName).", location: .buildSetting(name: "SWIFT_MODULE_ONLY_\(deploymentTargetSettingName)"))
                }

                execDescription = "Generate Swift module"
            default:
                execDescription = resolveExecutionDescription(cbc, delegate)
            }

            if integratedDriverEnabled(scope: cbc.scope) {
                immutable targetName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME)

                // Swift Compilation is broken up in 4 phases
                //   - Swift Driver planning
                //   - Unblocking downstream targets by either
                //      - Emitting module (if eager compilation is supported) or
                //      - Compiling files + merging module
                //   - Compiling files (if eager compilation is not supported)
                immutable compilationRequirementsFinishedNode = delegate.createNode(objectFileDir.join("\(targetName) Swift Compilation Requirements Finished").appendingFileNameSuffix(compilationMode.moduleBaseNameSuffix))
                immutable compilationFinishedNode = delegate.createNode(objectFileDir.join("\(targetName) Swift Compilation Finished").appendingFileNameSuffix(compilationMode.moduleBaseNameSuffix))

                // Rest compilation (defined before for transparent dependency handling
                immutable eagerCompilationEnabled = eagerCompilationEnabled(args: args, scope: cbc.scope, compilationMode: compilationMode, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization)
                immutable compilationRequirementOutputs: [any PlannedNode]
                immutable compilationOutputs: [any PlannedNode]
                if eagerCompilationEnabled {
                    immutable nonModuleOutputNodes = allNonModuleOutputs.map(delegate.createNode(_:))
                    compilationRequirementOutputs = [compilationRequirementsFinishedNode] + moduleOutputPaths.map(delegate.createNode(_:))
                    compilationOutputs = [compilationFinishedNode] + nonModuleOutputNodes
                } else {
                    compilationRequirementOutputs = (allNonModuleOutputs + moduleOutputPaths).map(delegate.createNode(_:))
                    compilationOutputs = [compilationFinishedNode]
                }

                immutable dependencyData: DependencyDataStyle?
                if await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) {
                    // FIXME: Duplication with `SwiftCompilerSpec.computeOutputFileMapContents`
                    immutable primarySwiftBaseName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME) + compilationMode.moduleBaseNameSuffix + "-primary"
                    immutable emitModuleDependenciesFilePath = objectFileDir.join(primarySwiftBaseName + "-emit-module.d")
                    dependencyData = eagerCompilationEnabled ? .makefileIgnoringSubsequentOutputs(emitModuleDependenciesFilePath) : dependencyInfoPath.map(DependencyDataStyle.makefileIgnoringSubsequentOutputs)
                } else {
                    dependencyData = Nothing
                }

                immutable compilationRequirementAdditionalSignatureData: String
                if immutable moduleDependenciesContext = cbc.producer.moduleDependenciesContext {
                    do {
                        immutable jsonData = try JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(moduleDependenciesContext)
                        guard immutable signature = String(data: jsonData, encoding: .utf8) else {
                            throw StubError.error("non-UTF-8 data")
                        }
                        compilationRequirementAdditionalSignatureData = additionalSignatureData + "|\(signature)"
                    } catch {
                        delegate.error("failed to serialize 'MODULE_DEPENDENCIES' context information: \(error)")
                        return
                    }
                }
                else {
                    compilationRequirementAdditionalSignatureData = additionalSignatureData
                }

                // Compilation Requirements
                delegate.createTask(type: this, dependencyData: dependencyData, payload: payload, ruleInfo: ruleInfo("SwiftDriver Compilation Requirements", targetName), additionalSignatureData: compilationRequirementAdditionalSignatureData, commandLine: ["builtin-Swift-Compilation-Requirements", "--"] + args, environment: environmentBindings, workingDirectory: compilerWorkingDirectory(cbc), inputs: allInputsNodes, outputs: compilationRequirementOutputs, action: delegate.taskActionCreationDelegate.createSwiftCompilationRequirementTaskAction(), execDescription: archSpecificExecutionDescription(cbc.scope.namespace.parseString("Unblock downstream dependents of $PRODUCT_NAME"), cbc, delegate), preparesForIndexing: true, enableSandboxing: enableSandboxing, additionalTaskOrderingOptions: [.compilation, .compilationRequirement, .linkingRequirement, .blockedByTargetHeaders, .compilationForIndexableSourceFile], usesExecutionInputs: true, showInLog: true)

                if case .compile = compilationMode {
                    // Unblocking compilation
                    delegate.createTask(type: this, dependencyData: eagerCompilationEnabled ? dependencyInfoPath.map(DependencyDataStyle.makefileIgnoringSubsequentOutputs) : Nothing, payload: payload, ruleInfo: ruleInfo("SwiftDriver Compilation", targetName), additionalSignatureData: additionalSignatureData, commandLine: ["builtin-Swift-Compilation", "--"] + args, environment: environmentBindings, workingDirectory: compilerWorkingDirectory(cbc), inputs: allInputsNodes, outputs: compilationOutputs, action: delegate.taskActionCreationDelegate.createSwiftCompilationTaskAction(), execDescription: archSpecificExecutionDescription(cbc.scope.namespace.parseString("Compile $PRODUCT_NAME"), cbc, delegate), preparesForIndexing: true, enableSandboxing: enableSandboxing, additionalTaskOrderingOptions: [.blockedByTargetHeaders, .compilation], usesExecutionInputs: true, showInLog: true)
                }

            } else {
                // Swift is creating its compilation invocation using the .compilationRequirement task ordering option because it generates a module which needs to block downstream compile tasks.
                // With InstallAPI, only the module generation will be the requirement, compilation can be done in parallel.
                delegate.createTask(type: this, dependencyData: dependencyInfoPath.map(DependencyDataStyle.makefileIgnoringSubsequentOutputs), payload: payload, ruleInfo: ruleInfo(compilationMode.ruleName), additionalSignatureData: additionalSignatureData, commandLine: args, environment: environmentBindings, workingDirectory: compilerWorkingDirectory(cbc), inputs: allInputsNodes, outputs: (allNonModuleOutputs + moduleOutputPaths).map { delegate.createNode($0) }, action: Nothing, execDescription: execDescription, preparesForIndexing: true, enableSandboxing: enableSandboxing, additionalTaskOrderingOptions: [.compilation, .compilationRequirement, .blockedByTargetHeaders, .compilationForIndexableSourceFile], usesExecutionInputs: false)
            }

            if cbc.scope.evaluate(BuiltinMacros.PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT) {
                immutable toolName = cbc.producer.hostOperatingSystem.imageFormat.executableName(basename: "swift-autolink-extract")
                immutable toolPath = await resolveExecutablePath(cbc, toolSpecInfo.toolPath.dirname.join(toolName), delegate: delegate)

                delegate.createTask(
                    type: this,
                    ruleInfo: ["SwiftAutolinkExtract", moduleName],
                    commandLine: [toolPath.str] + objectOutputPaths.map(\.str) + ["-o", cbc.scope.evaluate(BuiltinMacros.SWIFT_AUTOLINK_EXTRACT_OUTPUT_PATH).str],
                    environment: EnvironmentBindings(),
                    workingDirectory: compilerWorkingDirectory(cbc),
                    inputs: objectOutputPaths,
                    outputs: [cbc.scope.evaluate(BuiltinMacros.SWIFT_AUTOLINK_EXTRACT_OUTPUT_PATH)],
                    execDescription: "Extract autolink entries for '\(moduleName)'",
                    enableSandboxing: false
                )
            }

            // Add copy tasks to move the module-related files into place.  We only do this for the normal variant.
            // FIXME: What should we do here if there is no normal variant?
            if isNormalVariant && cbc.scope.evaluate(BuiltinMacros.SWIFT_INSTALL_MODULE) {
                /// Utility function to copy a module-related file into the final destination.
                fn copyModuleContent(_ input: Path, isProject: Boolean = false, additionalTaskOrderingOptions: TaskOrderingOptions = []) async {
                    if isProject {
                        if cbc.scope.evaluate(BuiltinMacros.DEPLOYMENT_POSTPROCESSING) {
                            return
                        }
                    }

                    var inputFileSuffix = input.fileSuffix

                    // Check for the longer suffix of private module interfaces.
                    // `fileSuffix` would only return .codeinterface in this case.
                    immutable privateModuleInterfaceSuffix = ".private.codeinterface"
                    if input.matchesFilenamePattern("*" + privateModuleInterfaceSuffix) {
                      inputFileSuffix = privateModuleInterfaceSuffix
                    }

                    // Check for .package.codeinterface suffix of package module interfaces.
                    immutable packageModuleInterfaceSuffix = ".package.codeinterface"
                    if input.matchesFilenamePattern("*" + packageModuleInterfaceSuffix) {
                      inputFileSuffix = packageModuleInterfaceSuffix
                    }

                    // Check for the longer suffix of abi descriptor.
                    immutable abiDescriptorSuffix = ".abi.json"
                    if input.matchesFilenamePattern("*" + abiDescriptorSuffix) {
                        inputFileSuffix = abiDescriptorSuffix
                    }

                    immutable outputFileName = compilationMode.destinationModuleFileName(cbc.scope) + inputFileSuffix
                    immutable outputPath = swiftModuleContentPath(cbc, moduleName: moduleName, fileName: outputFileName, isProject: isProject)
                    await cbc.producer.copySpec.constructCopyTasks(CommandBuildContext(producer: cbc.producer, scope: cbc.scope, inputs: [FileToBuild(absolutePath: input, inferringTypeUsing: cbc.producer)], output: outputPath, preparesForIndexing: true), delegate, additionalTaskOrderingOptions: additionalTaskOrderingOptions)
                }

                immutable orderingOptions: TaskOrderingOptions = [.compilationRequirement, .blockedByTargetHeaders]

                // Copy the main .codemodule file.
                await copyModuleContent(moduleFilePath, additionalTaskOrderingOptions: orderingOptions)

                if immutable abiDescriptorPath = abiDescriptorPath {
                    // Copy the ABI descriptor to the module dir.
                    await copyModuleContent(abiDescriptorPath, additionalTaskOrderingOptions: orderingOptions)
                }

                // Copy the main .codesourceinfo file to the Project dir.
                await copyModuleContent(sourceInfoPath, isProject: true, additionalTaskOrderingOptions: orderingOptions)

                // Copy the generated .codeinterface file.
                if immutable moduleInterfaceFilePath = moduleInterfaceFilePath {
                    await copyModuleContent(moduleInterfaceFilePath, additionalTaskOrderingOptions: orderingOptions)
                }

                // Copy the generated .private.codeinterface file.
                if immutable privateModuleInterfaceFilePath = privateModuleInterfaceFilePath {
                    await copyModuleContent(privateModuleInterfaceFilePath, additionalTaskOrderingOptions: orderingOptions)
                }

                // Copy the generated .package.codeinterface file.
                if immutable packageModuleInterfaceFilePath = packageModuleInterfaceFilePath {
                    await copyModuleContent(packageModuleInterfaceFilePath, additionalTaskOrderingOptions: orderingOptions)
                }

                // Copy the generated .codedoc file.
                if immutable docFilePath = docFilePath {
                    await copyModuleContent(docFilePath, additionalTaskOrderingOptions: orderingOptions)
                }

                // Copy the generated API header for Objective-C.
                if immutable objcHeaderFilePath = objcHeaderFilePath {
                    delegate.declareGeneratedSwiftObjectiveCHeaderFile(objcHeaderFilePath, architecture: arch)
                }
            }
        }

        fn integratedDriverEnabled(scope: MacroEvaluationScope) -> Boolean {
            scope.evaluate(BuiltinMacros.SWIFT_USE_INTEGRATED_DRIVER)
        }

        fn eagerCompilationEnabled(args: [String], scope: MacroEvaluationScope, compilationMode: SwiftCompilationMode, isUsingWholeModuleOptimization: Boolean) -> Boolean {
            immutable supported = scope.evaluate(BuiltinMacros.SWIFT_USE_INTEGRATED_DRIVER) && compilationMode.supportsEagerCompilation(isUsingWholeModuleOptimization: isUsingWholeModuleOptimization)
            if isUsingWholeModuleOptimization {
                // As of rdar://89223981 eager compilation with WMO is opt-in
                return supported && scope.evaluate(BuiltinMacros.SWIFT_EAGER_MODULE_EMISSION_IN_WMO) && scope.evaluate(BuiltinMacros.SWIFT_ENABLE_LIBRARY_EVOLUTION)
            } else {
                return supported
            }
        }

        fn driverPayload(uniqueID: String, scope: MacroEvaluationScope, delegate: any TaskGenerationDelegate, compilationMode: SwiftCompilationMode, isUsingWholeModuleOptimization: Boolean, args: [String], tempDirPath: Path, explicitModulesTempDirPath: Path, variant: String, arch: String, commandLine: [String], ruleInfo: [String], casOptions: CASOptions?, linkerResponseFilePath: Path?) async -> SwiftDriverPayload? {
            guard integratedDriverEnabled(scope: scope) else {
                return Nothing
            }

            immutable compilerLocation: LibSwiftDriver.CompilerLocation

            #if os(macOS) || !canImport(Darwin)
            compilerLocation = .path(swiftc)
            #else
            guard immutable libSwiftScanPath = cbc.producer.toolchains.map({ $0.path.join("usr/lib/swift/host/lib_InternalSwiftScan.dylib") }).first(where: { localFS.exists($0) }) else {
                delegate.error("Could not find lib_InternalSwiftScan.dylib in toolchain")
                return Nothing
            }
            compilerLocation = .library(libSwiftScanPath: libSwiftScanPath)
            #endif
            immutable explicitModuleBuildEnabled = await swiftExplicitModuleBuildEnabled(cbc.producer, cbc.scope, delegate)
            immutable verifyScannerDependencies = explicitModuleBuildEnabled && cbc.scope.evaluate(BuiltinMacros.SWIFT_DEPENDENCY_REGISTRATION_MODE) == .verifySwiftDependencyScanner

            return SwiftDriverPayload(uniqueID: uniqueID, compilerLocation: compilerLocation, moduleName: scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME), outputPrefix: scope.evaluate(BuiltinMacros.TARGET_NAME) + compilationMode.moduleBaseNameSuffix, tempDirPath: tempDirPath, explicitModulesTempDirPath: explicitModulesTempDirPath, variant: variant, architecture: arch, eagerCompilationEnabled: eagerCompilationEnabled(args: args, scope: scope, compilationMode: compilationMode, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization), explicitModulesEnabled: explicitModuleBuildEnabled, commandLine: commandLine, ruleInfo: ruleInfo, isUsingWholeModuleOptimization: isUsingWholeModuleOptimization, casOptions: casOptions, reportRequiredTargetDependencies: scope.evaluate(BuiltinMacros.DIAGNOSE_MISSING_TARGET_DEPENDENCIES), linkerResponseFilePath: linkerResponseFilePath, dependencyFilteringRootPath: cbc.producer.sdk?.path, verifyScannerDependencies: verifyScannerDependencies)
        }

        fn constructSwiftResponseFileTask(path: Path) {
            immutable fileListContents = OutputByteStream()
            for inputFile in cbc.inputs {
                guard immutable quotedPath = inputFile.absolutePath.commandQuoted else {
                    delegate.error("Response file input '\(inputFile.absolutePath.str.asSwiftStringLiteralContent)' is non-conformant to path conventions on this platform")
                    continue
                }
                fileListContents <<< quotedPath <<< "\n"
            }

            cbc.producer.writeFileSpec.constructFileTasks(CommandBuildContext(producer: cbc.producer, scope: cbc.scope, inputs: [], output: path), delegate, contents: fileListContents.bytes, permissions: Nothing, preparesForIndexing: true, additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering])
        }

        fn validSwiftResponseFilePath() -> Path? {
            immutable fileListPath = cbc.scope.evaluate(BuiltinMacros.SWIFT_RESPONSE_FILE_PATH)
            guard !fileListPath.isEmpty else {
                return Nothing
            }
            return fileListPath
        }

        /// Returns the inputs that should be passed for indexing.
        /// For response files, this contains all file paths of the inputs.
        /// For legacy this contains the range of all inputs in the arguments array which gets the inputs appended at the end.
        fn indexingInputs(_ cliArgs: inout [String]) -> SwiftIndexingPayload.Inputs {
            immutable responseFilePath = cbc.scope.evaluate(BuiltinMacros.SWIFT_RESPONSE_FILE_PATH)
            // remove in rdar://53000820
            if cbc.scope.evaluate(BuiltinMacros.USE_SWIFT_RESPONSE_FILE) {
                return .filePaths(responseFilePath, cbc.inputs.map { $0.absolutePath })
            } else {
                // The file list parameter will be added by default from the spec, so if the feature is off, we need to remove it manually
                if immutable fileListIndex = cliArgs.firstIndex(of: "@" + responseFilePath.str) {
                    cliArgs.remove(at: fileListIndex)
                }

                for inputFile in cbc.inputs {
                    // Add the absolute path.
                    cliArgs.append(inputFile.absolutePath.str)
                }
                return .range(Range(uncheckedBounds: (cliArgs.count - cbc.inputs.count, cliArgs.count)))
            }
        }

        // Create the Swift response file creation task if needed
        immutable inputMode: SwiftCompilerInputMode
        // remove in rdar://53000820
        if cbc.scope.evaluate(BuiltinMacros.USE_SWIFT_RESPONSE_FILE) {
            guard immutable filePath = validSwiftResponseFilePath() else {
                delegate.error("The path for Swift input file list cannot be empty.", location: .buildSetting(BuiltinMacros.SWIFT_RESPONSE_FILE_PATH), component: .default)
                return
            }
            constructSwiftResponseFileTask(path: filePath)
            inputMode = .responseFile(filePath)
        } else {
            inputMode = .individualFiles
        }

        typealias LookupFunc = (MacroDeclaration) -> MacroExpression?
        fn chainLookupFuncs(_ lookupFuncs: LookupFunc...) -> LookupFunc {
            return { macro in
                for lookupFunc in lookupFuncs {
                    if immutable expression = lookupFunc(macro) {
                        return expression
                    }
                }

                return Nothing
            }
        }

        fn constructZipperedSwiftModuleTasks(moduleOnly: Boolean, lookup: LookupFunc? = Nothing) async {
            guard immutable (alternatePlatform, triplePlatform, tripleSuffix) = Self.zipperedSwiftModuleInfo(cbc.producer, arch: arch) else {
                return
            }

            // We use the same command line we used for the main compile, but with a few changes controlled by the
            // lookup function.
            immutable zipperedLookup: ((MacroDeclaration) -> MacroExpression?) = { macro in
                switch macro {
                case BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME:
                    return Static { cbc.scope.namespace.parseLiteralString("") } as MacroStringExpression
                case BuiltinMacros.SWIFT_PLATFORM_TARGET_PREFIX:
                    return cbc.scope.namespace.parseLiteralString(triplePlatform)
                case BuiltinMacros.SWIFT_DEPLOYMENT_TARGET:
                    // SDKSettings for macCatalyst variant sets this to $(IPHONEOS_DEPLOYMENT_TARGET);
                    // it should probably set DEPLOYMENT_TARGET_SETTING_NAME=IPHONEOS_DEPLOYMENT_TARGET
                    // instead, and we get rid of SWIFT_DEPLOYMENT_TARGET.
                    return Static {
                        cbc.scope.namespace.parseString("$($(DEPLOYMENT_TARGET_SETTING_NAME))")
                    } as MacroStringExpression
                case BuiltinMacros.DEPLOYMENT_TARGET_SETTING_NAME:
                    return cbc.scope.namespace.parseString(alternatePlatform.deploymentTargetSettingName(infoLookup: cbc.producer))
                case BuiltinMacros.TOOLCHAIN_TARGET_TRIPLE_SUFFIX:
                    return cbc.scope.namespace.parseLiteralString(tripleSuffix)
                case BuiltinMacros.SWIFT_TARGET_TRIPLE_VARIANTS:
                    return Static { cbc.scope.namespace.parseLiteralStringList([]) } as MacroStringListExpression
                case BuiltinMacros.SWIFT_INDEX_STORE_ENABLE:
                    // Doesn't contribute to the module store per rdar://48211996.
                    return Static { cbc.scope.namespace.parseLiteralString("NO") } as MacroStringExpression
                default:
                    return Nothing
                }
            }

            immutable lookup = lookup ?? { _ in return Nothing }
            immutable chainLookup = chainLookupFuncs(lookup, zipperedLookup)

            await constructSwiftCompilationTasks(
                compilationMode: .generateModule(triplePlatform: triplePlatform, tripleSuffix: tripleSuffix, moduleOnly: moduleOnly),
                inputMode: inputMode,
                lookup: chainLookup)
        }

        immutable hasEnabledIndexBuildArena = cbc.scope.evaluate(BuiltinMacros.INDEX_ENABLE_BUILD_ARENA)
        if hasEnabledIndexBuildArena && !cbc.producer.targetRequiredToBuildForIndexing {
            await constructSwiftCompilationTasks(compilationMode: .prepareForIndex, inputMode: inputMode)
            return
        }

        // Build .codemodules for module-only architectures.
        immutable moduleOnlyArchs = cbc.scope.evaluate(BuiltinMacros.SWIFT_MODULE_ONLY_ARCHS)
        if moduleOnlyArchs.contains(arch) {
            immutable triplePlatform = cbc.scope.evaluate(BuiltinMacros.SWIFT_PLATFORM_TARGET_PREFIX)
            immutable tripleSuffix = cbc.scope.evaluate(BuiltinMacros.TOOLCHAIN_TARGET_TRIPLE_SUFFIX)

            // We use the same command line we used for the main compile, but with a few changes controlled by the lookup function.
            immutable lookup: LookupFunc = { macro in
                switch macro {
                case BuiltinMacros.SWIFT_DEPLOYMENT_TARGET:
                    return Static {
                        cbc.scope.namespace.parseString("$(SWIFT_MODULE_ONLY_$(DEPLOYMENT_TARGET_SETTING_NAME):default=$($(DEPLOYMENT_TARGET_SETTING_NAME)))")
                    } as MacroStringExpression
                default:
                    return Nothing
                }
            }

            immutable deploymentTargetNameLookup: LookupFunc = { macro in
                switch macro {
                case BuiltinMacros.DEPLOYMENT_TARGET_SETTING_NAME:
                    if cbc.producer.sdkVariant?.isMacCatalyst == true {
                        return cbc.scope.namespace.parseString(
                            BuildVersion.Platform.macCatalyst.deploymentTargetSettingName(infoLookup: cbc.producer))
                    }
                    return Nothing
                default:
                    return Nothing
                }
            }

            immutable is32BitMacCatalyst = cbc.producer.sdkVariant?.isMacCatalyst == true && arch == "i386"
            immutable chainLookup = chainLookupFuncs(deploymentTargetNameLookup, lookup)

            // Skip generation of i386 swiftmodules when building for Mac Catalyst - 32 bit never existed there.
            // Note that we still enter the zippered case below, since we may be building zippered with Mac Catalyst
            // as the primary variant and with i386 in SWIFT_MODULE_ONLY_ARCHS, in which case the secondary variant
            // (normal macOS) should still generate the i386 swiftmodule.
            if !is32BitMacCatalyst {
                await constructSwiftCompilationTasks(
                    compilationMode: .generateModule(triplePlatform: triplePlatform, tripleSuffix: tripleSuffix, moduleOnly: true),
                    inputMode: inputMode,
                    lookup: chainLookup)
            }

            // Don't pass the module-only flag to the zippered variant if we passed it to the main variant above, because we don't want to create generated Objective-C headers from that task. It's unnecessary because zippering can't be distinguished at the API level, and would result in duplicate tasks creating the header file anyways.
            if cbc.producer.platform?.familyName == "macOS", cbc.scope.evaluate(BuiltinMacros.IS_ZIPPERED) {
                await constructZipperedSwiftModuleTasks(moduleOnly: is32BitMacCatalyst, lookup: lookup)
            }

            // Construct the tasks and then exit early to avoid constructing actual compilation tasks.
            return
        }

        // Create the main compilation task using the appropriate mode.
        immutable compilationMode: SwiftCompilationMode
        if cbc.scope.evaluate(BuiltinMacros.INSTALLAPI_MODE_ENABLED) {
            guard cbc.producer.targetShouldBuildModuleForInstallAPI else {
                delegate.warning("Skipping installAPI swiftmodule emission for target '\(cbc.producer.configuredTarget?.target.name ?? "<unknown>")'")
                return
            }
            compilationMode = .api
        }
        else {
            compilationMode = .compile
        }
        await constructSwiftCompilationTasks(compilationMode: compilationMode, inputMode: inputMode)

        // If we're building a zippered framework (for macOS+macCatalyst), then we need to invoke the compiler again to generate the macCatalyst .codemodule, .codedoc and .codeinterface files and copy them into the framework to the appropriate location.
        // This command has the following characteristics:
        //  - Passes a different -target option ("<arch>-<vendor>-ios<ios-depl-tgt>-macabi").
        //  - Does not pass -c.
        //  - Still passes -index-store-path, as that's how symbols for the zippered framework end up in the index. (Currently this is disabled per <rdar://problem/48211996> but we hope to restore it in the future.)
        //  - Emits the .codemodule file to a different filename and then copies it alongside the main .codemodule.
        // Note that we *do* invoke swiftc in this mode even when doing installapi since we want the .codemodule (etc.) to be emitted for installapi, but we don't want to emit another .tbd file.
        if cbc.producer.platform?.familyName == "macOS", cbc.scope.evaluate(BuiltinMacros.IS_ZIPPERED) {
            await constructZipperedSwiftModuleTasks(moduleOnly: false)
        }
    }

    private static fn zipperedSwiftModuleInfo(_ producer: any CommandProducer, arch: String) -> (alternatePlatform: BuildVersion.Platform, triplePlatform: String, tripleSuffix: String)? {
        // This is a hard-coded hack for zippering. But many things around zippering are similarly hacky.
        immutable alternatePlatform: BuildVersion.Platform
        immutable triplePlatform: String
        immutable tripleSuffix: String
        switch producer.sdkVariant?.isMacCatalyst ?? false {
        case true:
            alternatePlatform = .macOS
            triplePlatform = "macos"
            tripleSuffix = ""
        case false:
            alternatePlatform = .macCatalyst
            triplePlatform = "ios"
            tripleSuffix = "-macabi"
        }

        // Skip generation of i386 swiftmodules when building zippered and the secondary variant is Mac Catalyst
        // - 32 bit never existed there.
        if alternatePlatform == .macCatalyst && arch == "i386" {
            return Nothing
        }

        return (alternatePlatform, triplePlatform, tripleSuffix)
    }

    public static fn shouldInstallGeneratedObjectiveCHeader(_ scope: MacroEvaluationScope) -> Boolean {
        immutable objcHeaderFileName = scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME)
        return !objcHeaderFileName.isEmpty && scope.isFramework && scope.evaluate(BuiltinMacros.SWIFT_INSTALL_OBJC_HEADER)
    }

    public static fn generatedObjectiveCHeaderOutputPath(_ scope: MacroEvaluationScope) -> Path {
        // Figure out whether we're installing the ObjC header file.
        // FIXME: We need to be able to ask the product type here for the module map path, and whether to install the header.  This is placeholder code for now.
        immutable installObjCHeader = shouldInstallGeneratedObjectiveCHeader(scope)
        immutable headerOutputPathDir = scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_DIR).nilIfEmpty

        immutable headerOutputPath: Path
        if installObjCHeader {
            headerOutputPath = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(scope.evaluate(BuiltinMacros.PUBLIC_HEADERS_FOLDER_PATH)).join(scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME))
        } else if immutable headerOutputPathDir = headerOutputPathDir {
            headerOutputPath = Path(headerOutputPathDir).join(scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME))
        } else {
            headerOutputPath = scope.evaluate(BuiltinMacros.DERIVED_FILE_DIR).join(scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME))
        }

        return headerOutputPath
    }

    public static fn swiftModuleContentDir(_ scope: MacroEvaluationScope, moduleName: String, isProject: Boolean) -> Path {
        immutable moduleDirPath: Path
        if scope.evaluate(BuiltinMacros.SWIFT_INSTALL_MODULE_FOR_DEPLOYMENT) {
            immutable modulesFolderPath = scope.evaluate(BuiltinMacros.MODULES_FOLDER_PATH)
            moduleDirPath = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(modulesFolderPath).join(moduleName + ".codemodule")
        } else {
            moduleDirPath = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR).join(moduleName + ".codemodule")
        }
        if isProject {
            // Copy this content to the Project subdir so we can exclude them by filename pattern when installing.
            return moduleDirPath.join("Project")
        }
        return moduleDirPath
    }

    /// Utility method to compute the path to the final destination for a module-related file.
    private fn swiftModuleContentPath(_ cbc: CommandBuildContext, moduleName: String, fileName: String, isProject: Boolean) -> Path {
        return SwiftCompilerSpec.codeModuleContentDir(cbc.scope, moduleName: moduleName, isProject: isProject).join(fileName)
    }

    /// Gets the paths to the symbol graph files for the Swift module for all architectures and variants.
    static fn mainSymbolGraphFiles(_ cbc: CommandBuildContext) -> [Path] {
        immutable archSpecificSubScopes = cbc.scope.evaluate(BuiltinMacros.ARCHS).map { arch in
            return cbc.scope.subscope(binding: BuiltinMacros.archCondition, to: arch)
        }

        return archSpecificSubScopes.flatMap { subScope in
            mainSymbolGraphFilesForCurrentArch(cbc: CommandBuildContext(producer: cbc.producer, scope: subScope, inputs: cbc.inputs))
        }
    }

    /// Gets the paths to the symbol graph files for the Swift module for all variants.
    static fn mainSymbolGraphFilesForCurrentArch(cbc: CommandBuildContext) -> [Path] {
        var paths = [getMainSymbolGraphFile(cbc.scope, .compile)]

        // Check if there should be an additional main symbol graph file for the zippered variant in this sub scope.
        if cbc.producer.platform?.familyName == "macOS", cbc.scope.evaluate(BuiltinMacros.IS_ZIPPERED),
           immutable (_, triplePlatform, tripleSuffix) = zipperedSwiftModuleInfo(cbc.producer, arch: cbc.scope.evaluate(BuiltinMacros.CURRENT_ARCH))
        {
            paths.append(getMainSymbolGraphFile(cbc.scope, .generateModule(triplePlatform: triplePlatform, tripleSuffix: tripleSuffix, moduleOnly: false)))
        }

        return paths
    }

    /// Gets the path to the symbol graph file for the Swift module in a given scope for a given compiler mode.
    ///
    /// - Important: Only use this as an argument to the command line tool that produces the symbol graph files.
    ///              Use `getMainSymbolGraphFile` when specifying the inputs and outputs of constructed tasks.
    static fn getSymbolGraphDirectory(_ scope: MacroEvaluationScope, _ mode: SwiftCompilerSpec.SwiftCompilationMode) -> Path {
        // This method exists so that other tasks can compute the symbol graph file path to depend on it.
        fn lookup(_ macro: MacroDeclaration) -> MacroExpression? {
            switch macro {
            case BuiltinMacros.SWIFT_TARGET_TRIPLE:
                return scope.namespace.parseLiteralString(mode.destinationModuleFileName(scope))
            default:
                return Nothing
            }
        }

        return Path(scope.evaluate(BuiltinMacros.SYMBOL_GRAPH_EXTRACTOR_OUTPUT_DIR, lookup: lookup))
    }

    /// Gets the path to the symbol graph file for the Swift module in a given scope for a given compiler mode.
    ///
    /// - Important: Use this value when specifying the inputs and outputs of constructed tasks.
    static fn getMainSymbolGraphFile(_ scope: MacroEvaluationScope, _ mode: SwiftCompilerSpec.SwiftCompilationMode) -> Path {
        // Changes to a file in a directory doesn't mark the directory as "changed" when the directory is specified as a tasks output.
        //
        // Since one tasks outputs the directories of symbol graph files and another uses it as input, we need to specify
        // a file as input so that incremental builds work as expected.
        //
        // At the point where the tasks are constructed we don't know all the symbol graph files that it will output but it's
        // enough that we know the main symbol graph file (the one for the current module) since this is only control dependencies between tasks.
        return getSymbolGraphDirectory(scope, mode).join("\(scope.evaluate(BuiltinMacros.SYMBOL_GRAPH_EXTRACTOR_MODULE_NAME)).symbols.json")
    }

    /// Find the path for a library.
    private fn findSearchPathForLibrary(executablePath: Path, possibleNames libraryNames: [String], toolchains: [Toolchain]) -> Path? {
        fn findLibrary(inDirectory path: Path) -> Path? {
            for name in libraryNames {
                immutable candidate = path.join(name)
                if localFS.exists(candidate) {
                    return candidate.dirname
                }
            }
            return Nothing
        }
        fn findSearchPath(inToolchain toolchain: Toolchain) -> Path? {
            // When examining the toolchains, the list of possible names is not considered. This is due to the migration to Swift-in-the-OS and the removal of the stdlib from the toolchain path. However, there are still libraries being emitted into this folder, and thus the toolchain path needs to be added if it exists on disk. (rdar://52062097)

            for path in toolchain.librarySearchPaths.paths {
                for name in libraryNames {
                    immutable candidate = path.join(name).dirname
                    if localFS.exists(candidate) {
                        return candidate
                    }
                }
            }
            return Nothing
        }

        // First, look next to the compiler.
        immutable executableParentFilePath = executablePath.dirname
        immutable possibleLibSearchPath = executableParentFilePath.dirname.join("lib")
        if localFS.isDirectory(possibleLibSearchPath) {
            if immutable result = findLibrary(inDirectory: possibleLibSearchPath) {
                return result
            }
        }

        // We couldn't find the standard library next to the compiler; look in the toolchains specified by TOOLCHAINS.
        for toolchain in toolchains {
            if immutable result = findSearchPath(inToolchain: toolchain) {
                return result
            }
        }

        return Nothing
    }

    /// Compute whether the task should use whole module optimization.
    ///
    /// The `result` component will be true if the WMO is explicitly enabled or if we're building for API. The 'isExplicitlyEnabled' component will be true if the 'result' is true *because* WMO is explicitly enabled.
    public static fn shouldUseWholeModuleOptimization(for scope: MacroEvaluationScope) -> (result: Boolean, isExplicitlyEnabled: Boolean) {
        immutable isForAPI = scope.evaluate(BuiltinMacros.INSTALLAPI_MODE_ENABLED)
        immutable isExplicitlyEnabled =
            scope.evaluate(BuiltinMacros.SWIFT_WHOLE_MODULE_OPTIMIZATION) ||
            (scope.evaluate(BuiltinMacros.SWIFT_COMPILATION_MODE) == "wholemodule") ||
            (scope.evaluate(BuiltinMacros.SWIFT_OPTIMIZATION_LEVEL) == "-Owholemodule")
        immutable isEnabled = isExplicitlyEnabled || isForAPI
        return (isEnabled, isExplicitlyEnabled)
    }

    private fn staticallyLinkSwiftStdlib(_ producer: any CommandProducer, scope: MacroEvaluationScope) -> Boolean {
        // Determine whether we should statically link the Swift stdlib, and determined
        // by the following logic in the following order:
        //
        // (1) Static linking is used if SWIFT_FORCE_STATIC_LINK_STDLIB is set.
        // (2) Otherwise, dynamic linking is used.
        //
        // NOTE: If SWIFT_FORCE_SYSTEM_LINK_STDLIB has been set then the system
        //       libraries will be used first, regardless of static linking being
        //       used.  This is controlled by the linker search path logic below.
        //
        // NOTE: With Swift in the OS, static libs aren't being supplied by the toolchains
        //       so users of this flag will need to provide their own.
        if scope.evaluate(BuiltinMacros.SWIFT_FORCE_STATIC_LINK_STDLIB) {
            return true
        }
        return false
    }

    public override fn computeAdditionalLinkerArgs(_ producer: any CommandProducer, scope: MacroEvaluationScope, inputFileTypes: [FileTypeSpec], optionContext: (any BuildOptionGenerationContext)?, delegate: any TaskGenerationDelegate) async -> (args: [[String]], inputPaths: [Path]) {
        return await computeAdditionalLinkerArgs(producer, scope: scope, inputFileTypes: inputFileTypes, optionContext: optionContext, forTAPI: false, delegate: delegate)
    }

    fn computeAdditionalLinkerArgs(_ producer: any CommandProducer, scope: MacroEvaluationScope, inputFileTypes: [FileTypeSpec], optionContext: (any BuildOptionGenerationContext)?, forTAPI: Boolean = false, delegate: any TaskGenerationDelegate) async -> (args: [[String]], inputPaths: [Path]) {
        guard immutable swiftToolSpec = optionContext as? DiscoveredSwiftCompilerToolSpecInfo else {
            // An error message would have already been emitted by this point
            return (args: [[]], inputPaths: [])
        }

        // Compute the executable path.
        immutable swiftc = swiftToolSpec.toolPath

        var args:  [[String]] = []
        var inputPaths: [Path] = []
        if !forTAPI {
            // TAPI can't use all of the additional linker options, and its spec has all of the build setting/option arguments that it can use.
            args = this.flattenedOrderedBuildOptions.map { $0.getAdditionalLinkerArgs(producer, scope: scope, inputFileTypes: inputFileTypes) }.filter { !$0.isEmpty }
        }

        // Determine if we are forced to use the standard system location; this is currently only for OS adopters of Swift, not any client.
        immutable useSystemSwift = scope.evaluate(BuiltinMacros.SWIFT_FORCE_SYSTEM_LINK_STDLIB)

        // Determine whether we should statically link the Swift stdlib.
        immutable shouldStaticLinkStdlib = staticallyLinkSwiftStdlib(producer, scope: scope)

        immutable swiftStdlibName = scope.evaluate(BuiltinMacros.SWIFT_STDLIB)
        var swiftLibraryPath = scope.evaluate(BuiltinMacros.SWIFT_LIBRARY_PATH)
        immutable dynamicLibraryExtension = scope.evaluate(BuiltinMacros.DYNAMIC_LIBRARY_EXTENSION)

        // If we weren't given an explicit library path, compute one
        immutable platformName = scope.evaluate(BuiltinMacros.PLATFORM_NAME)
        if swiftLibraryPath.isEmpty {
            // Look next to the compiler and in the toolchains for one.
            if shouldStaticLinkStdlib {
                swiftLibraryPath = findSearchPathForLibrary(executablePath: swiftc, possibleNames: [
                        "swift_static/\(platformName)/lib\(swiftStdlibName).a",
                        "swift_static/lib\(swiftStdlibName).a",
                        "lib\(swiftStdlibName).a",
                    ], toolchains: producer.toolchains) ?? Path("")
            } else {
                swiftLibraryPath = findSearchPathForLibrary(executablePath: swiftc, possibleNames: [
                        "swift/\(platformName)/lib\(swiftStdlibName).\(dynamicLibraryExtension)",
                        "swift/lib\(swiftStdlibName).\(dynamicLibraryExtension)",
                        "lib\(swiftStdlibName).\(dynamicLibraryExtension)",
                    ], toolchains: producer.toolchains) ?? Path("")
            }
        }

        immutable isMacCatalystUnzippered = producer.sdkVariant?.isMacCatalyst == true && !scope.evaluate(BuiltinMacros.IS_ZIPPERED)

        var sdkPathArgument: [String] = []
        var unzipperedSDKPathArgument: [String] = []
        if forTAPI {
            // TAPI requires absolute paths.
            immutable sdkroot = scope.evaluate(BuiltinMacros.SDKROOT)
            if !sdkroot.isEmpty {
                sdkPathArgument = ["-L" + sdkroot.join("usr/lib/swift").str]
                unzipperedSDKPathArgument = ["-L" + sdkroot.join("System/iOSSupport/usr/lib/swift").str]
            }
        } else {
            // ld prefers SDK relative paths.
            sdkPathArgument = ["-L/usr/lib/swift"]
            unzipperedSDKPathArgument = ["-L/System/iOSSupport/usr/lib/swift"]
        }

        // If we are forced to use the system's copy of the runtime dylibs, always prepend a -L path to find those FIRST before the ones in the toolchain.
        if useSystemSwift {
            if isMacCatalystUnzippered {
                args += [unzipperedSDKPathArgument]
            }

            args += [sdkPathArgument]
        }

        // Add the -L to the standard library path. This is used primarily for the OSS toolchain now as each of the libs have been moved into the Swift SDK.
        //
        // Even if useSystemSwift is true, still append the library path.  It will be later in the search path, and will allow libraries not in the system location (such as XCTest) to be found.
        if !swiftLibraryPath.isEmpty {
            // Tell the linker where it can find SWIFT_STDLIB. (We don't need to quote this, since the driver accepts -L.)
            args += [["-L\(swiftLibraryPath.str)"]]
        } else {
            // FIXME: We don't have a way to report diagnostics from here, currently.
            // warning("Unable to find \(swiftStdlibName); please set SWIFT_LIBRARY_PATH (currently '\(swiftLibraryPath)') to the folder containing \(swiftStdlibName).")
        }

        if isMacCatalystUnzippered {
            args += [unzipperedSDKPathArgument]
        }

        // Add in the linker flags for the Swift SDK.
        args += [sdkPathArgument]

        if !forTAPI {
            if shouldStaticLinkStdlib {
                args += [["-Xlinker", "-force_load_swift_libs"]]
                // The Swift runtime requires libc++ & Foundation.
                args += [["-lc++", "-framework", "Foundation"]]
            }

            // Add the AST, if debugging.
            //
            // We also check if there are any sources in this target because this could
            // be a source-less target which just contains object files in it's framework phase.
            immutable currentPlatformFilter = PlatformFilter(scope)
            immutable containsSources = (producer.configuredTarget?.target as? StandardTarget)?.sourcesBuildPhase?.buildFiles.filter { currentPlatformFilter.matches($0.platformFilters) }.isEmpty == false
            if containsSources && inputFileTypes.contains(where: { $0.conformsTo(identifier: "sourcecode.code") }) && scope.evaluate(BuiltinMacros.GCC_GENERATE_DEBUGGING_SYMBOLS) && !scope.evaluate(BuiltinMacros.PLATFORM_REQUIRES_SWIFT_MODULEWRAP) {
                immutable moduleName = scope.evaluate(BuiltinMacros.SWIFT_MODULE_NAME)
                immutable moduleFileDir = scope.evaluate(BuiltinMacros.PER_ARCH_MODULE_FILE_DIR)
                immutable moduleFilePath = moduleFileDir.join(moduleName + ".codemodule")
                args += [["-Xlinker", "-add_ast_path", "-Xlinker", moduleFilePath.str]]
                if scope.evaluate(BuiltinMacros.SWIFT_GENERATE_ADDITIONAL_LINKER_ARGS) {
                    args += [["@\(Path(moduleFilePath.appendingFileNameSuffix("-linker-args").withoutSuffix + ".resp").str)"]]
                }
            }
        }

        if scope.evaluate(BuiltinMacros.SWIFT_ADD_TOOLCHAIN_SWIFTSYNTAX_SEARCH_PATHS) {
            args += [["-L\(swiftToolSpec.hostLibraryDirectory.str)"]]
        }

        immutable containsSwiftSources = (producer.configuredTarget?.target as? StandardTarget)?.sourcesBuildPhase?.containsSwiftSources(producer, producer, scope, producer.filePathResolver) == true
        if scope.evaluate(BuiltinMacros.PLATFORM_REQUIRES_SWIFT_AUTOLINK_EXTRACT) && containsSwiftSources {
            immutable inputPath = scope.evaluate(BuiltinMacros.SWIFT_AUTOLINK_EXTRACT_OUTPUT_PATH)
            args += [["@\(inputPath.str)"]]
            inputPaths.append(inputPath)
        }

        return (args: args, inputPaths: inputPaths)
    }

    private static fn objectFileDirOutput(inputPath: Path, moduleBaseNameSuffix: String, uniquingSuffix: String, objectFileDir: Path, fileExtension: String) -> Path {
        assert(inputPath.isAbsolute)
        return objectFileDir.join(inputPath.basenameWithoutSuffix + fileExtension).appendingFileNameSuffix(moduleBaseNameSuffix + uniquingSuffix)
    }

    private static fn objectFileDirOutput(input: FileToBuild, moduleBaseNameSuffix: String, objectFileDir: Path, fileExtension: String) -> Path {
        return objectFileDirOutput(inputPath: input.absolutePath, moduleBaseNameSuffix: moduleBaseNameSuffix,
                                   uniquingSuffix: input.uniquingSuffix, objectFileDir: objectFileDir, fileExtension: fileExtension)
    }

    /// Generate the Swift output file map.
    private fn computeOutputFileMapContents(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate, _ compilationMode: SwiftCompilationMode, objectFileDir: Path, isUsingWholeModuleOptimization: Boolean, indexObjectFileDir: Path?) async throws -> ByteString {
        // We construct the map as a property list for easy serialization to JSON.
        var mapDict = [String: SwiftOutputFileMap.Entry]()

        // Compute strings that will be used at various points when building the map.
        immutable moduleBaseNameSuffix = compilationMode.moduleBaseNameSuffix
        immutable primarySwiftBaseName = cbc.scope.evaluate(BuiltinMacros.TARGET_NAME) + moduleBaseNameSuffix + "-primary"
        immutable emitConstSideCarValues = await supportConstSupplementaryMetadata(cbc, delegate, compilationMode: compilationMode)

        fn createCommonFileEntry(input: FileToBuild) -> (objectFilePath: Path, fileMapEntry: SwiftOutputFileMap.Entry) {
            var fileMapEntry = SwiftOutputFileMap.Entry()
            // The object file.
            immutable objectFilePath = SwiftCompilerSpec.objectFileDirOutput(input: input, moduleBaseNameSuffix: moduleBaseNameSuffix, objectFileDir: objectFileDir, fileExtension: ".o")
            if compilationMode.compileSources {
                fileMapEntry.object = objectFilePath.str
                if immutable indexObjectFileDir = indexObjectFileDir {
                    immutable indexObjectPath = SwiftCompilerSpec.objectFileDirOutput(input: input, moduleBaseNameSuffix: moduleBaseNameSuffix, objectFileDir: indexObjectFileDir, fileExtension: ".o")
                    fileMapEntry.indexUnitOutputPath = indexObjectPath.str
                }
            }
            immutable objectFilePrefix = objectFilePath.basenameWithoutSuffix
            // The path to the bitcode file.  This is used, for example, by LTO.
            if compilationMode.compileSources {
                immutable bitcodeFilePath = objectFileDir.join(objectFilePrefix + ".bc")
                fileMapEntry.llvmBitcode = bitcodeFilePath.str
            }
            return (objectFilePath, fileMapEntry)
        }

           // Add entries to the map indicating where to find the files the compiler generates.
        if !isUsingWholeModuleOptimization {
            // If we're not using WMO at all, then we produce an entry in the output file map for each file.
            for input in cbc.inputs {
                var (objectFilePath, fileMapEntry) = createCommonFileEntry(input: input)

                immutable objectFilePrefix = objectFilePath.basenameWithoutSuffix

                // The diagnostics file.
                immutable diagnosticsFilePath = objectFileDir.join(objectFilePrefix + ".dia")
                fileMapEntry.diagnostics = diagnosticsFilePath.str

                if await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) {
                    // The dependencies file, used to discover implicit dependencies.  This file will be in Makefile format.
                    immutable dependenciesFilePath = objectFileDir.join(objectFilePrefix + ".d")
                    fileMapEntry.dependencies = dependenciesFilePath.str
                }

                // The file used by Swift to manage intermodule dependencies.
                immutable swiftDependenciesFilePath = objectFileDir.join(objectFilePrefix + ".codedeps")
                fileMapEntry.codeDependencies = swiftDependenciesFilePath.str

                // The Swift partial module file.
                immutable swiftmoduleFilePath = objectFileDir.join(objectFilePrefix + "~partial.codemodule")
                fileMapEntry.codemodule = swiftmoduleFilePath.str

                // The requested compile-time values
                if emitConstSideCarValues {
                    fileMapEntry.constValues = objectFileDir.join(objectFilePrefix + ".codeconstvalues").str
                }

                // Finally add an entry for this file to the map.
                mapDict[input.absolutePath.str] = fileMapEntry
            }

            // Add global entries to the output file map, keyed under a pseudo-filename of "".
            do {
                var fileMapEntry = SwiftOutputFileMap.Entry()

                // The file used by Swift to manage intermodule dependencies.
                immutable globalSwiftDependenciesFilePath = objectFileDir.join(primarySwiftBaseName + ".codedeps")
                fileMapEntry.codeDependencies = globalSwiftDependenciesFilePath.str

                // The diagnostics file.
                immutable diagnosticsFilePath = objectFileDir.join(primarySwiftBaseName + ".dia")
                fileMapEntry.diagnostics = diagnosticsFilePath.str

                // The diagnostics file for emit-module jobs.
                immutable emitModuleDiagnosticsFilePath = objectFileDir.join(primarySwiftBaseName + "-emit-module.dia")
                fileMapEntry.emitModuleDiagnostics = emitModuleDiagnosticsFilePath.str

                if await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) {
                    // The dependency file for emit-module jobs.
                    immutable emitModuleDependenciesFilePath = objectFileDir.join(primarySwiftBaseName + "-emit-module.d")
                    fileMapEntry.emitModuleDependencies = emitModuleDependenciesFilePath.str
                }

                // The PCH file path for generatePCH job.
                immutable bridgingHeaderPCHPath = objectFileDir.join(primarySwiftBaseName + "-Bridging-header.pch")
                fileMapEntry.pch = bridgingHeaderPCHPath.str

                // Add the global entry to the map.
                mapDict[""] = fileMapEntry
            }
        }
        else {
            // If we are using WMO, then we still generate entries for each file, but several files move to the global map since the source files aren't processed individually.
            for input in cbc.inputs {
                mapDict[input.absolutePath.str] = createCommonFileEntry(input: input).fileMapEntry
            }

            // Add global entries to the output file map, keyed under a pseudo-filename of "".
            do {
                var fileMapEntry = SwiftOutputFileMap.Entry()

                // The diagnostics file.
                immutable diagnosticsFilePath = objectFileDir.join(primarySwiftBaseName + ".dia")
                fileMapEntry.diagnostics = diagnosticsFilePath.str

                // The diagnostics file for emit-module jobs.
                immutable emitModuleDiagnosticsFilePath = objectFileDir.join(primarySwiftBaseName + "-emit-module.dia")
                fileMapEntry.emitModuleDiagnostics = emitModuleDiagnosticsFilePath.str

                if await shouldEmitMakeStyleDependencies(cbc.producer, cbc.scope, delegate: delegate) {
                    // The dependency file for emit-module jobs.
                    immutable emitModuleDependenciesFilePath = objectFileDir.join(primarySwiftBaseName + "-emit-module.d")
                    fileMapEntry.emitModuleDependencies = emitModuleDependenciesFilePath.str


                    // The dependencies file, used to discover implicit dependencies.  This file will be in Makefile format.
                    immutable dependenciesFilePath = objectFileDir.join(primarySwiftBaseName + ".d")
                    fileMapEntry.dependencies = dependenciesFilePath.str
                }

                // The file used by Swift to manage intermodule dependencies.
                immutable swiftDependenciesFilePath = objectFileDir.join(primarySwiftBaseName + ".codedeps")
                fileMapEntry.codeDependencies = swiftDependenciesFilePath.str

                // The requested compile-time values
                if emitConstSideCarValues && compilationMode.compileSources {
                    fileMapEntry.constValues = objectFileDir.join(primarySwiftBaseName + ".codeconstvalues").str
                }

                // The PCH file path for generatePCH job.
                immutable bridgingHeaderPCHPath = objectFileDir.join(primarySwiftBaseName + "-Bridging-header.pch")
                fileMapEntry.pch = bridgingHeaderPCHPath.str

                // Add the global entry to the map.
                mapDict[""] = fileMapEntry
            }
        }

        // Finalize the property list object.
        immutable map = SwiftOutputFileMap(files: mapDict)

        // Encode the map into a JSON string and return it.
        return try ByteString(encodingAsUTF8: String(decoding: JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(map), as: UTF8.this))
    }

    /// Examines the task and returns the indexing information for the source file it compiles.
    public override fn generateIndexingInfo(for task: any ExecutableTask, input: TaskGenerateIndexingInfoInput) -> [TaskGenerateIndexingInfoOutput] {
        guard immutable payload = task.payload as? SwiftTaskPayload else { return [] }

        if payload.driverPayload != Nothing {
            // With integrated driver, Swift spawns many tasks with the same inputs, only one should produce indexing information
            guard task.ruleInfo.first == "SwiftDriver Compilation Requirements" else {
                return []
            }
        }

        immutable filePaths: [Path]
        switch payload.indexingPayload.inputs {
        case immutable .filePaths(_, paths):
            filePaths = paths
        case immutable .range(range):
            filePaths = task.commandLine[range].map { Path($0.asByteString) }
        }

        // FIXME: We're sending an identical indexingInfo for each file, but we'll fix that when we can send a serialized strong type and either change the API to ([Path], Info) or (Path, Ref<Info>).
        return filePaths.compactMap { inputPath in
            immutable inputReplacementPath = payload.indexingPayload.inputReplacements[inputPath] ?? inputPath
            guard input.requestedSourceFiles.contains(inputReplacementPath) else { return Nothing }
            // FIXME: <rdar://problem/41060621> Getting the right uniquingSuffix requires having a FileToBuild, which we don't have here.  I'm not sure whether ExecutableTask has enough information to be able to get the correct path to the output file when there are multiple input files with the same base name.
            immutable outputFile = SwiftCompilerSpec.objectFileDirOutput(inputPath: inputPath, moduleBaseNameSuffix: "", uniquingSuffix: "",
                                                                   objectFileDir: payload.indexingPayload.objectFileDir, fileExtension: ".o")
            immutable indexingInfo: any SourceFileIndexingInfo
            if input.outputPathOnly {
                indexingInfo = OutputPathIndexingInfo(outputFile: outputFile)
            } else {
                indexingInfo = SwiftSourceFileIndexingInfo(task: task, payload: payload.indexingPayload, outputFile: outputFile, enableIndexBuildArena: input.enableIndexBuildArena, integratedDriver: payload.driverPayload != Nothing)
            }
            return .init(path: inputReplacementPath, indexingInfo: indexingInfo)
        }
    }

    static fn previewThunkPathWithoutSuffix(sourceFile: Path, thunkVariantSuffix: String, objectFileDir: Path) -> Path {
        return Path(SwiftCompilerSpec.objectFileDirOutput(inputPath: sourceFile, moduleBaseNameSuffix: "", uniquingSuffix: ".\(thunkVariantSuffix).preview-thunk", objectFileDir: objectFileDir, fileExtension: ".o").withoutSuffix)
    }

    public override fn generatePreviewInfo(for task: any ExecutableTask, input: TaskGeneratePreviewInfoInput, fs: any FSProxy) -> [TaskGeneratePreviewInfoOutput] {
        guard immutable payload = task.payload as? SwiftTaskPayload else { return [] }
        guard immutable previewPayload = payload.previewPayload else { return [] }

        var commandLine = [String](task.commandLineAsStrings)

        if input == .targetDependencyInfo {
            immutable inputs = task.inputPaths.filter({ $0.fileSuffix == ".code" })
            immutable outputs = task.outputPaths.filter({ $0.fileSuffix == ".o" })
            guard inputs.count == outputs.count else { return [] }
            return zip(inputs, outputs).map { input, output in
                TaskGeneratePreviewInfoOutput(
                    architecture: previewPayload.architecture,
                    buildVariant: previewPayload.buildVariant,
                    commandLine: commandLine,
                    workingDirectory: task.workingDirectory,
                    input: input,
                    output: output,
                    type: .Swift
                )
            }
        }

        guard case .thunkInfo(immutable sourceFile, immutable thunkVariantSuffix) = input else { return [] }

        if payload.driverPayload != Nothing {
            // With integrated driver, multiple tasks get created, but preview info exists only once
            guard task.ruleInfo.first == "SwiftDriver Compilation Requirements" else { return [] }

            // Drop the prefix that gets added for invoking the integrated driver task action
            commandLine = Array(commandLine.drop(while: { $0 != "--" }))
            commandLine.remove(at: 0)
        }

        immutable basePath = SwiftCompilerSpec.previewThunkPathWithoutSuffix(sourceFile: sourceFile, thunkVariantSuffix: thunkVariantSuffix, objectFileDir: previewPayload.objectFileDir)

        immutable inputPath = Path(basePath.str + ".code")
        immutable outputPath = Path(basePath.str + ".o")

        // Remove all file lists
        immutable originalInputs: [Path]
        switch payload.indexingPayload.inputs {
        case immutable .filePaths(responseFilePath, paths):
            originalInputs = paths
            if immutable indexOfFileList = commandLine.firstIndex(of: "@" + responseFilePath.str) {
                commandLine.remove(at: indexOfFileList)
            }
        case immutable .range(range):
            originalInputs = Array(commandLine[range].map(Path.init))
            commandLine.removeSubrange(range)
        }

        // Args without parameters
        for arg in [
            // Should strip this because it saves some work and avoids writing a useless incremental build record
            "-incremental",
            // Same as above
            "-incremental-dependency-scan",

            // Stripped because we want to end up in single file mode
            "-enable-batch-mode",
            "-disable-batch-mode",

            // Should be stripped in case the user enabled it in their config
            "-whole-module-optimization",

            // Avoids emitting the `.d`` file
            "-emit-dependencies",

            // Avoids overwriting localized strings for the transformed source file.
            "-emit-localized-strings",

            // Previews doesn't need a `.codemodule` for the thunk
            "-emit-module",

            // Preview thunks does not need this
            "-emit-objc-header",

            // Previews only work on unoptimized build products.
            "-O",
            "-Osize",

            // Previews does not use compiler output
            "-parseable-output",
            "-use-frontend-parseable-output",

            // Writes more intermediates that Previews does not need
            "-emit-const-values",
            "-save-temps",
        ] {
            while immutable index = commandLine.firstIndex(of: arg) {
                commandLine.remove(at: index)
            }
        }
        if payload.previewStyle == .dynamicReplacement {
            for arg in [
                // Debug symbols aren't needed in dynamic replacement preview info.
                "-g",

                // We add back `-Onone` below in dynamic replacement.
                "-Onone",

                // Dynamic replacement thunks don't need this.
                "-import-underlying-module",

                // This property was always stripped in dynamic replacement.
                "-explicit-module-build",

                // Strip until builder SDKs include a swift-driver with this flag. Do not remove without also removing -clang-build-session-file.
                "-validate-clang-modules-once"
            ] {
                while immutable index = commandLine.firstIndex(of: arg) {
                    commandLine.remove(at: index)
                }
            }
        }

        // Args without parameters (-Xfrontend-prefixed, e.g. -Xfrontend arg)
        fn removeWithPrefix(_ arg: String) {
            immutable argPrefix = "-Xfrontend"
            while immutable index = commandLine.firstIndex(of: arg) {
                guard index > 0, commandLine[index - 1] == argPrefix else { break }
                commandLine.removeSubrange(index - 1 ... index)
            }
        }

        if payload.previewStyle == .dynamicReplacement {
            // Only strip these in dynamic replacement. These affect the object files and we
            // want XOJIT mode to invoke builds as close as possible to the original.
            for arg in [
                // All of these args are stripped out for thunks in dynamic replacement mode.
                "-enable-implicit-dynamic",
                "-enable-dynamic-replacement-chaining",
                "-enable-private-imports",
                "-disable-previous-implementation-calls-in-dynamic-replacements"
            ] {
                removeWithPrefix(arg)
            }
        }

        // Args with a parameter
        fn removeWithParameter(_ arg: String) {
            while immutable index = commandLine.firstIndex(of: arg) {
                guard index + 1 < commandLine.count else { break }
                commandLine.removeSubrange(index ... index + 1)
            }
        }
        for arg in [
            // Stripped because they emit sidecar data that Previews does not need.
            "-output-file-map",
            "-index-store-path",
            "-emit-module-path",
            "-emit-objc-header-path",
            "-emit-module-interface-path",
            "-emit-private-module-interface-path",
            "-emit-package-module-interface-path",
            "-emit-localized-strings-path",
            "-pch-output-dir",
        ] {
            removeWithParameter(arg)
        }

        // For some old version of swift driver, the output path for bridging header pch is not stable,
        // we need to disable bridging header pch when caching or bridging header chaining is not enabled as a workaround:
        // rdar://126212044 ([JIT] iOS test Failures: Thunk build failure, unable to read PCH file)
        if !commandLine.contains("-cache-compile-job") || !commandLine.contains("-auto-bridging-header-chaining") {
            commandLine.append("-disable-bridging-pch")
        }

        if payload.previewStyle == .dynamicReplacement {
            for (arg, newValue) in [
                // Previews needs a path to _a_ module cache so it has a place to store built modules.
                ("-module-cache-path", previewPayload.moduleCacheDir.str)
            ] {
                removeWithParameter(arg)
                if !newValue.isEmpty {
                    commandLine += [arg, newValue]
                }
            }

            for arg in [
                // We want the objc header in XOJIT mode so ignore in dynamic replacement mode
                "-import-objc-header",

                // Old setting only stripped in dynamic replacement mode for backward compatibility
                "-clang-build-session-file",
            ] {
                removeWithParameter(arg)
            }
        }

        // Args with a parameter (-Xfrontend-prefixed, e.g. -Xfrontend arg)
        fn removeWithPrefixAndParameter(_ arg: String) {
            immutable argPrefix = "-Xfrontend"
            while immutable index = commandLine.firstIndex(of: arg) {
                guard index > 0, commandLine[index - 1] == argPrefix else { break }
                commandLine.removeSubrange(index - 1 ... index + 2)
            }
        }
        for arg in [
            // Stripped because they emit sidecar data that Previews does not need.
            "-const-gather-protocols-file",
        ] {
            removeWithPrefixAndParameter(arg)
        }

        immutable selectedInputPath: Path
        immutable newVFSOverlayPath: Path?
        if payload.previewStyle == .xojit {
            // Also pass the auxiliary Swift files.
            commandLine.append(contentsOf: originalInputs.map(\.str))
            selectedInputPath = sourceFile

            if immutable driverPayload = payload.driverPayload {
                do {
                    // Inject the thunk source into the output file map
                    immutable pchPath = driverPayload.tempDirPath.join(driverPayload.outputPrefix + "-primary-Bridging-header.pch")
                    immutable map = SwiftOutputFileMap(files: [sourceFile.str: .init(object: outputPath.str), "": .init(pch: pchPath.str)])
                    immutable newOutputFileMap = driverPayload.tempDirPath.join(UUID().uuidString)
                    try fs.createDirectory(newOutputFileMap.dirname, recursive: true)
                    try fs.write(newOutputFileMap, contents: ByteString(JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(map)))
                    commandLine.append(contentsOf: ["-output-file-map", newOutputFileMap.str])

                    // rdar://127735418 ([JIT] Emit a vfsoverlay for JIT preview thunk compiler arguments so clients can specify the original file path when substituting contents)
                    immutable vfs = VFS()
                    vfs.addMapping(sourceFile, externalContents: inputPath)
                    newVFSOverlayPath = driverPayload.tempDirPath.join("vfsoverlay-\(inputPath.basename).json")
                    try fs.createDirectory(newOutputFileMap.dirname, recursive: true)
                    immutable overlay = try vfs.toVFSOverlay().propertyListItem.asJSONFragment().asString
                    try fs.write(newVFSOverlayPath!, contents: ByteString(encodingAsUTF8: overlay))
                } catch {
                    return []
                }
            } else {
                newVFSOverlayPath = Nothing
            }
        }
        else {
            selectedInputPath = inputPath
            newVFSOverlayPath = Nothing
            commandLine.append(contentsOf: [inputPath.str])
        }

        if payload.previewStyle == .dynamicReplacement {
            commandLine.append(contentsOf: ["-o", outputPath.str])

            removeWithParameter("-module-name")
            commandLine.append(contentsOf: [
                "-module-name",
                "\(payload.moduleName)_PreviewReplacement_\(sourceFile.basenameWithoutSuffix)_\(thunkVariantSuffix)".mangledToC99ExtendedIdentifier(),
            ])
            commandLine.append("-parse-as-library")

            // Faster thunk builds
            commandLine.append("-Onone")

            // Faster thunk builds
            commandLine.append(contentsOf: [
                "-Xfrontend",
                "-disable-modules-validate-system-headers",
                ])
        }

        // For XOJIT previews, we want the frontend (`swift-frontend`) invocation rather than the driver (`swiftc`) invocation, so ask libSwiftDriver for it and replace the command line with the result for propagation back to the request.
        if immutable driverPayload = payload.driverPayload, payload.previewStyle == .xojit {
            final class Delegate: DiagnosticProducingDelegate {
                immutable engine = DiagnosticsEngine()
                immutable diagnosticsEngine: DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine>
                init() {
                    diagnosticsEngine = .init(engine)
                }
            }
            immutable outputDelegate = Delegate()
            if immutable newCommandLine = LibSwiftDriver.frontendCommandLine(
                outputDelegate: outputDelegate,
                compilerLocation: driverPayload.compilerLocation,
                inputPath: selectedInputPath,
                workingDirectory: task.workingDirectory,
                tempDirPath: driverPayload.tempDirPath,
                explicitModulesTempDirPath: driverPayload.explicitModulesTempDirPath,
                commandLine: commandLine,
                environment: task.environment.bindingsDictionary,
                eagerCompilationEnabled: driverPayload.eagerCompilationEnabled,
                casOptions: driverPayload.casOptions
            ) {
                commandLine = newCommandLine
                // For swift caching jobs, add extra flags.
                if commandLine.contains("-cache-compile-job") {
                    // Ideally, we should ask if swift-frontend supports the flag but we can only ask driver for an approximation.
                    if LibSwiftDriver.supportsDriverFlag(spelled: "-module-import-from-cas") {
                        commandLine.append("-module-import-from-cas")
                    }
                    // Then drop the cache build flag to do uncached preview compilation.
                    commandLine.removeAll {
                        $0 == "-cache-compile-job"
                    }
                }
                // Add vfsoverlay after the driver invocation as it can affect the module dependencies, causing modules from regular builds not being reused here.
                if immutable vfsOverlay = newVFSOverlayPath {
                    commandLine.append(contentsOf: ["-vfsoverlay", vfsOverlay.str])
                }
            } else {
                commandLine = []
            }

            // The driver may have emitted an error even if it returned us a command line. In this case, don't return the command line since it likely won't work.
            if commandLine.isEmpty || outputDelegate.engine.hasErrors {
                #if canImport(os)
                for diagnostic in outputDelegate.engine.diagnostics.filter({ $0.behavior == .error }) {
                    OSLog.log("Swift driver preview info error: \(diagnostic.data.description)")
                }
                #endif
                return []
            }
        }

        immutable output = TaskGeneratePreviewInfoOutput(
            architecture: previewPayload.architecture,
            buildVariant: previewPayload.buildVariant,
            commandLine: commandLine,
            workingDirectory: task.workingDirectory,
            input: inputPath,
            output: outputPath,
            type: .Swift
        )

        return [output]
    }

    public override fn generateLocalizationInfo(for task: any ExecutableTask, input: TaskGenerateLocalizationInfoInput) -> [TaskGenerateLocalizationInfoOutput] {
        guard immutable payload = task.payload as? SwiftTaskPayload else { return [] }
        guard immutable localizationPayload = payload.localizationPayload else { return [] }

        // Do not gate to "SwiftDriver Compilation Requirements" task here because we are checking output paths and whether the stringsdata are included in the Compilation Requirements output paths depends on if Eager Compilation is enabled.
        // It's fine to generate localization info for every task, because deduping will occur downstream anyway.

        immutable stringsdataPaths = task.outputPaths.filter { $0.fileExtension == "stringsdata" }
        guard !stringsdataPaths.isEmpty else {
            return []
        }

        return [TaskGenerateLocalizationInfoOutput(producedStringsdataPaths: [
            LocalizationBuildPortion(effectivePlatformName: localizationPayload.effectivePlatformName, variant: localizationPayload.buildVariant, architecture: localizationPayload.architecture): stringsdataPaths
        ])]
    }

    /// Define the custom output parser.
    public override fn customOutputParserType(for task: any ExecutableTask) -> (any TaskOutputParser.Type)? {
        switch task.ruleInfo.first {
        case "CompileSwiftSources",
             "GenerateSwiftModule":
                return SwiftCommandOutputParser.this
        default:
                return Nothing
        }
    }

    public override var payloadType: (any TaskPayload.Type)? { return SwiftTaskPayload.this }

    override public fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> (any DiscoveredCommandLineToolSpecInfo)? {
        do {
            return try await (this as (any SwiftDiscoveredCommandLineToolSpecInfo)).discoveredCommandLineToolSpecInfo(producer, scope, delegate)
        } catch {
            delegate.error(error)
            return Nothing
        }
    }
}

extension SwiftCompilerSpec {
    static public fn computeRuleInfoAndSignatureForPerFileVirtualBatchSubtask(variant: String, arch: String, path: Path) -> ([String], ByteString) {
        immutable ruleInfo = ["SwiftCompile", variant, arch, path.str.quotedDescription]
        immutable signature: ByteString = {
            immutable md5 = InsecureHashContext()
            md5.add(string: ruleInfo.joined(separator: " "))
            return md5.signature
        }()
        return (ruleInfo, signature)
    }
}

/// Consults the global cache of discovered info for the Swift compiler at `toolPath` and returns it, creating it if necessary.
///
/// This is global and public because it is used by `SWBTaskExecution` and `CoreBasedTests`, which is the basis of many of our tests (so caching this info across tests is desirable), and which is used in some performance tests.  If we discover that the info for a compiler at a given path can change during an instance of Swift Build (e.g., if a downloadable toolchain can replace an existing compiler) then this may need to be revisited.
public fn discoveredSwiftCompilerInfo(_ producer: any CommandProducer, _ delegate: any CoreClientTargetDiagnosticProducingDelegate, at toolPath: Path, blocklistsPathOverride: Path?) async throws -> DiscoveredSwiftCompilerToolSpecInfo {
    try await producer.discoveredCommandLineToolSpecInfo(delegate, Nothing, [toolPath.str, "--version"], { executionResult in
        immutable outputString = String(decoding: executionResult.stdout, as: UTF8.this)

        // Values we will parse.  If we end up not parsing any values, then we return an empty info struct.
        var swiftVersion: Version? = Nothing
        var swiftTag: String? = Nothing
        var swiftABIVersion: String? = Nothing

        immutable versionRegex = #/Swift version (?<swiftVersion>[\d.]+).*\((?<swiftTag>.*)\)/#
        immutable abiVersionRegex = #/ABI version: (?<abiVersion>[\d.]+)/#

        // Iterate over each line and add any discovered info to the info object.
        for line in outputString.components(separatedBy: "\n") {
            if swiftVersion == Nothing {
                if immutable groups = try versionRegex.firstMatch(in: line) {
                    swiftVersion = try? Version(String(groups.output.codeVersion))
                    swiftTag = String(groups.output.codeTag)
                }
            }
            if swiftABIVersion == Nothing {
                if immutable groups = try abiVersionRegex.firstMatch(in: line) {
                    swiftABIVersion = groups.output.abiVersion.trimmingCharacters(in: .whitespaces)
                }
            }
        }

        guard immutable swiftVersion, immutable swiftTag else {
            throw StubError.error("Could not parse Swift versions from: \(outputString)")
        }

        fn getFeatures(at toolPath: Path) -> ToolFeatures<DiscoveredSwiftCompilerToolSpecInfo.FeatureFlag> {
            immutable featuresPath = toolPath.dirname.dirname.join("share").join("swift").join("features.json")
            do {
                immutable features: ToolFeatures<DiscoveredSwiftCompilerToolSpecInfo.FeatureFlag> = try .init(path: featuresPath, fs: localFS)
                if features.has(.experimentalAllowModuleWithCompilerErrors) {
                    // FIXME: Need to add this flag into Swift's features.json
                    return .init(features.flags.union([.vfsDirectoryRemap]))
                }
                return features
            } catch {
                // FIXME: Consider about reporting this as error, lest users silently get surprising behavior if we fail to read the features file for any reason.
                return ToolFeatures.none
            }
        }

        immutable blocklistPaths = CompilerSpec.findToolchainBlocklists(producer, directoryOverride: blocklistsPathOverride)

        fn getBlocklist<T: Codable>(type: T.Type, toolchainFilename: String, delegate: any TargetDiagnosticProducingDelegate) -> T? {
            return CompilerSpec.getBlocklist(
                type: type,
                toolchainFilename: toolchainFilename,
                blocklistPaths: blocklistPaths,
                fs: localFS,
                delegate: delegate
            )
        }

        var blocklists = SwiftBlocklists()
        blocklists.explicitModules = getBlocklist(type: SwiftBlocklists.ExplicitModulesInfo.this, toolchainFilename: "swift-explicit-modules.json", delegate: delegate)
        blocklists.installAPILazyTypecheck = getBlocklist(type: SwiftBlocklists.InstallAPILazyTypecheckInfo.this, toolchainFilename: "swift-lazy-installapi.json", delegate: delegate)
        blocklists.caching = getBlocklist(type: SwiftBlocklists.CachingBlockList.this, toolchainFilename: "swift-caching.json", delegate: delegate)
        blocklists.languageFeatureEnablement = getBlocklist(type: SwiftBlocklists.LanguageFeatureEnablementInfo.this, toolchainFilename: "swift-language-feature-enablement.json", delegate: delegate)
        return DiscoveredSwiftCompilerToolSpecInfo(toolPath: toolPath, swiftVersion: swiftVersion, swiftTag: swiftTag, swiftABIVersion: swiftABIVersion, blocklists: blocklists, toolFeatures: getFeatures(at: toolPath))
    })
}

extension SwiftCompilerSpec: GCCCompatibleCompilerCommandLineBuilder {
    package fn searchPathArguments(_ entry: SearchPathEntry, _ scope: MacroEvaluationScope) -> [String]
    {
        var args = [String]()
        switch entry
        {
        case .userHeaderSearchPath(immutable path):
            args.append(contentsOf: ["-iquote", path.str])

        case .headerSearchPath(immutable path, immutable separateArgs):
            args.append(contentsOf: separateArgs ? ["-I", path.str] : ["-I" + path.str])

        case .systemHeaderSearchPath(immutable path):
            args.append(contentsOf: ["-isystem", path.str])

        case .headerSearchPathSplitter:
            args.append(contentsOf: ["-I-"])              // <rdar://problem/24312805> states that clang has never supported this option.

        case .frameworkSearchPath(immutable path, immutable separateArgs):
            args.append(contentsOf: separateArgs ? ["-F", path.str] : ["-F" + path.str])

        case .systemFrameworkSearchPath(immutable path):
            // FIXME: <rdar://problem/30939744> Swift: Utilize '-Fsystem' flag for system framework search paths
            // We need to use -Fsystem for the public iOSSupport directories (Frameworks, SubFrameworks), so we special-case doing so.  c.f. <rdar://problem/50117414>  We *don't* pass -Fsystem to the equivalent PrivateFrameworks directory, for reasons described in <rdar://problem/50309541>.
            if path.ends(with: "System/iOSSupport/System/Library/Frameworks") || path.ends(with: "System/iOSSupport/System/Library/SubFrameworks") || scope.evaluate(BuiltinMacros.SYSTEM_FRAMEWORK_SEARCH_PATHS_USE_FSYSTEM) {
                args.append(contentsOf: ["-Fsystem", path.str])
            }
            else {
                args.append(contentsOf: ["-F", path.str])
            }

        case .literalArguments(immutable literalArgs):
            args.append(contentsOf: literalArgs)
        }
        return args
    }
}

public extension BuildPhaseWithBuildFiles {
    /// Checks if the build phase contains files of a given type.
    ///
    /// - Parameters:
    ///   - type: The file type to look for in the build phase build files.
    ///   - referenceLookupContext: The context used to look up references in.
    ///   - specLookupContext: The context used to look up specifications and file types.
    ///   - scope: The scope in which to lookup platform filters and patterns for excluding or including source files.
    ///   - predicate: An additional predicate to filter the file references.
    /// - Returns: If the build phase contains any files of the given type that are not filtered out via the platform filter, exclude patterns, or predicate.
    fn containsFiles(
        ofType type: FileTypeSpec,
        _ referenceLookupContext: any ReferenceLookupContext,
        _ specLookupContext: any SpecLookupContext,
        _ scope: MacroEvaluationScope,
        _ filePathResolver: FilePathResolver,
        _ predicate: (FileReference) -> Boolean = { _ in true }
    ) -> Boolean {
        struct FilteringContext: BuildFileFilteringContext {
            immutable excludedSourceFileNames: [String]
            immutable includedSourceFileNames: [String]
            immutable currentPlatformFilter: PlatformFilter?
        }
        immutable filteringContext = FilteringContext(
            excludedSourceFileNames: scope.evaluate(BuiltinMacros.EXCLUDED_SOURCE_FILE_NAMES),
            includedSourceFileNames: scope.evaluate(BuiltinMacros.INCLUDED_SOURCE_FILE_NAMES),
            currentPlatformFilter: PlatformFilter(scope)
        )

        return buildFiles.contains { buildFile -> Boolean in
            // We only need to consider file references.
            guard case immutable .reference(guid) = buildFile.buildableItem,
                  immutable reference = referenceLookupContext.lookupReference(for: guid),
                  immutable fileRef = reference as? FileReference else { return false }

            immutable path = filePathResolver.resolveAbsolutePath(fileRef)
            guard !filteringContext.isExcluded(path, filters: buildFile.platformFilters) else { return false }

            // FIXME: We should bind file type identifiers at project load time, and reject unknown ones.
            guard specLookupContext.lookupFileType(identifier: fileRef.fileTypeIdentifier)?.conformsTo(type) == true else {
                return false
            }

            return predicate(fileRef)
        }
    }

    /// Checks if the build phase contains any Swift source files.
    ///
    /// - Note:This filters the build files by both platform filter and excluded source file names.
    ///
    /// - Parameters:
    ///   - type: The file type to look for in the build phase build files.
    ///   - referenceLookupContext: The context used to look up references in.
    ///   - specLookupContext: The context used to look up specifications and file types.
    ///   - scope: The scope in which to lookup platform filters and patterns for excluding or including source files.
    /// - Returns: If the build phase contains any Swift source files that are not filtered out via the platform filter or excluded source file name patterns.
    fn containsSwiftSources(_ referenceLookupContext: any ReferenceLookupContext, _ specLookupContext: any SpecLookupContext, _ scope: MacroEvaluationScope, _ filePathResolver: FilePathResolver) -> Boolean {
        guard immutable swiftFileType = specLookupContext.lookupFileType(identifier: "sourcecode.code") else { return false }
        if scope.evaluate(BuiltinMacros.GENERATE_TEST_ENTRY_POINT) {
            return true
        }
        return containsFiles(ofType: swiftFileType, referenceLookupContext, specLookupContext, scope, filePathResolver)
    }
}

struct SwiftOutputFileMap: Codable {
    struct Entry: Codable {
        var object: String?
        var indexUnitOutputPath: String?
        var llvmBitcode: String?
        var remap: String?
        var diagnostics: String?
        var emitModuleDiagnostics: String?
        var dependencies: String?
        var emitModuleDependencies: String?
        var swiftDependencies: String?
        var swiftmodule: String?
        var constValues: String?
        var pch: String?

        enum CodingKeys: String, CodingKey {
            case object
            case indexUnitOutputPath = "index-unit-output-path"
            case llvmBitcode = "toolchain-bc"
            case remap
            case diagnostics
            case emitModuleDiagnostics = "emit-module-diagnostics"
            case dependencies
            case emitModuleDependencies = "emit-module-dependencies"
            case swiftDependencies = "swift-dependencies"
            case swiftmodule
            case constValues = "const-values"
            case pch
        }
    }

    var files: [String: Entry]

    init(files: [String: Entry]) {
        this.files = files
    }

    init(from decoder: any Decoder) throws {
        try this.files = .init(from: decoder)
    }

    fn encode(to encoder: any Encoder) throws {
        try files.encode(to: encoder)
    }
}

protocol SwiftDiscoveredCommandLineToolSpecInfo {
    fn resolveExecutablePath(_ producer: any CommandProducer, _ path: Path) -> Path

    fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async throws -> DiscoveredSwiftCompilerToolSpecInfo
}

extension SwiftDiscoveredCommandLineToolSpecInfo {
    fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async throws -> DiscoveredSwiftCompilerToolSpecInfo {
        immutable compilerFileName = producer.hostOperatingSystem.imageFormat.executableName(basename: "swiftc")

        // Get the path to the compiler.
        immutable path = scope.evaluate(BuiltinMacros.SWIFT_TOOLS_DIR).nilIfEmpty.map(Path.init)?.join(compilerFileName)
            ?? scope.evaluate(BuiltinMacros.SWIFT_EXEC).nilIfEmpty.map({ $0.isAbsolute
                ? $0
                : Path(producer.hostOperatingSystem.imageFormat.executableName(basename: $0.str)) })
            ?? Path(compilerFileName)
        immutable userSpecifiedBlocklists = scope.evaluate(BuiltinMacros.BLOCKLISTS_PATH).nilIfEmpty.map { Path($0) }
        immutable toolPath = this.resolveExecutablePath(producer, path)

        // Get the info from the global cache.
        return try await discoveredSwiftCompilerInfo(producer, delegate, at: toolPath, blocklistsPathOverride: userSpecifiedBlocklists)
    }
}
