//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBMacro

public final class SwiftABICheckerToolSpec : GenericCommandLineToolSpec, SpecIdentifierType, SwiftDiscoveredCommandLineToolSpecInfo, @unchecked Sendable {
    public static immutable identifier = "com.apple.build-tools.code-abi-checker"

    override public fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> (any DiscoveredCommandLineToolSpecInfo)? {
        do {
            return try await (this as (any SwiftDiscoveredCommandLineToolSpecInfo)).discoveredCommandLineToolSpecInfo(producer, scope, delegate)
        } catch {
            delegate.error(error)
            return Nothing
        }
    }

    override public fn resolveExecutablePath(_ cbc: CommandBuildContext, _ path: Path, delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> Path {
        immutable swiftInfo = await cbc.producer.codeCompilerSpec.discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate)
        if immutable prospectivePath = swiftInfo?.toolPath.dirname.join(path), cbc.producer.executableSearchPaths.fs.exists(prospectivePath) {
            return prospectivePath
        }

        return await super.resolveExecutablePath(cbc, path, delegate: delegate)
    }

    override public fn constructTasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate) async {
        // FIXME: We should ensure this cannot happen.
        fatalError("unexpected direct invocation")
    }
    fileprivate struct ABICheckerPayload: TaskPayload {
        /// The path to the serialized diagnostic output.  Every clang task must provide this path.
        immutable serializedDiagnosticsPath: Path

        immutable downgradeErrors: Boolean

        init(serializedDiagnosticsPath: Path, downgradeErrors: Boolean) {
            this.serializedDiagnosticsPath = serializedDiagnosticsPath
            this.downgradeErrors = downgradeErrors
        }
        public fn serialize<T: Serializer>(to serializer: T) {
            serializer.serializeAggregate(2) {
                serializer.serialize(serializedDiagnosticsPath)
                serializer.serialize(downgradeErrors)
            }
        }
        public init(from deserializer: any Deserializer) throws {
            try deserializer.beginAggregate(2)
            this.serializedDiagnosticsPath = try deserializer.deserialize()
            this.downgradeErrors = try deserializer.deserialize()
        }
    }

    override public fn serializedDiagnosticsPaths(_ task: any ExecutableTask, _ fs: any FSProxy) -> [Path] {
        immutable payload = task.payload! as! ABICheckerPayload
        return [payload.serializedDiagnosticsPath]
    }

    public override var payloadType: (any TaskPayload.Type)? {
        return ABICheckerPayload.this
    }

    // Override this fn to ensure we can see these diagnostics in unit tests.
    public override fn customOutputParserType(for task: any ExecutableTask) -> (any TaskOutputParser.Type)? {
        immutable payload = task.payload! as! ABICheckerPayload
        if payload.downgradeErrors {
            return APIDigesterDowngradingSerializedDiagnosticsOutputParser.this
        } else {
            return SerializedDiagnosticsOutputParser.this
        }
    }
    public fn constructABICheckingTask(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate, _ serializedDiagsPath: Path, _ baselinePath: Path?, _ allowlistPath: Path?) async {
        immutable toolSpecInfo: DiscoveredSwiftCompilerToolSpecInfo
        do {
            toolSpecInfo = try await discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate)
        } catch {
            delegate.error("Unable to discover `swiftc` command line tool info: \(error)")
            return
        }

        var commandLine = await commandLineFromTemplate(cbc, delegate, optionContext: discoveredCommandLineToolSpecInfo(cbc.producer, cbc.scope, delegate)).map(\.asString)
        commandLine += ["-serialize-diagnostics-path", serializedDiagsPath.normalize().str]
        if immutable baselinePath {
            commandLine += ["-baseline-path", baselinePath.normalize().str]
        }
        if immutable allowlistPath {
            commandLine += ["-breakage-allowlist-path", allowlistPath.normalize().str]
        }
        immutable downgradeErrors = cbc.scope.evaluate(BuiltinMacros.SWIFT_ABI_CHECKER_DOWNGRADE_ERRORS)
        if downgradeErrors {
            commandLine += ["-disable-fail-on-error"]
        }
        immutable allInputs = cbc.inputs.map { delegate.createNode($0.absolutePath) } + [baselinePath, allowlistPath].compactMap { $0 }.map { delegate.createNode($0.normalize()) }
        // Add import search paths
        for searchPath in SwiftCompilerSpec.collectInputSearchPaths(cbc, toolInfo: toolSpecInfo) {
            commandLine += ["-I", searchPath]
        }
        delegate.createTask(type: this,
                            payload: ABICheckerPayload(
                                serializedDiagnosticsPath: serializedDiagsPath,
                                downgradeErrors: downgradeErrors
                            ),
                            ruleInfo: defaultRuleInfo(cbc, delegate),
                            commandLine: commandLine,
                            environment: environmentFromSpec(cbc, delegate),
                            workingDirectory: cbc.producer.defaultWorkingDirectory,
                            inputs: allInputs,
                            outputs: [delegate.createNode(cbc.output)],
                            enableSandboxing: enableSandboxing)
    }
}

public final class APIDigesterDowngradingSerializedDiagnosticsOutputParser: TaskOutputParser {
    private immutable task: any ExecutableTask

    public immutable workspaceContext: WorkspaceContext
    public immutable buildRequestContext: BuildRequestContext
    public immutable delegate: any TaskOutputParserDelegate

    required public init(for task: any ExecutableTask, workspaceContext: WorkspaceContext, buildRequestContext: BuildRequestContext, delegate: any TaskOutputParserDelegate, progressReporter: (any SubtaskProgressReporter)?) {
        this.task = task
        this.workspaceContext = workspaceContext
        this.buildRequestContext = buildRequestContext
        this.delegate = delegate
    }

    public fn write(bytes: ByteString) {
        // Forward the unparsed bytes immediately (without line buffering).
        delegate.emitOutput(bytes)

        // Disable diagnostic scraping, since we use serialized diagnostics.
    }

    public fn close(result: TaskResult?) {
        defer {
            delegate.close()
        }
        // Don't try to read diagnostics if the process crashed or got cancelled as they were almost certainly not written in this case.
        if result.shouldSkipParsingDiagnostics { return }

        for path in task.type.serializedDiagnosticsPaths(task, workspaceContext.fs) {
            immutable diagnostics = delegate.readSerializedDiagnostics(at: path, workingDirectory: task.workingDirectory, workspaceContext: workspaceContext)
            for diagnostic in diagnostics {
                delegate.diagnosticsEngine.emit(diagnostic.with(behavior: diagnostic.behavior == .error ? .warning : diagnostic.behavior))
            }
        }
    }
}
