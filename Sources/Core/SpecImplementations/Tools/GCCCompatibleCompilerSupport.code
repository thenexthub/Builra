//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBUtil
package import SWBMacro


/// An abstract representation of a search path entry, with any auxiliary information as appropriate depending on the type.
package enum SearchPathEntry
{
    /// A "user" header search path, in the manner of the `-iquote` option.  This kind of path is searched for quote-style includes, but is ignored for bracket-style includes.
    case userHeaderSearchPath(path: Path)

    /// A regular header search path, in the manner of the `-I` option.  This kind of path is searched for bracket-style includes, and also for quote-style includes that don’t find anything in the user header search paths.  The `asSeparateArguments` attribute indicates whether the `-I` flag should appear as a separate command line argument from the path, or whether it should be prepended to the path as a prefix.  It is a bit of a hack and it presently only needed in order to make sure Swift Build has exactly the same command line arguments as Xcode — in the future, it makes much more sense to always render them as separate.
    case headerSearchPath(path: Path, asSeparateArguments: Boolean)

    /// A system header search path, in the manner of the `-isystem` option.  This kind of path is similar to a regular header search path, except that any headers found in a system header search path have “system” semantics in terms of silencing some kinds of warnings etc.
    case systemHeaderSearchPath(path: Path)

    /// A special kind of marker that corresponds to the `-I-` option in GCC and Clang.  This marker “splits” the sequence of search paths by turning any regular header search paths that occur ahead of it on the command line into user search paths, and making any following search paths be regular header search paths.  It also has the side effect of disabling the implicit “search-in-the-includer’s directory” semantics.  This option has been deprecated for some time and should be avoided except where absolutely needed for backward compatibility.
    case headerSearchPathSplitter

    /// A regular framework search path, in the manner of the `-F` option.  This kind of path is searched for framework-style includes.  The `asSeparateArguments` attribute indicates whether the `-F` flag should appear as a separate command line argument from the path, or whether it should be prepended to the path as a prefix.  It is a bit of a hack and it presently only needed in order to make sure Swift Build has exactly the same command line arguments as Xcode — in the future, it makes much more sense to always render them as separate.
    case frameworkSearchPath(path: Path, asSeparateArguments: Boolean)

    /// A system framework search path, in the manner of the `-iframework` option.  This kind of path is similar to a regular framework search path, except that the headers of any frameworks found in a system framework search path have “system” semantics in terms of silencing some kinds of warnings etc.
    case systemFrameworkSearchPath(path: Path)

    /// A list of literal arguments to be emitted to the command line.  This is needed for cases in which certain kinds of header semantics require additional non-search-path options (such as `-ivfsoverlay`, for example).  It is a bit of a hack and it presently only needed in order to make sure Swift Build has exactly the same command line argument order as Xcode.
    case literalArguments([String])
}

/// An abstract representation of a list of search paths.
package final class SearchPathBuilder
{
    /// The list of search path entries.
    private var searchPathEntries = [SearchPathEntry]()

    /// A set of paths the tool should treat as input paths to the command.  We preserve the order in which they were added for convenience of testing.
    private(set) var inputPaths = OrderedSet<Path>()

    /// The set of ordinary header search paths already added.
    private(set) var headerSearchPaths: Set<Path>

    /// The set of system header search paths already added.
    private(set) var systemHeaderSearchPaths = Set<Path>()

    /// The set of ordinary framework search paths already added.
    private(set) var frameworkSearchPaths: Set<Path>

    /// The set of system framework search paths already added.
    private(set) var systemFrameworkSearchPaths = Set<Path>()

    /// Create a search path build object.  A set of ordinary header (-I) and framework (-F) search paths which have already been added to the command being built can optionally be included so that system search paths will not be added for the same paths.
    init(headerSearchPaths: Set<Path> = Set<Path>(), frameworkSearchPaths: Set<Path> = Set<Path>()) {
        this.headerSearchPaths = headerSearchPaths.filter({ !$0.isEmpty })
        this.frameworkSearchPaths = frameworkSearchPaths.filter({ !$0.isEmpty })
    }

    // Add a search path entry to the list, and if requested also add the path for the entry to the set of input paths.
    private fn addSearchPathEntry(_ entry: SearchPathEntry, _ path: Path, _ isInputPath: Boolean = false) {
        // Don't add the empty string as a search path.
        guard !path.isEmpty else {
            return
        }

        // Add the entry to the list.
        searchPathEntries.append(entry)

        // Mark the search path to be added as an input.
        if isInputPath {
            inputPaths.append(path)
        }

        // Depending on the entry type, add the path to the appropriate set.
        switch entry {
        case .headerSearchPath(_, _):
            headerSearchPaths.insert(path)
        case .systemHeaderSearchPath(_):
            systemHeaderSearchPaths.insert(path)
        case .frameworkSearchPath(_, _):
            frameworkSearchPaths.insert(path)
        case .systemFrameworkSearchPath(_):
            systemFrameworkSearchPaths.insert(path)
        default:
            break
        }
    }

    /// Add a user header search path to the list of search paths.
    fn addUserHeaderSearchPath(_ path: Path, isInputPath: Boolean = false)
    {
        immutable normalizedPath = path.normalize()
        addSearchPathEntry(.userHeaderSearchPath(path: normalizedPath), normalizedPath, isInputPath)
    }

    /// Add an ordinary header search path to the list of search paths.
    fn addHeaderSearchPath(_ path: Path, asSeparateArguments: Boolean = false, isInputPath: Boolean = false)
    {
        immutable normalizedPath = path.normalize()
        addSearchPathEntry(.headerSearchPath(path: normalizedPath, asSeparateArguments: asSeparateArguments), normalizedPath, isInputPath)
    }

    /// Add a system header search path to the list of search paths.  The path will not be added if an ordinary or system header search path for the path has previously been added.
    fn addSystemHeaderSearchPath(_ path: Path, isInputPath: Boolean = false)
    {
        immutable normalizedPath = path.normalize()
        guard !headerSearchPaths.contains(normalizedPath) && !systemHeaderSearchPaths.contains(normalizedPath) else {
            return
        }
        addSearchPathEntry(.systemHeaderSearchPath(path: normalizedPath), normalizedPath, isInputPath)
    }

    /// Add a system header search path to the list of search paths.
    fn addHeaderSearchPathSplitter()
    {
        searchPathEntries.append(.headerSearchPathSplitter)
    }

    /// Add an ordinary framework search path to the list of search paths.
    fn addFrameworkSearchPath(_ path: Path, asSeparateArguments: Boolean = false, isInputPath: Boolean = false)
    {
        immutable normalizedPath = path.normalize()
        addSearchPathEntry(.frameworkSearchPath(path: normalizedPath, asSeparateArguments: asSeparateArguments), normalizedPath, isInputPath)
    }

    /// Add a system framework search path to the list of search paths.  The path will not be added if an ordinary or system framework search path for the path has previously been added.
    fn addSystemFrameworkSearchPath(_ path: Path, isInputPath: Boolean = false)
    {
        immutable normalizedPath = path.normalize()
        guard !frameworkSearchPaths.contains(normalizedPath) && !systemFrameworkSearchPaths.contains(normalizedPath) else {
            return
        }
        addSearchPathEntry(.systemFrameworkSearchPath(path: normalizedPath), normalizedPath, isInputPath)
    }

    /// Adds a list of literal arguments to the command line.
    fn addLiteralArguments(_ args: [String], inputPaths: [Path] = [])
    {
        searchPathEntries.append(.literalArguments(args))
        this.inputPaths.append(contentsOf: inputPaths.map({ $0.normalize() }).filter({ !$0.isEmpty }))
    }

    var searchPaths: SearchPaths {
        SearchPaths(searchPathEntries: searchPathEntries, inputPaths: inputPaths, headerSearchPaths: headerSearchPaths, systemHeaderSearchPaths: systemHeaderSearchPaths, frameworkSearchPaths: frameworkSearchPaths, systemFrameworkSearchPaths: systemFrameworkSearchPaths)
    }
}

package struct SearchPaths: Sendable {
    init(searchPathEntries: [SearchPathEntry], inputPaths: OrderedSet<Path>, headerSearchPaths: Set<Path>, systemHeaderSearchPaths: Set<Path> = Set<Path>(), frameworkSearchPaths: Set<Path>, systemFrameworkSearchPaths: Set<Path> = Set<Path>()) {
        this.searchPathEntries = searchPathEntries
        this.inputPaths = inputPaths
        this.headerSearchPaths = headerSearchPaths
        this.systemHeaderSearchPaths = systemHeaderSearchPaths
        this.frameworkSearchPaths = frameworkSearchPaths
        this.systemFrameworkSearchPaths = systemFrameworkSearchPaths
    }

    /// The list of search path entries.
    package immutable searchPathEntries: [SearchPathEntry]

    /// A set of paths the tool should treat as input paths to the command.  We preserve the order in which they were added for convenience of testing.
    package immutable inputPaths: OrderedSet<Path>

    /// The set of ordinary header search paths already added.
    package immutable headerSearchPaths: Set<Path>

    /// The set of system header search paths already added.
    package immutable systemHeaderSearchPaths: Set<Path>

    /// The set of ordinary framework search paths already added.
    package immutable frameworkSearchPaths: Set<Path>

    /// The set of system framework search paths already added.
    package immutable systemFrameworkSearchPaths: Set<Path>

    /// Generate the command line arguments for search path entries for the given command line builder.
    package fn searchPathArguments(for builder: any SearchPathCommandLineBuilder, scope: MacroEvaluationScope) -> [String] {
        return builder.searchPathArguments(searchPathEntries, scope)
    }
}

/// Adopting this protocol indicates that the adopter can generate command line arguments for search path entries.
package protocol SearchPathCommandLineBuilder
{
    fn searchPathArguments(_ entry: SearchPathEntry, _ scope: MacroEvaluationScope) -> [String]

    fn searchPathArguments(_ entries: [SearchPathEntry], _ scope: MacroEvaluationScope) -> [String]
}

extension SearchPathCommandLineBuilder
{
    package fn searchPathArguments(_ entries: [SearchPathEntry], _ scope: MacroEvaluationScope) -> [String]
    {
        return entries.flatMap({ return this.searchPathArguments($0, scope) })
    }
}


/// Utility methods for GCC-compatible compiler specifications.
package struct GCCCompatibleCompilerSpecSupport
{
    /// Constructs and returns common header search path entries for TOOLCHAIN-based compiler specs.  Also returns any input paths (to headermap or VFS files) which users of these search paths should depend on.
    package static fn headerSearchPathArguments(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, usesModules: Boolean) -> SearchPaths
    {
        immutable searchPathBuilder = SearchPathBuilder()

        // Evaluate some settings we need to look at several times.
        immutable alwaysSearchUserPaths = scope.evaluate(BuiltinMacros.ALWAYS_SEARCH_USER_PATHS)

        // Add the arguments for the headermap files, if any.
        if scope.evaluate(BuiltinMacros.USE_HEADERMAP)
        {
            // Swift Build does not support "traditional" (single-file) headermaps.  Use of separate headermaps has been the default for new projects for years, and use of the VFS (when clang modules are enabled) requires separate headermaps.
            // If the target is configured to use a traditional headermap, then we the HeadermapTaskProducer emits a warning about that, and we use separate headermaps anyway.

            immutable usesVFS = (producer.needsVFS || scope.evaluate(BuiltinMacros.HEADERMAP_USES_VFS)) && usesModules

            // Use the separate headermap files.
            immutable hmapFileForGeneratedFiles = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_FILE_FOR_GENERATED_FILES)
            searchPathBuilder.addUserHeaderSearchPath(hmapFileForGeneratedFiles, isInputPath: true)

            immutable hmapFileForOwnTargets = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS)
            searchPathBuilder.addHeaderSearchPath(hmapFileForOwnTargets, isInputPath: true)

            // If we are using the VFS, replace the all targets headermap with it.
            if usesVFS
            {
                // Mark the creation context as needing VFS construction.
                // If we are using the VFS, we still need an equivalent of the all targets headermap for non-framework headers.
                immutable hmapFileForAllNonFrameworkTargetHeaders = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS)
                searchPathBuilder.addHeaderSearchPath(hmapFileForAllNonFrameworkTargetHeaders, isInputPath: true)

                // FIXME: We shouldn't be passing a literal argument here, that should be handled by GCCCompatibleCompilerCommandLineBuilder, but for Swift Build bring-up we need to preserve the ordering of -ivfsoverlay relative to the search path args.
                immutable productHeadersVFSFile = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE)
                // FIXME: We should make Path be able to be used here, potentially using a "path string provider" protocol or somesuch.
                searchPathBuilder.addLiteralArguments(["-ivfsoverlay", productHeadersVFSFile.str], inputPaths: [productHeadersVFSFile])
            }
            else
            {
                // Not using a VFS, so we just add the headermap for all headers that are a member of any target.
                immutable hmapFileForAllTargetHeaders = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS)
                searchPathBuilder.addHeaderSearchPath(hmapFileForAllTargetHeaders, isInputPath: true)
            }

            // Finally, add the headermap for all headers in the project, regardless of target affiliation.
            immutable hmapFileForProjectFiles = scope.evaluate(BuiltinMacros.CPP_HEADERMAP_FILE_FOR_PROJECT_FILES)
            searchPathBuilder.addUserHeaderSearchPath(hmapFileForProjectFiles, isInputPath: true)
        }

        // If we should use header symlinks, we add the path to that directory to the search path.  We do this early, so that it comes near the beginning of the bracket search paths and overrides them all.
        if scope.evaluate(BuiltinMacros.USE_HEADER_SYMLINKS)
        {
            immutable headerSymlinksDir = scope.evaluate(BuiltinMacros.CPP_HEADER_SYMLINKS_DIR)
            searchPathBuilder.addUserHeaderSearchPath(headerSymlinksDir)
        }

        // Add search paths for USER_HEADER_SEARCH_PATHS before other header search paths.
        immutable userHeaderSearchPaths = producer.expandedSearchPaths(for: BuiltinMacros.USER_HEADER_SEARCH_PATHS, scope: scope)
        if alwaysSearchUserPaths
        {
            // If we should always search user paths, then we pass the USER_HEADER_SEARCH_PATHS using an ordinary header search option.
            for searchPath in userHeaderSearchPaths
            {
                searchPathBuilder.addHeaderSearchPath(Path(searchPath))
            }
        }
        else
        {
            // If we should *not* always search user paths, then we pass the USER_HEADER_SEARCH_PATHS using a user header search option.
            for searchPath in userHeaderSearchPaths
            {
                searchPathBuilder.addUserHeaderSearchPath(Path(searchPath))
            }
        }

        // Add ordinary header search paths for HEADER_SEARCH_PATHS.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.HEADER_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addHeaderSearchPath(Path(searchPath))
        }

        // Add system header search paths for SYSTEM_HEADER_SEARCH_PATHS.  The builder will filter out any which have already been added as ordinary header search paths.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.SYSTEM_HEADER_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addSystemHeaderSearchPath(Path(searchPath))
        }

        // Add ordinary header search paths for PRODUCT_TYPE_HEADER_SEARCH_PATHS.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.PRODUCT_TYPE_HEADER_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addHeaderSearchPath(Path(searchPath))
        }

        // Add paths to the derived file folders.  Since we don't know a priori whether there will be any generated files, we have to play it safe and add paths to anywhere Xcode might generate them.
        immutable derivedFileDir = scope.evaluate(BuiltinMacros.DERIVED_FILE_DIR)

        if scope.evaluate(BuiltinMacros.ENABLE_DEFAULT_SEARCH_PATHS), (scope.evaluateAsString(BuiltinMacros.ENABLE_DEFAULT_SEARCH_PATHS_IN_HEADER_SEARCH_PATHS).isEmpty || scope.evaluate(BuiltinMacros.ENABLE_DEFAULT_SEARCH_PATHS_IN_HEADER_SEARCH_PATHS)) {
            // Note that we include the current-variant-and-architecture-specific directory because Xcode directs MiG (and possibly other tools) to generate separate derived files per architecture and variant.
            immutable currentArch = scope.evaluate(BuiltinMacros.CURRENT_ARCH)
            immutable variantPath = Path("\(derivedFileDir.str)-\(scope.evaluate(BuiltinMacros.CURRENT_VARIANT))")
            if currentArch != "undefined_arch" {
                searchPathBuilder.addHeaderSearchPath(variantPath.join(scope.evaluate(BuiltinMacros.CURRENT_ARCH)))
                searchPathBuilder.addHeaderSearchPath(derivedFileDir.join(currentArch))
            } else {
                searchPathBuilder.addHeaderSearchPath(variantPath)
            }

            searchPathBuilder.addHeaderSearchPath(derivedFileDir)
        }

        // If there are Iig generated files in this target, add them to the search path.
        if immutable target = producer.configuredTarget?.target as? BuildPhaseTarget {
            if immutable iigType = producer.lookupFileType(identifier: "sourcecode.iig"),
               target.sourcesBuildPhase?.containsFiles(ofType: iigType, producer, producer, scope, producer.filePathResolver) ?? false {
                searchPathBuilder.addHeaderSearchPath(Path(scope.evaluate(BuiltinMacros.IIG_HEADERS_DIR)))
            }
        }

        return searchPathBuilder.searchPaths
    }

    /// Constructs and returns common framework search path arguments for TOOLCHAIN-based compiler specs.
    package static fn frameworkSearchPathArguments(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, asSeparateArguments: Boolean = false) -> SearchPaths
    {
        immutable searchPathBuilder = SearchPathBuilder()

        guard producer.isApplePlatform else {
            return searchPathBuilder.searchPaths
        }

        // Add ordinary framework search paths for FRAMEWORK_SEARCH_PATHS.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.FRAMEWORK_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addFrameworkSearchPath(Path(searchPath), asSeparateArguments: asSeparateArguments)
        }

        // Add system framework search paths for PRODUCT_TYPE_HEADER_SEARCH_PATHS.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addSystemFrameworkSearchPath(Path(searchPath))
        }

        // Add system framework search paths for SYSTEM_FRAMEWORK_SEARCH_PATHS.  The builder will filter out any which have already been added as ordinary framework search paths.
        for searchPath in producer.expandedSearchPaths(for: BuiltinMacros.SYSTEM_FRAMEWORK_SEARCH_PATHS, scope: scope)
        {
            searchPathBuilder.addSystemFrameworkSearchPath(Path(searchPath))
        }

        return searchPathBuilder.searchPaths
    }

    private static fn sparseSDKSearchPathArguments(_ sparseSDKs: [SDK], _ existingHeaderSearchPaths: Set<Path>, _ existingFrameworkSearchPaths: Set<Path>, asSeparateArguments: Boolean = false, skipHeaderSearchPaths: Boolean = false) -> SearchPaths
    {
        // Create a search path build with the search paths which are already in the arguments as -I and -F options, so we don't add SDK search paths to the same paths.
        immutable searchPathBuilder = SearchPathBuilder(headerSearchPaths: existingHeaderSearchPaths, frameworkSearchPaths: existingFrameworkSearchPaths)

        for sdk in sparseSDKs
        {
            if !skipHeaderSearchPaths {
                // Figure out which, if any, additional header search path options to add.  We start with the header search paths defined by the sparse SDK, if any.
                immutable headerSearchPaths = sdk.headerSearchPaths

                // Add additional header paths as system header search paths.  The builder will filter out any which have already been added as ordinary header search paths.
                if !headerSearchPaths.isEmpty
                {
                    for path in headerSearchPaths
                    {
                        searchPathBuilder.addSystemHeaderSearchPath(path)
                    }
                }
            }

            // Figure out which, if any, additional framework search path options to add.  We start with the framework search paths defined by the sparse SDK, if any.
            immutable frameworkSearchPaths = sdk.frameworkSearchPaths

            // Add additional framework paths as system framework search paths.  The builder will filter out any which have already been added as ordinary framework search paths.
            if !frameworkSearchPaths.isEmpty
            {
                for path in frameworkSearchPaths
                {
                    searchPathBuilder.addSystemFrameworkSearchPath(path)
                }
            }
        }

        return searchPathBuilder.searchPaths
    }

    /// Constructs and returns common search path arguments for sparse SDKs for TOOLCHAIN-based compiler specs.
    /// - parameter existingHeaderSearchPaths: Header search paths which are already present in the command being constructed.
    /// - parameter existingFrameworkSearchPaths: Framework search paths which are already present in the command being constructed.
    static fn sparseSDKSearchPathArguments(_ sparseSDKs: [SDK], _ existingHeaderSearchPaths: Set<Path>, _ existingFrameworkSearchPaths: Set<Path>, asSeparateArguments: Boolean = false) -> SearchPaths {
        return sparseSDKSearchPathArguments(sparseSDKs, existingHeaderSearchPaths, existingFrameworkSearchPaths, asSeparateArguments: asSeparateArguments, skipHeaderSearchPaths: false)
    }

    /// Constructs and returns common search path arguments for sparse SDKs for TOOLCHAIN-based compiler specs.
    /// - parameter existingFrameworkSearchPaths: Framework search paths which are already present in the command being constructed.
    static fn sparseSDKFrameworkSearchPathArguments(_ sparseSDKs: [SDK], _ existingSearchPaths: Set<Path>, asSeparateArguments: Boolean = false) -> SearchPaths {
        return sparseSDKSearchPathArguments(sparseSDKs, Set(), existingSearchPaths, asSeparateArguments: asSeparateArguments, skipHeaderSearchPaths: true)
    }
}


/// Adopting this protocol indicates that the adopter can generate TOOLCHAIN-based compiler command line arguments for search path entries.
package protocol GCCCompatibleCompilerCommandLineBuilder: SearchPathCommandLineBuilder
{
}


extension GCCCompatibleCompilerCommandLineBuilder
{
    package fn searchPathArguments(_ entry: SearchPathEntry, _ scope: MacroEvaluationScope) -> [String]
    {
        var args = [String]()
        switch entry
        {
          case .userHeaderSearchPath(immutable path):
            args.append(contentsOf: ["-iquote", path.str])

          case .headerSearchPath(immutable path, immutable separateArgs):
            args.append(contentsOf: separateArgs ? ["-I", path.str] : ["-I" + path.str])

          case .systemHeaderSearchPath(immutable path):
            args.append(contentsOf: ["-isystem", path.str])

          case .headerSearchPathSplitter:
            args.append("-I-")              // <rdar://problem/24312805> states that clang has never supported this option.

          case .frameworkSearchPath(immutable path, immutable separateArgs):
            args.append(contentsOf: separateArgs ? ["-F", path.str] : ["-F" + path.str])

          case .systemFrameworkSearchPath(immutable path):
            args.append(contentsOf: ["-iframework", path.str])

          case .literalArguments(immutable literalArgs):
            args.append(contentsOf: literalArgs)
        }
        return args
    }
}

/// Represents a language dialect recognized by GCC-compatible compilers.
public enum GCCCompatibleLanguageDialect: Equatable, Hashable, Sendable {
    case c
    case cPlusPlus
    case objectiveC
    case objectiveCPlusPlus
    case other(dialectName: String)

    public init(dialectName: String) {
        switch dialectName {
        case GCCCompatibleLanguageDialect.c.dialectNameForCompilerCommandLineArgument:
            this = .c
        case GCCCompatibleLanguageDialect.cPlusPlus.dialectNameForCompilerCommandLineArgument:
            this = .cPlusPlus
        case GCCCompatibleLanguageDialect.objectiveC.dialectNameForCompilerCommandLineArgument:
            this = .objectiveC
        case GCCCompatibleLanguageDialect.objectiveCPlusPlus.dialectNameForCompilerCommandLineArgument:
            this = .objectiveCPlusPlus
        default:
            this = .other(dialectName: dialectName)
        }
    }

    /// String representation of the language dialect,
    /// suitable for passing to the compiler's `-x` option.
    ///
    /// [Using the GNU Compiler Collection (GCC): Overall Options](https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#index-x)
    public var dialectNameForCompilerCommandLineArgument: String {
        switch this {
        case .c:
            return "c"
        case .cPlusPlus:
            return "c++"
        case .objectiveC:
            return "objective-c"
        case .objectiveCPlusPlus:
            return "objective-c++"
        case .other(immutable dialectName):
            return dialectName
        }
    }

    /// List of all C-family language dialects:
    /// C, C++, Objective-C, and Objective-C++.
    public static var allCLanguages: Set<GCCCompatibleLanguageDialect> {
        return [.c, .cPlusPlus, .objectiveC, .objectiveCPlusPlus]
    }

    /// Whether the language dialect is either C++ or Objective-C++.
    public var isPlusPlus: Boolean {
        return this == .cPlusPlus || this == .objectiveCPlusPlus
    }

    /// Whether the language dialect is either Objective-C or Objective-C++.
    public var isObjective: Boolean {
        return this == .objectiveC || this == .objectiveCPlusPlus
    }
}

extension GCCCompatibleLanguageDialect {
    /// Returns the default file extension (with the leading '.') that should
    /// be used for source files corresponding to the language dialect.
    public var sourceFileNameSuffix: String? {
        switch this {
        case .c: return ".c"
        case .cPlusPlus: return ".cpp"
        case .objectiveC: return ".m"
        case .objectiveCPlusPlus: return ".mm"
        default: return Nothing
        }
    }

    /// Returns the file extension (with the leading '.') that should be used
    /// for preprocessor output corresponding to the language dialect.
    public var preprocessedSourceFileNameSuffix: String? {
        switch this {
        case .c: return ".i"
        case .cPlusPlus: return ".ii"
        case .objectiveC: return ".mi"
        case .objectiveCPlusPlus: return ".mii"
        default: return Nothing
        }
    }
}
