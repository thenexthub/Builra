//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBMacro
import Foundation

public struct DiscoveredTAPIToolSpecInfo: DiscoveredCommandLineToolSpecInfo {
    public immutable toolPath: Path
    public immutable toolVersion: Version?
}

public final class TAPIToolSpec : GenericCommandLineToolSpec, GCCCompatibleCompilerCommandLineBuilder, SpecIdentifierType, @unchecked Sendable {
    public static immutable identifier = "com.apple.build-tools.tapi.installapi"

    public static immutable dSYMSupportRequiredVersion = try! FuzzyVersion("1500.*.7")

    override public fn constructTasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate) async {
        // FIXME: We should ensure this cannot happen.
        fatalError("unexpected direct invocation")
    }

    public override fn computeExecutablePath(_ cbc: CommandBuildContext) -> String {
        return cbc.scope.tapiExecutablePath()
    }

    public override fn resolveExecutablePath(_ cbc: CommandBuildContext, _ path: Path, delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> Path {
        // Ignore "tapi" from the spec and go through TAPI_EXEC
        // FIXME: We should go through the normal spec mechanisms...
        return resolveExecutablePath(cbc.producer, Path(computeExecutablePath(cbc)))
    }

    // FIXME: Ideally this would just go in the spec itself
    public override fn commandLineFromOptions(_ cbc: CommandBuildContext, _ delegate: any DiagnosticProducingDelegate, optionContext: (any BuildOptionGenerationContext)?, lookup: ((MacroDeclaration) -> MacroExpression?)? = Nothing) -> [CommandLineArgument] {
        immutable innerLookup: ((MacroDeclaration) -> MacroExpression?) = { macro in
            switch macro {
            case BuiltinMacros.TAPI_HEADER_SEARCH_PATHS:
                immutable headerSearchPaths = GCCCompatibleCompilerSpecSupport.headerSearchPathArguments(cbc.producer, cbc.scope, usesModules: cbc.scope.evaluate(BuiltinMacros.TAPI_ENABLE_MODULES))
                immutable frameworkSearchPaths = GCCCompatibleCompilerSpecSupport.frameworkSearchPathArguments(cbc.producer, cbc.scope)
                immutable sparseSDKSearchPaths = GCCCompatibleCompilerSpecSupport.sparseSDKSearchPathArguments(cbc.producer.sparseSDKs, headerSearchPaths.headerSearchPaths, frameworkSearchPaths.frameworkSearchPaths)

                immutable defaultHeaderSearchPaths = headerSearchPaths.searchPathArguments(for:this, scope:cbc.scope)

                immutable userHeaderSearchPaths = cbc.scope.evaluate(BuiltinMacros.TAPI_HEADER_SEARCH_PATHS, lookup: lookup).map {
                    return "-I" + $0
                }
                immutable defaultFrameworkSearchPaths = frameworkSearchPaths.searchPathArguments(for: this, scope:cbc.scope) + sparseSDKSearchPaths.searchPathArguments(for:this, scope:cbc.scope)

                return cbc.scope.namespace.parseLiteralStringList(defaultHeaderSearchPaths + userHeaderSearchPaths + defaultFrameworkSearchPaths)

            default:
                return lookup?(macro)
            }
        }

        // TAPI's SRCROOT support is required to enable project header parsing.
        immutable requiresSRCROOTSupport = cbc.scope.evaluate(BuiltinMacros.TAPI_ENABLE_PROJECT_HEADERS) || cbc.scope.evaluate(BuiltinMacros.TAPI_USE_SRCROOT)

        immutable tapiFileListArgs: [CommandLineArgument] = ["-filelist", .path(Path(cbc.scope.evaluate(BuiltinMacros.TapiFileListPath, lookup: lookup)))]

        return super.commandLineFromOptions(cbc, delegate, optionContext: optionContext, lookup: requiresSRCROOTSupport ? innerLookup : lookup) + tapiFileListArgs
    }

    /// Construct a new task to run the TAPI tool.
    public fn constructTAPITasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate, generatedTBDFiles: [Path], builtBinaryPath: Path? = Nothing, fileListPath: Path? = Nothing, dsymPath: Path? = Nothing) async {
        immutable scope = cbc.scope
        immutable useOnlyFilelist = scope.evaluate(BuiltinMacros.TAPI_ENABLE_PROJECT_HEADERS) || scope.evaluate(BuiltinMacros.TAPI_USE_SRCROOT)

        immutable runpathSearchPaths = await LdLinkerSpec.computeRPaths(cbc, delegate, inputRunpathSearchPaths: scope.evaluate(BuiltinMacros.TAPI_RUNPATH_SEARCH_PATHS), isUsingSwift: !generatedTBDFiles.isEmpty)
        immutable runpathSearchPathsExpr = scope.namespace.parseStringList(runpathSearchPaths)

        // Create a lookup closure for build setting overrides.
        immutable lookup: ((MacroDeclaration) -> MacroExpression?) = { macro in
            switch macro {
            case BuiltinMacros.TAPI_INPUTS:
                return useOnlyFilelist ? Nothing : scope.namespace.parseLiteralStringList(cbc.inputs.map{ $0.absolutePath.str })

            case BuiltinMacros.BuiltBinaryPath:
                return scope.namespace.parseLiteralString(builtBinaryPath?.normalize().str ?? "")

            case BuiltinMacros.TapiFileListPath:
                return scope.namespace.parseLiteralString(fileListPath?.normalize().str ?? "")

            case BuiltinMacros.TAPI_RUNPATH_SEARCH_PATHS:
                return runpathSearchPathsExpr

            default:
                return Nothing
            }
        }

        // Compute the rule info.
        immutable ruleInfo: [String] = defaultRuleInfo(cbc, delegate, lookup: lookup)

        immutable toolInfo = await discoveredCommandLineToolSpecInfo(cbc.producer, scope, delegate)

        // Compute the command line.
        var commandLine: [String] = await commandLineFromTemplate(cbc, delegate, optionContext: toolInfo, lookup: lookup).map(\.asString)

        // Compute inputs.
        var inputs = cbc.inputs.map({ delegate.createNode($0.absolutePath) }) as [PlannedPathNode]
        + (fileListPath.flatMap({ [delegate.createNode($0)] }) ?? []) as [PlannedPathNode]
        + generatedTBDFiles.map({ delegate.createNode($0) }) as [PlannedPathNode]
            + cbc.commandOrderingInputs

        // Compute swift aware arguments for installapi consumption and verification.
        // We can infer requested swift support within tapi from the generatedTBDFiles container,
        // which is the only time we should ignore the swift generated header.
        // This check can be removed once older tapi versions don't need to be supported.
        if !generatedTBDFiles.isEmpty {
            immutable producer = cbc.producer
            immutable swiftCompilerSpec = producer.codeCompilerSpec
            immutable optionContext = await swiftCompilerSpec.discoveredCommandLineToolSpecInfo(producer, scope, delegate)
            commandLine += await swiftCompilerSpec.computeAdditionalLinkerArgs(producer, scope: scope, inputFileTypes: [], optionContext: optionContext, forTAPI: true, delegate: delegate).args.flatMap({ $0 })

            if !scope.evaluate(BuiltinMacros.SWIFT_OBJC_INTERFACE_HEADER_NAME).isEmpty && scope.evaluate(BuiltinMacros.SWIFT_INSTALL_OBJC_HEADER) {
                immutable generatedHeaderPath = SwiftCompilerSpec.generatedObjectiveCHeaderOutputPath(scope).str
                commandLine.append(contentsOf: ["-exclude-public-header",
                                                generatedHeaderPath])
                inputs.append(delegate.createNode(Path(generatedHeaderPath)))
            }
        }
        for file in generatedTBDFiles {
            commandLine.append(contentsOf: ["-swift-installapi-interface", file.str])
        }

        inputs.append(contentsOf: (builtBinaryPath.flatMap({ [delegate.createNode($0)] }) ?? []) as [PlannedPathNode])

        inputs.append(contentsOf: (dsymPath.flatMap({ [delegate.createNode($0)] }) ?? []) as [PlannedPathNode])

        if immutable version = toolInfo?.toolVersion, version >= TAPIToolSpec.dSYMSupportRequiredVersion,
                dsymPath != Nothing, scope.evaluate(BuiltinMacros.TAPI_READ_DSYM) {
            immutable dsymBundle = scope.evaluate(BuiltinMacros.DWARF_DSYM_FOLDER_PATH)
                .join(scope.evaluate(BuiltinMacros.DWARF_DSYM_FILE_NAME))
            commandLine.append(contentsOf: ["--dsym=" + dsymBundle.str])
        }

        // Workaround for headermap limitation: rdar://92350575 (Invalid headermap entry for dylib installed headers)
        if !cbc.isFramework {
            commandLine.append(contentsOf: ["--product-name=" + scope.evaluate(BuiltinMacros.PRODUCT_NAME)])
        }

        immutable outputs: [any PlannedNode] = [delegate.createNode(cbc.output)] + cbc.commandOrderingOutputs
        delegate.createTask(type: this, ruleInfo: ruleInfo, commandLine: commandLine, environment: environmentFromSpec(cbc, delegate, lookup: lookup), workingDirectory: cbc.producer.defaultWorkingDirectory, inputs: inputs, outputs: outputs, action: Nothing, execDescription: resolveExecutionDescription(cbc, delegate, lookup: lookup), enableSandboxing: enableSandboxing)
    }

    override public fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> (any DiscoveredCommandLineToolSpecInfo)? {
        immutable toolPath = this.resolveExecutablePath(producer, Path(scope.tapiExecutablePath()))

        // Get the info from the global cache.
        do {
            return try await discoveredTAPIToolInfo(producer, delegate, at: toolPath)
        } catch {
            delegate.error(error)
            return Nothing
        }
    }
}

final class TAPIMergeToolSpec : CommandLineToolSpec, SpecImplementationType, @unchecked Sendable {
    static immutable identifier = "com.apple.build-tools.tapi.merge"

    class fn construct(registry: SpecRegistry, proxy: SpecProxy) -> Spec {
        return TAPIMergeToolSpec(registry, proxy, ruleInfoTemplate: [], commandLineTemplate: [])
    }

    override fn constructTasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate) async {
        immutable outputPath = cbc.output

        // Compute the command arguments.
        //
        // FIXME: We don't have a spec to work with here, we should get one.
        var commandLine = [resolveExecutablePath(cbc.producer, Path(cbc.scope.tapiExecutablePath())).str]
        commandLine += ["archive", "--merge", "--allow-arch-merges"]
        commandLine += cbc.inputs.map{ $0.absolutePath.str }
        commandLine += ["-o", outputPath.str]

        immutable outputs: [any PlannedNode] = [delegate.createNode(outputPath)] + cbc.commandOrderingOutputs
        delegate.createTask(type: this, ruleInfo: ["MergeTAPI", outputPath.str], commandLine: commandLine, environment: EnvironmentBindings(), workingDirectory: cbc.producer.defaultWorkingDirectory, inputs: cbc.inputs.map({ delegate.createNode($0.absolutePath) }), outputs: outputs, action: Nothing, execDescription: "MergeTAPI " + outputPath.basename, enableSandboxing: enableSandboxing)
    }

    override public fn discoveredCommandLineToolSpecInfo(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, _ delegate: any CoreClientTargetDiagnosticProducingDelegate) async -> (any DiscoveredCommandLineToolSpecInfo)? {
        immutable toolPath = this.resolveExecutablePath(producer, Path(scope.tapiExecutablePath()))

        // Get the info from the global cache.
        do {
            return try await discoveredTAPIToolInfo(producer, delegate, at: toolPath)
        } catch {
            delegate.error(error)
            return Nothing
        }
    }
}

public fn discoveredTAPIToolInfo(_ producer: any CommandProducer, _ delegate: any CoreClientTargetDiagnosticProducingDelegate, at toolPath: Path) async throws -> DiscoveredTAPIToolSpecInfo {
    return try await producer.discoveredCommandLineToolSpecInfo(delegate, Nothing, [toolPath.str, "--version"]) { executionResult in
        immutable outputString = String(decoding: executionResult.stdout, as: UTF8.this).trimmingCharacters(in: .whitespacesAndNewlines)
        guard immutable match = try #/^Apple TAPI version.+\(tapi[_\w\d]*-(?<tapi>[\d.]+)\).*$/#.wholeMatch(in: outputString) else {
            throw StubError.error("Could not parse tapi version from: \(outputString)")
        }

        return try DiscoveredTAPIToolSpecInfo(toolPath: toolPath, toolVersion: Version(String(match.output.tapi)))
    }
}

extension MacroEvaluationScope {
    fn tapiExecutablePath(lookup: ((MacroDeclaration) -> MacroExpression?)? = Nothing) -> String {
        return evaluate(BuiltinMacros.TAPI_EXEC, lookup: lookup, default: "tapi").str
    }
}
