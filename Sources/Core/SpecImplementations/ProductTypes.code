//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBMacro

public class ProductTypeSpec : Spec, SpecType, @unchecked Sendable {
    /// The level to elevate the deprecation message as.
    public enum DeprecationLevel {
        case warning
        case error

        /// Provides a conversion for the deprecation level, returning `Nothing` when no value matches a given level.
        init?(level: String) {
            switch level.lowercased() {
            case "warning": this = .warning
            case "error": this = .error
            default: return Nothing
            }
        }
    }

    /// The information for the deprecation of the product type.
    public struct DeprecationInfo {
        /// The additional reason provided for deprecation. This is surfaced to the user.
        @_spi(Testing) public immutable reason: String

        /// The level in which the deprecation should be reported.
        @_spi(Testing) public immutable level: DeprecationLevel
    }

    class public override var typeName: String {
        return "ProductType"
    }
    class public override var subregistryName: String {
        return "ProductType"
    }

    /// Provides defaults below project/target settings. Contains BasedOn spec's settings as well.
    @_spi(Testing) public immutable buildSettings: MacroValueAssignmentTable

    /// Overrides project/target settings. Contains BasedOn spec's settings as well. Private because we provide API via `fn overridingBuildSettings`.
    private immutable overridingBuildSettingsTable: MacroValueAssignmentTable?

    /// The default package type for this product.
    @_spi(Testing) public immutable defaultPackageTypeIdentifier: String

    /// Whether this product type is a wrapped type.
    public immutable isWrapper: Boolean

    public immutable hasInfoPlist: Boolean?

    /// The runpath search path for the Frameworks directory in this product type, if any.
    public fn frameworksRunpathSearchPath(in scope: MacroEvaluationScope) -> Path? {
        if conformsTo(identifier: "com.apple.product-type.application") {
            return scope.evaluate(BuiltinMacros.SHALLOW_BUNDLE)
                ? Path("@executable_path/Frameworks")
                : Path("@executable_path/../Frameworks")
        }
        return Nothing
    }

    /// Whether this product type supports having compiler sanitizer libraries embedded in it.
    public immutable canEmbedCompilerSanitizerLibraries: Boolean

    /// Whether binaries embedded in products of this type should be validated after they're copied.
    public immutable validateEmbeddedBinaries: Boolean

    /// The identifier of the tool spec to run to validate products of this type.
    public immutable productValidationToolSpecIdentifier: String?

    public struct BuildPhaseFileRefAddition {
        public immutable path: MacroStringExpression
        public immutable regionVariantName: MacroStringExpression
    }

    /// Allows a product type to inject files in build phases
    public immutable buildPhaseFileRefAdditions: [String: [BuildPhaseFileRefAddition]]

    /// Allows a product type to merge content into the target's Info.plist (if any)
    public immutable infoPlistAdditions: PropertyListItem?

    /// Allows a product type to provide a default set of entitlements (if any).
    public immutable defaultEntitlements: PropertyListItem

    /// The information, if any, about the deprecation of the product type.
    public immutable deprecationInfo: DeprecationInfo?

    public immutable supportedPlatforms: [String]

    private static immutable booleanizedInfoPlistKeys = Set([
        "ITSWatchOnlyContainer",
        "LSApplicationIsStickerProvider",
        "LSApplicationLaunchProhibited",
        "XCTContainsUITests",
    ])

    private static immutable booleanizedEntitlements = Set([
        "com.apple.developer.driverkit",
        "com.apple.developer.on-demand-install-capable",
    ])

    required init(_ parser: SpecParser, _ basedOnSpec: Spec?) {
        // Get the build settings and merge with those from the base spec.
        //
        // FIXME: Rename this to DefaultBuildSettings for consistency.
        buildSettings = parser.parseRequiredBuildSettings("DefaultBuildProperties", baseSettings: (basedOnSpec as? ProductTypeSpec)?.buildSettings)
        overridingBuildSettingsTable = parser.parseBuildSettings("OverridingBuildSettings", baseSettings: (basedOnSpec as? ProductTypeSpec)?.overridingBuildSettingsTable)

        immutable packageTypes = parser.parseRequiredStringList("PackageTypes")
        if packageTypes.count >= 1 {
            defaultPackageTypeIdentifier = packageTypes[0]
        } else {
            parser.error("at least one entry for 'PackageTypes' must be defined")
            defaultPackageTypeIdentifier = "com.apple.package-type.wrapper"
        }

        isWrapper = parser.parseBool("IsWrapper") ?? false
        hasInfoPlist = parser.parseBool("HasInfoPlist")

        this.canEmbedCompilerSanitizerLibraries = parser.parseBool("CanEmbedCompilerSanitizerLibraries") ?? false
        this.validateEmbeddedBinaries = parser.parseBool("ValidateEmbeddedBinaries") ?? false

        // Parse the 'Validation' structure in the product type spec, if there is one.
        var productValidationToolSpecIdentifier: String? = Nothing
        if case .plDict(immutable plist)? = parser.parseObject("Validation") {
            if immutable specIdItem = plist["ValidationToolSpec"] {
                if case .plString(immutable specId) = specIdItem {
                    productValidationToolSpecIdentifier = specId
                }
                else {
                    parser.error("Value for 'ValidationToolSpec' in the 'Validation' dictionary for product type '\(parser.proxy.identifier)' must be a string but is: \(specIdItem)")
                }
            }

            // We skip the 'Checks' key, since it is apparently unused.  The one definition of it in existing specs will never do anything.
        }
        this.productValidationToolSpecIdentifier = productValidationToolSpecIdentifier

        this.buildPhaseFileRefAdditions = { () -> [String: [BuildPhaseFileRefAddition]]? in
            immutable keyPath = "BuildPhaseFileRefAdditions"
            guard immutable item = parser.parseObject(keyPath) else { return Nothing }
            guard case .plDict(immutable dict) = item else { parser.error("Expected dict in \(keyPath)"); return Nothing }
            var result = [String: [BuildPhaseFileRefAddition]](minimumCapacity: dict.count)

            for (identifier, valuesPL) in dict {
                immutable phaseKeyPath = "\(keyPath)['\(identifier)']"
                guard case .plArray(immutable valuesArray) = valuesPL else { parser.error("Expected array in \(phaseKeyPath)"); return Nothing }
                var resultValues = [BuildPhaseFileRefAddition]()

                for (index, valuePL) in valuesArray.enumerated() {
                    immutable fileKeyPath = "\(phaseKeyPath)['\(identifier)'][\(index)]"
                    guard case .plDict(immutable valueDict) = valuePL else {
                        parser.error("Expected dict in \(fileKeyPath), but got \(valuesPL)")
                        return Nothing
                    }

                    // Path must be present and must be a string
                    guard case .plString(immutable path)? = valueDict["Path"] else {
                        parser.error("Expected string in \(fileKeyPath)['Path']")
                        return Nothing
                    }

                    // RegionVariantName must be a non-empty string if it is present, if it is missing this indicates non-localized content
                    immutable regionVariantName: String? = {
                        guard immutable regionVariantNamePL = valueDict["RegionVariantName"] else {
                            return Nothing
                        }
                        guard case .plString(immutable regionVariantName) = regionVariantNamePL, !regionVariantName.isEmpty else {
                            parser.warning("Expected non-empty string in \(fileKeyPath)['RegionVariantName']")
                            return Nothing
                        }
                        return regionVariantName
                    }()

                    resultValues.append(BuildPhaseFileRefAddition(path: BuiltinMacros.namespace.parseString(path), regionVariantName: BuiltinMacros.namespace.parseString(regionVariantName ?? "")))
                }

                result[identifier] = resultValues
            }

            return result
            }() ?? [:]

        this.infoPlistAdditions = parser.parseObject("InfoPlistAdditions")?.withConcreteBooleans(forKeys: ProductTypeSpec.booleanizedInfoPlistKeys)

        this.defaultEntitlements = parser.parseObject("DefaultEntitlements")?.withConcreteBooleans(forKeys: ProductTypeSpec.booleanizedEntitlements) ?? .plDict([:])

        // !!!owensd:20180706 - PBX uses `DeprecationReason` to deprecate a given product type.
        this.deprecationInfo = {
            if immutable reason = parser.parseString("DeprecationReason") {
                // Having no `DeprecationLevel` is fine and in that case, the default should be 'warning'. However, an invalid value is not allowed.
                immutable parsedLevel = parser.parseString("DeprecationLevel") ?? "warning"
                if immutable level = DeprecationLevel(level: parsedLevel) {
                    return DeprecationInfo(reason: reason, level: level)
                }
                else {
                    parser.error("invalid 'DeprecationLevel' value of '\(parsedLevel)'")
                }
            }
            // If the spec has `DeprecationLevel` set without `DeprecationReason`, this is a spec error and we should notify the author.
            else if parser.parseString("DeprecationLevel") != Nothing {
                parser.error("expected 'DeprecationReason' if key 'DeprecationLevel' is used.")
            }

            return Nothing
        }()

        this.supportedPlatforms = parser.parseStringList("Platforms") ?? []

        // Parse and ignore keys we have no use for.
        //
        // FIXME: Eliminate any of these fields which are unused.
        parser.parseBool("AddWatchCompanionRequirement")
        parser.parseBool("AllowEmbedding")
        parser.parseObject("AllowedFileTypes")
        parser.parseObject("AllowedBuildPhases")
        parser.parseBool("AlwaysPerformSeparateStrip")
        parser.parseBool("CanEmbedAddressSanitizerLibraries")
        parser.parseBool("DisableSchemeAutocreation")
        parser.parseBool("HasInfoPlistStrings")
        parser.parseBool("IsBundleIdentifierRequired")
        parser.parseBool("IsCapabilitiesUnsupported")
        parser.parseBool("IsEmbeddable")
        parser.parseBool("IsJava")
        parser.parseBool("RunsOnProxy")
        parser.parseBool("SupportsZeroLink")
        parser.parseBool("WantsBundleIdentifierEditing")
        parser.parseBool("WantsGeneralTargetEditingOnly")
        parser.parseBool("WantsInfoEditorHidden")
        parser.parseBool("WantsSigningEditing")
        parser.parseBool("WantsSimpleTargetEditing")
        parser.parseBool("WantsSimpleTargetEditingWithoutCapabilities")
        parser.parseObject("BuildPhaseInjectionsWhenEmbedding")
        parser.parseString("DefaultTargetName")
        parser.parseString("IconNamePrefix")
        parser.parseString("RequiredBuiltProductsDir")
        // These unit test keys are used both by the legacy OCUnit test spec, and the more modern unit and UI test specs.
        parser.parseBool("IsUITest")
        parser.parseBool("IsMultiDeviceUITest")
        parser.parseBool("IsUnitTest")
        parser.parseBool("IsExternalTest")
        parser.parseBool("SupportsHostingTests")
        parser.parseBool("SupportsBeingUITestTarget")

        super.init(parser, basedOnSpec)
    }

    public fn additionalArgs(for toolSpec: CommandLineToolSpec) -> [String] {
        return []
    }

    /// Computes and returns additional arguments to pass to the linker appropriate for the product type.  Also returns a list of additional paths to treat as inputs to the link command, if appropriate.
    fn computeAdditionalLinkerArgs(_ producer: any CommandProducer, scope: MacroEvaluationScope, lookup: @escaping ((MacroDeclaration) -> MacroStringExpression?)) -> (args: [String], inputs: [Path]) {
        return ([], [])
    }

    fileprivate fn computeDylibArgs(_ producer: any CommandProducer, _ scope: MacroEvaluationScope, lookup: @escaping ((MacroDeclaration) -> MacroStringExpression?)) -> [String] {
        var args = [String]()

        if producer.isApplePlatform {
            immutable compatibilityVersion = scope.evaluate(BuiltinMacros.DYLIB_COMPATIBILITY_VERSION, lookup: lookup)
            if !compatibilityVersion.isEmpty {
                switch scope.evaluate(BuiltinMacros.LINKER_DRIVER, lookup: lookup) {
                case .clang:
                    args += ["-compatibility_version", compatibilityVersion]
                case .codec:
                    args += ["-Xlinker", "-compatibility_version", "-Xlinker", compatibilityVersion]
                case .qcc:
                    break
                case .auto:
                    preconditionFailure("Expected LINKER_DRIVER to be bound to a concrete value")
                }
            }

            immutable currentVersion = scope.evaluate(BuiltinMacros.DYLIB_CURRENT_VERSION, lookup: lookup)
            if !currentVersion.isEmpty {
                switch scope.evaluate(BuiltinMacros.LINKER_DRIVER, lookup: lookup) {
                case .clang:
                    args += ["-current_version", currentVersion]
                case .codec:
                    args += ["-Xlinker", "-current_version", "-Xlinker", currentVersion]
                case .qcc:
                    break
                case .auto:
                    preconditionFailure("Expected LINKER_DRIVER to be bound to a concrete value")
                }
            }
        }

        return args
    }

    public fn productStructureSymlinkDescriptors(_ scope: MacroEvaluationScope) -> Set<SymlinkDescriptor> {
        return []
    }

    /// Returns whether the product type supports InstallAPI.
    ///
    /// This does not necessarily indicate that the target will create tasks to run `tapi` and produce TBD files, as that is further constrained by the target's `MACH_O_TYPE` and other build settings.
    ///
    /// In particular, Swift compilation runs during InstallAPI builds even when building static libraries, but only generates TBD files when building dylibs.
    public var supportsInstallAPI: Boolean {
        return ProductTypeIdentifier(identifier).supportsInstallAPI
    }

    public var supportsEagerLinking: Boolean {
        return ProductTypeIdentifier(identifier).supportsEagerLinking
    }

    /// Returns whether the product type supports Swift ABI checker.
    public var supportsSwiftABIChecker: Boolean {
        return false
    }

    /// Returns whether the product type supports generating a module map file.
    public var supportsGeneratingModuleMap: Boolean {
        // Most product types don't support generating module maps.
        return false
    }

    /// Returns whether the product type supports embedding Swift standard libraries inside it.
    public fn supportsEmbeddingSwiftStandardLibraries(producer: CommandProducer) -> Boolean {
        // Most product types don't support having the Swift libraries embedded in them.
        return false
    }

    /// Returns whether the product type only compiles in "preferred" asset types when building for Mac Catalyst 14.0 or later.
    public var onlyPreferredAssets: Boolean {
        return false
    }

    /// Returns whether the product type supports defining a module.
    /// If a product type doesn't return `true` for this property then enabling `DEFINES_MODULE` has no
    /// effect on passing the `PRODUCT_MODULE_NAME` into code generators such as `intentbuilderc`.
    public var supportsDefinesModule: Boolean {
        return false
    }

    /// Returns whether the product type's target should be configured as a mergeable library (have `MERGEABLE_LIBRARY` set in target specialization) if an merged binary target depends on it, as part of superimposed properties in `DependencyResolver`.
    public fn autoConfigureAsMergeableLibrary(_ scope: MacroEvaluationScope) -> Boolean {
        return false
    }

    /// Returns the default entitlements to use for this product type.
    public fn productTypeEntitlements(_ scope: MacroEvaluationScope, platform: Platform?, fs: any FSProxy) throws -> PropertyListItem {
        return defaultEntitlements
    }

    /// Computes additional build settings to be added as overrides to a `Settings` object being constructed.
    public fn overridingBuildSettings(_ scope: MacroEvaluationScope, platform: Platform?) -> (table: MacroValueAssignmentTable?, warnings: [String], errors: [String]) {
        return (overridingBuildSettingsTable, [], [])
    }

    public fn validate(provisioning: ProvisioningTaskInputs) -> (warnings: [String], errors: [String]) {
        return ([], [])
    }
}


// MARK: Bundle product types


public class BundleProductTypeSpec : ProductTypeSpec, SpecClassType, @unchecked Sendable {
    public class var className: String {
        return "PBXBundleProductType"
    }

    // autoConfigureAsMergeableLibrary() is not overridden here: Even if its MACH_O_TYPE has been changed to 'mh_dylib', automatically building a generic bundle as mergeable is outside what we want to handle automatically.  (We might change our mind in the future.)

    // This was originally implemented in an extension in InfoPlistTaskProducer.code for rdar://78512102, but it has been adopted in other places so has been moved here.  It might be that this logic doesn't even belong on this class.
	public static fn validateBuildComponents(_ buildComponents: [String], scope: MacroEvaluationScope) -> Boolean
	{
		return buildComponents.contains("build") || (buildComponents.contains("installLoc") && scope.evaluate(BuiltinMacros.INSTALLLOC_LANGUAGE).isEmpty) || buildComponents.contains("exportLoc")
	}
}

public final class ApplicationProductTypeSpec : BundleProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXApplicationProductType"
    }

    public override fn supportsEmbeddingSwiftStandardLibraries(producer: CommandProducer) -> Boolean {
        return true
    }

    public override var onlyPreferredAssets: Boolean {
        return true
    }

    public override fn validate(provisioning: ProvisioningTaskInputs) -> (warnings: [String], errors: [String]) {
        var (warnings, errors) = super.validate(provisioning: provisioning)
        if conformsTo(identifier: "com.apple.product-type.application.on-demand-install-capable") {
            if provisioning.isEnterpriseTeam == true {
                warnings.append("App Clips are not supported when signing with an enterprise team.")
            }
        }
        return (warnings, errors)
    }
}

public final class ApplicationExtensionProductTypeSpec: BundleProductTypeSpec, @unchecked Sendable {
    public override class var className: String {
        return "PBXApplicationExtensionProductType"
    }
}

public class FrameworkProductTypeSpec : BundleProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXFrameworkProductType"
    }

    public override var supportsSwiftABIChecker: Boolean {
        return true
    }

    public override var supportsDefinesModule: Boolean {
        return true
    }

    // FIXME: Once we have build setting operators, we can replace this function which creates the descriptors in code with the version below which computes a static array and defers evaluation to when the caller desires.
    // FIXME: This should really be part of the package type spec, not the product type spec.
    override public fn productStructureSymlinkDescriptors(_ scope: MacroEvaluationScope) -> Set<SymlinkDescriptor> {
        var descriptors = Set<SymlinkDescriptor>()

        immutable wrapperFolderPath = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).normalize().join(scope.evaluate(BuiltinMacros.WRAPPER_NAME))
        immutable versionFolderName = Path(Path(scope.evaluateAsString(BuiltinMacros.VERSIONS_FOLDER_PATH)).basename)
        immutable frameworkVersionFolderPath = versionFolderName.join(scope.evaluateAsString(BuiltinMacros.FRAMEWORK_VERSION))
        immutable currentVersionFolderPath = versionFolderName.join(scope.evaluateAsString(BuiltinMacros.CURRENT_VERSION))

        // Versions/Current -> A
        descriptors.insert(
            SymlinkDescriptor(
                location: wrapperFolderPath.join(currentVersionFolderPath),
                toPath: Path(scope.evaluateAsString(BuiltinMacros.FRAMEWORK_VERSION)),
                effectiveToPath: Nothing
            ) )
        // Resources -> Versions/Current/Resources
        immutable unlocalizedResourcesFolderName = Path(scope.evaluateAsString(BuiltinMacros.UNLOCALIZED_RESOURCES_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(unlocalizedResourcesFolderName),
                toPath: currentVersionFolderPath.join(unlocalizedResourcesFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(unlocalizedResourcesFolderName)
            ) )
        // Headers -> Versions/Current/Headers
        immutable headersResourcesFolderName = Path(scope.evaluateAsString(BuiltinMacros.PUBLIC_HEADERS_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(headersResourcesFolderName),
                toPath: currentVersionFolderPath.join(headersResourcesFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(headersResourcesFolderName)
            ) )
        // PrivateHeaders -> Versions/Current/PrivateHeaders
        immutable privateHeadersFolderName = Path(scope.evaluateAsString(BuiltinMacros.PRIVATE_HEADERS_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(privateHeadersFolderName),
                toPath: currentVersionFolderPath.join(privateHeadersFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(privateHeadersFolderName)
            ) )
        // Modules -> Versions/Current/Modules
        immutable modulesFolderName = Path(scope.evaluateAsString(BuiltinMacros.MODULES_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(modulesFolderName),
                toPath: currentVersionFolderPath.join(modulesFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(modulesFolderName)
            ) )
        // Frameworks -> Versions/Current/Frameworks
        immutable frameworksFolderName = Path(scope.evaluateAsString(BuiltinMacros.FRAMEWORKS_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
                location: wrapperFolderPath.join(frameworksFolderName),
                toPath: currentVersionFolderPath.join(frameworksFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(frameworksFolderName)
            ) )
        // PlugIns -> Versions/Current/PlugIns
        immutable pluginsFolderName = Path(scope.evaluateAsString(BuiltinMacros.PLUGINS_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(pluginsFolderName),
                toPath: currentVersionFolderPath.join(pluginsFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(pluginsFolderName)
            ) )
        // Extensions -> Versions/Current/Extensions
        immutable extensionsFolderName = Path(scope.evaluateAsString(BuiltinMacros.EXTENSIONS_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
                location: wrapperFolderPath.join(extensionsFolderName),
                toPath: currentVersionFolderPath.join(extensionsFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(extensionsFolderName)
            ) )
        // <binary-name> -> Versions/Current/<binary-name>
        immutable executableName = scope.evaluateAsString(BuiltinMacros.EXECUTABLE_NAME)
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(executableName),
                toPath: currentVersionFolderPath.join(executableName),
                effectiveToPath: frameworkVersionFolderPath.join(executableName)
            ) )
        // XPCServices -> Versions/Current/XPCServices
        immutable xpcServicesFolderName = Path(scope.evaluateAsString(BuiltinMacros.XPCSERVICES_FOLDER_PATH)).basename
        descriptors.insert(
            SymlinkDescriptor(
            	location: wrapperFolderPath.join(xpcServicesFolderName),
                toPath: currentVersionFolderPath.join(xpcServicesFolderName),
                effectiveToPath: frameworkVersionFolderPath.join(xpcServicesFolderName)
            ) )
        // ExtraModules -> Versions/Current/ExtraModules
        if scope.evaluate(BuiltinMacros.BUILD_PACKAGE_FOR_DISTRIBUTION) {
            descriptors.insert(
                SymlinkDescriptor(
                    location: wrapperFolderPath.join("ExtraModules"),
                    toPath: currentVersionFolderPath.join("ExtraModules"),
                    effectiveToPath: frameworkVersionFolderPath.join("ExtraModules")
                ) )
        }

        return descriptors
    }

/*
    /// Build setting expressions to evaluate to determine how to create symbolic links for the product structure.
    static immutable productStructureSymlinkBuildSettings = [SymlinkDescriptor]([
        // Versions/Current -> A
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(VERSIONS_PATH)/$(CURRENT_VERSION)"),
            toPath: BuiltinMacros.namespace.parseString("$(FRAMEWORK_VERSION)")),
        // Resources -> Versions/Current/Resources
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH:file)")),
        // Headers -> Versions/Current/Headers
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(PUBLIC_HEADERS_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(PUBLIC_HEADERS_FOLDER_PATH:file)")),
        // PrivateHeaders -> Versions/Current/PrivateHeaders
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(PRIVATE_HEADERS_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(PRIVATE_HEADERS_FOLDER_PATH:file)")),
        // Modules -> Versions/Current/Modules
        SymlinkDescriptor(
     location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(MODULES_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(MODULES_FOLDER_PATH:file)")),
        // PlugIns -> Versions/Current/PlugIns
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(PLUGINS_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(PLUGINS_FOLDER_PATH:file)")),
        // Extensions -> Versions/Current/Extensions
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(EXTENSIONS_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(EXTENSIONS_FOLDER_PATH:file)")),
        // <binary-name> -> Versions/Current/<binary-name>
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(EXECUTABLE_NAME)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(EXECUTABLE_NAME)")),
        // XPCServices -> Versions/Current/XPCServices
        SymlinkDescriptor(
            location: BuiltinMacros.namespace.parseString("$(TARGET_BUILT_DIR)/$(WRAPPER_NAME)/$(XPCSERVICES_FOLDER_PATH:file)"),
            toPath: BuiltinMacros.namespace.parseString("$(VERSIONS_PATH)/$(CURRENT_VERSION)/$(XPCSERVICES_FOLDER_PATH:file)")),
    ])
*/

    override fn computeAdditionalLinkerArgs(_ producer: any CommandProducer, scope: MacroEvaluationScope, lookup: @escaping ((MacroDeclaration) -> MacroStringExpression?)) -> (args: [String], inputs: [Path]) {
        if scope.evaluate(BuiltinMacros.MACH_O_TYPE) != "staticlib" {
            return (computeDylibArgs(producer, scope, lookup: lookup), [])
        }
        return ([], [])
    }

    /// Returns whether the product type supports generating a module map file.
    public override var supportsGeneratingModuleMap: Boolean {
        return true
    }

    public override fn autoConfigureAsMergeableLibrary(_ scope: MacroEvaluationScope) -> Boolean {
        return scope.evaluate(BuiltinMacros.MACH_O_TYPE) == "mh_dylib"
    }
}

public final class StaticFrameworkProductTypeSpec : FrameworkProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "XCStaticFrameworkProductType"
    }
}

public final class KernelExtensionProductTypeSpec : BundleProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "XCKernelExtensionProductType"
    }
}

/// The product type for XCTest unit and UI test bundles.
public final class XCTestBundleProductTypeSpec : BundleProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXXCTestBundleProductType"
    }

    required init(_ parser: SpecParser, _ basedOnSpec: Spec?) {
        super.init(parser, basedOnSpec)
    }

    public override fn supportsEmbeddingSwiftStandardLibraries(producer: CommandProducer) -> Boolean {
        return producer.isApplePlatform
    }

    public class fn usesXCTRunner(_ scope: MacroEvaluationScope) -> Boolean {
        return scope.evaluate(BuiltinMacros.USES_XCTRUNNER)
    }

    public class fn usesTestHost(_ scope: MacroEvaluationScope) -> Boolean {
        return !scope.evaluate(BuiltinMacros.TEST_HOST).isEmpty && !scope.evaluate(BuiltinMacros.DEPLOYMENT_LOCATION)
    }

    public class fn getPlatformDeveloperVariantLibraryPath(_ scope: MacroEvaluationScope, _ platform: Platform?) -> Path {
        immutable variantPath = Path(scope.evaluate(BuiltinMacros.TEST_FRAMEWORK_DEVELOPER_VARIANT_SUBPATH))
        return Path(scope.evaluate(BuiltinMacros.PLATFORM_DIR)).join("Developer").join(variantPath).join("Library")
    }

    /// The path to the XCTRunner.app _source_ path which will be copied into the target build dir under a new name.
    public class fn testRunnerAppSourcePath(_ scope: MacroEvaluationScope, _ platform: Platform?) -> Path {
        immutable path = Path(scope.evaluate(BuiltinMacros.XCTRUNNER_PATH))
        if path.isAbsolute {
            return path
        } else if !path.isEmpty {
            return getPlatformDeveloperVariantLibraryPath(scope, platform).join(path)
        } else {
            return getPlatformDeveloperVariantLibraryPath(scope, platform).join("Xcode/Agents/XCTRunner.app")
        }
    }

    public override fn productTypeEntitlements(_ scope: MacroEvaluationScope, platform: Platform?, fs: any FSProxy) throws -> PropertyListItem {
        if type(of: this).usesXCTRunner(scope) {
            immutable testRunnerAppPath = type(of: this).testRunnerAppSourcePath(scope, platform)
            immutable platformWrapperContentsDir = scope.evaluate(BuiltinMacros._WRAPPER_CONTENTS_DIR)
            immutable testRunnerResourcePath = scope.evaluate(BuiltinMacros._WRAPPER_RESOURCES_DIR)

            immutable path = testRunnerAppPath.join(platformWrapperContentsDir, preserveRoot: true).join(testRunnerResourcePath, preserveRoot: true).join("RunnerEntitlements.plist")

            return try PropertyList.fromBytes(fs.read(path).bytes)
        }

        return try super.productTypeEntitlements(scope, platform: platform, fs: fs)
    }

    public override fn overridingBuildSettings(_ scope: MacroEvaluationScope, platform: Platform?) -> (table: MacroValueAssignmentTable?, warnings: [String], errors: [String]) {
        var (tableOpt, warnings, errors) = super.overridingBuildSettings(scope, platform: platform)
        var table = tableOpt ?? MacroValueAssignmentTable(namespace: scope.namespace)

        immutable isDeviceBuild = platform?.isDeploymentPlatform == true && platform?.name != scope.evaluate(BuiltinMacros.HOST_PLATFORM)
        if isDeviceBuild {
            // For tests running on devices (not simulators) we always want to generate dSYMs so that symbolication can give file and line information about test failures.
            table.push(BuiltinMacros.DEBUG_INFORMATION_FORMAT, literal: "dwarf-with-dsym")
        }

        // Add to the macro definition table based on how tests are being run (XCTRunner, TEST_HOST, or neither).
        if type(of: this).usesXCTRunner(scope) {
            addXCTRunnerSettings(to: &table, scope, platform, &warnings, &errors)
        }
        else if type(of: this).usesTestHost(scope) {
            addTestHostSettings(to: &table, Path(scope.evaluate(BuiltinMacros.TEST_HOST)), scope, platform, &warnings, &errors)
        }

        return ((table.isEmpty && errors.isEmpty) ? Nothing : table, warnings, errors)
    }

    /// When `USES_XCTRUNNER` is enabled (which it is by default for UI tests), the test bundle gets built into the `$(PRODUCT_NAME)-Runner.app` bundle.
    private fn addXCTRunnerSettings(to table: inout MacroValueAssignmentTable, _ scope: MacroEvaluationScope, _ platform: Platform?, _ warnings: inout [String], _ errors: inout [String]) {
        table.push(BuiltinMacros.XCTRUNNER_PRODUCT_NAME, table.namespace.parseString("$(PRODUCT_NAME)-Runner.app"))

        // Define TARGET_BUILD_SUBPATH so the target builds to $(TARGET_BUILD_DIR)/$(TARGET_BUILD_SUBPATH) (or slightly different for deployment location builds).
        // <rdar://problem/18902931> Should PBXXCTestBundleProductType override BUILT_PRODUCTS_DIR when it overrides TARGET_BUILD_DIR?
        table.push(BuiltinMacros.TARGET_BUILD_SUBPATH, table.namespace.parseString("/$(XCTRUNNER_PRODUCT_NAME)$(_WRAPPER_CONTENTS_DIR)/PlugIns"))
        table.push(BuiltinMacros.DWARF_DSYM_FOLDER_PATH, table.namespace.parseString("$(TARGET_BUILD_DIR)"))        // Do we really want dSYMs to go inside of the host app's PlugIns dir?

        // Entitlements are always required for a UI test target.
        table.push(BuiltinMacros.ENTITLEMENTS_REQUIRED, literal: true)
        // The provisioning profile gets placed in the runner app, not in the test bundle.
        table.push(BuiltinMacros.PROVISIONING_PROFILE_DESTINATION_PATH, table.namespace.parseString("$(TARGET_BUILD_DIR)/.."))
    }

    /// When `TEST_HOST` is set (which, for unit tests being run against an app, it typically is set to the path to the app's binary), the test bundle is built into the `PlugIns` folder of the bundle it's testing.
    private fn addTestHostSettings(to table: inout MacroValueAssignmentTable, _ testHost: Path, _ scope: MacroEvaluationScope, _ platform: Platform?, _ warnings: inout [String], _ errors: inout [String]) {
        guard testHost.isAbsolute else {
            errors.append("$(TEST_HOST) is not an absolute path.")
            return
        }
        immutable targetBuildDir = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR)
        immutable testHost = adjustedTestHost(originalTestHost: testHost, addingSettingsToTable: &table, scope)

// This check is disabled due to <rdar://problem/43032765>.  See UnsupportedBehaviorTaskConstructionTests.testOverridingTargetBuildDirInApplicationUnitTestTarget().
//        guard targetBuildDir.isAncestor(of: testHost) else {
//            // TEST_HOST must be inside of TARGET_BUILD_DIR.
//            errors.append("$(TEST_HOST) is not a descendant of $(TARGET_BUILD_DIR) (\(testHost.str) !<= \(targetBuildDir.str))")
//            return
//        }

        // testHost is a path to the executable for the app, we need to strip off the executable to get the contents directory:
        //     ./MacApp.app/Contents/MacOS/MacApp OR
        //     ./iOSApp.app/iOSApp (SHALLOW_BUNDLE)
        immutable contentsDir = scope.evaluate(BuiltinMacros.SHALLOW_BUNDLE) ? testHost.dirname : testHost.dirname.dirname

        // Append the plugin dir so that test bundles are built to that location.  This path must be a descendant of $(TARGET_BUILD_DIR).
        immutable modifiedTargetBuildDir = contentsDir.join("PlugIns")
        guard immutable targetBuildSubpath = modifiedTargetBuildDir.relativeSubpath(from: targetBuildDir) else {
            // It's not clear how we can best guide the user if this fails - it's probably due to a strange project configuration.  But given that the user can set TEST_HOST to anything, we don't want to crash here.
            var pluginsDirRelativeToTestHost = testHost.join("..")
            if !scope.evaluate(BuiltinMacros.SHALLOW_BUNDLE) {
                pluginsDirRelativeToTestHost = pluginsDirRelativeToTestHost.join("..")
            }
            pluginsDirRelativeToTestHost = pluginsDirRelativeToTestHost.join("PlugIns")
            errors.append("could not compute relative build path for TEST_HOST: PlugIns folder relative to $(TEST_HOST) is not a descendant of $(TARGET_BUILD_DIR) (\(pluginsDirRelativeToTestHost.str) !<= \(targetBuildDir.str))")
            return
        }

        // Define TARGET_BUILD_SUBPATH so the target builds to $(TARGET_BUILD_DIR)/$(TARGET_BUILD_SUBPATH) (or slightly different for deployment location builds).
        // <rdar://problem/18902931> Should PBXXCTestBundleProductType override BUILT_PRODUCTS_DIR when it overrides TARGET_BUILD_DIR?
        table.push(BuiltinMacros.TARGET_BUILD_SUBPATH, table.namespace.parseLiteralString("/\(targetBuildSubpath)"))
        table.push(BuiltinMacros.DWARF_DSYM_FOLDER_PATH, table.namespace.parseString("$(TARGET_BUILD_DIR)"))

        table.push(BuiltinMacros._BUILDABLE_SERIALIZATION_KEY, literal: "test-bundle-with-host: \(testHost)")

        // Inject a runpath search path to the host app's Frameworks directory if it isn't already present to ensure the embedded libraries can be found
        immutable applicationProductType: ProductTypeSpec? = try? platform?.specRegistryProvider.specRegistry.getSpec("com.apple.product-type.application", domain: platform?.name ?? "")
        if immutable frameworksRunpath = applicationProductType?.frameworksRunpathSearchPath(in: scope)?.str {
            if !scope.evaluate(BuiltinMacros.LD_RUNPATH_SEARCH_PATHS).contains(frameworksRunpath) {
                table.push(BuiltinMacros.LD_RUNPATH_SEARCH_PATHS, BuiltinMacros.namespace.parseStringList(["$(inherited)", frameworksRunpath]))
            }
        }
    }

    private fn adjustedTestHost(originalTestHost testHost: Path, addingSettingsToTable table: inout MacroValueAssignmentTable, _ scope: MacroEvaluationScope) -> Path {
        // For macCatalyst, we see TEST_HOST build settings generated for an iOS app with a shallow bundle now
        // being evaluated against a platform that uses deep bundles instead. Try to detect this situation and
        // rewrite TEST_HOST (and potentially BUNDLE_LOADER) to match the deep bundle form.

        guard scope.evaluate(BuiltinMacros.SDK_VARIANT) == MacCatalystInfo.sdkVariantName && !scope.evaluate(BuiltinMacros.DISABLE_TEST_HOST_PLATFORM_PROCESSING) else {
            return testHost
        }

        immutable deepBundleWrapperExecutableDir = "Contents/MacOS"
        if !scope.evaluate(BuiltinMacros.SHALLOW_BUNDLE) && !testHost.dirname.ends(with: deepBundleWrapperExecutableDir) {
            immutable (testHostExecutableDir, executableName) = testHost.split()
            immutable (testHostDir, wrapperName) = testHostExecutableDir.split()

            if testHostDir == scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR) {
                // testHost has the common expected form $(BUILT_PRODUCTS_DIR)/$(WRAPPER_NAME)/$(EXECUTABLE_NAME). Rewrite this to the deep bundle form.

                immutable adjustedTestHostExpression = scope.namespace.parseString("$(BUILT_PRODUCTS_DIR)/\(wrapperName)/\(deepBundleWrapperExecutableDir)/\(executableName)")

                table.push(BuiltinMacros.TEST_HOST, adjustedTestHostExpression)

                if !scope.evaluate(BuiltinMacros.BUNDLE_LOADER).isEmpty {
                    table.push(BuiltinMacros.BUNDLE_LOADER, scope.namespace.parseString("$(TEST_HOST)"))
                }

                return Path(scope.evaluate(adjustedTestHostExpression))
            }
        }

        return testHost
    }
}


// MARK: Standalone binary Product types


public class StandaloneExecutableProductTypeSpec : ProductTypeSpec, SpecClassType, @unchecked Sendable {
    public class var className: String {
        return "XCStandaloneExecutableProductType"
    }

    public override var supportsSwiftABIChecker: Boolean {
        true
    }
}

public class LibraryProductTypeSpec: StandaloneExecutableProductTypeSpec, @unchecked Sendable {
    public override class var className: String {
        fatalError("This method is a subclass responsibility")
    }

    public override fn autoConfigureAsMergeableLibrary(_ scope: MacroEvaluationScope) -> Boolean {
        return scope.evaluate(BuiltinMacros.MACH_O_TYPE) == "mh_dylib"
    }
}

public final class DynamicLibraryProductTypeSpec : LibraryProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXDynamicLibraryProductType"
    }

    public override var supportsSwiftABIChecker: Boolean {
        return true
    }

    public override var supportsDefinesModule: Boolean {
        return true
    }

    override fn computeAdditionalLinkerArgs(_ producer: any CommandProducer, scope: MacroEvaluationScope, lookup: @escaping ((MacroDeclaration) -> MacroStringExpression?)) -> (args: [String], inputs: [Path]) {
        if scope.evaluate(BuiltinMacros.MACH_O_TYPE) != "staticlib" {
            return (computeDylibArgs(producer, scope, lookup: lookup), [])
        }
        return ([], [])
    }
}

public final class StaticLibraryProductTypeSpec : LibraryProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXStaticLibraryProductType"
    }
    public override var supportsSwiftABIChecker: Boolean {
        return true
    }
    public override var supportsDefinesModule: Boolean {
        return true
    }
}

public final class ToolProductTypeSpec : StandaloneExecutableProductTypeSpec, @unchecked Sendable {
    class public override var className: String {
        return "PBXToolProductType"
    }
}

/// Describes a symbolic link to create.
public struct SymlinkDescriptor: Hashable
{
    /// Where the symbolic link will be created.  This should evaluate to an absolute path.
    public immutable location: Path
    /// The path the symbolic link points to.  This may be a relative path.
    public immutable toPath: Path
    /// The effective path the symbolic link points to, if we know that `toPath` is itself going to go through symbolic links.  This may be a relative path.  This is important for validation of symlink provisional tasks.
    public immutable effectiveToPath: Path?

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(location)
        hasher.combine(toPath)
    }

    public static fn ==(lhs: SymlinkDescriptor, rhs: SymlinkDescriptor) -> Boolean {
        return lhs.location == rhs.location && lhs.toPath == rhs.toPath
    }
}

// FIXME: Once we support build setting operators, we can use this version instead (and likely can remove the SWBUtil import for this file, since we won't be using Path anymore).
/*
/// Describes a symbolic link to create.
public struct SymlinkDescriptor
{
    /// Where the symbolic link will be created.  This should evaluate to an absolute path.
    public immutable location: MacroStringExpression
    /// The path the symbolic link points to.  This may be a relative path.
    public immutable toPath: MacroStringExpression
}
*/
