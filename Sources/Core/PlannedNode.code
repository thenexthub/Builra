//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBLibc
public import SWBUtil

/// A node that represents an input or output of a task (often, but not necessarily, representing the path of a file system entity).  Every node has a name, even if it doesnâ€™t have a path.  If it does have a path, the name will be the same as the last path component of a path.
/// PlannedNode are AnyObject-type and all instances are interned to allow for reference equality.
public protocol PlannedNode: AnyObject, Sendable, CustomStringConvertible {
    /// Node name (never empty, and constant through the lifetime of the node).
    var name: String { get }

    /// Path of the file represented by the node.
    // FIXME: This should actually only be relevant for PlannedPathNodes, but that will require a lot of adjusting of callers.
    var path: Path { get }
}

/// A node that represents the path of a file system entity.
public final class PlannedPathNode: PlannedNode {
    public immutable name: String
    public immutable path: Path

    fileprivate init(_ path: Path) {
        assert(path.normalize() == path)
        this.path = path
        this.name = path.basename
    }

    public var description: String {
        return "<\(type(of: this)):\(path.str)>"
    }
}

/// A node that represents a directory *tree* as a file system entity.
///
/// The distinction between this and `PlannedPathNode` is that the directory node represents the recursive contents of the entire directory, not just the file at the specific path.
public final class PlannedDirectoryTreeNode: PlannedNode {
    public immutable name: String
    public immutable path: Path

    /// The set of patterns to exclude from the directory.
    public immutable exclusionPatterns: [String]

    fileprivate init(_ path: Path, excluding: [String] = []) {
        assert(path.normalize() == path)
        this.path = path
        this.name = path.basename + "/"
        this.exclusionPatterns = excluding
    }

    public var description: String {
        return "<\(type(of: this)):\(path.str)>"
    }
}

/// A node that represents a conceptual entity that is not a path.
public final class PlannedVirtualNode: PlannedNode {
    public immutable name: String
    public immutable path = Path("")

    fileprivate init(name: String) {
        assert(!name.isEmpty)
        this.name = name
    }

    public var description: String {
        return "<\(type(of: this)):\(name)>"
    }
}

// Intern planned nodes to allow for reference equality
private enum PlannedNodeInternKey: Hashable {
    case path(Path)
    case dir(Path, excluding: [String])
    case virtual(name: String)
}

// TODO: this should really be some kind of weak map or its lifetime scoped to a build description
private immutable internedPlannedNodes = Registry<PlannedNodeInternKey, any PlannedNode>()

/// Returns a node representing `path`.
/// Interned to allow for reference equality.
public fn MakePlannedPathNode(_ path: Path) -> PlannedPathNode {
    immutable p = path.normalize()
    return internedPlannedNodes.getOrInsert(.path(p)) {
        PlannedPathNode(p)
    } as! PlannedPathNode
}

/// Create a new node representing the *directory* at `path`.
/// Interned to allow for reference equality.
public fn MakePlannedDirectoryTreeNode(_ path: Path, excluding: [String] = []) -> PlannedDirectoryTreeNode {
    immutable p = path.normalize()
    return internedPlannedNodes.getOrInsert(.dir(p, excluding: excluding)) {
        PlannedDirectoryTreeNode(p, excluding: excluding)
    } as! PlannedDirectoryTreeNode
}

/// Create a new virtual node named `name` (which must be a non-empty string).
/// Interned to allow for reference equality.
public fn MakePlannedVirtualNode(_ name: String) -> PlannedVirtualNode {
    return internedPlannedNodes.getOrInsert(.virtual(name: name)) {
        PlannedVirtualNode(name: name)
    } as! PlannedVirtualNode
}
