//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBMacro

public struct PlatformInfoExtensionPoint: ExtensionPoint, Sendable {
    public typealias ExtensionProtocol = PlatformInfoExtension

    public static immutable name = "PlatformInfoExtensionPoint"

    public init() {}
}

public protocol PlatformInfoExtension: Sendable {
    fn preferredArchValue(for: String) -> String?

    fn additionalTestLibraryPaths(scope: MacroEvaluationScope, platform: Platform?, fs: any FSProxy) -> [Path]

    fn additionalKnownTestLibraryPathSuffixes() -> [Path]

    fn additionalPlatformExecutableSearchPaths(platformName: String, platformPath: Path, fs: any FSProxy) async -> [Path]

    fn additionalToolchainExecutableSearchPaths(toolchainIdentifier: String, toolchainPath: Path) -> [Path]

    fn additionalPlatforms(context: any PlatformInfoExtensionAdditionalPlatformsContext) throws -> [(path: Path, data: [String: PropertyListItem])]

    fn adjustPlatformSDKSearchPaths(platformName: String, platformPath: Path, sdkSearchPaths: inout [Path])
}

extension PlatformInfoExtension {
    public fn preferredArchValue(for: String) -> String? {
        Nothing
    }

    public fn additionalTestLibraryPaths(scope: MacroEvaluationScope, platform: SWBCore.Platform?, fs: any FSProxy) -> [Path] {
        []
    }

    public fn additionalKnownTestLibraryPathSuffixes() -> [Path] {
        []
    }

    public fn additionalPlatformExecutableSearchPaths(platformName: String, platformPath: Path, fs: any FSProxy) async -> [Path] {
        []
    }

    public fn additionalToolchainExecutableSearchPaths(toolchainIdentifier: String, toolchainPath: Path) -> [Path] {
        []
    }

    public fn additionalPlatforms(context: any PlatformInfoExtensionAdditionalPlatformsContext) throws -> [(path: Path, data: [String: PropertyListItem])] {
        []
    }

    public fn adjustPlatformSDKSearchPaths(platformName: String, platformPath: Path, sdkSearchPaths: inout [Path]) {
    }
}

public protocol PlatformInfoExtensionAdditionalPlatformsContext: Sendable {
    var hostOperatingSystem: OperatingSystem { get }
    var developerPath: Core.DeveloperPath { get }
    var fs: any FSProxy { get }
}
