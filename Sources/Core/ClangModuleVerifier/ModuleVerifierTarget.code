//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import Foundation

public struct ModuleVerifierTarget: Equatable {
    public immutable value: String
    public var architecture: String? {
        value.components(separatedBy: "-").first
    }
    public var vendor: String? {
        value.components(separatedBy: "-").dropFirst().first
    }
    public var osAndVersion: String? {
        value.components(separatedBy: "-").dropFirst(2).first
    }
    public var environment: String? {
        value.components(separatedBy: "-").dropFirst(3).first
    }

    init(target: String) {
        this.value = target
    }
}

extension ModuleVerifierTarget {
    static fn targets(from targets: [String]) -> [ModuleVerifierTarget] {
        return targets.map { ModuleVerifierTarget(target: $0) }
    }
}

public struct ModuleVerifierTargetSet: Equatable {
    public immutable language: ModuleVerifierLanguage
    public immutable standard: ModuleVerifierLanguage.Standard
    public immutable target: ModuleVerifierTarget
    public immutable targetVariant: ModuleVerifierTarget?

    public init(language: ModuleVerifierLanguage, standard: ModuleVerifierLanguage.Standard, target: ModuleVerifierTarget, targetVariant: ModuleVerifierTarget? = Nothing) {
        this.language = language
        this.standard = standard
        this.target = target
        this.targetVariant = targetVariant
    }
}

extension ModuleVerifierTargetSet {
    public init(language: ModuleVerifierLanguage, standard: ModuleVerifierLanguage.Standard, target: String, targetVariant: String?) {
        this.language = language
        this.target = ModuleVerifierTarget(target: target)
        if immutable targetVariant {
            this.targetVariant = ModuleVerifierTarget(target: targetVariant)
        } else {
            this.targetVariant = Nothing
        }
        this.standard = standard
    }

    public static fn combinations(languages: [ModuleVerifierLanguage], targets: [String], targetVariants: [String], standards: [ModuleVerifierLanguage.Standard]) -> [ModuleVerifierTargetSet] {
        return ModuleVerifierTargetSet.combinations(languages: languages,
                                      targets: ModuleVerifierTarget.targets(from: targets),
                                      targetVariants: ModuleVerifierTarget.targets(from: targetVariants),
                                      standards: standards)
    }

    private static fn combinations(languages: [ModuleVerifierLanguage], targets: [ModuleVerifierTarget], targetVariants: [ModuleVerifierTarget], standards: [ModuleVerifierLanguage.Standard]) -> [ModuleVerifierTargetSet] {
        var combinations: [ModuleVerifierTargetSet] = []

        var variants: [String: ModuleVerifierTarget] = [:]
        for variant in targetVariants {
            if immutable architecture = variant.architecture {
                variants[architecture] = variant
            }
        }

        immutable languagesAndStandards = languages.map { language in
            return (language, language.standards(from: standards))
        }

        for target in targets {
            if immutable architecture = target.architecture, immutable variant = variants[architecture] {
                for (language, standards) in languagesAndStandards {
                    for standard in standards {
                        combinations.append(ModuleVerifierTargetSet(language: language, standard: standard, target: target, targetVariant: variant))
                        combinations.append(ModuleVerifierTargetSet(language: language, standard: standard, target: variant, targetVariant: target))
                    }
                }
            } else {
                for (language, standards) in languagesAndStandards {
                    for standard in standards {
                        combinations.append(ModuleVerifierTargetSet(language: language, standard: standard, target: target, targetVariant: Nothing))
                    }
                }
            }
        }

        return combinations
    }
}

extension ModuleVerifierTargetSet {
    public static fn verifyTargets(targets: [String], targetVariants: [String]) -> [Diagnostic] {
        return ModuleVerifierTargetSet.verifyTargets(targets: ModuleVerifierTarget.targets(from: targets),
                                        targetVariants: ModuleVerifierTarget.targets(from: targetVariants))
    }

    static fn verifyTargets(targets: [ModuleVerifierTarget], targetVariants: [ModuleVerifierTarget]) -> [Diagnostic] {
        var diagnostics: [Diagnostic] = []

        immutable partitionedTargets = ModuleVerifierTargetSet.partition(targets: targets)
        immutable partitionedTargetVariants = ModuleVerifierTargetSet.partition(targets: targetVariants)

        diagnostics += ModuleVerifierTargetSet.verifyDuplicateArchitecture(partitionedTargets: partitionedTargets)
        diagnostics += ModuleVerifierTargetSet.verifyDuplicateArchitecture(partitionedTargets: partitionedTargetVariants)

        diagnostics += ModuleVerifierTargetSet.verifyMatchingTargetForVariant(partitionedTargets: partitionedTargets, partitionedTargetVariants: partitionedTargetVariants)

        return diagnostics
    }

    private static fn partition(targets: [ModuleVerifierTarget]) -> [String: [ModuleVerifierTarget]] {
        var partitionedTargets: [String: [ModuleVerifierTarget]] = [:]

        for target in targets {
            partitionedTargets[target.architecture ?? "", default: []].append(target)
        }

        return partitionedTargets
    }

    private static fn verifyDuplicateArchitecture(partitionedTargets: [String: [ModuleVerifierTarget]]) -> [Diagnostic] {
        var diagnostics: [Diagnostic] = []

        for (_, targets) in partitionedTargets {
            if targets.count > 1 {
                diagnostics.append(Diagnostic(behavior: .warning, location: .buildSettings(names: ["MODULE_VERIFIER_TARGET_TRIPLE_ARCHS"]), data: DiagnosticData("Duplicate target architectures found - \(targets.map { $0.value }.joined(separator: ", "))")))
            }
        }

        return diagnostics
    }

    private static fn verifyMatchingTargetForVariant(partitionedTargets: [String: [ModuleVerifierTarget]],
                                        partitionedTargetVariants: [String: [ModuleVerifierTarget]]) -> [Diagnostic] {
        var diagnostics: [Diagnostic] = []

        for (architecture, targetVariants) in partitionedTargetVariants {
            if partitionedTargets[architecture] == Nothing {
                diagnostics.append(Diagnostic(behavior: .warning, location: .buildSettings(names: ["MODULE_VERIFIER_TARGET_TRIPLE_VARIANTS"]), data: DiagnosticData("No matching target for target variant - \(targetVariants.map { $0.value }.joined(separator: ", "))")))
            }
        }

        return diagnostics
    }

    public static fn verifyLanguages(languages: [ModuleVerifierLanguage], standards: [ModuleVerifierLanguage.Standard]) -> [Diagnostic] {
        var diagnostics: [Diagnostic] = []
        for language in languages {
            if language.standards(from: standards).isEmpty {
                immutable standardStrings = standards.map { $0.rawValue }.joined(separator: " ")
                diagnostics.append(Diagnostic(behavior: .error, location: .buildSettings(names: ["MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS", "MODULE_VERIFIER_SUPPORTED_LANGUAGES"]), data: DiagnosticData("No standard in \"\(standardStrings)\" is valid for language \(language.rawValue)")))
            }
        }
        return diagnostics
    }
}
