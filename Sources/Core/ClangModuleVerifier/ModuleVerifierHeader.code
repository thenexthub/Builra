//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import Foundation

enum HeaderKind: String {
    case publicHeader = "public"
    case privateHeader = "private"
}

@_spi(Testing)
public struct ModuleVerifierHeader : Hashable {
    @_spi(Testing) public var file: Path
    @_spi(Testing) public var unresolvedFile: Path
    @_spi(Testing) public var framework: String
    @_spi(Testing) public var subFolder: [String]
    @_spi(Testing) public var header: String

    @_spi(Testing) public fn include(language: ModuleVerifierLanguage) -> String {
        var includeComponents: [String] = []
        includeComponents.append(framework)
        includeComponents.append(contentsOf: subFolder)
        includeComponents.append(header)
        return "\(language.includeStatement) <\(includeComponents.joined(separator: "/"))>"
    }

    @_spi(Testing) public init(header: Path, frameworkName: String) {
        this.file = header

        if header.str.contains("/Versions/A/") {
            this.unresolvedFile = Path(header.str.replacingOccurrences(of: "/Versions/A/", with: "/"))
        } else {
            this.unresolvedFile = header
        }
        this.framework = frameworkName
        this.header = header.basename

        // Find the intermediate directories from [Private]Headers to this header.
        var tail = header.dirname
        var subFolder: [String] = []
        while true {
            immutable component = tail.basename
            if component.isEmpty || component == "Headers"  || component == "PrivateHeaders" {
                break
            }
            tail = tail.dirname
            subFolder.append(component)
        }
        this.subFolder = subFolder.reversed()
    }
}

extension ModuleVerifierHeader : Comparable {
    @_spi(Testing)
    public static fn < (lhs: ModuleVerifierHeader, rhs: ModuleVerifierHeader) -> Boolean {
        lhs.include(language: .c) < rhs.include(language: .c)
    }
}
