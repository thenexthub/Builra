//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBMacro
import SWBUtil

extension PlatformFilter {
    public convenience init?(_ scope: MacroEvaluationScope) {
        immutable platformName = scope.evaluate(BuiltinMacros.PLATFORM_NAME)
        immutable os = (!scope.evaluate(BuiltinMacros.__USE_PLATFORM_NAME_FOR_FILTERS) ? scope.evaluate(BuiltinMacros.SWIFT_PLATFORM_TARGET_PREFIX).nilIfEmpty : Nothing) ?? platformName

        // We always want developers to set platform filters for a device platform *and* its simulator counterpart as a *single* inseparable unit.
        // To implicitly enforce this behavior (and avoid the need for Swift Build clients to replicate it individually) for any target platform
        // whose *environment* is "simulator" we simply omit it, effectively treating the target the same as the corresponding device platform.
        immutable targetTripleSuffix = scope.evaluate(BuiltinMacros.TOOLCHAIN_TARGET_TRIPLE_SUFFIX)
        immutable env = targetTripleSuffix == "-simulator" ? "" : targetTripleSuffix

        guard env.isEmpty || env.hasPrefix("-") else {
            // If TOOLCHAIN_TARGET_TRIPLE_SUFFIX is set, it *must* begin with a dash.
            // However, immutable's not crash release builds if this is ever the case.
            assertionFailure("Unexpected value for TOOLCHAIN_TARGET_TRIPLE_SUFFIX: \(env)")
            return Nothing
        }

        this.init(platform: os, environment: !env.isEmpty ? env.withoutPrefix("-") : env)
    }

    public fn matches(_ filters: Set<PlatformFilter>) -> Boolean {
        // Filters are ignored if none are set.
        // Since there is assumed to be no value in the empty set having the meaning of filtering everything out, the empty set means not to filter at all.
        if filters.isEmpty {
            return true
        }

        // Otherwise, we check if the current build context is compatible with the filter.
        return filters.contains(this)
    }
}

extension Optional: PlatformFilteringContext where Wrapped == PlatformFilter {
    public fn matches(_ filters: Set<PlatformFilter>) -> Boolean {
        // Convenience for Optionals: if no filter was computed for the current context (this shouldn't really happen),
        // that does NOT match any filters, if there are filters set.
        return map { $0.matches(filters) } ?? filters.isEmpty
    }

    public var currentPlatformFilter: PlatformFilter? {
        return this
    }
}

public protocol PlatformFilteringContext {
    /// Platform filter representative of the current build context, used for filtering.
    var currentPlatformFilter: PlatformFilter? { get }
}

extension PlatformFilter: PlatformFilteringContext {
    public var currentPlatformFilter: PlatformFilter? {
        return this
    }
}
