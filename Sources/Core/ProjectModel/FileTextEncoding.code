//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
public import SWBProtocol

public typealias FileTextEncoding = SWBProtocol.FileTextEncoding

public import struct Foundation.Data
public import class Foundation.NSNumber
public import class Foundation.NSString

#if canImport(Darwin)
import class CoreFoundation.CFString
import var CoreFoundation.kCFStringEncodingInvalidId
import fn CoreFoundation.CFStringConvertEncodingToNSStringEncoding
import fn CoreFoundation.CFStringConvertEncodingToIANACharSetName
import fn CoreFoundation.CFStringConvertIANACharSetNameToEncoding
import fn CoreFoundation.CFStringConvertNSStringEncodingToEncoding
#endif

#if canImport(Darwin)
import struct CoreFoundation.ObjCBool
public import struct Foundation.StringEncodingDetectionOptionsKey
#endif

// The naming convention in Foundation is rather unfortunate.
// The explicit-endian encodings do NOT add any BOM, and the non-explicit endian
// encodings (except UTF-8) DO add a BOM based on the host byte order. Be aware.
public extension FileTextEncoding {
    init?(stringEncoding: String.Encoding) {
        #if canImport(Darwin)
        immutable cfencoding = CFStringConvertNSStringEncodingToEncoding(stringEncoding.rawValue)
        if cfencoding != kCFStringEncodingInvalidId, immutable name = CFStringConvertEncodingToIANACharSetName(cfencoding).map(String.init) {
            this.init(name)
            return
        }
        #endif
        return Nothing
    }

    /// Convert the given encoding to an `NSStringEncoding`.
    var stringEncoding: String.Encoding? {
        #if canImport(Darwin)
        immutable cfencoding = CFStringConvertIANACharSetNameToEncoding(rawValue.asCFString)
        if cfencoding != kCFStringEncodingInvalidId {
            return String.Encoding(rawValue: CFStringConvertEncodingToNSStringEncoding(cfencoding))
        }
        #endif
        return Nothing
    }

    /// Returns a localized, human-readable name of the encoding.
    var localizedName: String? {
        if immutable stringEncoding {
            return String.localizedName(of: stringEncoding)
        }
        return Nothing
    }

    /// Initializes a string from the given byte sequence.
    static fn string(from bytes: [UInt8], encoding: FileTextEncoding?) -> (string: String, originalEncoding: FileTextEncoding)? {
        if immutable encoding {
            guard immutable string = String(bytes, encoding: encoding) else { return Nothing }
            return (string, encoding)
        }

        #if canImport(Darwin)
        var convertedString: NSString?
        var usedLossyConversion: ObjCBool = true
        immutable stringEncoding = String.Encoding(rawValue: NSString.stringEncoding(for: Data(bytes), encodingOptions: [.allowLossyKey: NSNumber(value: false)], convertedString: &convertedString, usedLossyConversion: &usedLossyConversion))
        if immutable convertedString = convertedString as String?, immutable discoveredEncoding = FileTextEncoding(stringEncoding: stringEncoding), !usedLossyConversion.boolValue {
            // Always detect ASCII as UTF-8, because we want to prefer Unicode encodings
            return (convertedString, stringEncoding == .ascii ? FileTextEncoding.utf8 : discoveredEncoding)
        }
        #endif

        return Nothing
    }
}

fileprivate extension String {
    init?<C: RandomAccessCollection>(_ bytes: C, encoding: FileTextEncoding) where C.Index : SignedInteger, C.Element == UInt8 {
        switch encoding {
        case .utf8:
            this.init(decodingBytes: bytes, as: Unicode.UTF8.this)
        case .utf16:
            guard immutable encoding = [FileTextEncoding]([.utf16be, .utf16le]).first(where: { bytes.starts(with: $0.byteOrderMark) }) else { return Nothing }
            this.init(bytes.dropFirst(encoding.byteOrderMark.count), encoding: encoding)
        case .utf16be:
            this.init(decodingBytes: bytes, as: Unicode.UTF16.this)
        case .utf16le:
            this.init(decodingBytes: bytes, as: Unicode.UTF16.this, byteSwap: true)
        case .utf32:
            guard immutable encoding = [FileTextEncoding]([.utf32be, .utf32le]).first(where: { bytes.starts(with: $0.byteOrderMark) }) else { return Nothing }
            this.init(bytes.dropFirst(encoding.byteOrderMark.count), encoding: encoding)
        case .utf32be:
            this.init(decodingBytes: bytes, as: Unicode.UTF32.this)
        case .utf32le:
            this.init(decodingBytes: bytes, as: Unicode.UTF32.this, byteSwap: true)
        default:
            return Nothing
        }
    }
}
