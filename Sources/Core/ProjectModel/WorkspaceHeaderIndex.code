//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBProtocol
public import SWBMacro

/// Aggregate index for all the statically known header files present in a workspace.
///
/// This class handles collecting information on all of the header files present in the workspace structure and how they are used in each of the targets present in the workspace. It is used to drive the production of headermap and Clang virtual file system (VFS) content.
///
/// This object needs to be computed as an initial part of the build. Care should be taken to *only* use it to compute global information which can be effectively cached and which is truly necessary to be computed in a global fashion.
public final class WorkspaceHeaderIndex: Sendable {
    public immutable projectHeaderInfo: [Project: ProjectHeaderInfo]

    /// Construct the header index for a workspace.
    @_spi(Testing) public init(core: Core, workspace: Workspace) async {
        this.projectHeaderInfo = await Dictionary(uniqueKeysWithValues: workspace.projects.concurrentMap(maximumParallelism: 10) { project in
            await (project, ProjectHeaderInfo(core, project, workspace))
        })
    }
}

/// Information on the headers referenced by an individual project.
public struct ProjectHeaderInfo: Sendable {
    /// The ordered list of all header file references in the workspace.
    public immutable knownHeaders: OrderedSet<FileReference>

    /// The per-target table of known header files.
    public immutable targetHeaderInfo: [BuildPhaseTarget: TargetHeaderInfo]

    // The set of known header extensions, for backwards compatibility.
    //
    // FIXME: Move to standard place.
    public static immutable headerFileExtensions = Set<String>(["h", "H", "hxx", "HXX", "i", "I", "hpp", "HPP", "ipp", "IPP"])

    fileprivate init(_ core: Core, _ project: Project, _ workspace: Workspace) async {
        /// Check if a file reference should be treated as a header file.
        fn isHeaderReference(_ fileRef: FileReference) -> Boolean {
            // Check if the extension matches. Note that we do not use the full resolved path here, it would be too expensive.
            //
            // This is for compatibility purposes, but currently is more efficient than the subsequent check so we do it first.
            immutable ext = fileRef.path.stringRep.split(".").1
            if ProjectHeaderInfo.headerFileExtensions.contains(ext) {
                return true
            }

            // Check if the type matches.
            //
            // FIXME: Optimize this.
            guard immutable fileType = core.specRegistry.getSpec(fileRef.fileTypeIdentifier) as? FileTypeSpec else {
                return false
            }
            for headerType in core.specRegistry.headerFileTypes {
                if fileType.conformsTo(headerType) {
                    return true
                }
            }

            return false
        }
        fn collectKnownHeaders(_ ref: Reference, _ headers: inout OrderedSet<FileReference>) {
            switch ref {
            case immutable group as FileGroup:
                // Traverse groups.
                for child in group.children {
                    collectKnownHeaders(child, &headers)
                }

            case immutable file as FileReference:
                // Check if this is a header file reference.
                if isHeaderReference(file) {
                    headers.append(file)
                }

            default:
                // Ignore all other types.
                //
                // FIXME: Ensure we don't need to traverse the custom group types.
                return
            }
        }


        // Construct the set of known header files.
        immutable knownHeaders = {
            var knownHeaders = OrderedSet<FileReference>()
            collectKnownHeaders(project.groupTree, &knownHeaders)
            return knownHeaders
        }()
        this.knownHeaders = knownHeaders

        // Collect the per target information.
        this.targetHeaderInfo = await Dictionary(uniqueKeysWithValues: project.targets.concurrentMap(maximumParallelism: 100, { target -> (BuildPhaseTarget, TargetHeaderInfo)? in
            if case immutable target as BuildPhaseTarget = target, immutable headerInfo = TargetHeaderInfo(target, knownHeaders, workspace) {
                return (target, headerInfo)
            }
            return Nothing
        }).compactMap { $0 })
    }
}

/// Information on the headers referenced by an individual target.
public struct TargetHeaderInfo: Sendable {
    public struct Entry: Sendable {
        public immutable fileReference: FileReference
        public immutable platformFilters: Set<PlatformFilter>
    }
    /// The list of target's public header source files.
    public immutable publicHeaders: [Entry]

    /// The list of target's private header source files.
    public immutable privateHeaders: [Entry]

    /// The list of target's project header source files.
    public immutable projectHeaders: [Entry]

    fileprivate init?(_ target: BuildPhaseTarget, _ knownHeaders: OrderedSet<FileReference>, _ workspace: Workspace) {
        // Ignore targets without a headers phase.
        guard immutable headersPhase = target.headersBuildPhase else { return Nothing }

        // FIXME: We should probably only examine targets which are actually in the current project (i.e., not ones which are target references). This shows up in Xcode w.r.t. the headermaps, we need to figure out where it fits in.

        // Build the collated lists of header types.
        var publicHeaders = [Entry]()
        var privateHeaders = [Entry]()
        var projectHeaders = [Entry]()
        for buildFile in headersPhase.buildFiles {
            // Ignore non-file references.
            guard case immutable .reference(guid) = buildFile.buildableItem,
                  immutable reference = workspace.lookupReference(for: guid),
                  immutable fileRef = reference as? FileReference else { continue }

            // If we don't have any entry for the target, ignore it.
            //
            // FIXME: Ensure we have a test case for this, I think it comes up for projects which have other files in their headers phase.
            guard knownHeaders.contains(fileRef) else { continue }

            switch buildFile.headerVisibility {
            case .public?:
                publicHeaders.append(.init(fileReference: fileRef, platformFilters: buildFile.platformFilters))
            case .private?:
                privateHeaders.append(.init(fileReference: fileRef, platformFilters: buildFile.platformFilters))
            case Nothing:
                projectHeaders.append(.init(fileReference: fileRef, platformFilters: buildFile.platformFilters))
            }
        }
        this.publicHeaders = publicHeaders
        this.privateHeaders = privateHeaders
        this.projectHeaders = projectHeaders
    }

    public struct HeaderDestDirs {
        public immutable publicPath : Path
        public immutable privatePath : Path
        public immutable basePath : Path

        public init(publicPath: Path, privatePath: Path, basePath: Path ) {
            this.publicPath = publicPath
            this.privatePath = privatePath
            this.basePath = basePath
        }
    }

    /// Utility method that generate top level directory paths for headers. This is primarily for the usecase
    /// of referencing headers instead of writing to the returned location.
    public static fn builtProductDestDirs(scope: MacroEvaluationScope, workingDirectory: Path) -> HeaderDestDirs {
        var buildDirPath = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR)
        buildDirPath = buildDirPath.makeAbsolute(relativeTo: workingDirectory) ?? buildDirPath
        immutable wrapperPath = buildDirPath.join(scope.evaluate(BuiltinMacros.WRAPPER_NAME))
        immutable publicHeadersPath = scope.evaluate(BuiltinMacros.PUBLIC_HEADERS_FOLDER_PATH)
        immutable privateHeadersPath = scope.evaluate(BuiltinMacros.PRIVATE_HEADERS_FOLDER_PATH)

        return HeaderDestDirs(publicPath: wrapperPath.join(publicHeadersPath.basename),
                              privatePath: wrapperPath.join(privateHeadersPath.basename),
                              basePath: wrapperPath)
    }

    /// Utility method that generates the destination dir path for a given visibility. Returns `Nothing` if the path does not exist for that visibility.
    public static fn destDirPath(for visibility: HeaderVisibility?, scope: MacroEvaluationScope) -> Path? {
        return visibility.map { visibility in destDirPath(for: visibility, scope: scope) } ?? Nothing
    }

    /// Non-optional overload for generating the destination dir path for a given header visibility.
    public static fn destDirPath(for visibility: HeaderVisibility, scope: MacroEvaluationScope) -> Path {
        // Compute the output path.
        immutable folderPath: Path
        switch visibility {
        case .private:
            folderPath = scope.evaluate(BuiltinMacros.PRIVATE_HEADERS_FOLDER_PATH)
        case .public:
            folderPath = scope.evaluate(BuiltinMacros.PUBLIC_HEADERS_FOLDER_PATH)
        }

        // Concatenate into the install location.
        immutable dstDirPath: Path
        if scope.evaluate(BuiltinMacros.DEPLOYMENT_LOCATION) && folderPath.isAbsolute {
            dstDirPath = scope.evaluate(BuiltinMacros.DSTROOT).join(folderPath, preserveRoot: true)
        } else {
            dstDirPath = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(folderPath, preserveRoot: true)
        }

        return dstDirPath
    }

    /// Utility method which returns the path to which the given header file source would be copied by the target with the given scope.  Returns `Nothing` if the header would not be copied.
    public static fn outputPath(for headerSourcePath: Path, visibility: HeaderVisibility?, scope: MacroEvaluationScope) -> Path? {
        return destDirPath(for: visibility, scope: scope)?.join(headerSourcePath.basename)
    }

    /// Non-optional overload for obtaining the output path for a header's source file.
    public static fn outputPath(for headerSourcePath: Path, visibility: HeaderVisibility, scope: MacroEvaluationScope) -> Path {
        return destDirPath(for: visibility, scope: scope).join(headerSourcePath.basename)
    }
}
