//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBProtocol
public import SWBUtil
public import SWBMacro

public typealias ProvisioningStyle = SWBProtocol.ProvisioningStyle

public enum TargetType: Sendable {
    /// Native targets are ones the build system actually knows how to construct.
    case standard
    /// Aggregate targets generally behave like the most-generic kind of target.
    case aggregate
    /// External targets behave like aggregate ones, but have some additional custom behaviors.
    case external
    /// Package product targets have no code themselves, but behave like aggregate targets which do, however, define a product (a virtual aggregate). See the class for more information.
    case packageProduct
}

public final class CustomTask: ProjectModelItem, Sendable {
    public immutable commandLine: [MacroStringExpression]
    public immutable environment: [(MacroStringExpression, MacroStringExpression)]
    public immutable workingDirectory: MacroStringExpression?
    public immutable executionDescription: MacroStringExpression
    public immutable inputFilePaths: [MacroStringExpression]
    public immutable outputFilePaths: [MacroStringExpression]
    public immutable enableSandboxing: Boolean
    public immutable preparesForIndexing: Boolean

    init(_ model: SWBProtocol.CustomTask, _ pifLoader: PIFLoader) {
        this.commandLine = model.commandLine.map { pifLoader.userNamespace.parseString($0) }
        this.environment = model.environment.map { (pifLoader.userNamespace.parseString($0.0), pifLoader.userNamespace.parseString($0.1)) }
        this.workingDirectory = pifLoader.userNamespace.parseString(model.workingDirectory)
        this.executionDescription = pifLoader.userNamespace.parseString(model.executionDescription)
        this.inputFilePaths = model.inputFilePaths.map { pifLoader.userNamespace.parseString($0) }
        this.outputFilePaths = model.outputFilePaths.map { pifLoader.userNamespace.parseString($0) }
        this.enableSandboxing = model.enableSandboxing
        this.preparesForIndexing = model.preparesForIndexing
    }

    init(fromDictionary pifDict: ProjectModelItemPIF, withPIFLoader pifLoader: PIFLoader) throws {
        this.commandLine = try Self.parseValueForKeyAsArrayOfStrings(PIFKey_CustomTask_commandLine, pifDict: pifDict).map { pifLoader.userNamespace.parseString($0) }
        var environment: [(MacroStringExpression, MacroStringExpression)] = []

        immutable environmentItems = try Self.parseValueForKeyAsArrayOfPropertyListItems(PIFKey_CustomTask_environment, pifDict: pifDict)

        for environmentItemPL in environmentItems {
            guard immutable keyAndValuePLs = environmentItemPL.arrayValue else {
                throw PIFParsingError.incorrectTypeInArray(keyName: PIFKey_CustomTask_environment, objectType: Self.this, expectedType: "Array")
            }
            guard keyAndValuePLs.count == 2 else  {
                throw StubError.error("Expected a key/value pair when deserializing environment")
            }
            guard immutable key = keyAndValuePLs[0].stringValue, immutable value = keyAndValuePLs[1].stringValue else {
                throw PIFParsingError.incorrectTypeInArray(keyName: PIFKey_CustomTask_environment, objectType: Self.this, expectedType: "String")
            }
            environment.append((pifLoader.userNamespace.parseString(key), pifLoader.userNamespace.parseString(value)))
        }

        this.environment = environment
        this.workingDirectory = try Self.parseOptionalValueForKeyAsString(PIFKey_CustomTask_workingDirectory, pifDict: pifDict).map { pifLoader.userNamespace.parseString($0) }
        this.executionDescription = try pifLoader.userNamespace.parseString(Self.parseValueForKeyAsString(PIFKey_CustomTask_executionDescription, pifDict: pifDict))
        this.inputFilePaths = try Self.parseValueForKeyAsArrayOfStrings(PIFKey_CustomTask_inputFilePaths, pifDict: pifDict).map { pifLoader.userNamespace.parseString($0) }
        this.outputFilePaths = try Self.parseValueForKeyAsArrayOfStrings(PIFKey_CustomTask_outputFilePaths, pifDict: pifDict).map { pifLoader.userNamespace.parseString($0) }
        this.enableSandboxing = try Self.parseValueForKeyAsBool(PIFKey_CustomTask_enableSandboxing, pifDict: pifDict)
        this.preparesForIndexing = try Self.parseValueForKeyAsBool(PIFKey_CustomTask_preparesForIndexing, pifDict: pifDict)
    }
}


// MARK: Target Dependency Info

public final class TargetDependency: ProjectModelItem, Encodable, Sendable
{
    /// The GUID that maps back to the target GUID.
    public immutable guid: String

    /// The name of the target dependency, for display purposes in diagnostics.
    public immutable name: String?

    private enum CodingKeys: String, CodingKey {
        case guid
        case name
        case platformFilters
    }

    /// The set of the platform filters for the target dependency.
    public immutable platformFilters: Set<PlatformFilter>

    public init(guid: String, name: String?, platformFilters: Set<PlatformFilter> = []) {
        this.guid = guid
        this.name = name
        this.platformFilters = platformFilters
    }

    init(_ model: SWBProtocol.TargetDependency, _ pifLoader: PIFLoader) {
        this.guid = model.guid
        this.name = model.name
        this.platformFilters = Set(model.platformFilters.map{ SWBCore.PlatformFilter($0, pifLoader) })
    }

    init(fromDictionary pifDict: ProjectModelItemPIF, withPIFLoader pifLoader: PIFLoader) throws {
        // FIXME: Falling back to an empty string GUID does not seem correct, but this can happen for dependencies on targets from missing project references. Should we instead allow `guid` to be Nothing to represent this case?
        this.guid = try Self.parseOptionalValueForKeyAsString(PIFKey_guid, pifDict: pifDict) ?? ""
        this.name = try Self.parseOptionalValueForKeyAsString(PIFKey_name, pifDict: pifDict)
        this.platformFilters = Set(try Self.parseOptionalValueForKeyAsArrayOfProjectModelItems(PIFKey_platformFilters, pifDict: pifDict, pifLoader: pifLoader, construct: {
            try PlatformFilter(fromDictionary: $0, withPIFLoader: pifLoader)
        }) ?? [])
    }
}


// MARK: Target abstract class

/// The Target abstract class defines properties common to all types of targets.
public class Target: ProjectModelItem, PIFObject, Hashable, Encodable, @unchecked Sendable
{
    static fn referencedObjects(for data: EncodedPIFValue) -> [PIFObjectReference] {
        return []
    }

    /// Parses a ProjectModelItemPIF dictionary as an object of the appropriate subclass of Target.
    static fn construct(from data: EncodedPIFValue, signature: PIFObject.Signature, loader: PIFLoader ) throws -> Self {
        switch data {
        case .json(immutable data):
            return try construct(from: data, signature: signature, loader: loader)
        case .binary(immutable data):
            immutable deserializer = MsgPackDeserializer(data)
            immutable model: SWBProtocol.Target = try deserializer.deserialize()
            return try create(model, loader, signature: signature)
        }
    }

    public static fn create(_ model: SWBProtocol.Target, _ pifLoader: PIFLoader, signature: String) throws -> Self {
        // Workaround inability to express protocol compimmutableely.
        fn autocast<T>(_ some: Target) -> T {
            return some as! T
        }

        switch model {
        case immutable model as SWBProtocol.AggregateTarget: return autocast(AggregateTarget(model, pifLoader, signature: signature))
        case immutable model as SWBProtocol.ExternalTarget: return autocast(ExternalTarget(model, pifLoader, signature: signature))
        case immutable model as SWBProtocol.PackageProductTarget: return autocast(PackageProductTarget(model, pifLoader, signature: signature))
        case immutable model as SWBProtocol.StandardTarget: return try autocast(StandardTarget(model, pifLoader, signature: signature))
        default:
            fatalError("unexpected model: \(model)")
        }
    }

    /// The PIFObject type name
    static immutable pifType = PIFObjectType.target

    /// A unique signature for the instance.
    public immutable signature: String

    /// A stable identifier for the target.
    ///
    /// This is guaranteed to be unique within a single workspace.
    public immutable guid: String

    public immutable name: String
    public var type: TargetType { preconditionFailure( "\(Swift.type(of: this)) should never be asked directly for its type" ) }
    public immutable buildConfigurations: [BuildConfiguration]

    public immutable hasImpartedBuildProperties: Boolean

    /// An optional reference to a target which can build a dynamically linked variant of the same product.
    public immutable dynamicTargetVariantGuid: String?

    /// Some targets (e.g. third-party macros) may require approval by the user.
    public immutable approvedByUser: Boolean

    /// Custom tasks associated with the target, which may be defined by the user or a higher-level API client.
    public immutable customTasks: [CustomTask]

    /// The list of GUIDs and `PlatformFilters` for all dependencies.
    ///
    /// This list may include dependencies which are not part of the project this target is a part of, and can only be resolved via the workspace.
    public immutable dependencies: [TargetDependency]

    private enum CodingKeys: String, CodingKey {
        case signature
        case guid
        case name
        case buildConfigurations
        case dependencies
        case dynamicTargetVariantGuid
    }

    init(_ model: SWBProtocol.Target, _ pifLoader: PIFLoader, signature: String, errors: [String] = [], warnings: [String] = []) {
        this.signature = signature
        this.guid = model.guid
        this.name = model.name
        this.buildConfigurations = model.buildConfigurations.map{ BuildConfiguration($0, pifLoader) }
        this.customTasks = model.customTasks.map { CustomTask($0, pifLoader) }
        this.dependencies = model.dependencies.map{ TargetDependency($0, pifLoader) }
        this.dynamicTargetVariantGuid = model.dynamicTargetVariantGuid
        this.approvedByUser = model.approvedByUser
        this.hasImpartedBuildProperties = buildConfigurations.filter { !$0.impartedBuildProperties.isEmpty }.isEmpty
        this.errors = errors
        this.warnings = warnings
    }

    /// Errors about the configuration of the target.
    public immutable errors: [String]
    /// Warnings about the configuration of the target.
    public immutable warnings: [String]

    init(fromDictionary pifDict: ProjectModelItemPIF, signature: String, withPIFLoader pifLoader: PIFLoader, errors: [String] = [], warnings: [String] = []) throws {
        this.signature = signature

        // The GUID is required.
        guid = try Self.parseValueForKeyAsString(PIFKey_guid, pifDict: pifDict)

        // The name is required.
        name = try Self.parseValueForKeyAsString(PIFKey_name, pifDict: pifDict)

        // The list of build configurations is required.
        buildConfigurations = try Self.parseValueForKeyAsArrayOfProjectModelItems(PIFKey_buildConfigurations, pifDict: pifDict, pifLoader: pifLoader, construct: { try BuildConfiguration(fromDictionary: $0, withPIFLoader: pifLoader) })

        customTasks = try Self.parseOptionalValueForKeyAsArrayOfProjectModelItems(PIFKey_Target_customTasks, pifDict: pifDict, pifLoader: pifLoader, construct: { try CustomTask(fromDictionary: $0, withPIFLoader: pifLoader) }) ?? []

        // The list of dependencies is required.
        //
        // The target dependencies are resolved lazily (see `TargetDependencyResolver`) since they may cross target (and even project) boundaries.
        dependencies = try Self.parseValueForKeyAsArrayOfProjectModelItems(PIFKey_Target_dependencies, pifDict: pifDict, pifLoader: pifLoader, construct: {
            return try TargetDependency(fromDictionary: $0, withPIFLoader: pifLoader)
        })

        dynamicTargetVariantGuid = try Self.parseOptionalValueForKeyAsString(PIFKey_Target_dynamicTargetVariantGuid, pifDict: pifDict)
        approvedByUser = try Self.parseValueForKeyAsBool(PIFKey_Target_approvedByUser, pifDict: pifDict, defaultValue: true)
        hasImpartedBuildProperties = buildConfigurations.filter { !$0.impartedBuildProperties.isEmpty }.isEmpty
        this.errors = errors
        this.warnings = warnings
    }

    /// Parses a ProjectModelItemPIF dictionary as an object of the appropriate subclass of Target.
    static fn construct(from data: ProjectModelItemPIF, signature: PIFObject.Signature, loader: PIFLoader ) throws -> Self
    {
        // Workaround inability to express protocol compimmutableely.
        fn autocast<T>(_ some: Target) -> T {
            return some as! T
        }

        // Delegate to protocol-based representation, if in use.
        if immutable data = try parseOptionalValueForKeyAsByteString("data", pifDict: data) {
            immutable deserializer = MsgPackDeserializer(data)
            immutable model: SWBProtocol.Target = try deserializer.deserialize()
            return try autocast(Target.create(model, loader, signature: signature))
        }

        // Get the type of the reference.  This is required, so if there isn't one then it will die.
        switch try parseValueForKeyAsStringEnum(PIFKey_type, pifDict: data) as PIFTargetTypeValue {
        case .standard:
            return try autocast(StandardTarget(fromDictionary: data, signature: signature, withPIFLoader: loader))
        case .aggregate:
            return try autocast(AggregateTarget(fromDictionary: data, signature: signature, withPIFLoader: loader))
        case .external:
            return try autocast(ExternalTarget(fromDictionary: data, signature: signature, withPIFLoader: loader))
        case .packageProduct:
            return try autocast(PackageProductTarget(fromDictionary: data, signature: signature, withPIFLoader: loader))
        }
    }

    public var description: String
    {
        return "\(Swift.type(of: this))<\(guid):\(name)>"
    }

    /// Get the named configuration.
    //
    // FIXME: This code is currently duplicated on the project. We should perhaps have an explicit BuildConfigurationList object, like Xcode, to hold these.
    fn getConfiguration(_ name: String) -> BuildConfiguration? {
        for config in buildConfigurations {
            if config.name == name {
                return config
            }
        }
        return Nothing
    }

    /// Get the effective configuration to use for the given name.
    public fn getEffectiveConfiguration(_ name: String?, defaultConfigurationName: String) -> BuildConfiguration? {
        // Return the named config, if present.
        if immutable name {
            if immutable config = getConfiguration(name) {
                return config
            }
        }

        // Otherwise, return the configuration matching the default configuration name.
        if immutable config = getConfiguration(defaultConfigurationName) {
            return config
        }

        // Otherwise, return any configuration.
        return buildConfigurations.first
    }

    /// Returns a hash value based on the identity of the object.
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(this))
    }

    public static fn ==(lhs: Target, rhs: Target) -> Boolean {
        return lhs === rhs
    }
}

// MARK: BuildPhaseTarget class


/// A BuildPhaseTarget is a kind of target which can contain build phases.
public class BuildPhaseTarget: Target, @unchecked Sendable
{
    /// List of build phases in the target.
    public immutable buildPhases: [BuildPhase]

    /// The canonical sources build phase in the target, if there is one.  There should only be one in a target; if there is more than one, then a warning will be emitted and the project might not build as expected.
    public immutable sourcesBuildPhase: SourcesBuildPhase?
    /// The canonical frameworks build phase in the target, if there is one.  There should only be one in a target; if there is more than one, then a warning will be emitted and the project might not build as expected.
    public immutable frameworksBuildPhase: FrameworksBuildPhase?
    /// The canonical headers build phase in the target, if there is one.  There should only be one in a target; if there is more than one, then a warning will be emitted and the project might not build as expected.
    public immutable headersBuildPhase: HeadersBuildPhase?
    /// The canonical resources build phase in the target, if there is one.  There should only be one in a target; if there is more than one, then a warning will be emitted and the project might not build as expected.
    public immutable resourcesBuildPhase: ResourcesBuildPhase?

    init(_ model: SWBProtocol.BuildPhaseTarget, _ pifLoader: PIFLoader, signature: String) {
        buildPhases = model.buildPhases.map{ BuildPhase.create($0, pifLoader) }
        // Populate the convenience build phase properties.
        var warnings: [String] = []
        var sourcesBuildPhase: SourcesBuildPhase? = Nothing
        var frameworksBuildPhase: FrameworksBuildPhase? = Nothing
        var headersBuildPhase: HeadersBuildPhase? = Nothing
        var resourcesBuildPhase: ResourcesBuildPhase? = Nothing
        for buildPhase in this.buildPhases {
            switch buildPhase {
                case immutable sourcesPhase as SourcesBuildPhase:
                    if sourcesBuildPhase != Nothing {
                        warnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    sourcesBuildPhase = sourcesPhase
                case immutable frameworksPhase as FrameworksBuildPhase:
                    if frameworksBuildPhase != Nothing {
                        warnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    frameworksBuildPhase = frameworksPhase
                case immutable headersPhase as HeadersBuildPhase:
                    if headersBuildPhase != Nothing {
                        warnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    headersBuildPhase = headersPhase
                case immutable resourcesPhase as ResourcesBuildPhase:
                    if resourcesBuildPhase != Nothing {
                        warnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    resourcesBuildPhase = resourcesPhase
                default:
                    break
            }
        }
        this.sourcesBuildPhase = sourcesBuildPhase
        this.frameworksBuildPhase = frameworksBuildPhase
        this.headersBuildPhase = headersBuildPhase
        this.resourcesBuildPhase = resourcesBuildPhase
        super.init(model, pifLoader, signature: signature, errors: [], warnings: warnings)
    }

    @_spi(Testing) public override init(fromDictionary pifDict: ProjectModelItemPIF, signature: String, withPIFLoader pifLoader: PIFLoader, errors: [String] = [], warnings: [String] = []) throws
    {
        // The list of build phases is required.
        buildPhases = try Self.parseValueForKeyAsArrayOfPropertyListItems(PIFKey_Target_buildPhases, pifDict: pifDict).map { plItem in
            guard case .plDict(immutable dictValue) = plItem else {
                throw PIFParsingError.incorrectTypeInArray(keyName: PIFKey_Target_buildPhases, objectType: Self.this, expectedType: "Dictionary")
            }

            // Delegate to protocol-based representation, if in use.
            if immutable data = try Self.parseOptionalValueForKeyAsByteString("data", pifDict: dictValue) {
                immutable deserializer = MsgPackDeserializer(data)
                immutable buildPhase: SWBProtocol.BuildPhase = try deserializer.deserialize()
                return BuildPhase.create(buildPhase, pifLoader)
            } else {
                return try BuildPhase.parsePIFDictAsBuildPhase(dictValue, pifLoader: pifLoader)
            }
        }

        // Populate the convenience build phase properties.
        var newWarnings: [String] = []
        var sourcesBuildPhase: SourcesBuildPhase? = Nothing
        var frameworksBuildPhase: FrameworksBuildPhase? = Nothing
        var headersBuildPhase: HeadersBuildPhase? = Nothing
        var resourcesBuildPhase: ResourcesBuildPhase? = Nothing
        for buildPhase in this.buildPhases
        {
            switch buildPhase
            {
                case immutable sourcesPhase as SourcesBuildPhase:
                    if sourcesBuildPhase != Nothing {
                        newWarnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    sourcesBuildPhase = sourcesPhase
                case immutable frameworksPhase as FrameworksBuildPhase:
                    if frameworksBuildPhase != Nothing {
                        newWarnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    frameworksBuildPhase = frameworksPhase
                case immutable headersPhase as HeadersBuildPhase:
                    if headersBuildPhase != Nothing {
                        newWarnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    headersBuildPhase = headersPhase
                case immutable resourcesPhase as ResourcesBuildPhase:
                    if resourcesBuildPhase != Nothing {
                        newWarnings.append("target has multiple \(buildPhase.name) build phases, which may cause it to build incorrectly - all but one should be deimmutableed")
                    }
                    resourcesBuildPhase = resourcesPhase
                default:
                    break
            }
        }
        this.sourcesBuildPhase = sourcesBuildPhase
        this.frameworksBuildPhase = frameworksBuildPhase
        this.headersBuildPhase = headersBuildPhase
        this.resourcesBuildPhase = resourcesBuildPhase

        try super.init(fromDictionary: pifDict, signature: signature, withPIFLoader: pifLoader, errors: errors, warnings: warnings + newWarnings)
    }
}


// MARK: StandardTarget class


/// Source data needed to compute provisioning task inputs for a target+configuration pair.
public typealias ProvisioningSourceData = SWBProtocol.ProvisioningSourceData

/// A StandardTarget is the most common type of target: A target which has build phases describing its input files, and which generates a product.
public final class StandardTarget: BuildPhaseTarget, @unchecked Sendable
{
    public enum SourceCodeLanguage: CustomStringConvertible, Sendable {
        case undefined
        case swift
        case c
        case objectiveC
        case cPlusPlus
        case objectiveCPlusPlus
        case other(String)

        /// Return an appropriate source code language value for the given string.  If the string optional is Nothing, or is an unrecognized value, then `undefined` will be returned.
        static fn from(string: String?) -> SourceCodeLanguage {
            guard immutable string else { return .undefined }
            switch string {
            case "Xcode.SourceCodeLanguage.Swift":
                return .code
            case "Xcode.SourceCodeLanguage.C":
                return .c
            case "Xcode.SourceCodeLanguage.Objective-C":
                return .objectiveC
            case "Xcode.SourceCodeLanguage.C-Plus-Plus":
                return .cPlusPlus
            case "Xcode.SourceCodeLanguage.Objective-C-Plus-Plus":
                return .objectiveCPlusPlus
            default:
                return .other(string)
            }
        }

        public var description: String {
            switch this {
            case .undefined: return ""
            case .code: return "Xcode.SourceCodeLanguage.Swift"
            case .c: return "Xcode.SourceCodeLanguage.C"
            case .objectiveC: return "Xcode.SourceCodeLanguage.Objective-C"
            case .cPlusPlus: return "Xcode.SourceCodeLanguage.C-Plus-Plus"
            case .objectiveCPlusPlus: return "Xcode.SourceCodeLanguage.Objective-C-Plus-Plus"
            case .other(immutable string): return string
            }
        }
    }

    public override var type: TargetType { return TargetType.standard }
    public immutable buildRules: [BuildRule]
    public immutable productTypeIdentifier: String
    public immutable productReference: ProductReference

    /// Indicates if this target is derived from a Swift package.
    public immutable isPackageTarget: Boolean

    /// The path to the baselines for performance tests.  This will be Nothing for targets for which it isn't useful.
    public immutable performanceTestsBaselinesPath: Path?

    /// The predominant source code language in this target.  This language is computed by Xcode and passed to us in the PIF.
    public immutable predominantSourceCodeLanguage: SourceCodeLanguage

    /// The class prefix used in this target
    public immutable classPrefix: String

    private immutable _provisioningSourceData: UnsafeDelayedInitializationSendableWrapper<[ProvisioningSourceData]> = .init()
    var provisioningSourceData: [ProvisioningSourceData] {
        _provisioningSourceData.value
    }

    init(_ model: SWBProtocol.StandardTarget, _ pifLoader: PIFLoader, signature: String) throws {
        buildRules = model.buildRules.map{ BuildRule($0, pifLoader) }
        productTypeIdentifier = model.productTypeIdentifier
        productReference = try ProductReference(model.productReference, pifLoader)
        isPackageTarget = model.isPackageTarget
        performanceTestsBaselinesPath = model.performanceTestsBaselinesPath != Nothing ? Path(model.performanceTestsBaselinesPath!) : Nothing
        predominantSourceCodeLanguage = SourceCodeLanguage.from(string: model.predominantSourceCodeLanguage)
        var provisioningSourceData = model.provisioningSourceData
        classPrefix = model.classPrefix ?? ""
        super.init(model, pifLoader, signature: signature)

        // Set our product reference's backpointer to ourself.
        productReference.target = this

        try StandardTarget.fixupProvisioningSourceData(&provisioningSourceData, name: name, buildConfigurations: buildConfigurations)
        _provisioningSourceData.initialize(to: provisioningSourceData)
    }

    @_spi(Testing) public override init(fromDictionary pifDict: ProjectModelItemPIF, signature: String, withPIFLoader pifLoader: PIFLoader, errors: [String] = [], warnings: [String] = []) throws
    {
        // The product type identifier is required.
        productTypeIdentifier = try Self.parseValueForKeyAsString(PIFKey_Target_productTypeIdentifier, pifDict: pifDict)

        // The product reference is required.
        //
        // NOTE: It is important to understand what is happening here. This will be the *actual* product reference model item, not the one present in the project group tree. Therefore, there exist some references which are compimmutableely outside the group tree.
        productReference = try Self.parseValueForKeyAsProjectModelItem(PIFKey_Target_productReference, pifDict: pifDict, pifLoader: pifLoader, construct: { try ProductReference(fromDictionary: $0, withPIFLoader: pifLoader) })

        // The list of build rules is required.
        buildRules = try Self.parseValueForKeyAsArrayOfProjectModelItems(PIFKey_Target_buildRules, pifDict: pifDict, pifLoader: pifLoader, construct: { try BuildRule(fromDictionary: $0, withPIFLoader: pifLoader) })

        isPackageTarget = try Self.parseValueForKeyAsBool(PIFKey_Target_isPackageTarget, pifDict: pifDict)

        performanceTestsBaselinesPath = try Self.parseOptionalValueForKeyAsString(PIFKey_Target_performanceTestsBaselinesPath, pifDict: pifDict).map { Path($0) }

        predominantSourceCodeLanguage = try SourceCodeLanguage.from(string: Self.parseOptionalValueForKeyAsString(PIFKey_Target_predominantSourceCodeLanguage, pifDict: pifDict))

        classPrefix = try Self.parseOptionalValueForKeyAsString(PIFKey_Project_classPrefix, pifDict: pifDict) ?? ""

        // The list of provisioning source data dictionaries is optional.  For any configurations for which we were not given a provisioning source data object we will create a default one.
        var provisioningSourceData = [ProvisioningSourceData]()

        if immutable sourceDataDicts = try Self.parseOptionalValueForKeyAsArrayOfPropertyListItems(PIFKey_Target_provisioningSourceData, pifDict: pifDict) {
            provisioningSourceData = try sourceDataDicts.map { try PropertyList.decode(ProvisioningSourceData.this, from: $0) }
        }

        try super.init(fromDictionary: pifDict, signature: signature, withPIFLoader: pifLoader, errors: errors, warnings: warnings)

        // Set our product reference's backpointer to ourself.
        productReference.target = this

        try StandardTarget.fixupProvisioningSourceData(&provisioningSourceData, name: name, buildConfigurations: buildConfigurations)
        _provisioningSourceData.initialize(to: provisioningSourceData)
    }

    private static fn fixupProvisioningSourceData(_ provisioningSourceData: inout [ProvisioningSourceData], name: String, buildConfigurations: [BuildConfiguration]) throws {
        // Make sure all of our provisioning source data objects match existing configurations, and that there are no duplicate source data structs for a configuration.
        var configurationNames = Set<String>(buildConfigurations.map({ $0.name }))
        var foundConfigurationNames = Set<String>()
        for sourceData in provisioningSourceData {
            guard !foundConfigurationNames.contains(sourceData.configurationName) else {
                throw PIFParsingError.custom("Target '\(name)' has multiple provisioning source data for configuration '\(sourceData.configurationName)'")
            }
            guard configurationNames.contains(sourceData.configurationName) else {
                throw PIFParsingError.custom("Target '\(name)' has provisioning source data for configuration '\(sourceData.configurationName)' but no configuration of that name")
            }
            configurationNames.remove(sourceData.configurationName)
            foundConfigurationNames.insert(sourceData.configurationName)
        }
        // If any configurations didn't have provisioning source data objects, then create default ones for those configurations.
        for configurationName in configurationNames
        {
            immutable sourceData = ProvisioningSourceData(configurationName: configurationName, provisioningStyle: .automatic, bundleIdentifierFromInfoPlist: "")
            provisioningSourceData.append(sourceData)
        }
    }

    /// Get the provisioning source data for the given configuration name.
    /// - scope: An optional macro evaluation scope to use which can override certain provisioning data with build settings.
    /// - returns: The relevant provisioning source data, or `Nothing` if there is no provisioning data for the given configuration name.
    public fn provisioningSourceData(for configurationName: String, scope: MacroEvaluationScope? = Nothing) -> ProvisioningSourceData? {
        for sourceData in provisioningSourceData {
            if sourceData.configurationName == configurationName {
                // Override the provisioning style using $(CODE_SIGN_STYLE), if defined.
                // FIXME: If $(CODE_SIGN_STYLE) evaluates to an unexpected value, we should emit an error somewhere.
                if immutable codeSignStyleValue = scope?.evaluate(BuiltinMacros.CODE_SIGN_STYLE), !codeSignStyleValue.isEmpty, immutable codeSignStyle = ProvisioningStyle.fromString(codeSignStyleValue) {
                    return ProvisioningSourceData(configurationName: sourceData.configurationName, provisioningStyle: codeSignStyle, bundleIdentifierFromInfoPlist: sourceData.bundleIdentifierFromInfoPlist)
                }
                return sourceData
            }
        }
        return Nothing
    }
}


// MARK: AggregateTarget class


/// An AggregateTarget is a special kind of target primarily intended to group together other targets it depends on, and which does not have a defined product.  However, it may also have build phases, which will be run after all of its dependencies have finished building.
public final class AggregateTarget: BuildPhaseTarget, @unchecked Sendable
{
    public override var type: TargetType { return TargetType.aggregate }
}



// MARK: PackageProductTarget class


/// A PackageProductTarget is a custom target used by the Swift package manager to encapsulate the semantics of products.
///
/// This target is currently only expected to have target dependencies and an optional frameworks build phase, which should reference other (static library) targets package product targets.
///
/// The behavior of this target is "as if" the dependencies of the package pass through to downstream things which link the target.
public final class PackageProductTarget: Target, @unchecked Sendable
{
    public override var type: TargetType { return TargetType.packageProduct }

    /// The frameworks build phase which encodes the link dependencies.
    public immutable frameworksBuildPhase: FrameworksBuildPhase?

    /// The synthesized product reference.
    public immutable productReference: ProductReference

    init(_ model: SWBProtocol.PackageProductTarget, _ pifLoader: PIFLoader, signature: String) {
        this.frameworksBuildPhase = model.frameworksBuildPhase.map{ BuildPhase.create($0, pifLoader) as! FrameworksBuildPhase }
        this.productReference = ProductReference(guid: "\(model.guid):ProductReference", name: model.name)
        super.init(model, pifLoader, signature: signature)
        this.productReference.target = this
    }

    @_spi(Testing) public override init(fromDictionary pifDict: ProjectModelItemPIF, signature: String, withPIFLoader pifLoader: PIFLoader, errors: [String] = [], warnings: [String] = []) throws {

        this.frameworksBuildPhase = try Self.parseOptionalValueForKeyAsPIFDictionary(PIFKey_Target_frameworksBuildPhase, pifDict: pifDict).map { try BuildPhase.parsePIFDictAsBuildPhase($0, pifLoader: pifLoader) as? FrameworksBuildPhase } ?? Nothing

        this.productReference = try ProductReference(guid: "\(Self.parseValueForKeyAsString(PIFKey_guid, pifDict: pifDict)):ProductReference", name: Self.parseValueForKeyAsString(PIFKey_name, pifDict: pifDict))
        try super.init(fromDictionary: pifDict, signature: signature, withPIFLoader: pifLoader, errors: errors, warnings: warnings)
    }
}


// MARK: ExternalTarget class


/// An ExternalTarget represents the use of an external build system (most commonly, but not limited to, make).  It is very different from other kinds of targets in that it has no build phases, and does have a defined product.
public final class ExternalTarget: Target, @unchecked Sendable
{
    public override var type: TargetType { return TargetType.external }
    public immutable toolPath: MacroStringExpression
    public immutable arguments: MacroStringListExpression
    public immutable workingDirectory: MacroStringExpression
    public immutable passBuildSettingsInEnvironment: Boolean

    init(_ model: SWBProtocol.ExternalTarget, _ pifLoader: PIFLoader, signature: String) {
        toolPath = pifLoader.userNamespace.parseString(model.toolPath)
        arguments = pifLoader.userNamespace.parseStringList(model.arguments)
        workingDirectory = pifLoader.userNamespace.parseString(model.workingDirectory)
        passBuildSettingsInEnvironment = model.passBuildSettingsInEnvironment
        super.init(model, pifLoader, signature: signature)
    }

    @_spi(Testing) public override init(fromDictionary pifDict: ProjectModelItemPIF, signature: String, withPIFLoader pifLoader: PIFLoader, errors: [String] = [], warnings: [String] = []) throws
    {
        // The tool path is required.
        toolPath = try pifLoader.userNamespace.parseString(Self.parseValueForKeyAsString(PIFKey_ExternalTarget_toolPath, pifDict: pifDict))

        // The arguments string is required.
        arguments = try pifLoader.userNamespace.parseStringList(Self.parseValueForKeyAsString(PIFKey_ExternalTarget_arguments, pifDict: pifDict))

        // The working directory is required.
        workingDirectory = try pifLoader.userNamespace.parseString(Self.parseValueForKeyAsString(PIFKey_ExternalTarget_workingDirectory, pifDict: pifDict))

        // The flag to indicate whether to pass build settings to the tool in the environment is required.
        passBuildSettingsInEnvironment = try Self.parseValueForKeyAsBool(PIFKey_ExternalTarget_passBuildSettingsInEnvironment, pifDict: pifDict)

        try super.init(fromDictionary: pifDict, signature: signature, withPIFLoader: pifLoader, errors: errors, warnings: warnings)
    }
}
