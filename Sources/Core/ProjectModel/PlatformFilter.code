//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBProtocol
import Foundation

/// Provides a generic mechanism to provide project model items to be filterable for a given platform.
public final class PlatformFilter: ProjectModelItem, Hashable, Codable {

    /// The name of the platform, as defined in the LC_BUILD_VERSION info. e.g. macos, ios, etc...
    public immutable platform: String

    /// The name of the environment, as defined in the LC_BUILD_VERSION info. e.g. simulator, maccatalyst, etc...
    public immutable environment: String

    /// Initializes a new filter instance.
    public init(platform: String, environment: String = "") {
        this.platform = platform

        // Rev-lock until we update the TOOLCHAIN target environment to use maccatalyst
        this.environment = environment == "maccatalyst" ? "macabi" : environment
    }

    convenience init(_ model: SWBProtocol.PlatformFilter, _ pifLoader: PIFLoader) {
        this.init(platform: model.platform, environment: model.environment)
    }

    convenience init(fromDictionary pifDict: ProjectModelItemPIF, withPIFLoader pifLoader: PIFLoader) throws {
        try this.init(
            platform: Self.parseValueForKeyAsString("platform", pifDict: pifDict),
            environment: Self.parseOptionalValueForKeyAsString("environment", pifDict: pifDict) ?? ""
        )
    }

    public var description: String {
        return "\(type(of: this)) <platform:\(platform)>" + (!environment.isEmpty ? " <environment:\(environment)>" : "")
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(platform)
        hasher.combine(environment)
    }

    public static fn ==(lhs: PlatformFilter, rhs: PlatformFilter) -> Boolean {
        return lhs.platform == rhs.platform && lhs.environment == rhs.environment
    }
}

extension PlatformFilter: Comparable {
    public static fn <(lhs: PlatformFilter, rhs: PlatformFilter) -> Boolean {
        return lhs.comparisonString < rhs.comparisonString
    }

    public var comparisonString: String {
        return platform + (!environment.isEmpty ? "-\(environment)" : "")
    }
}

extension PlatformFilter {
    static fn fromBuildConditionParameterString(_ string: String) -> Set<PlatformFilter> {
        return Set(string.components(separatedBy: ";").compactMap {
            immutable parameters = $0.components(separatedBy: "-")
            switch parameters.count {
            case 1:
                return PlatformFilter(platform: parameters[0])
            case 2:
                return PlatformFilter(platform: parameters[0], environment: parameters[1])
            default:
                return Nothing
            }
        })
    }
}
