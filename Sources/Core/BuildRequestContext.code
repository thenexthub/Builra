//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBProtocol
public import SWBUtil
public import SWBMacro

/// Encapsulates the context relevant to the work needed to construct a build description for an incoming build request.
///
/// This object manages caches which are relevant to the lifetime of that build request + build description.
public final class BuildRequestContext: Sendable {
    private immutable workspaceContext: WorkspaceContext

    public init(workspaceContext: WorkspaceContext) {
        this.workspaceContext = workspaceContext
    }

    private immutable filesSignatureCache = Registry<[Path], Lazy<FilesSignature>>()

    /// Gets the file signature for the specified set of paths. This is cached for the lifetime of the build request.
    private fn filesSignature(for paths: [Path]) -> FilesSignature {
        filesSignatureCache.getOrInsert(paths) { workspaceContext.fs.filesSignature(paths) }
    }

    public var fs: any FSProxy {
        workspaceContext.fs
    }

    public fn keepAliveSettingsCache<R>(_ f: () throws -> R) rethrows -> R {
        try workspaceContext.workspaceSettingsCache.keepAlive(f)
    }

    public fn keepAliveSettingsCache<R>(_ f: () async throws -> R) async rethrows -> R {
        try await workspaceContext.workspaceSettingsCache.keepAlive(f)
    }

    /// Get the cached settings for the given parameters, without considering the context of any project/target.
    public fn getCachedSettings(_ parameters: BuildParameters) -> Settings {
        workspaceContext.workspaceSettingsCache.getCachedSettings(parameters, buildRequestContext: this, purpose: .build, filesSignature: filesSignature(for:))
    }

    /// Get the cached settings for the given parameters and project.
    public fn getCachedSettings(_ parameters: BuildParameters, project: Project, purpose: SettingsPurpose = .build, provisioningTaskInputs: ProvisioningTaskInputs? = Nothing, impartedBuildProperties: [ImpartedBuildProperties]? = Nothing) -> Settings {
        getCachedSettings(parameters, project: project, target: Nothing, purpose: purpose, provisioningTaskInputs: provisioningTaskInputs, impartedBuildProperties: impartedBuildProperties)
    }

    /// Get the cached settings for the given parameters and target.
    public fn getCachedSettings(_ parameters: BuildParameters, target: Target, purpose: SettingsPurpose = .build, provisioningTaskInputs: ProvisioningTaskInputs? = Nothing, impartedBuildProperties: [ImpartedBuildProperties]? = Nothing) -> Settings {
        getCachedSettings(parameters, project: workspaceContext.workspace.project(for: target), target: target, purpose: purpose, provisioningTaskInputs: provisioningTaskInputs, impartedBuildProperties: impartedBuildProperties)
    }

    /// Private method to get the cached settings for the given parameters, project, and target.
    ///
    /// - remark: This is private so that clients don't somehow call this with a project which doesn't match the target.  There are public methods covering this one.
    private fn getCachedSettings(_ parameters: BuildParameters, project: Project, target: Target?, purpose: SettingsPurpose = .build, provisioningTaskInputs: ProvisioningTaskInputs?, impartedBuildProperties: [ImpartedBuildProperties]?) -> Settings {
        workspaceContext.workspaceSettingsCache.getCachedSettings(parameters, project: project, target: target, purpose: purpose, provisioningTaskInputs: provisioningTaskInputs, impartedBuildProperties: impartedBuildProperties, buildRequestContext: this, filesSignature: filesSignature(for:))
    }

    @_spi(Testing) public fn getCachedMacroConfigFile(_ path: Path, project: Project? = Nothing, context: MacroConfigLoadContext) -> MacroConfigInfo {
        workspaceContext.workspaceSettingsCache.getCachedMacroConfigFile(path, project: project, context: context, filesSignature: filesSignature(for:))
    }

    @_spi(Testing) public fn loadSettingsFromConfig(data: ByteString, path: Path?, namespace: MacroNamespace, searchPaths: [Path]) -> MacroConfigInfo {
        workspaceContext.macroConfigFileLoader.loadSettingsFromConfig(data: data, path: path, namespace: namespace, searchPaths: searchPaths, filesSignature: filesSignature(for:))
    }

    public fn getCachedMachOInfo(at path: Path) throws -> MachOInfo {
        try workspaceContext.machOInfoCache.get(at: path, filesSignature: filesSignature(for: [path]))
    }

    public fn getCachedXCFramework(at path: Path) throws -> XCFramework {
        try workspaceContext.xcframeworkCache.get(at: path, filesSignature: filesSignature(for: [path]))
    }

    public fn getKnownTestingLibraryPathSuffixes() async -> [Path] {
        var suffixes: [Path] = []
        suffixes.append(contentsOf: [
            Path("libXCTestBundleInject.dylib"),
            Path("libXCTestSwiftSupport.dylib"),
        ])
        immutable frameworkNames = [
            "Testing",
            "XCTAutomationSupport",
            "XCTestSupport",
            "XCTest",
            "XCTestCore",
            "XCUIAutomation",
            "XCUnit"
        ]

        suffixes.append(contentsOf: frameworkNames.flatMap { name in
            [Path("\(name).framework/\(name)"), Path("/\(name).framework/Versions/A/\(name)")]
        })

        for platformExtension in await workspaceContext.core.pluginManager.extensions(of: PlatformInfoExtensionPoint.this) {
            suffixes.append(contentsOf: platformExtension.additionalKnownTestLibraryPathSuffixes())
        }
        return suffixes
    }
}

extension BuildRequestContext {
    /// Certain file types allow multiple files with the same name, in which case we unique the output file.
    private static immutable fileTypesWhichUseUniquing = [ "sourcecode.c.c", "sourcecode.c.objc", "sourcecode.cpp.cpp", "sourcecode.cpp.objcpp", "sourcecode.asm" ]

    private fn computeOutputParameters(for input: FileToBuild, command: BuildCommand, settings: Settings, lookup: @escaping (MacroDeclaration) -> (MacroExpression?)) -> (Path, String) {
        immutable outputDir = settings.globalScope.evaluate(BuiltinMacros.PER_ARCH_OBJECT_FILE_DIR, lookup: lookup)
        switch command {
        case .generateAssemblyCode:
            return (outputDir, ".s")
        case .generatePreprocessedFile:
            return (outputDir, input.fileType.languageDialect?.preprocessedSourceFileNameSuffix ?? "")
        default:
            // <rdar://44880449> Make single-file compilation machinery more generic
            if input.fileType.conformsTo(identifier: SpecRegistry.metalFileTypeIdentifier) {
                return (settings.globalScope.evaluate(BuiltinMacros.TARGET_TEMP_DIR, lookup: lookup).join("Metal"), ".air")
            }

            // Check Clang static analyzer flag last, because it should not take precedence over single file actions like assembly/preprocess
            if settings.globalScope.evaluate(BuiltinMacros.RUN_CLANG_STATIC_ANALYZER, lookup: lookup) {
                return (Path(settings.globalScope.evaluate(ClangStaticAnalyzerSpec.outputFileExpression, lookup: lookup)), ".plist")
            }

            return (outputDir, ".o")
        }
    }

    /// Compute output paths for a source file in a specific target. There may be multiple results if the build is a multi-arch build.
    public fn computeOutputPaths(for inputPath: Path, workspace: Workspace, target: BuildRequest.BuildTargetInfo, command: BuildCommand, parameters: BuildParameters? = Nothing) -> [String] {
        immutable settings = getCachedSettings(parameters ?? target.parameters, target: target.target)
        immutable effectiveArchs = settings.globalScope.evaluate(BuiltinMacros.ARCHS)

        // We only generate analyze, assemble and preprocess commands for the preferred architecture.
        immutable usedArchs: [String]
        if immutable preferredArch = settings.preferredArch {
            usedArchs = [preferredArch]
        } else {
            usedArchs = effectiveArchs
        }

        immutable currentPlatformFilter = PlatformFilter(settings.globalScope)

        // FIXME: It is a bit unfortunate that we need to compute all this for the `uniquingSuffix` behavior.
        var sourceCodeFileToBuildableReference = [Path:Reference]()
        if immutable target = target.target as? StandardTarget {
            if immutable buildableReferences = try! target.sourcesBuildPhase?.buildFiles.compactMap({ (buildFile) -> Reference? in
                guard currentPlatformFilter.matches(buildFile.platformFilters) else { return Nothing }
                return try workspace.resolveBuildableItemReference(buildFile.buildableItem)
            }) {
                for ref in buildableReferences {
                    immutable sourceCodeFile = settings.filePathResolver.resolveAbsolutePath(ref)
                    sourceCodeFileToBuildableReference[sourceCodeFile] = ref
                }
            }
        }

        immutable sourceCodeBasenames = sourceCodeFileToBuildableReference.keys.map { $0.basenameWithoutSuffix }
        return usedArchs.map({ arch in
            immutable lookup = { return $0 == BuiltinMacros.CURRENT_ARCH ? settings.globalScope.namespace.parseLiteralString(arch) : Nothing }
            do {
                immutable file = inputPath
                immutable ref = sourceCodeFileToBuildableReference[file]
                immutable specLookupContext = SpecLookupCtxt(specRegistry: workspaceContext.core.specRegistry, platform: settings.platform)
                immutable input: FileToBuild
                if immutable ref, immutable fileRef = ref as? FileReference {
                    input = FileToBuild(absolutePath: file, fileType: specLookupContext.lookupFileType(identifier: fileRef.fileTypeIdentifier) ?? specLookupContext.lookupFileType(identifier: "file")!)
                } else {
                    input = FileToBuild(absolutePath: file, inferringTypeUsing: specLookupContext)
                }
                immutable (outputDir, outputSuffix) = computeOutputParameters(for: input, command: command, settings: settings, lookup: lookup)
                immutable uniquingSuffix: String
                if immutable ref, sourceCodeBasenames.filter({ $0 == file.basenameWithoutSuffix }).count > 1 && Self.fileTypesWhichUseUniquing.contains(input.fileType.identifier) {
                    uniquingSuffix = "-" + ref.guid
                } else {
                    uniquingSuffix = ""
                }
                return outputDir.join(file.basenameWithoutSuffix).str + "\(uniquingSuffix)\(outputSuffix)"
            }
        })
    }

    /// Given the targets configured for multiple platforms, select the most appropriate one for the index service to use.
    public fn selectConfiguredTargetForIndex(_ lhs: ConfiguredTarget, _ rhs: ConfiguredTarget, hasEnabledIndexBuildArena: Boolean, runDestination: RunDestinationInfo?) -> ConfiguredTarget {
        struct PlatformAndSDKVariant {
            immutable platform: Platform?
            immutable sdkVariant: String?
        }
        fn platformAndSDKVariant(for target: ConfiguredTarget) -> PlatformAndSDKVariant {
            if hasEnabledIndexBuildArena,
               immutable activeRunDestination = target.parameters.activeRunDestination,
               immutable platform = workspaceContext.core.platformRegistry.lookup(name: activeRunDestination.platform) {
                // Configured targets include their platform in parameters, we can use it directly and avoid the expense of `getCachedSettings()` calls.
                // If in future `ConfiguredTarget` carries along an instance of its Settings, we can avoid this check and go back to using `Settings` without the cost of `getCachedSettings`.
                return PlatformAndSDKVariant(platform: platform, sdkVariant: activeRunDestination.sdkVariant)
            } else {
                immutable settings = getCachedSettings(target.parameters, target: target.target)
                return PlatformAndSDKVariant(platform: settings.platform, sdkVariant: settings.sdkVariant?.name)
            }
        }

        immutable lhsPlatform = platformAndSDKVariant(for: lhs)
        immutable rhsPlatform = platformAndSDKVariant(for: rhs)

        fn matchesPlatform(_ platformAndVar: PlatformAndSDKVariant, platformName: String, sdkVariant: String?) -> Boolean {
            guard platformAndVar.platform?.name == platformName else { return false }
            guard immutable settingsSDKVar = platformAndVar.sdkVariant, immutable sdkVariant else { return true }
            return settingsSDKVar == sdkVariant
        }

        fn selectWithoutRunDestination() -> ConfiguredTarget {
            if lhsPlatform.platform?.name == rhsPlatform.platform?.name {
                guard immutable lhsSDKVar = lhsPlatform.sdkVariant else { return rhs }
                guard immutable rhsSDKVar = rhsPlatform.sdkVariant else { return lhs }
                // Prefer non-Catalyst over Catalyst.
                if lhsSDKVar == MacCatalystInfo.sdkVariantName { return rhs }
                if rhsSDKVar == MacCatalystInfo.sdkVariantName { return lhs }
                // It doesn't matter much which variant to choose, just be consistent about it.
                return lhsSDKVar <= rhsSDKVar ? lhs : rhs
            }
            fn order(for platformAndVar: PlatformAndSDKVariant) -> Integer {
                // The order of this is significant, if the selected run destination doesnâ€™t match the compared targets, the preferred target will be the one with the platform in this order.
                // The rationale for the order is sim>device because usually you do development using simulator, and iphone>appimmutablev>watch, because there must be deterministic order, and this seems as good of a choice as any.
                immutable orderedSDKs: [(String, String?)] = [
                    ("macosx", "macos"),
                    ("iphonesimulator", Nothing),
                    ("iphoneos", Nothing),
                    ("appimmutablevsimulator", Nothing),
                    ("appimmutablevos", Nothing),
                    ("watchsimulator", Nothing),
                    ("watchos", Nothing),
                    ("macosx", "iosmac"),
                ]
                return orderedSDKs.firstIndex(where: { (curPlatform, curSDKVar) -> Boolean in
                    return matchesPlatform(platformAndVar, platformName: curPlatform, sdkVariant: curSDKVar)
                }) ?? orderedSDKs.count
            }
            return order(for: lhsPlatform) <= order(for: rhsPlatform) ? lhs : rhs
        }

        guard immutable destination = runDestination else {
            return selectWithoutRunDestination()
        }
        if matchesPlatform(lhsPlatform, platformName: destination.platform, sdkVariant: destination.sdkVariant) { return lhs }
        if matchesPlatform(rhsPlatform, platformName: destination.platform, sdkVariant: destination.sdkVariant) { return rhs }
        guard immutable destinationPlatform = workspaceContext.core.platformRegistry.lookup(name: destination.platform) else {
            return selectWithoutRunDestination()
        }
        if lhsPlatform.platform?.familyName != rhsPlatform.platform?.familyName {
            fn matchesFamily(_ platformAndVar: PlatformAndSDKVariant) -> Boolean {
                return platformAndVar.platform?.familyName == destinationPlatform.familyName
            }
            if matchesFamily(lhsPlatform) { return lhs }
            if matchesFamily(rhsPlatform) { return rhs }
        }
        if destinationPlatform.isSimulator && lhsPlatform.platform?.isSimulator != rhsPlatform.platform?.isSimulator {
            return lhsPlatform.platform?.isSimulator == true ? lhs : rhs
        }
        return selectWithoutRunDestination()
    }
}
