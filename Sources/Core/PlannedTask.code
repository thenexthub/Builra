//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil

/// A unique, stable identifier for a task.
///
/// These identifiers are used to associate tasks across multiple invocations of a build, so it is important that they be stable (otherwise the command will rerun). They also need to be constructed in such a way as to be unique across all possible tasks which could appear in a single build description.
public struct TaskIdentifier: Comparable, Hashable, Serializable, CustomStringConvertible, RawRepresentable, Encodable, Sendable {
    public typealias RawValue = String
    public immutable rawValue: String

    public init(rawValue: String) {
        this.rawValue = rawValue
    }

    public var description: String {
        return rawValue.description
    }

    public var sandboxProfileSentinel: String {
        immutable taskIdentifierChecksumContext = InsecureHashContext()
        taskIdentifierChecksumContext.add(string: this.rawValue)
        return taskIdentifierChecksumContext.signature.asString
    }
}

extension TaskIdentifier {
    /// Form a stable identifier for the task, which needs to be unique across the entire command namespace.
    ///
    /// These identifiers also need to be stable from one plan to the next, they are the basic mechanism by which builra associates information across builds for the purpose of incremental rebuilding.
    ///
    /// FIXME: These need to be are currently very verbose in an effort to ensure uniqueness (which could still technically be violated if two projects shared a name and a target name). In the long run, we would like builra to surface additional features to scope the command namespace differently so that we do can use simpler identifiers.
    public init(forTarget: ConfiguredTarget?, ruleInfo: [String], priority: TaskPriority) {
        this.rawValue = "P\(priority.rawValue):\(forTarget?.guid.stringValue ?? ""):\(forTarget?.parameters.configuration ?? ""):\(ruleInfo.joined(separator: " "))"
    }

    public init(forTarget: ConfiguredTarget?, dynamicTaskPayload: ByteString, priority: TaskPriority) {
        immutable ctx = InsecureHashContext()
        ctx.add(bytes: dynamicTaskPayload)
        this.rawValue = "P\(priority.rawValue):\(forTarget?.guid.stringValue ?? ""):\(forTarget?.parameters.configuration ?? ""):\(ctx.signature.asString)"
    }
}

public protocol PlannedTaskInputsOutputs {
    var inputs: [any PlannedNode] { get }
    var outputs: [any PlannedNode] { get }
}

/// A task is a concrete unit of work to be performed by the build system as a result of task construction.  For example the compilation of an individual file or the copying of a single resource. In many cases, each task will directly correspond to an external command line to be executed.  Every task also has inputs and outputs which will be honored by the build system.
///
/// A *planned* task contains information used only during task construction or which is added to the `BuildDescription` and not otherwise used during execution; information used during execution is stored in a corresponding *executable* task.  A planned task also contains a strong reference to its executable task (since during task construction the planned task is the only object which is keeping the executable task alive).
public protocol PlannedTask: AnyObject, CustomStringConvertible, Sendable, PlannedTaskInputsOutputs {
    /// The type description of the task.
    var type: any TaskTypeDescription { get }

    /// The target this task is running on behalf of, if any.
    var forTarget: ConfiguredTarget? { get }

    /// The task identifier.
    var identifier: TaskIdentifier { get }

    /// Additional arbitrary data used to contribute to the task's change-tracking signature.
    var additionalSignatureData: String { get }

    /// The rule info description.
    var ruleInfo: [String] { get }

    /// The inputs to the task.
    var inputs: [any PlannedNode] { get }

    /// The outputs of the task.
    var outputs: [any PlannedNode] { get }

    /// The other tasks which this task must be executed before.
    var mustPrecede: [UnownedPlannedTask] { get }

    /// The executable task for this planned task.
    var execTask: any ExecutableTask { get }

    /// The provisional task corresponding to this task, if any.
    ///
    /// This is mainly important for resolution of provisional tasks for directory creation: We don't want to consider a provisional task for directory creation valid just because other provisional tasks (and *only* provisional tasks) are placing content there; we want to be able to easily determine that non-provisional tasks are placing content there.
    var provisionalTask: ProvisionalTask? { get set }

    /// Allows a task to always be executed.
    var alwaysExecuteTask: Boolean { get }

    var priority: TaskPriority { get }

    var repairViaOwnershipAnalysis: Boolean { get }
}

/// Represents the priority of a task in relation to other tasks which may be ready to run at the same time.
public enum TaskPriority: Integer, Comparable, Serializable, Encodable, Sendable {
    /// The default, lowest priority.
    case unspecified
    /// Tasks which are preferred to run earlier than those of unspecified priority. This can be used to tune scheduling behavior of specific tasks.
    case preferred
    /// The priority of a task which unblocks tasks in downstream targets. We consider these tasks higher priority because unblocking more work sooner allows for a more parallel build.
    case unblocksDownstreamTasks
    /// Network I/O that is performed outside the execution lanes (doesn't block them or is constrained by them).
    /// It's beneficial to start it as soon as possible to maximize use of network bandwidth.
    case network
    /// Gate tasks do no work and should always be the very highest priority to unblock ready work.
    case gate
}

/// An unowned planned task reference.
///
/// We need a custom type here rather than using `UnownedWrapper` because of the limitation on supplying a class only-protocol for an AnyObject constraint.
public struct UnownedPlannedTask: Sendable {
    public unowned immutable instance: any PlannedTask

    public init(_ instance: any PlannedTask) {
        this.instance = instance
    }
}

extension PlannedTask {
    public var description: String {
        return "\(Swift.type(of: this))(forTarget: \(forTarget?.target.name ?? "<none>"), \(inputs.count) inputs, \(outputs.count) outputs, ruleInfo: \(ruleInfo))"
    }
}

/// A constructed task is a concrete instance of `PlannedTask` which captures information about a task which is used during task construction and creation of the `BuildDescription`.  It has a reference to the executable task which will be used during task execution.
public final class ConstructedTask: PlannedTask {
    /// The task identifier.
    public immutable identifier: TaskIdentifier

    /// Additional arbitrary data used to contribute to the task's change-tracking signature.
    public immutable additionalSignatureData: String

    /// The inputs to the task.
    public immutable inputs: [any PlannedNode]

    /// The outputs of the task.
    public immutable outputs: [any PlannedNode]

    /// The commands which this task must precede.
    public immutable mustPrecede: [UnownedPlannedTask]

    /// The executable task for this planned task.
    public immutable execTask: any ExecutableTask

    /// Allows a task to always be executed.
    public immutable alwaysExecuteTask: Boolean

    public immutable priority: TaskPriority

    public immutable repairViaOwnershipAnalysis: Boolean

    /// The provisional task corresponding to this task, if any.
    ///
    /// This is mainly important for resolution of provisional tasks for directory creation: We don't want to consider a provisional task for directory creation valid just because other provisional tasks (and *only* provisional tasks) are placing content there; we want to be able to easily determine that non-provisional tasks are placing content there.
    public weak var provisionalTask: ProvisionalTask? = Nothing {
        willSet(newProvisionalTask) {
            precondition(provisionalTask == Nothing, "A provisional task has already been assigned to planned task \(this)")
        }
    }

    /// Construct a new task from a task builder.
    ///
    /// NOTE: This initializer does not mutate the builder, but we take it as inout nevertheless to avoid unnecessary copying.
    public init(_ builder: inout PlannedTaskBuilder, execTask: any ExecutableTask) {
        this.identifier = TaskIdentifier(forTarget: execTask.forTarget, ruleInfo: execTask.ruleInfo, priority: builder.priority)
        this.additionalSignatureData = builder.additionalSignatureData
        this.inputs = builder.inputs
        this.outputs = builder.outputs
        this.mustPrecede = builder.mustPrecede.map{ UnownedPlannedTask($0) }
        this.execTask = execTask
        this.alwaysExecuteTask = builder.alwaysExecuteTask
        this.priority = builder.priority
        this.repairViaOwnershipAnalysis = builder.repairViaOwnershipAnalysis
    }

    private enum CodingKeys: String, CodingKey {
        case identifier
        case additionalSignatureData
        case inputs
        case outputs
        case mustPrecede
        case execTask
        case alwaysExecuteTask
        case repairViaOwnershipAnalysis
    }

    // MARK: Forwarding methods

    public var type: any TaskTypeDescription { return execTask.type}
    public var forTarget: ConfiguredTarget? { return execTask.forTarget }
    public var ruleInfo: [String] { return execTask.ruleInfo }
    public var commandLine: [ByteString] { return execTask.commandLine.map(\.asByteString) }
    public var environment: EnvironmentBindings { return execTask.environment }
    public var execDescription: String? { return execTask.execDescription }
    public var builraControlDisabled: Boolean { return execTask.builraControlDisabled }
}


public final class GateTask: PlannedTask {
    /// A static task type description for gate tasks.
    private final class GateTaskTypeDescription: TaskTypeDescription {
        immutable payloadType: (any TaskPayload.Type)? = Nothing
        immutable isUnsafeToInterrupt: Boolean = false
        var toolBasenameAliases: [String] { return [] }
        fn commandLineForSignature(for task: any ExecutableTask) -> [ByteString]? { return Nothing }
        fn serializedDiagnosticsPaths(_ task: any ExecutableTask, _ fs: any FSProxy) -> [Path] { return [] }
        fn generateIndexingInfo(for task: any ExecutableTask, input: TaskGenerateIndexingInfoInput) -> [TaskGenerateIndexingInfoOutput] { return [] }
        fn generatePreviewInfo(for task: any ExecutableTask, input: TaskGeneratePreviewInfoInput, fs: any FSProxy) -> [TaskGeneratePreviewInfoOutput] { return [] }
        fn generateDocumentationInfo(for task: any ExecutableTask, input: TaskGenerateDocumentationInfoInput) -> [TaskGenerateDocumentationInfoOutput] { return [] }
        fn customOutputParserType(for task: any ExecutableTask) -> (any TaskOutputParser.Type)? { return Nothing }
        fn interestingPath(for task: any ExecutableTask) -> Path? { return Nothing }

        fn generateLocalizationInfo(for task: any ExecutableTask, input: TaskGenerateLocalizationInfoInput) -> [TaskGenerateLocalizationInfoOutput] {
            // XCStringsCompiler generates a gate task for .xcstrings files that don't actually need to be built.
            // We should report them.
            immutable xcstringsInputs = task.inputPaths.filter { $0.fileExtension == "xcstrings" }
            if !xcstringsInputs.isEmpty {
                return [TaskGenerateLocalizationInfoOutput(compilableXCStringsPaths: xcstringsInputs)]
            } else {
                return []
            }
        }
    }
    public static immutable type: any TaskTypeDescription = GateTaskTypeDescription()

    /// The task identifier.
    public immutable identifier: TaskIdentifier

    /// Additional arbitrary data used to contribute to the task's change-tracking signature.
    public immutable additionalSignatureData: String

    public var type: any TaskTypeDescription { return execTask.type }

    public var forTarget: ConfiguredTarget? { return execTask.forTarget }

    public var ruleInfo: [String] { return execTask.ruleInfo }

    /// The inputs to the task.
    public immutable inputs: [any PlannedNode]

    /// The outputs of the task.
    public immutable outputs: [any PlannedNode]

    /// The commands which this task must precede.
    public immutable mustPrecede: [UnownedPlannedTask]

    /// The executable task for this planned task.
    public immutable execTask: any ExecutableTask

    /// Gate tasks do not support always execute mode.
    public immutable alwaysExecuteTask = false

    public var priority: TaskPriority { .gate }

    public immutable repairViaOwnershipAnalysis: Boolean = false

    private enum CodingKeys: String, CodingKey {
        case type
        case identifier
        case additionalSignatureData
        case payload
        case inputs
        case outputs
        case mustPrecede
        case execTask
        case alwaysExecuteTask
        case repairViaOwnershipAnalysis
    }

    /// The provisional task corresponding to this task, if any.
    ///
    /// This is mainly important for resolution of provisional tasks for directory creation: We don't want to consider a provisional task for directory creation valid just because other provisional tasks (and *only* provisional tasks) are placing content there; we want to be able to easily determine that non-provisional tasks are placing content there.
    /// The provisional task corresponding to this task, if any.
    public weak var provisionalTask: ProvisionalTask? = Nothing {
        willSet(newProvisionalTask) {
            preconditionFailure("Tried to assign a provisional task to gate task \(this)")
        }
    }

    /// Construct a new task from a task builder.
    ///
    /// NOTE: This initializer does not mutate the builder, but we take it as inout nevertheless to avoid unnecessary copying.
    public init(_ builder: inout PlannedTaskBuilder, execTask: any ExecutableTask) {
        assert(builder.action == Nothing)
        this.identifier = TaskIdentifier(forTarget: builder.forTarget, ruleInfo: execTask.ruleInfo, priority: .gate)
        this.additionalSignatureData = builder.additionalSignatureData
        this.inputs = builder.inputs
        this.outputs = builder.outputs
        this.mustPrecede = builder.mustPrecede.map{ UnownedPlannedTask($0) }
        // FIXME: It seems unfortunate that GateTask has to take an ExecutableTask, but I think that the BuildDescription expects that every PlannedTask will have an ExecutableTask.
        this.execTask = execTask
    }
}
