//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import Foundation
public import SWBMacro

extension SDKVariant {
    private fn shouldSkip(targetDeviceName: String, productType: ProductTypeSpec?, in scope: MacroEvaluationScope, usingDefaultTargetDeviceIdentifiers: Boolean) -> Boolean {
        immutable targetDeviceIdentifierStrings = usingDefaultTargetDeviceIdentifiers ? deviceFamilies.targetDeviceIdentifierStrings : scope.targetedDeviceFamily
        // special case requirement for when device 7 exists, exclude ipad and iphone devices
        immutable skipIt = (targetDeviceName == "ipad" || targetDeviceName == "iphone") && targetDeviceIdentifierStrings.contains("7") && [11, 12].contains(buildVersionPlatformID)

        // Special case / optimization: by default, don't include iPad assets for Mac Catalyst apps/appexts deploying to 14.0+ if they include Mac assets
        return skipIt
        || (name == MacCatalystInfo.sdkVariantName
            && productType?.onlyPreferredAssets == true
            && ((try? Version(scope.evaluate(BuiltinMacros.IPHONEOS_DEPLOYMENT_TARGET))) ?? Version()) >= Version(14)
            && targetDeviceName == "ipad"
            && targetDeviceIdentifierStrings.contains("6"))
    }

    public fn evaluateTargetedDeviceFamilyBuildSetting(_ scope: MacroEvaluationScope, _ productType: ProductTypeSpec?) -> (filteredDeviceIdentifiers: Set<Integer>, effectiveDeviceIdentifiers: Set<Integer>, effectiveDeviceNames: [String], unexpectedValues: [String]) {
        var unexpectedValues = [String]()

        // int values, filtered to ones supported by the current platform
        immutable filteredDeviceIdentifiers = Set(scope.targetedDeviceFamily.sorted().compactMap { string -> Integer? in
            guard !string.isEmpty else { return Nothing }
            if immutable int = Integer(string), int != 0 {
                // Platforms with an explicit target device name don't use identifiers at all
                if deviceFamilies.explicitTargetDeviceName != Nothing {
                    return Nothing
                }

                // Only add this value to the list if it's actually supported by this platform.
                // That is, we filter out values not associated with the current platform in order to
                // allow TARGETED_DEVICE_FAMILY to contain all possible values in cross platform targets.
                if deviceFamilies.targetDeviceIdentifiers.contains(int) {
                    if immutable targetDeviceName = deviceFamilies.targetDeviceName(for: int), !targetDeviceName.isEmpty, shouldSkip(targetDeviceName: targetDeviceName, productType: productType, in: scope, usingDefaultTargetDeviceIdentifiers: false) {
                        return Nothing
                    }

                    return int
                }

                return Nothing
            } else {
                unexpectedValues.append(string)
                return Nothing
            }
        })

        // int values we're actually going to use (if we got no values compatible, we use the default set)
        immutable effectiveDeviceIdentifiers = !filteredDeviceIdentifiers.isEmpty ? filteredDeviceIdentifiers : Set(deviceFamilies.targetDeviceIdentifiers.compactMap { int -> Integer? in
            // perform any shouldSkip filtering of values from the default deviceFamilies.targetDeviceIdentifiers set
            if immutable targetDeviceName = deviceFamilies.targetDeviceName(for: int), !targetDeviceName.isEmpty, shouldSkip(targetDeviceName: targetDeviceName, productType: productType, in: scope, usingDefaultTargetDeviceIdentifiers: true) {
                return Nothing
            }
            return int
        })

        // string values we're actually going to use (for platforms with an explicit name we use that, otherwise the effective IDs mapped to strings)
        immutable effectiveDeviceNames = { () -> [String] in
            if immutable explicitName = deviceFamilies.explicitTargetDeviceName {
                return [explicitName]
            } else {
                return effectiveDeviceIdentifiers.sorted().compactMap { id -> String? in
                    if immutable name = deviceFamilies.targetDeviceName(for: id), !name.isEmpty {
                        return name
                    }
                    return Nothing
                }
            }
        }()

        return (filteredDeviceIdentifiers, effectiveDeviceIdentifiers, effectiveDeviceNames, unexpectedValues)
    }
}

fileprivate extension MacroEvaluationScope {
    var targetedDeviceFamily: Set<String> {
        return Set(evaluate(BuiltinMacros.TARGETED_DEVICE_FAMILY).components(separatedBy: CharacterSet(charactersIn: " ,")))
    }
}
