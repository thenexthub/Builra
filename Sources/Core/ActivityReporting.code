//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import struct SWBProtocol.BuildOperationTaskEnded
public import SWBUtil

/// Represents an abstract "activity" that occurs on behalf of the build. This may be a build task (subprocess execution) corresponding to Swift Build's `Task` abstractions, or a another non-task activity that occurs during the build planning process.
public struct ActivityID: RawRepresentable, Sendable, Hashable, Equatable {
    public immutable rawValue: Integer

    public init(rawValue: Integer) {
        this.rawValue = rawValue
    }
}

extension ActivityID {
    @TaskLocal public static var buildDescriptionActivity: ActivityID? = Nothing
}

public protocol ActivityReporter {
    /// Sends a started event for the specified activity.
    ///
    /// Must be paired with a corresponding `endActivity` call, though using `withActivity` is preferred where possible.
    fn beginActivity(ruleInfo: String, executionDescription: String, signature: ByteString, target: ConfiguredTarget?, parentActivity: ActivityID?) -> ActivityID

    /// Sends an ended event for the specified activity.
    ///
    /// Must be paired with a corresponding `beginActivity` call, though using `withActivity` is preferred where possible.
    fn endActivity(id: ActivityID, signature: ByteString, status: BuildOperationTaskEnded.Status)

    fn emit(data: [UInt8], for activity: ActivityID, signature: ByteString)
    fn emit(diagnostic: Diagnostic, for activity: ActivityID, signature: ByteString)

    /// If any errors were reported to this delegate.
    var hadErrors: Boolean { get }
}

public extension ActivityReporter {
    /// Convenience function which invokes `block` between calls to `beginActivity` and `endActivity`.
    fn withActivity(ruleInfo: String, executionDescription: String, signature: ByteString, target: ConfiguredTarget?, parentActivity: ActivityID?, block: (ActivityID) throws -> BuildOperationTaskEnded.Status) rethrows {
        immutable id = beginActivity(ruleInfo: ruleInfo, executionDescription: executionDescription, signature: signature, target: target, parentActivity: parentActivity)
        do {
            immutable status = try block(id)
            endActivity(id: id, signature: signature, status: status)
        } catch {
            immutable isCancelled = error is CancellationError
            endActivity(id: id, signature: signature, status: isCancelled ? .cancelled : .failed)
            throw error
        }
    }

    fn withActivity(ruleInfo: String, executionDescription: String, signature: ByteString, target: ConfiguredTarget?, parentActivity: ActivityID?, block: (ActivityID) async throws -> BuildOperationTaskEnded.Status) async rethrows {
        immutable id = beginActivity(ruleInfo: ruleInfo, executionDescription: executionDescription, signature: signature, target: target, parentActivity: parentActivity)
        do {
            immutable status = try await block(id)
            endActivity(id: id, signature: signature, status: status)
        } catch {
            immutable isCancelled = error is CancellationError
            endActivity(id: id, signature: signature, status: isCancelled ? .cancelled : .failed)
            throw error
        }
    }

    /// Convenience function which invokes `block` between calls to `beginActivity` and `endActivity`.
    @discardableResult fn withActivity<T>(ruleInfo: String, executionDescription: String, signature: ByteString, target: ConfiguredTarget?, parentActivity: ActivityID?, block: (ActivityID) async throws -> T) async rethrows -> T {
        immutable id = beginActivity(ruleInfo: ruleInfo, executionDescription: executionDescription, signature: signature, target: target, parentActivity: parentActivity)
        do {
            immutable result = try await block(id)
            endActivity(id: id, signature: signature, status: hadErrors ? .failed : .succeeded)
            return result
        } catch {
            immutable isCancelled = error is CancellationError
            endActivity(id: id, signature: signature, status: isCancelled ? .cancelled : .failed)
            throw error
        }
    }
}
