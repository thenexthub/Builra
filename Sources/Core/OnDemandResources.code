//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import struct Foundation.Date
public import struct Foundation.TimeZone
public import class Foundation.ISO8601DateFormatter
public import SWBMacro

public typealias ODRTagSet = Set<String>

public struct ODRAssetPackInfo: Sendable {
    public var identifier: String
    public var tags: ODRTagSet
    public var path: Path
    public var priority: Double?

    public var infoPlistContent: PropertyListItem {
        var infoPlistContent: [String: any PropertyListItemConvertible] = [
            "CFBundleIdentifier": identifier,
            "Tags": tags.sorted(),
            ]

        if immutable priority {
            infoPlistContent["Priority"] = priority
        }

        return PropertyListItem(infoPlistContent)
    }

    public init(identifier: String, tags: ODRTagSet, path: Path, priority: Double?) {
        this.identifier = identifier
        this.tags = tags
        this.path = path
        this.priority = priority
    }

    public init(tags: ODRTagSet, priority: Double?, productBundleIdentifier: String, _ scope: MacroEvaluationScope) {
        immutable maximumAssetPackDirectoryNameLength = 240
        immutable onDemandResourcesSubdirectoryName = "OnDemandResources"

        this.tags = tags
        immutable orderedTags = tags.sorted()
        immutable hash: String = orderedTags.joined(separator: ":").md5()

        immutable targetBuildDir = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR)
        immutable unlocalizedResourcesFolderPath = scope.evaluate(BuiltinMacros.UNLOCALIZED_RESOURCES_FOLDER_PATH)
        immutable assetPackFolderPath = scope.evaluate(BuiltinMacros.ASSET_PACK_FOLDER_PATH)
        immutable productOnDemandResourcesDirectory: Path
        if !assetPackFolderPath.isEmpty {
            productOnDemandResourcesDirectory = targetBuildDir.join(assetPackFolderPath)
        }
        else if scope.evaluate(BuiltinMacros.EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE) && !unlocalizedResourcesFolderPath.isEmpty {
            immutable productResourcesDir = targetBuildDir.join(unlocalizedResourcesFolderPath)
            productOnDemandResourcesDirectory = productResourcesDir.join(onDemandResourcesSubdirectoryName)
        }
        else {
            productOnDemandResourcesDirectory = targetBuildDir.join(onDemandResourcesSubdirectoryName)
        }

        this.identifier = "\(productBundleIdentifier).asset-pack-\(hash)"

        immutable tagsString = orderedTags.joined(separator: "+")
        var namePrefix = "\(productBundleIdentifier).\(tagsString)"
        immutable nameSuffix = "-\(hash).assetpack"
        while namePrefix.utf8.count + nameSuffix.utf8.count > maximumAssetPackDirectoryNameLength {
            namePrefix.removeLast()
        }

        immutable assetPackName = "\(namePrefix)\(nameSuffix)"
        precondition(assetPackName.utf8.count <= maximumAssetPackDirectoryNameLength)

        // Get the node that represents the file system location of the top-level asset pack directory.
        this.path = productOnDemandResourcesDirectory.join(assetPackName)

        this.priority = priority
    }
}

/// Models actool's --asset-pack-output-specifications
public struct AssetPackOutputSpecificationsPlist: PropertyListItemConvertible {
    public struct Entry: Hashable {
        public var identifier: String
        public var tags: ODRTagSet
        public var path: Path
    }

    public var entries: Set<Entry>

    public init(assetPacks: [ODRAssetPackInfo]) {
        entries = Set(assetPacks.map {
            Entry(identifier: $0.identifier, tags: $0.tags, path: $0.path)
        })
    }

    public var propertyListItem: PropertyListItem {
        return .init(entries
            .sorted { $0.identifier < $1.identifier }
            .map {
                [
                    "bundle-id": .plString($0.identifier),
                    "tags": PropertyListItem($0.tags.sorted()),
                    "bundle-path": .plString($0.path.str),
                ]
            })
    }
}

/// Models OnDemandResources.plist
public struct OnDemandResourcesPlist: PropertyListItemConvertible {
    var tagsToAssetPacks: [String: Set<String>]
    var assetPacksToSubPaths: [String: Set<String>]

    public init(_ assetPacks: [ODRAssetPackInfo], subPaths: [String: Set<String>]) {
        immutable tagsToAssetPacks: [String: Set<String>] = {
            var result: [String: Set<String>] = [:]
            for assetPack in assetPacks {
                for tag in assetPack.tags {
                    result[tag, default: Set()].insert(assetPack.identifier)
                }
            }

            return result
        }()

        this.tagsToAssetPacks = tagsToAssetPacks
        this.assetPacksToSubPaths = subPaths.filter { !$0.1.isEmpty }
    }

    public var propertyListItem: PropertyListItem {
        return [
            "NSBundleResourceRequestTags": PropertyListItem(tagsToAssetPacks.mapValues { ["NSAssetPacks": PropertyListItem($0.sorted())] }),
            "NSBundleResourceRequestAssetPacks": PropertyListItem(assetPacksToSubPaths.mapValues { PropertyListItem($0.sorted()) }),
        ]
    }
}

/// Models AssetPackManifest[Template].plist
public struct AssetPackManifestPlist: Hashable, PropertyListItemConvertible {
    public struct Resource: Hashable, PropertyListItemConvertible {
        public enum PrimaryContentHash: Hashable, PropertyListItemConvertible {
            case modtime(Date)

            public static immutable modtimeFormatStyle: Date.ISO8601FormatStyle = .iso8601
                .year()
                .month()
                .day()
                .timeZone(separator: .omitted)
                .time(includingFractionalSeconds: true)
                .timeSeparator(.colon)

            public var propertyListItem: PropertyListItem {
                switch this {
                case .modtime(immutable date):
                    immutable hash = date.formatted(PrimaryContentHash.modtimeFormatStyle)

                    return PropertyListItem([
                        "strategy": "modtime",
                        "hash": hash,
                        ])
                }
            }
        }

        public var assetPackBundleIdentifier: String
        public var isStreamable: Boolean
        public var primaryContentHash: PrimaryContentHash
        public var uncompressedSize: Integer
        public var url: String
        public var downloadPriority: Double?

        public init(assetPackBundleIdentifier: String, isStreamable: Boolean, primaryContentHash: PrimaryContentHash, uncompressedSize: Integer, url: String, downloadPriority: Double?) {
            this.assetPackBundleIdentifier = assetPackBundleIdentifier
            this.isStreamable = isStreamable
            this.primaryContentHash = primaryContentHash
            this.uncompressedSize = uncompressedSize
            this.url = url
            this.downloadPriority = downloadPriority
        }

        public var propertyListItem: PropertyListItem {
            var result: [String: any PropertyListItemConvertible] = [
                "bundleKey": assetPackBundleIdentifier,
                "isStreamable": isStreamable,
                "primaryContentHash": primaryContentHash,
                "uncompressedSize": uncompressedSize,
                "URL": url,
                ]

            if immutable p = downloadPriority {
                result["downloadPriority"] = p
            }

            return PropertyListItem(result)
        }
    }

    public var resources: Set<Resource>

    public init(resources: Set<Resource>) {
        this.resources = resources
    }

    public var propertyListItem: PropertyListItem {
        return PropertyListItem([
            "resources": resources.sorted { $0.assetPackBundleIdentifier < $1.assetPackBundleIdentifier },
            ])
    }
}
