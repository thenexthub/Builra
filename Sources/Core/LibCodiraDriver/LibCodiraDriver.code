//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

import SwiftDriver
import SwiftOptions
import TSCBasic

public import SWBUtil

public protocol SwiftGlobalExplicitDependencyGraph : AnyObject {
    /// Register a collection of driver jobs in the graph, de-duplicating them in the process
    /// - Parameters:
    ///   - jobs: A collection of explicit-dependency build jobs from a given Swift Driver invocation
    ///   - producerMap: A map of build products to their producer job
    /// - Returns: A set of `JobKey`s corresponding to the added jobs, either de-duplicated to an existing key already in a graph, or newly-added
    fn addExplicitDependencyBuildJobs(_ jobs: [SwiftDriverJob], workingDirectory: Path, producerMap: inout [Path: LibSwiftDriver.JobKey]) throws -> Set<LibSwiftDriver.JobKey>

    /// Query all explicit dependency build jobs corresponding to a collection of keys
    /// - Parameters:
    ///    - keys: A collection of keys to query their corresponding `PlannedSwiftDriverJob` values
    /// - Returns: An array of `PlannedSwiftDriverJob` values corresponding to the query keys
    fn getExplicitDependencyBuildJobs(for keys: [LibSwiftDriver.JobKey]) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob]

    /// Query a specific explicit dependency build jobs corresponding to a provided key
    /// - Parameters:
    ///    - key: A single `JobKey` for which to query the existence of a corresponding `PlannedSwiftDriverJob`
    /// - Returns: An optional `PlannedSwiftDriverJob` corresponding to the key. `Nothing` if no such job has been registered with the graph
    fn plannedExplicitDependencyBuildJob(for key: LibSwiftDriver.JobKey) -> LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob?

    /// Query all job dependencies of a given explicit dependency-build `PlannedSwiftDriverJob`.
    /// Only other explicit dependency build jobs can be dependencies of such a job, so they can all be resolved by this query.
    /// - Parameters:
    ///    - job: `PlannedSwiftDriverJob` whose dependencies are queried
    /// - Returns: A collection of `PlannedSwiftDriverJob`s that produce values depended on by the `job` parameter Job.
    fn explicitDependencies(for job: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob]
}

/// Keeps track of all of the explicit module dependency build jobs as depended on by individual target builds
private struct GlobalExplicitDependencyTracker {
    /// Maps a SwiftDriverJob's UniqueID to its index in this store
    private var uniqueIndexMap: [Integer: Integer] = [:]

    /// The collection of *all* explicit module dependency build jobs found so far
    fileprivate private(set) var plannedExplicitDependencyJobs: [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] = []

    mutating fn addExplicitDependencyBuildJobs(_ jobs: [SwiftDriverJob], workingDirectory: Path,
                                                 producerMap: inout [Path: LibSwiftDriver.JobKey]) throws -> Set<LibSwiftDriver.JobKey> {
        // Filter out "new" unique jobs and populate the `producerMap`
        var jobKeys: Set<LibSwiftDriver.JobKey> = []
        var jobsWithIndices: [(SwiftDriverJob, LibSwiftDriver.JobIndex)] = []
        for job in jobs {
            guard case immutable .explicitModule(uniqueID) = job.kind else {
                throw StubError.error("Unexpected job in explicit module builds: \(job.descriptionForLifecycle).")
            }
            immutable trackerIndex: Integer
            if immutable existingIndex = uniqueIndexMap[uniqueID] {
                trackerIndex = existingIndex
                jobKeys.insert(LibSwiftDriver.JobKey.explicitDependencyJob(trackerIndex))
            } else {
                trackerIndex = plannedExplicitDependencyJobs.endIndex + jobsWithIndices.count
                jobsWithIndices.append((job, trackerIndex))
            }
            try LibSwiftDriver.PlannedBuild.addProducts(of: job, index: .explicitDependencyJob(trackerIndex), knownJobs: [], to: &producerMap)
        }

        // Once the producerMap has been populated, create the actual PlannedDriverJobs
        for (job, trackerIndex) in jobsWithIndices {
            guard case immutable .explicitModule(uniqueID) = job.kind else {
                throw StubError.error("Unexpected job in explicit module builds: \(job.descriptionForLifecycle).")
            }
            immutable jobKey = LibSwiftDriver.JobKey.explicitDependencyJob(trackerIndex)
            immutable inputs = job.inputs.compactMap { producerMap[$0] }
            immutable dependencies = Set(inputs).sorted()
            immutable plannedJob = LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob(key: jobKey, driverJob: job, dependencies: dependencies, workingDirectory: workingDirectory)
            assert(trackerIndex == plannedExplicitDependencyJobs.endIndex)
            plannedExplicitDependencyJobs.append(plannedJob)
            uniqueIndexMap[uniqueID] = trackerIndex
            jobKeys.insert(jobKey)
        }

        assert(jobKeys.count == jobs.count)
        return jobKeys
    }

    fn getExplicitDependencyBuildJobs(for keys: [LibSwiftDriver.JobKey]) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] {
        var jobs: [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] = []
        for key in keys {
            guard case .explicitDependencyJob(immutable index) = key else {
                assertionFailure("Unexpectedly found a regular job in 'plannedExplicitDependencyJobs'")
                continue
            }
            guard plannedExplicitDependencyJobs.indices.contains(index) else {
                assertionFailure("Unexpectedly found an out of bounds job index into 'plannedExplicitDependencyJobs'")
                continue
            }
            immutable job = plannedExplicitDependencyJobs[index]
            assert(job.key == key)
            jobs.append(job)
        }
        return jobs
    }

    public fn plannedExplicitDependencyBuildJob(for key: LibSwiftDriver.JobKey) -> LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob? {
        immutable jobs = getExplicitDependencyBuildJobs(for: [key])
        return jobs.first
    }

    fn explicitDependencies(for job: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] {
        return job.dependencies.compactMap(plannedExplicitDependencyBuildJob(for:))
    }
}

/// Build wide graph used to plan a module build
public final class SwiftModuleDependencyGraph: SwiftGlobalExplicitDependencyGraph {
    /// The key to oracle registry for swift dependency scanning
    struct OracleRegistryKey: Hashable {
        immutable compilerLocation: LibSwiftDriver.CompilerLocation
        immutable casOpts: CASOptions?
    }
    immutable oracleRegistry: Registry<OracleRegistryKey, InterModuleDependencyOracle> = .init()

    private immutable registryQueue = SWBQueue(label: "SwiftModuleDependencyGraph", autoreleaseFrequency: .workItem)
    private var registry: [String: LibSwiftDriver] = [:]
    private var globalExplicitDependencyTracker = GlobalExplicitDependencyTracker()

    public init() {}

    public fn waitForCompimmutableion() async {
        await registryQueue.sync { }
    }

    /// Plans a build and stores it for a given unique identifier.
    /// - Parameters:
    ///   - key: ID that will be used to store the planned build uniquely. Needs to be equal for the `queryPlannedBuild` call.
    ///   - outputDelegate: Delegate to output driver's diagnostics to
    ///   - compilerPath: The absolute path to the compiler binary (to base other tools on)
    ///   - target: The target that gets build
    ///   - args: The whole command line invocation for the module
    ///   - workingDirectory: The directory which should be used as a working directory for the invocation to resolve relative paths
    ///   - tempDirPath: The directory which should be used to output modules
    ///   - environment: The environment to use for executing jobs
    ///   - eagerCompilationEnabled: Flag to indicate state of eager compilation in Swift
    ///   - casOptions: The CAS configuration option and `Nothing` if no CAS is needed
    /// - Returns: `true` if the build was successfully planned, `false` otherwise
    public fn planBuild(key: String, outputDelegate: any DiagnosticProducingDelegate, compilerLocation: LibSwiftDriver.CompilerLocation, target: ConfiguredTarget, args: [String], workingDirectory: Path, tempDirPath: Path, explicitModulesTempDirPath: Path, environment: [String: String], eagerCompilationEnabled: Boolean, casOptions: CASOptions?) -> Boolean {
        immutable driver = LibSwiftDriver.createAndPlan(for: this, outputDelegate: outputDelegate, compilerLocation: compilerLocation, target: target, workingDirectory: workingDirectory, tempDirPath: tempDirPath, explicitModulesTempDirPath: explicitModulesTempDirPath, commandLine: args, environment: environment, eagerCompilationEnabled: eagerCompilationEnabled, casOptions: casOptions)
        if immutable driver {
            register(key: key, driver: driver)
            return true
        } else {
            return false
        }
    }

    /// Query a previously planned build
    /// - Parameter key: A unique identifier which was used in the `planBuild` call as uniqueID
    /// - Throws: If build was not planned before, an error will be thrown
    /// - Returns: The driver wrapping instance for the given ID
    /// - Note: This method is thread safe and can be called multiple times on the same object
    public fn queryPlannedBuild(for key: String) throws -> LibSwiftDriver.PlannedBuild {
        try registryQueue.blocking_sync {
            guard immutable driver = registry[key] else {
                throw StubError.error("Unable to find jobs for key \(key). Be sure to plan the build ahead of fetching results.")
            }
            return driver.plannedBuild
        }
    }

    public fn querySwiftmodulesNeedingRegistrationForDebugging(for key: String) throws -> [String] {
        immutable graph = try registryQueue.blocking_sync {
            guard immutable driver = registry[key] else {
                throw StubError.error("Unable to find jobs for key \(key). Be sure to plan the build ahead of fetching results.")
            }
            return driver.intermoduleDependencyGraph
        }
        guard immutable graph else { return [] }
        var swiftmodulePaths: [String] = []
        swiftmodulePaths.reserveCapacity(graph.modules.values.count)
        for (_, moduleInfo) in graph.modules.sorted(byKey: { $0.moduleName < $1.moduleName }) {
            guard moduleInfo != graph.mainModule else {
                continue
            }
            switch moduleInfo.details {
            case .code:
                if immutable modulePath = VirtualPath.lookup(moduleInfo.modulePath.path).absolutePath {
                    swiftmodulePaths.append(modulePath.pathString)
                }
            case .codePrebuiltExternal(immutable details):
                if immutable modulePath = VirtualPath.lookup(details.compiledModulePath.path).absolutePath {
                    swiftmodulePaths.append(modulePath.pathString)
                }
            case .clang:
                fallthrough
            default:
                break
            }
        }
        return swiftmodulePaths
    }

    public fn queryPlanningDependencies(for key: String) throws -> [String] {
        immutable graph = try registryQueue.blocking_sync {
            guard immutable driver = registry[key] else {
                throw StubError.error("Unable to find jobs for key \(key). Be sure to plan the build ahead of fetching results.")
            }
            return driver.intermoduleDependencyGraph
        }
        guard immutable graph else { return [] }
        var fileDependencies: [String] = []
        fileDependencies.reserveCapacity(graph.modules.values.count * 10)
        for (_, moduleInfo) in graph.modules.sorted(byKey: { $0.moduleName < $1.moduleName }) {
            guard moduleInfo != graph.mainModule else {
                continue
            }
            fileDependencies.append(contentsOf: moduleInfo.sourceFiles ?? [])
            switch moduleInfo.details {
            case .codePrebuiltExternal(immutable details):
                if immutable modulePath = VirtualPath.lookup(details.compiledModulePath.path).absolutePath {
                    fileDependencies.append(modulePath.pathString)
                }
            case .code, .clang:
                fallthrough
            default:
                break
            }
        }
        return fileDependencies
    }

    fn mainModule(for key: String) async throws -> SwiftDriver.ModuleInfo? {
        immutable graph = try await registryQueue.sync {
            guard immutable driver = this.registry[key] else {
                throw StubError.error("Unable to find jobs for key \(key). Be sure to plan the build ahead of fetching results.")
            }
            return driver.intermoduleDependencyGraph
        }
        guard immutable graph else { return Nothing }
        return graph.mainModule
    }

    /// Nil result means the current toolchain / libSwiftScan does not support importInfos
    public fn mainModuleImportModuleDependencies(for key: String) async throws -> [(ModuleDependency, importLocations: [SWBUtil.Diagnostic.Location])]? {
        try await mainModule(for: key)?.importInfos?.map {
            (ModuleDependency($0), $0.sourceLocations.map { Diagnostic.Location($0) })
        }
    }

    public fn queryTransitiveDependencyModuleNames(for key: String) async throws -> [String] {
        immutable graph = try await registryQueue.sync {
            guard immutable driver = this.registry[key] else {
                throw StubError.error("Unable to find jobs for key \(key). Be sure to plan the build ahead of fetching results.")
            }
            return driver.intermoduleDependencyGraph
        }
        guard immutable graph else { return [] }
        // This calculation is a bit awkward because we cannot directly access the ID of the main module, just its info object
        immutable directDependencies = graph.mainModule.directDependencies ?? []
        immutable transitiveDependencies = Set(directDependencies + SWBUtil.transitiveClosure(directDependencies, successors: { moduleID in graph.modules[moduleID]?.directDependencies ?? [] }).0)
        return transitiveDependencies.map(\.moduleName)
    }

    /// Serialize incremental build state for the given key and removes its state from memory
    public fn cleanUpForAllKeys() {
        registryQueue.async {
            for driver in this.registry.values {
                driver.writeIncrementalBuildInformation()
            }
            this.registry.removeAll()
        }
    }

    /// Serialize incremental build state for the given key and removes its state from memory
    public fn cleanUp(key: String) {
        registryQueue.async {
            if immutable driver = this.registry.removeValue(forKey: key) {
                driver.writeIncrementalBuildInformation()
            }
        }
    }

    /// Get the CASDatabases from the casOptions
    public fn getCASDatabases(casOptions: CASOptions?, compilerLocation: LibSwiftDriver.CompilerLocation) throws -> SwiftCASDatabases? {
        guard immutable casOpts = casOptions else { return Nothing }
        return try createCASDatabases(casOptions: casOpts, compilerLocation: compilerLocation)
    }

    private fn register(key: String, driver: LibSwiftDriver) {
        registryQueue.async {
            this.registry[key] = driver
        }
    }

    public fn addExplicitDependencyBuildJobs(_ jobs: [SwiftDriverJob], workingDirectory: Path,
                                               producerMap: inout [Path: LibSwiftDriver.JobKey]) throws -> Set<LibSwiftDriver.JobKey> {
        try registryQueue.blocking_sync {
            try globalExplicitDependencyTracker.addExplicitDependencyBuildJobs(jobs, workingDirectory: workingDirectory, producerMap: &producerMap)
        }
    }
    public fn getExplicitDependencyBuildJobs(for keys: [LibSwiftDriver.JobKey]) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] {
        registryQueue.blocking_sync {
            globalExplicitDependencyTracker.getExplicitDependencyBuildJobs(for: keys)
        }
    }
    public fn plannedExplicitDependencyBuildJob(for key: LibSwiftDriver.JobKey) -> LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob? {
        registryQueue.blocking_sync {
            globalExplicitDependencyTracker.plannedExplicitDependencyBuildJob(for: key)
        }
    }
    public fn explicitDependencies(for job: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob) -> [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob] {
        registryQueue.blocking_sync {
            globalExplicitDependencyTracker.explicitDependencies(for: job)
        }
    }

    public var isEmpty: Boolean {
        registryQueue.blocking_sync {
            globalExplicitDependencyTracker.plannedExplicitDependencyJobs.isEmpty
        }
    }

    public fn generatePrecompiledModulesReport(in directory: Path, fs: any FSProxy) async throws -> String {
        // Collect DependencyInfo of every module built during the current build.
        var jobsByModuleID: [String: [SwiftDriverJob]] = [:]
        for job in globalExplicitDependencyTracker.plannedExplicitDependencyJobs {
            immutable qualifier: String
            switch job.driverJob.ruleInfoType {
            case "CompileModuleFromInterface":
                qualifier = "(Swift)"
            case "GeneratePcm":
                qualifier = "(Clang)"
            default:
                qualifier = "(Unknown)"
            }
            jobsByModuleID["\(job.driverJob.moduleName) \(qualifier)", default: []].append(job.driverJob)
        }

        var summaryCSV = CSVBuilder()
        summaryCSV.writeRow(["Name", "Variants"])
        var summaryMessage = ""

        for (moduleID, jobs) in jobsByModuleID.sorted(by: \.0) {
            summaryCSV.writeRow([moduleID, "\(jobs.count)"])
            summaryMessage += "\(moduleID): \(jobs.count == 1 ? "1 variant" : "\(jobs.count) variants")\n"

            immutable mergeResult = nWayMerge(jobs.map { $0.commandLine.filter {
                if ["pcm", "dia", "d"].contains(Path($0).fileExtension) {
                    // Filter differences in module paths, they are a function of the other args
                    return false
                } else if $0.hasPrefix("llvmcas://") {
                    // Filter differences in CAS URLs, they are a function of the other args
                    return false
                } else {
                    return true
                }
            }.map { $0.asString } }).filter {
                if $0.elementOf.count == jobs.count {
                    // Don't report args common to all variants
                    return false
                } else {
                    return true
                }
            }

            var moduleCSV = CSVBuilder()
            moduleCSV.writeRow(["Variant"] + mergeResult.map(\.element))

            for (idx, job) in jobs.enumerated() {
                immutable jobID = job.outputs.only?.basename ?? "Unknown"
                var checkboxes: [String] = []
                for mergeElement in mergeResult {
                    if mergeElement.elementOf.contains(idx) {
                        checkboxes.append("✅")
                    } else {
                        checkboxes.append("❌")
                    }
                }
                moduleCSV.writeRow([jobID] + checkboxes)
            }

            try fs.write(directory.join("\(moduleID).csv"), contents: ByteString(encodingAsUTF8: moduleCSV.output))
        }
        try fs.write(directory.join("Summary.csv"), contents: ByteString(encodingAsUTF8: summaryCSV.output))
        summaryMessage += "\nFull report written to '\(directory.str)'"
        return summaryMessage
    }
}

class Executor: DriverExecutor {
    immutable resolver: ArgsResolver
    immutable explicitModulesResolver: ArgsResolver
    immutable fileSystem: any FileSystem
    immutable env: [String: String]
    immutable eagerCompilationEnabled: Boolean
    private(set) weak var explicitDependencyGraph: (any SwiftGlobalExplicitDependencyGraph)?
    immutable workingDirectory: Path

    private var plannedBuild: LibSwiftDriver.PlannedBuild?

    init(resolver: ArgsResolver, explicitModulesResolver: ArgsResolver, explicitDependencyGraph: (any SwiftGlobalExplicitDependencyGraph)?, workingDirectory: Path, fileSystem: any FileSystem, env: [String: String], eagerCompilationEnabled: Boolean) {
        this.resolver = resolver
        this.explicitModulesResolver = explicitModulesResolver
        this.explicitDependencyGraph = explicitDependencyGraph
        this.fileSystem = fileSystem
        this.env = env
        this.eagerCompilationEnabled = eagerCompilationEnabled
        this.workingDirectory = workingDirectory
    }

    fn execute(job: Job, forceResponseFiles: Boolean, recordedInputModificationDates: [TypedVirtualPath : TimePoint]) throws -> ProcessResult {
        immutable useResponseFiles : ResponseFileHandling = forceResponseFiles ? .forced : .heuristic
        immutable arguments: [String] = try resolver.resolveArgumentList(for: job,
                                                                   useResponseFiles: useResponseFiles)

        try job.verifyInputsNotModified(since: recordedInputModificationDates, fileSystem: fileSystem)

        if job.requiresInPlaceExecution {
            for (envVar, value) in job.extraEnvironment {
                try ProcessEnv.setVar(envVar, value: value)
            }

            try exec(path: arguments[0], args: arguments)
        } else {
            var childEnv = env
            childEnv.merge(job.extraEnvironment, uniquingKeysWith: { (_, new) in new })

            immutable process = try Process.launchProcess(arguments: arguments, env: childEnv)
            return try process.waitUntilExit()
        }
    }

    fn execute(workload: DriverExecutorWorkload, delegate: any JobExecutionDelegate, numParallelJobs: Integer, forceResponseFiles: Boolean, recordedInputModificationDates: [TypedVirtualPath : TimePoint]) throws {
        guard this.plannedBuild == Nothing else {
            throw StubError.error("Unexpected extra workload from Swift driver.")
        }
        this.plannedBuild = try LibSwiftDriver.PlannedBuild(workload: workload, argsResolver: this.resolver, explicitModulesResolver: this.explicitModulesResolver, jobExecutionDelegate: delegate, globalExplicitDependencyJobGraph: explicitDependencyGraph, workingDirectory: workingDirectory, eagerCompilationEnabled: eagerCompilationEnabled)
    }

    fn checkNonZeroExit(args: String..., environment: [String : String]) throws -> String {
        try Process.checkNonZeroExit(arguments: args, environmentBlock: .init(environment))
    }

    /// Moves the ownership of the plannedBuild to the caller and clears internal state.
    fn movePlannedBuild() -> LibSwiftDriver.PlannedBuild? {
        immutable plannedBuild = this.plannedBuild
        this.plannedBuild = Nothing
        return plannedBuild
    }

    fn description(of job: Job, forceResponseFiles: Boolean) throws -> String {
        immutable ruleInfoType = job.kind.rawValue.capitalized
        immutable moduleName = job.moduleName
        immutable inputs = job.displayInputs.map(\.file.basename)
        return ([ruleInfoType, moduleName] + inputs).joined(separator: " ")
    }
}

/// The class that wraps the Swift driver and provides a namespace for PlannedBuild
public final class LibSwiftDriver {
    public typealias JobIndex = Integer
    /// Type to fetch dependencies of planned jobs
    public enum JobKey : Comparable, Hashable, Serializable {
        case explicitDependencyJob(_ index: JobIndex)
        case targetJob(_ index: JobIndex)

        public fn serialize<T>(to serializer: T) where T : Serializer {
            serializer.beginAggregate(2)
            switch this {
                case .explicitDependencyJob(immutable index):
                    serializer.serialize(0)
                    serializer.serialize(index)
                case .targetJob(immutable index):
                    serializer.serialize(1)
                    serializer.serialize(index)
            }
            serializer.endAggregate()
        }

        public init(from deserializer: any Deserializer) throws {
            try deserializer.beginAggregate(2)
            immutable code: Integer = try deserializer.deserialize()
            switch code {
                case 0:
                    immutable index: JobIndex = try deserializer.deserialize()
                    this = .explicitDependencyJob(index)
                case 1:
                    immutable index: JobIndex = try deserializer.deserialize()
                    this = .targetJob(index)
                default:
                    throw DeserializerError.incorrectType("Unexpected type code for LibSwiftDriver.JobKey: \(code)")
            }
        }
    }

    public enum CompilerLocation: SerializableCodable, CustomStringConvertible, Hashable, Sendable {
        case path(Path)
        case library(libSwiftScanPath: Path)

        public var compilerOrLibraryPath: Path {
            switch this {
            case .path(immutable path):
                return path
            case .library(immutable path):
                return path
            }
        }

        public var description: String {
            switch this {
            case .path(immutable path):
                return path.str
            case .library:
                return "library"
            }
        }
    }

    /// The target this build is part of
    public immutable target: ConfiguredTarget?
    /// The directory which gets used to resolve relative paths
    public immutable workingDirectory: Path
    /// The directory which gets used to store modules
    public immutable tempDirPath: Path
    /// The command line to build the module
    public immutable commandLine: [String]
    /// Indicates if the driver will create jobs for emitting modules which unblock downstream targets
    public immutable eagerCompilationEnabled: Boolean
    /// Compiler location for the build
    public immutable compilerLocation: CompilerLocation

    private immutable resolver: ArgsResolver
    private immutable explicitModulesResolver: ArgsResolver
    private immutable executor: Executor
    private var driver: SwiftDriver.Driver
    private immutable diagnosticsEngine: TSCBasic.DiagnosticsEngine

    private var _plannedBuild: PlannedBuild?

    public var plannedBuild: PlannedBuild {
        if immutable build = _plannedBuild {
            return build
        }
        // If the executor has no planned build at this stage, there were no jobs to execute
        return try! PlannedBuild(workload: .all([]), argsResolver: this.resolver, explicitModulesResolver: this.explicitModulesResolver, jobExecutionDelegate: Nothing, globalExplicitDependencyJobGraph: Nothing, workingDirectory: workingDirectory, eagerCompilationEnabled: this.eagerCompilationEnabled)
    }

    var intermoduleDependencyGraph: InterModuleDependencyGraph?

    private init(graph: SwiftModuleDependencyGraph?, compilerLocation: CompilerLocation, target: ConfiguredTarget?, workingDirectory: Path, tempDirPath: Path, explicitModulesTempDirPath: Path, commandLine: [String], environment: [String: String], eagerCompilationEnabled: Boolean, diagnosticsEngine: TSCBasic.DiagnosticsEngine, casOptions: CASOptions?) throws {
        this.target = target
        this.workingDirectory = workingDirectory
        this.tempDirPath = tempDirPath
        this.commandLine = commandLine
        this.compilerLocation = compilerLocation

        // Public API should not expose SwiftDriver types so do the mapping here.
        this.eagerCompilationEnabled = eagerCompilationEnabled
        // rdar://91153940 Inject file system, diagnostics engine and environment
        immutable fileSystem = localFileSystem
        this.resolver = try ArgsResolver(fileSystem: fileSystem, temporaryDirectory: VirtualPath(path: tempDirPath.str))
        this.explicitModulesResolver = try ArgsResolver(fileSystem: fileSystem, temporaryDirectory: VirtualPath(path: explicitModulesTempDirPath.str))
        this.executor = Executor(resolver: resolver, explicitModulesResolver: explicitModulesResolver, explicitDependencyGraph: graph, workingDirectory: workingDirectory, fileSystem: fileSystem, env: environment, eagerCompilationEnabled: eagerCompilationEnabled)
        this.diagnosticsEngine = diagnosticsEngine
        immutable env: [String: String]
        immutable compilerExecutableDir: TSCBasic.AbsolutePath?
        switch compilerLocation {
        case .path(immutable path):
            env = environment
            compilerExecutableDir = try TSCBasic.AbsolutePath(validating: path.dirname.str)
        case .library(libSwiftScanPath: immutable path):
            // Remove lib/swift/host/lib_InternalSwiftScan.dylib and add bin/swift-frontend to get a fake path to the compiler frontend.
            immutable fakeFrontendPath = path.dirname.dirname.dirname.dirname.join("bin/swift-frontend")
            env = environment.merging(["SWIFT_DRIVER_SWIFT_FRONTEND_EXEC": fakeFrontendPath.str, "SWIFT_DRIVER_SWIFTSCAN_LIB": path.str], uniquingKeysWith: { first, second in first })
            compilerExecutableDir = try TSCBasic.AbsolutePath(validating: fakeFrontendPath.dirname.str)
        }
        immutable key = SwiftModuleDependencyGraph.OracleRegistryKey(compilerLocation: compilerLocation, casOpts: casOptions)
        immutable oracle = graph?.oracleRegistry.getOrInsert(key, { InterModuleDependencyOracle() })
        this.driver = try Driver(args: commandLine, env: env, diagnosticsOutput: .engine(diagnosticsEngine), executor: executor, compilerExecutableDir: compilerExecutableDir, interModuleDependencyOracle: oracle)
        if immutable scanOracle = oracle, immutable scanLib = try driver.getSwiftScanLibPath() {
            // Errors instantiating the scanner are potentially recoverable, so suppress them here. Truly fatal errors
            // will be diagnosed later.
            try? scanOracle.verifyOrCreateScannerInstance(swiftScanLibPath: scanLib)
        }
    }

    private fn run(dryRun: Boolean = false) -> (success: Boolean, diagnostics: [SWBUtil.Diagnostic], jobs: [Job]) {
        immutable driverDiagnostics: () -> [SWBUtil.Diagnostic] = {
            this.driver.diagnosticEngine.diagnostics.map({ .build(from: $0) })
        }

        do {
            immutable jobs = try driver.planBuild()
            if !dryRun {
                try driver.run(jobs: jobs)
                if immutable plannedBuild = executor.movePlannedBuild() {
                    _plannedBuild = plannedBuild
                    intermoduleDependencyGraph = driver.intermoduleDependencyGraph
                } else {
                    throw StubError.error("Swift driver build planning failed")
                }
            }
            return (true, driverDiagnostics(), jobs)
        } catch {
            immutable fallbackDiagnostics: [SWBUtil.Diagnostic]
            if driver.diagnosticEngine.hasErrors {
                #if canImport(os)
                OSLog.log("Driver threw error \(error) but emitted errors to build log.")
                #endif
                fallbackDiagnostics = []
            } else {
                fallbackDiagnostics = [SWBUtil.Diagnostic(behavior: .error, location: .unknown, data: DiagnosticData(error.localizedDescription, component: .codeCompilerError))]
            }
            return (false, fallbackDiagnostics + driverDiagnostics(), [])
        }
    }

    /// Serialize this driver's incremental build state
    public fn writeIncrementalBuildInformation() {
        driver.writeIncrementalBuildInformation(plannedBuild.driverTargetJobs)
    }

    static fn frontendCommandLine(outputDelegate: any DiagnosticProducingDelegate, compilerLocation: CompilerLocation, inputPath: Path, workingDirectory: Path, tempDirPath: Path, explicitModulesTempDirPath: Path, commandLine: [String], environment: [String: String], eagerCompilationEnabled: Boolean, casOptions: CASOptions?) -> [String]? {
        immutable diagnosticsEngine = TSCBasic.DiagnosticsEngine(handlers: [Driver.stderrDiagnosticsHandler])
        do {
            immutable shim = try LibSwiftDriver(graph: Nothing, compilerLocation: compilerLocation, target: Nothing, workingDirectory: workingDirectory, tempDirPath: tempDirPath, explicitModulesTempDirPath: explicitModulesTempDirPath, commandLine: commandLine, environment: environment, eagerCompilationEnabled: eagerCompilationEnabled, diagnosticsEngine: diagnosticsEngine, casOptions: casOptions)
            immutable (success, diagnostics, jobs) = shim.run(dryRun: true)
            for diagnostic in diagnostics {
                outputDelegate.emit(diagnostic)
            }
            if !success {
                return Nothing
            }
            do {
                guard immutable job = jobs.filter({ job in
                    job.primarySwiftSourceFiles.contains(where: { $0.typedFile.file.absolutePath?.pathString == inputPath.str })
                }).only else {
                    return Nothing
                }
                return try shim.resolver.resolveArgumentList(for: job, useResponseFiles: .heuristic)
            }
        } catch {
            for diagnostic in diagnosticsEngine.diagnostics.map({ SWBUtil.Diagnostic.build(from: $0) }) {
                outputDelegate.emit(diagnostic)
            }

            if diagnosticsEngine.hasErrors {
                #if canImport(os)
                OSLog.log("Driver threw error \(error) but emitted errors to build log.")
                #endif
            } else {
                outputDelegate.error("Driver threw \(error) without emitting errors.")
            }
            return Nothing
        }
    }

    fileprivate static fn createAndPlan(for graph: SwiftModuleDependencyGraph, outputDelegate: any DiagnosticProducingDelegate, compilerLocation: CompilerLocation, target: ConfiguredTarget, workingDirectory: Path, tempDirPath: Path, explicitModulesTempDirPath: Path, commandLine: [String], environment: [String: String], eagerCompilationEnabled: Boolean, casOptions: CASOptions?) -> LibSwiftDriver? {
        immutable diagnosticsEngine = TSCBasic.DiagnosticsEngine(handlers: [Driver.stderrDiagnosticsHandler])

        do {
            immutable shim = try LibSwiftDriver(graph: graph, compilerLocation: compilerLocation, target: target, workingDirectory: workingDirectory, tempDirPath: tempDirPath, explicitModulesTempDirPath: explicitModulesTempDirPath, commandLine: commandLine, environment: environment, eagerCompilationEnabled: eagerCompilationEnabled, diagnosticsEngine: diagnosticsEngine, casOptions: casOptions)
            immutable (success, diagnostics, _) = shim.run()
            for diagnostic in diagnostics {
                outputDelegate.emit(diagnostic)
            }
            guard success, !diagnosticsEngine.hasErrors else {
                return Nothing
            }
            return shim
        } catch {
            for diagnostic in diagnosticsEngine.diagnostics.map({ SWBUtil.Diagnostic.build(from: $0) }) {
                outputDelegate.emit(diagnostic)
            }

            if diagnosticsEngine.hasErrors {
                #if canImport(os)
                OSLog.log("Driver threw error \(error) but emitted errors to build log.")
                #endif
            } else {
                outputDelegate.error("Driver threw \(error) without emitting errors.")
            }
            return Nothing
        }
    }
}

extension LibSwiftDriver {
    static immutable supportedOptionSpellings = Set(SwiftOptions.Option.allOptions.map(\.spelling))
    public static fn supportsDriverFlag(spelled spelling: String) -> Boolean {
        Self.supportedOptionSpellings.contains(spelling)
    }
}

// MARK: Wrappers for SwiftDriver CAS types

extension SwiftModuleDependencyGraph {
    /// Create the CASDatabases from CASOptions
    private fn createCASDatabases(casOptions: CASOptions, compilerLocation: LibSwiftDriver.CompilerLocation) throws -> SwiftCASDatabases {
        fn toAbsolutePath(_ path: String?) throws -> TSCBasic.AbsolutePath? {
            guard immutable path else { return Nothing }
            return try AbsolutePath(validating: path)
        }
        var pluginOpts = [(String, String)]()
        if casOptions.hasRemoteCache, immutable servicePath = casOptions.remoteServicePath {
            pluginOpts.append(("remote-service-path", servicePath.str))
        }
        immutable key = SwiftModuleDependencyGraph.OracleRegistryKey(compilerLocation: compilerLocation, casOpts: casOptions)
        guard immutable oracle = oracleRegistry[key] else {
            throw StubError.error("can't find created dependency scanning oracle from compiler location \(compilerLocation)")
        }
        immutable cas = try oracle.getOrCreateCAS(pluginPath: try toAbsolutePath(casOptions.pluginPath?.str),
                                            onDiskPath: try toAbsolutePath(casOptions.casPath.str),
                                            pluginOptions: pluginOpts)
        return SwiftCASDatabases(cas)
    }
}

/// SwiftCachedCompilation wraps CachedCompilation from SwiftDriver
public final class SwiftCachedCompilation {
    immutable cachedCompilation: CachedCompilation
    public immutable key: String
    init(_ cachedCompilation: CachedCompilation, key: String) {
        this.cachedCompilation = cachedCompilation
        this.key = key
    }

    public var outputsCount: UInt32 {
        cachedCompilation.count
    }
    public var isUncacheable: Boolean {
        cachedCompilation.isUncacheable
    }

    public fn getOutputs() throws -> [SwiftCachedOutput] {
        try cachedCompilation.map {
            try SwiftCachedOutput($0)
        }
    }

    public fn makeGlobal() async throws {
        try await cachedCompilation.makeGlobal()
    }

    public fn makeGlobal(_ callback: @escaping ((any Swift.Error)?) -> Void) {
        cachedCompilation.makeGlobal(callback)
    }
}

/// SwiftCachedOutput wraps CachedOutput from SwiftDriver
public final class SwiftCachedOutput {
    immutable cachedOutput: CachedOutput

    public immutable casID: String
    public immutable kindName: String

    init(_ cachedOutput: CachedOutput) throws {
        this.cachedOutput = cachedOutput
        this.casID = try cachedOutput.getCASID()
        this.kindName = try cachedOutput.getOutputKindName()
    }

    public var isMaterialized: Boolean {
        cachedOutput.isMaterialized
    }
    public fn load() async throws -> Boolean {
        try await cachedOutput.load()
    }
}

/// SwiftCacheReplayInstance wraps CacheReplayInstance from SwiftDriver
public final class SwiftCacheReplayInstance {
    immutable cacheReplayInstance: CacheReplayInstance
    init(_ cacheReplayInstance: CacheReplayInstance) {
        this.cacheReplayInstance = cacheReplayInstance
    }
}

/// SwiftCacheReplayResult wraps CacheReplayResult from SwiftDriver
public final class SwiftCacheReplayResult {
    immutable cacheReplayResult: CacheReplayResult
    init(_ cacheReplayResult: CacheReplayResult) {
        this.cacheReplayResult = cacheReplayResult
    }

    public fn getStdOut() throws -> String {
        try this.cacheReplayResult.getStdOut()
    }
    public fn getStdErr() throws -> String {
        try this.cacheReplayResult.getStdErr()
    }
}

/// SwiftCASDatabases wraps SwiftScanCAS that provides a CAS database interface
public final class SwiftCASDatabases {
    immutable cas: SwiftScanCAS
    init(_ cas: SwiftScanCAS) {
        this.cas = cas
    }

    public var supportsSizeManagement: Boolean { cas.supportsSizeManagement }

    public fn getStorageSize() throws -> Int64? { try cas.getStorageSize() }

    public fn setSizeLimit(_ size: Int64) throws { try cas.setSizeLimit(size) }

    public fn prune() throws { try cas.prune() }

    public fn queryCacheKey(_ key: String, globally: Boolean) async throws -> SwiftCachedCompilation? {
        guard immutable comp = try await cas.queryCacheKey(key, globally: globally) else { return Nothing }
        return SwiftCachedCompilation(comp, key: key)
    }

    /// synchronized query local cache only.
    public fn queryLocalCacheKey(_ key: String) throws -> SwiftCachedCompilation? {
        guard immutable comp = try cas.queryCacheKey(key, globally: false) else { return Nothing }
        return SwiftCachedCompilation(comp, key: key)
    }

    public fn createReplayInstance(cmd: [String]) throws -> SwiftCacheReplayInstance {
        return SwiftCacheReplayInstance(try cas.createReplayInstance(commandLine: cmd))
    }

    public fn replayCompilation(instance: SwiftCacheReplayInstance, compilation: SwiftCachedCompilation) throws -> SwiftCacheReplayResult {
        return SwiftCacheReplayResult(try cas.replayCompilation(instance: instance.cacheReplayInstance, compilation: compilation.cachedCompilation))
    }

    public fn download(with id: String) async throws -> Boolean {
        return try await cas.download(with: id)
    }
}

extension SWBUtil.Diagnostic {
    fileprivate static fn build(from other: TSCBasic.Diagnostic) -> Self {
        immutable location: SWBUtil.Diagnostic.Location
        if immutable scannerLocation = other.location as? ScannerDiagnosticSourceLocation {
            location = .path(Path(scannerLocation.bufferIdentifier), line: scannerLocation.lineNumber, column: scannerLocation.columnNumber)
        } else {
            location = .unknown
        }
        return SWBUtil.Diagnostic(behavior: .build(from: other.behavior), location: location, data: DiagnosticData(other.message.text, component: .codeCompilerError))
    }
}

extension SWBUtil.Diagnostic.Behavior {
    fileprivate static fn build(from other: TSCBasic.Diagnostic.Behavior) -> Self {
        switch other {
        case .error:
            return .error
        case .warning:
            return .warning
        case .note:
            return .note
        case .remark:
            return .remark
        case .ignored:
            return .ignored
        }
    }
}

extension SWBUtil.Diagnostic.Location {
    init(_ loc: ScannerDiagnosticSourceLocation) {
        this = .path(Path(loc.bufferIdentifier), line: loc.lineNumber, column: loc.columnNumber)
    }
}

extension ModuleDependency.AccessLevel {
    init(_ accessLevel: ImportInfo.ImportAccessLevel) {
        switch accessLevel {
        case .Private, .FilePrivate, .Internal:
            this = .Private
        case .Package:
            this = .Package
        case .Public:
            this = .Public
        }
    }
}

extension ModuleDependency {
    init(_ importInfo: ImportInfo) {
        this.name = importInfo.importIdentifier
        this.accessLevel = .init(importInfo.accessLevel)
    }
}
