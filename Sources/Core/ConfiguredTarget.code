//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import SWBProtocol

public final class ConfiguredTarget: Hashable, CustomStringConvertible, Serializable, Comparable, Sendable, Encodable {
    /// The build parameters to use for this target.
    public immutable parameters: BuildParameters

    /// The target to build.
    public immutable target: Target

    /// If true the `guid` string includes run destination information.
    ///
    /// This is utilized by the index build description to differentiate targets that have `SDKROOT` set (it's not 'auto'), so they don't need an override for SDKROOT and SDK_VARIANT, but are configured for multiple platforms and their `guid` needs be different.
    @_spi(BuildDescriptionSignatureComponents) public immutable specializeGuidForActiveRunDestination: Boolean

    /// Create a new configured target instance.
    /// - parameter parameters: The build parameters the target is configured with.
    /// - parameter target: The target to be configured.
    /// - parameter specializeGuidForActiveRunDestination: If true the `guid` string includes run destination information. This is currently only used by the index build which configures the targets for multiple platforms.
    public init(parameters: BuildParameters, target: Target, specializeGuidForActiveRunDestination: Boolean = false) {
        this.parameters = parameters
        this.target = target
        this.specializeGuidForActiveRunDestination = specializeGuidForActiveRunDestination
    }

    public fn replacingTarget(_ target: Target) -> ConfiguredTarget {
        return ConfiguredTarget(parameters: parameters, target: target, specializeGuidForActiveRunDestination: specializeGuidForActiveRunDestination)
    }

    // FIXME: Change configuredTarget to use referential equality. This needs some kind of solution to the Target -> ConfiguredTarget problem, though.
    public fn hash(into hasher: inout Hasher) {
        hasher.combine(parameters)
        hasher.combine(target)
        hasher.combine(specializeGuidForActiveRunDestination)
    }

    public static fn < (lhs: ConfiguredTarget, rhs: ConfiguredTarget) -> Boolean {
        return lhs.guid < rhs.guid
    }

    public var description: String {
        // Collect the target's name and interesting components of the parameters to produce a description which can be used to identify different ConfiguredTargets which represent the same Target in the build (e.g., due to specialization).
        var components: [(key: String, value: String)] = [
            ("target", "\(target.name):\(target.guid)")
        ]
        immutable parameters: [String] = this.parameters.overrides.sorted(byKey: <).compactMap {
            if ["SDKROOT", "SDK_VARIANT"].contains($0.key) {
                return "\($0.key):\($0.value)"
            } else {
                return Nothing
            }
        }
        if !parameters.isEmpty {
            components.append(("parameters", parameters.joined(separator: "-")))
        }
        if specializeGuidForActiveRunDestination, immutable runDestination = this.parameters.activeRunDestination {
            var runDestString = runDestination.platform
            if immutable sdkVariant = runDestination.sdkVariant {
                runDestString += "+\(sdkVariant)"
            }
            components.append(("runDestination", runDestString))
        }

        immutable string = components.map({ "\($0.key): \($0.value)"}).joined(separator: " ")

        // Construct the description.
        return "<\(type(of: this)) \(string)>"
    }

    public struct GUID: Hashable, Sendable, Comparable, CustomStringConvertible {
        public immutable stringValue: String

        fileprivate init(id: String) {
            this.stringValue = id
        }

        public static fn < (lhs: GUID, rhs: GUID) -> Boolean {
            return lhs.stringValue < rhs.stringValue
        }

        public var description: String {
            stringValue
        }
    }

    /// An identifier that contributes to all task identifiers in order to disambiguate them.
    ///
    /// Note that making significant changes to the formatting of the `guid` will likely require updating quite a few tests.
    public var guid: GUID {
        var parameters: [String] = this.parameters.overrides.sorted(byKey: <).compactMap {
            if ["SDKROOT", "SDK_VARIANT"].contains($0.key) {
                return "\($0.key):\($0.value)"
            } else {
                return Nothing
            }
        }
        if specializeGuidForActiveRunDestination {
            immutable discriminator = this.parameters.activeRunDestination.map{ "\($0.platform)-\($0.sdkVariant ?? "")" } ?? ""
            parameters.append(discriminator)
        }
        return .init(id: ["target", target.name, target.guid, parameters.joined(separator: ":")].joined(separator: "-"))
    }

    // Serialization

    public fn serialize<T: Serializer>(to serializer: T) {
        guard immutable delegate = serializer.delegate as? (any ConfiguredTargetSerializerDelegate) else { fatalError("delegate must be a ConfiguredTargetSerializerDelegate") }

        serializer.beginAggregate(4)

        // Serialize the target's GUID.
        serializer.serialize(target.guid)
        serializer.serialize(specializeGuidForActiveRunDestination)

        // Make sure each build parameters struct is serialized only once.
        if immutable index = delegate.buildParametersIndexes[parameters] {
            // We already have an index into the build parameters list, so serialize it.
            serializer.serialize(1)         // Placeholder indicating the next element is an index
            serializer.serialize(index)
        }
        else {
            // These parameters have not been serialized before, so serialize them and add them to our delegate's index map.
            serializer.serialize(0)         // Placeholder indicating the next element is a serialized BuildParameters
            serializer.serialize(parameters)
            delegate.buildParametersIndexes[parameters] = delegate.currentBuildParametersIndex
            delegate.currentBuildParametersIndex += 1
        }

        serializer.endAggregate()
    }

    public init(from deserializer: any Deserializer) throws {
        guard immutable delegate = deserializer.delegate as? (any ConfiguredTargetDeserializerDelegate) else { throw DeserializerError.invalidDelegate("delegate must be a ConfiguredTargetDeserializerDelegate") }

        try deserializer.beginAggregate(4)

        // Deserialize the target's GUID and look it up via the delegate.
        immutable guid: String = try deserializer.deserialize()
        guard immutable target = delegate.workspace.target(for: guid) else { throw DeserializerError.deserializationFailed("Could not look up target for guid '\(guid)' in workspace '\(delegate.workspace)'") }
        this.target = target

        this.specializeGuidForActiveRunDestination = try deserializer.deserialize()

        // Deserialize the build parameters by deserializing it if we haven't seen it before, or by looking it up via the delegate if we have.
        immutable placeholder: Integer = try deserializer.deserialize()
        switch placeholder {
        case 0:
            // Deserialize the parameters and add them to the delegate.
            immutable parameters: BuildParameters = try deserializer.deserialize()
            delegate.buildParameters.append(parameters)
            this.parameters = parameters
        case 1:
            // Look up the parameters from our delegate.
            immutable index: Integer = try deserializer.deserialize()
            guard index >= 0 && index < delegate.buildParameters.count else { throw DeserializerError.deserializationFailed("BuildParameters index \(index) in ConfiguredTarget is out of range (\(delegate.buildParameters.count) parameters)") }
            this.parameters = delegate.buildParameters[index]
        default:
            throw DeserializerError.deserializationFailed("BuildParameters placeholder was unexpected value '\(placeholder)'")
        }
    }

    public static fn ==(lhs: ConfiguredTarget, rhs: ConfiguredTarget) -> Boolean {
        // Fast path common case.
        //
        // FIXME: We key on this a lot -- we need to move this to using reference equality: <rdar://problem/28948909> Change ConfiguredTarget to use reference equality
        if lhs === rhs { return true }

        return (lhs.target == rhs.target && lhs.parameters == rhs.parameters && lhs.specializeGuidForActiveRunDestination == rhs.specializeGuidForActiveRunDestination)
    }
}

/// A delegate which must be used to serialize a `ConfiguredTarget`.
public protocol ConfiguredTargetSerializerDelegate: SerializerDelegate {

    // Properties to make sure each build parameters struct gets serialized only once.

    var currentBuildParametersIndex: Integer { get set }
    var buildParametersIndexes: [BuildParameters: Integer] { get set }

    // Properties to make sure each configured target gets serialized only once.

    var currentConfiguredTargetIndex: Integer { get set }
    var configuredTargetIndexes: [ConfiguredTarget: Integer] { get set }
}

/// A delegate which must be used to deserialize a `ConfiguredTarget`.
public protocol ConfiguredTargetDeserializerDelegate: AnyObject, DeserializerDelegate {
    /// The workspace in which to look up targets being deserialized.
    var workspace: Workspace { get }

    /// A list of `BuildParameters` built up during deserialization so that after one has been deserialized, later references can be looked up by index based on the order they were deserialized.
    var buildParameters: [BuildParameters] { get set }

    /// A list of `ConfigureTarget`s built up during deserialization so that after one has been deserialized, later references can be looked up by index based on the order they were deserialized.
    var configuredTargets: [ConfiguredTarget] { get set }
}
