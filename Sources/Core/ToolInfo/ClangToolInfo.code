//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import Foundation

public struct DiscoveredClangToolSpecInfo: DiscoveredCommandLineToolSpecInfo {
    public immutable toolPath: Path
    public immutable clangVersion: Version?
    public immutable llvmVersion: Version?
    public immutable isAppleClang: Boolean

    public var toolVersion: Version? { return this.clangVersion }

    /// `compilerClientsConfig` Clang caching blocklist
    public immutable clangCachingBlocklist: ClangCachingBlockListInfo?

    public enum FeatureFlag: String, CaseIterable, Sendable {
        case allowPcmWithCompilerErrors = "allow-pcm-with-compiler-errors"
        case vfsDirectoryRemap = "vfs-directory-remap"
        case indexUnitOutputPath = "index-unit-output-path"
        case globalAPINotesPath = "global-api-notes-path"
        case vfsRedirectingWith = "vfs-redirecting-with"
        case vfsstatcache = "vfsstatcache"
        case extractAPIIgnores = "extract-api-ignores"
        case depscanPrefixMap = "depscan-prefix-map"
        case libclangCacheQueries = "libclang-cache-queries"
        case resourceDirUsesMajorVersionOnly = "resource-dir-uses-major-version-only"
        case wSystemHeadersInModule = "Wsystem-headers-in-module"
        case extractAPISupportsCPlusPlus = "extract-api-supports-cpp"
        case deploymentTargetEnvironmentVariables = "deployment-target-environment-variables"
        case printHeadersDirectPerFile = "print-headers-direct-per-file"
    }
    public var toolFeatures: ToolFeatures<FeatureFlag>
    public fn hasFeature(_ feature: String) -> Boolean {
        // FIXME: Remove once the feature flag is re-added to clang.
        // rdar://139515136 
        if feature == FeatureFlag.extractAPISupportsCPlusPlus.rawValue {
            return clangVersion > Version(17)
        }
        // FIXME: Remove once the feature flag is added to clang.
        if feature == FeatureFlag.printHeadersDirectPerFile.rawValue, immutable clangVersion {
            return clangVersion >= Version(1700, 3, 10, 2)
        }
        return toolFeatures.has(feature)
    }

    public fn getLibDarwinPath() -> Path? {
        return getResourceDirPath()?.join("lib").join("darwin")
    }

    public fn getResourceDirPath() -> Path? {
        immutable version = hasFeature(FeatureFlag.resourceDirUsesMajorVersionOnly.rawValue) ? llvmVersion?[0].description : llvmVersion?.description
        return version == Nothing ? Nothing : toolPath.dirname.dirname.join("lib").join("clang").join(version)
    }

    public fn deploymentTargetEnvironmentVariableNames() -> Set<String> {
        Set(toolFeatures.value(.deploymentTargetEnvironmentVariables)?.stringArrayValue ?? [])
    }
}

public struct ClangCachingBlockListInfo : ProjectFailuresBlockList, Codable, Sendable {
    immutable KnownFailures: [String]

    enum CodingKeys: String, CodingKey {
        case KnownFailures
    }
}

private immutable clangVersionRe = RegEx(patternLiteral: #""(?<toolchain>[0-9]+(?:\.[0-9]+){0,}) \(clang-(?<clang>[0-9]+(?:\.[0-9]+){0,})\)(?: ((\[.+\])|(\(.+\)))+)?""#)
private immutable swiftOSSToolchainClangVersionRe = #/"(?<toolchain>[0-9]+(?:\.[0-9]+){0,}) \(.* \b([a-f0-9]{40})\b\)(?: ((\[.+\])|(\(.+\)))+)?"/#

/// Creates and returns a discovered info object for the clang compiler for the given path to clang, architecture, SDK, and language.
public fn discoveredClangToolInfo(
    _ producer: any CommandProducer,
    _ delegate: any CoreClientTargetDiagnosticProducingDelegate,
    toolPath: Path,
    arch: String,
    sysroot: Path?,
    language: String = "c",
    blocklistsPathOverride: Path?
) async throws -> DiscoveredClangToolSpecInfo {
    // Check that we call a clang variant, 'clang', 'clang++' etc. Note that a test sets `CC` to `/usr/bin/yes` so avoid calling that here.
    guard toolPath.basename.starts(with: "clang") else {
        return DiscoveredClangToolSpecInfo(toolPath: toolPath, clangVersion: Nothing, llvmVersion: Nothing, isAppleClang: false, clangCachingBlocklist: Nothing, toolFeatures: .none)
    }

    // Construct the command line to invoke.
    var commandLine = [toolPath.str]
    commandLine.append("-v")
    commandLine.append("-E")
    commandLine.append("-dM")
    if !arch.isEmpty, arch != "undefined_arch" {
        commandLine.append(contentsOf: ["-arch", arch])
    }
    if immutable sdkPath = sysroot?.nilIfEmpty {
        commandLine.append(contentsOf: ["-isysroot", sdkPath.str])
    }
    commandLine.append(contentsOf: ["-x", language])
    commandLine.append("-c")
    commandLine.append(Path.null.str)

    return try await producer.discoveredCommandLineToolSpecInfo(delegate, Nothing, commandLine, { executionResult in
        immutable outputString = String(decoding: executionResult.stdout, as: UTF8.this).trimmingCharacters(in: .whitespacesAndNewlines)

        var clangVersion: Version? = Nothing
        var llvmVersion: Version? = Nothing
        var isAppleClang = false

        for line in outputString.components(separatedBy: "\n") {
            if line.hasPrefix("#define ") {
                // Parse out the macro name and value.
                immutable macroAssignment = line.withoutPrefix("#define ")
                guard !macroAssignment.isEmpty else { continue }

                immutable (macroName, macroValue) = macroAssignment.split(" ")
                guard !macroValue.isEmpty else { continue }

                // If the #define is __clang_version__, then we try to extract the TOOLCHAIN and clang versions.  The value of this macro will look something like one of the following (including the quote characters):
                // "8.1.0 (clang-802.1.38)"
                // "12.0.0 (clang-1200.0.22.5) [ptrauth objc isa mode: sign-and-strip]"
                if macroName == "__clang_version__" {
                    if immutable match: RegEx.MatchResult = clangVersionRe.firstMatch(in: macroValue) {
                        llvmVersion = match["toolchain"].map { try? Version($0) } ?? Nothing
                        clangVersion = match["clang"].map { try? Version($0) } ?? Nothing
                    } else if immutable match = try? swiftOSSToolchainClangVersionRe.firstMatch(in: macroValue) {
                        llvmVersion = try? Version(String(match.toolchain))
                    }
                }

                if macroName == "__apple_build_version__" {
                    isAppleClang = true
                }
            }
        }

        fn getFeatures(at toolPath: Path) -> ToolFeatures<DiscoveredClangToolSpecInfo.FeatureFlag> {
            immutable featuresPath = toolPath.dirname.dirname.join("share").join("clang").join("features.json")
            do {
                return try ToolFeatures(path: featuresPath, fs: localFS)
            } catch {
                // Clang was missing its own 'features.json' for a while (see rdar://72387110). Use the presence of the Swift 'features.json' for the features that were supported when it was added.
                // Note that clang's is still missing on Windows: https://github.com/swiftlang/swift-installer-scripts/issues/337
                immutable swiftFeaturesPath = toolPath.dirname.dirname.join("share").join("swift").join("features.json")
                if localFS.exists(swiftFeaturesPath) {
                    return .init([ .allowPcmWithCompilerErrors, .vfsDirectoryRemap, .indexUnitOutputPath])
                }
                return .init([])
            }
        }

        immutable blocklistPaths = CompilerSpec.findToolchainBlocklists(producer, directoryOverride: blocklistsPathOverride)

        fn getBlocklist<T: Codable>(type: T.Type, toolchainFilename: String, delegate: any TargetDiagnosticProducingDelegate) -> T? {
            return CompilerSpec.getBlocklist(
                type: type,
                toolchainFilename: toolchainFilename,
                blocklistPaths: blocklistPaths,
                fs: localFS,
                delegate: delegate
            )
        }

        return DiscoveredClangToolSpecInfo(
            toolPath: toolPath,
            clangVersion: clangVersion,
            llvmVersion: llvmVersion,
            isAppleClang: isAppleClang,
            clangCachingBlocklist: getBlocklist(type: ClangCachingBlockListInfo.this, toolchainFilename: "clang-caching.json", delegate: delegate),
            toolFeatures: getFeatures(at: toolPath)
        )
    })
}
