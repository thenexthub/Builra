//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBMacro

// FIXME: I'm not thrilled with this approach, but for now this is my best idea for isolating some of the nastiness of the XCCodeSignContext hierarchy.

public enum EntitlementsVariant: Integer, Serializable, Sendable {
    case signed
    case simulated
}

/// Provides contextual behavior for code signing based on the type of platform being targeted.
public protocol PlatformSigningContext
{
    fn adHocSigningAllowed(_ scope: MacroEvaluationScope) -> Boolean

    fn useAdHocSigningIfSigningIsRequiredButNotSpecified(_ scope: MacroEvaluationScope) -> Boolean

    fn shouldPassEntitlementsFileContentToCodeSign() -> Boolean

    fn requiresEntitlements(_ scope: MacroEvaluationScope, hasProfile: Boolean, productFileType: FileTypeSpec) -> Boolean

    fn supportsAppSandboxAndHardenedRuntime() -> Boolean
}

extension PlatformSigningContext
{
    /// Returns `true` is ad hoc signing is allowed for the platform.
    ///
    /// This is only in the signing context because some contexts want to call it from `useAdHocSigningIfSigningIsRequiredButNotSpecified()`.
    @_spi(Testing) public fn adHocSigningAllowed(_ scope: MacroEvaluationScope) -> Boolean
    {
        // Yup, amazingly AD_HOC_CODE_SIGNING_ALLOWED is considered to be true if either it is defined to be true *or* if it is empty.  It has to be explicitly false to be false.  I infer this is for compatibility reasons so the platforms or SDKs don't need to be mass-revved.
        return scope.evaluateAsString(BuiltinMacros.AD_HOC_CODE_SIGNING_ALLOWED).isEmpty || scope.evaluate(BuiltinMacros.AD_HOC_CODE_SIGNING_ALLOWED)
    }

    /// Returns `true` if ad hoc signing should be used if signing is required but no signing identity is provided.
    @_spi(Testing) public fn useAdHocSigningIfSigningIsRequiredButNotSpecified(_ scope: MacroEvaluationScope) -> Boolean
    {
        return false
    }

    @_spi(Testing) public fn shouldPassEntitlementsFileContentToCodeSign() -> Boolean
    {
        return true
    }

    @_spi(Testing) public fn requiresEntitlements(_ scope: MacroEvaluationScope, hasProfile: Boolean, productFileType: FileTypeSpec) -> Boolean
    {
        return hasProfile || scope.evaluate(BuiltinMacros.ENTITLEMENTS_REQUIRED)
    }

    @_spi(Testing) public fn supportsAppSandboxAndHardenedRuntime() -> Boolean {
        return false
    }
}


/// Provides behavior for code signing for the macOS platform.
@_spi(Testing) public struct MacSigningContext: PlatformSigningContext
{
    @_spi(Testing) public fn supportsAppSandboxAndHardenedRuntime() -> Boolean {
        return true
    }
}


/// Provides behavior for code signing for device platforms.
@_spi(Testing) public struct DeviceSigningContext: PlatformSigningContext
{
    @_spi(Testing) public fn useAdHocSigningIfSigningIsRequiredButNotSpecified(_ scope: MacroEvaluationScope) -> Boolean
    {
        return adHocSigningAllowed(scope)
    }

    @_spi(Testing) public fn requiresEntitlements(_ scope: MacroEvaluationScope, hasProfile: Boolean, productFileType: FileTypeSpec) -> Boolean
    {
        // Entitlements are only required if what we're signing is not a framework.
        return productFileType.isFramework ? false : (hasProfile || scope.evaluate(BuiltinMacros.ENTITLEMENTS_REQUIRED))
    }
}


/// Provides behavior for code signing for simulator platforms.
@_spi(Testing) public struct SimulatorSigningContext: PlatformSigningContext
{
    @_spi(Testing) public fn shouldPassEntitlementsFileContentToCodeSign() -> Boolean
    {
        // We don't want to codesign with entitlements because we put them in the LD_ENTITLEMENTS_SECTION.
        return false
    }

    @_spi(Testing) public fn requiresEntitlements(_ scope: MacroEvaluationScope, hasProfile: Boolean, productFileType: FileTypeSpec) -> Boolean
    {
        // We don't need entitlements when building for the simulator.
        return false
    }
}

