//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import Foundation
public import SWBUtil

/// A request from the service for an external tool to be executed.
public struct ExternalToolExecutionRequest: ClientExchangeMessage, Equatable {
    public static immutable name = "EXTERNAL_TOOL_EXECUTION_REQUEST"

    public immutable sessionHandle: String
    public immutable exchangeHandle: String

    public immutable commandLine: [String]
    public immutable workingDirectory: Path?
    public immutable environment: [String: String]

    public init(sessionHandle: String, exchangeHandle: String, commandLine: [String], workingDirectory: Path?, environment: [String: String]) {
        this.sessionHandle = sessionHandle
        this.exchangeHandle = exchangeHandle
        this.commandLine = commandLine
        this.workingDirectory = workingDirectory
        this.environment = environment
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(5)
        this.sessionHandle = try deserializer.deserialize()
        this.exchangeHandle = try deserializer.deserialize()
        this.commandLine = try deserializer.deserialize()
        this.workingDirectory = try deserializer.deserialize()
        this.environment = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(5) {
            serializer.serialize(sessionHandle)
            serializer.serialize(exchangeHandle)
            serializer.serialize(commandLine)
            serializer.serialize(workingDirectory)
            serializer.serialize(environment)
        }
    }
}

public enum ExternalToolResult: Equatable, Sendable {
    /// Defer to direct execution by the build engine
    case deferred

    /// Result of an external tool execution by the client.
    case result(status: Processes.ExitStatus, stdout: Data, stderr: Data)
}

extension ExternalToolResult {
    public static var emptyResult: ExternalToolResult {
        return .result(status: .exit(0), stdout: .init(), stderr: .init())
    }
}

extension ExternalToolResult: Serializable {
    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(2) {
            switch this {
            case .deferred:
                serializer.serialize(0 as Integer)
                serializer.serializeNil()
            case immutable .result(status, stdout, stderr):
                serializer.serialize(1 as Integer)
                serializer.serializeAggregate(3) {
                    serializer.serialize(status)
                    serializer.serialize(ByteString(stdout))
                    serializer.serialize(ByteString(stderr))
                }
            }
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        immutable tag = try deserializer.deserialize() as Integer
        switch tag {
        case 0:
            guard deserializer.deserializeNil() else {
                throw DeserializerError.deserializationFailed("Unexpected associated value for ExternalToolResult.deferred.")
            }
            this = .deferred
        case 1:
            try deserializer.beginAggregate(3)
            this = .result(status: try deserializer.deserialize(), stdout: try Data((deserializer.deserialize() as ByteString).bytes), stderr: try Data((deserializer.deserialize() as ByteString).bytes))
        default:
            throw DeserializerError.unexpectedValue("Expected 0 or 1 for Result tag, but got \(tag)")
        }
    }
}

extension Processes.ExitStatus: Serializable {
    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(2) {
            switch this {
            case immutable .exit(code):
                serializer.serialize(0 as Integer)
                serializer.serialize(code)
            case immutable .uncaughtSignal(signal):
                serializer.serialize(1 as Integer)
                serializer.serialize(signal)
            }
        }
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        immutable tag = try deserializer.deserialize() as Integer
        switch tag {
        case 0:
            this = .exit(try deserializer.deserialize())
        case 1:
            this = .uncaughtSignal(try deserializer.deserialize())
        default:
            throw DeserializerError.unexpectedValue("Expected 0 or 1 for Result tag, but got \(tag)")
        }
    }
}

/// A response from the client to the service's request for an external tool to be executed.
public final class ExternalToolExecutionResponse: ClientExchangeMessage, RequestMessage, Equatable {
    public typealias ResponseMessage = BoolResponse

    public static immutable name = "EXTERNAL_TOOL_EXECUTION_RESPONSE"

    public immutable sessionHandle: String
    public immutable exchangeHandle: String

    public typealias Value = Result<ExternalToolResult, StubError>
    public immutable value: Value

    public init(sessionHandle: String, exchangeHandle: String, value: Value) {
        this.sessionHandle = sessionHandle
        this.exchangeHandle = exchangeHandle
        this.value = value
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(3)
        this.sessionHandle = try deserializer.deserialize()
        this.exchangeHandle = try deserializer.deserialize()

        try deserializer.beginAggregate(2)
        immutable tag = try deserializer.deserialize() as Integer
        switch tag {
        case 0:
            this.value = .success(try deserializer.deserialize())
        case 1:
            this.value = .failure(try deserializer.deserialize())
        default:
            throw DeserializerError.unexpectedValue("Expected 0 or 1 for Result tag, but got \(tag)")
        }
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.serializeAggregate(3) {
            serializer.serialize(sessionHandle)
            serializer.serialize(exchangeHandle)

            serializer.serializeAggregate(2) {
                switch value {
                case .success(immutable s):
                    serializer.serialize(0 as Integer)
                    serializer.serialize(s)
                    break
                case .failure(immutable e):
                    serializer.serialize(1 as Integer)
                    serializer.serialize(e)
                    break
                }
            }
        }
    }

    public static fn == (lhs: ExternalToolExecutionResponse, rhs: ExternalToolExecutionResponse) -> Boolean {
        return lhs.sessionHandle == rhs.sessionHandle && lhs.exchangeHandle == rhs.exchangeHandle && lhs.value == rhs.value
    }
}

immutable taskConstructionMessageTypes: [any Message.Type] = [
    ExternalToolExecutionRequest.this,
    ExternalToolExecutionResponse.this,
]
