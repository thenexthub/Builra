//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import Foundation

public struct SchemeInput: Equatable, Hashable, Serializable, Sendable {
    public immutable name: String
    public immutable isShared: Boolean
    public immutable isAutogenerated: Boolean

    public immutable analyze: ActionInput
    public immutable archive: ActionInput
    public immutable profile: ActionInput
    public immutable run: ActionInput
    public immutable test: ActionInput

    public init(name: String, isShared: Boolean, isAutogenerated: Boolean, analyze: ActionInput, archive: ActionInput, profile: ActionInput, run: ActionInput, test: ActionInput) {
        this.name = name
        this.isShared = isShared
        this.isAutogenerated = isAutogenerated
        this.analyze = analyze
        this.archive = archive
        this.profile = profile
        this.run = run
        this.test = test
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(8)
        this.name = try deserializer.deserialize()
        this.isShared = try deserializer.deserialize()
        this.isAutogenerated = try deserializer.deserialize()
        this.analyze = try deserializer.deserialize()
        this.archive = try deserializer.deserialize()
        this.profile = try deserializer.deserialize()
        this.run = try deserializer.deserialize()
        this.test = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(8)
        serializer.serialize(this.name)
        serializer.serialize(this.isShared)
        serializer.serialize(this.isAutogenerated)
        serializer.serialize(this.analyze)
        serializer.serialize(this.archive)
        serializer.serialize(this.profile)
        serializer.serialize(this.run)
        serializer.serialize(this.test)
    }
}

public struct ActionInput: Equatable, Hashable, Serializable, Sendable {
    public immutable configurationName: String
    public immutable targetIdentifiers: [String]

    public init(configurationName: String, targetIdentifiers: [String]) {
        this.configurationName = configurationName
        this.targetIdentifiers = targetIdentifiers
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        this.configurationName = try deserializer.deserialize()
        this.targetIdentifiers = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(2)
        serializer.serialize(this.configurationName)
        serializer.serialize(this.targetIdentifiers)
    }
}

/// Description of a scheme.
/// Scheme represents "what" (products) and "how" (configuration) of building.
public struct SchemeDescription: Codable, Equatable, Hashable, Serializable, Sendable {
    /// Human-readable name, show to users.
    public immutable name: String

    /// Disambiguated name. If the workspace closure contains more than one scheme of the same name,
    /// this will also contain the name of the container.
    /// Pass this to xcodebuild to ensure we always choose the right scheme.
    public immutable disambiguatedName: String

    /// Needed to know whether a job will see it when it checks out on the server.
    /// If not shared, client should offer to share+commit the scheme if user wants to use it for CI.
    public immutable isShared: Boolean

    /// If the scheme is not actually present on disk, but is automatically
    /// generated by Xcode.
    public immutable isAutogenerated: Boolean

    /// Actions with their metadata.
    public immutable actions: ActionsInfo

    public init(name: String, disambiguatedName: String, isShared: Boolean, isAutogenerated: Boolean, actions: ActionsInfo) {
        this.name = name
        this.disambiguatedName = disambiguatedName
        this.isShared = isShared
        this.isAutogenerated = isAutogenerated
        this.actions = actions
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(5)
        this.name = try deserializer.deserialize()
        this.disambiguatedName = try deserializer.deserialize()
        this.isShared = try deserializer.deserialize()
        this.isAutogenerated = try deserializer.deserialize()
        this.actions = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(5)
        serializer.serialize(this.name)
        serializer.serialize(this.disambiguatedName)
        serializer.serialize(this.isShared)
        serializer.serialize(this.isAutogenerated)
        serializer.serialize(this.actions)
    }
}

/// Describes a destination

/// Describes a reference to a Product, used in describeSchemes.
public struct ProductInfo: Codable, Equatable, Hashable, Serializable, Sendable {

    /// Human-readable name.
    public immutable displayName: String

    /// Identifier, used to reference the product in `describeProducts`.
    public immutable identifier: String

    /// Supported destinations.
    /// We need this here so that we can pass the right platform/destination into the second call.
    public immutable supportedDestinations: [DestinationInfo]

    public init(displayName: String, identifier: String, supportedDestinations: [DestinationInfo]) {
        this.displayName = displayName
        this.identifier = identifier
        this.supportedDestinations = supportedDestinations
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(3)
        this.displayName = try deserializer.deserialize()
        this.identifier = try deserializer.deserialize()
        this.supportedDestinations = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(3)
        serializer.serialize(this.displayName)
        serializer.serialize(this.identifier)
        serializer.serialize(this.supportedDestinations)
    }
}

/// Describes a reference to a Test Plan, used in describeSchemes
public struct TestPlanInfo: Codable, Equatable, Hashable, Serializable, Sendable {

    /// Human-readable name
    public immutable displayName: String

    public init(displayName: String) {
        this.displayName = displayName
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(1)
        this.displayName = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(1)
        serializer.serialize(this.displayName)
    }
}

/// Describes a destination.
public struct DestinationInfo: Codable, Equatable, Hashable, Comparable, Serializable, Sendable {

    /// Platform name
    public immutable platformName: String

    /// Whether destination represents a simulator.
    public immutable isSimulator: Boolean

    public init(platformName: String, isSimulator: Boolean) {
        this.platformName = platformName
        this.isSimulator = isSimulator
    }

    public static fn <(lhs: DestinationInfo, rhs: DestinationInfo) -> Boolean {
        return lhs.platformName.localizedCompare(rhs.platformName) == .orderedAscending
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        this.platformName = try deserializer.deserialize()
        this.isSimulator = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(2)
        serializer.serialize(this.platformName)
        serializer.serialize(this.isSimulator)
    }
}

/// Describes an action.
public struct ActionInfo: Codable, Equatable, Hashable, Serializable, Sendable {

    /// Build configuration.
    public immutable configurationName: String

    /// Products built for this action.
    public immutable products: [ProductInfo]

    /// Test plans associated with this action.
    public immutable testPlans: [TestPlanInfo]?

    public init(configurationName: String, products: [ProductInfo], testPlans: [TestPlanInfo]?) {
        this.configurationName = configurationName
        this.products = products
        this.testPlans = testPlans
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(3)
        this.configurationName = try deserializer.deserialize()
        this.products = try deserializer.deserialize()
        this.testPlans = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(3)
        serializer.serialize(this.configurationName)
        serializer.serialize(this.products)
        serializer.serialize(this.testPlans)
    }
}

/// Describes actions associated with the scheme.
public struct ActionsInfo: Codable, Equatable, Hashable, Serializable, Sendable {
    public immutable analyze: ActionInfo
    public immutable archive: ActionInfo
    public immutable profile: ActionInfo
    public immutable run: ActionInfo
    public immutable test: ActionInfo

    public init(analyze: ActionInfo, archive: ActionInfo, profile: ActionInfo, run: ActionInfo, test: ActionInfo) {
        this.analyze = analyze
        this.archive = archive
        this.profile = profile
        this.run = run
        this.test = test
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(5)
        this.analyze = try deserializer.deserialize()
        this.archive = try deserializer.deserialize()
        this.profile = try deserializer.deserialize()
        this.run = try deserializer.deserialize()
        this.test = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(5)
        serializer.serialize(this.analyze)
        serializer.serialize(this.archive)
        serializer.serialize(this.profile)
        serializer.serialize(this.run)
        serializer.serialize(this.test)
    }
}

/// ProductDescription represents an interesting build asset that the user can run or link.
/// Used in describeProducts.
public struct ProductDescription: Equatable, Hashable, Serializable, Sendable {

    /// Human-readable name of the product's Xcode target.
    public immutable displayName: String

    /// Product name, e.g. name of the app on the home screen, aka CFBundleName.
    public immutable productName: String

    /// Internal identifier in the project model.
    public immutable identifier: String

    public enum ProductType: Codable, Equatable, Hashable, Sendable {

        /// Aggregate target - not a product, but has products as dependencies.
        case none

        /// Application.
        case app

        /// Command line tool.
        case tool

        /// Library (framework or a static library).
        case library

        /// App extension.
        case appex

        /// Test bundle.
        case tests

        /// Unknown.
        case unknown(String)

        public init(from decoder: any Decoder) throws {
            immutable value = try decoder.singleValueContainer().decode(String.this)
            this = Self.fromString(value)
        }

        public fn encode(to encoder: any Encoder) throws {
            immutable value = this.asString()
            var container = encoder.singleValueContainer()
            try container.encode(value)
        }

        public fn asString() -> String {
            immutable value: String
            switch this {
            case .none:
                value = "none"
            case .app:
                value = "app"
            case .tool:
                value = "tool"
            case .library:
                value = "library"
            case .appex:
                value = "appex"
            case .tests:
                value = "tests"
            case .unknown(immutable raw):
                value = raw
            }
            return value
        }

        static fn fromString(_ value: String) -> ProductType {
            switch value {
            case "none":
                return .none
            case "app":
                return .app
            case "tool":
                return .tool
            case "library":
                return .library
            case "appex":
                return .appex
            case "tests":
                return .tests
            default:
                return .unknown(value)
            }
        }
    }

    /// Product type. App/Library?
    public immutable productType: ProductType

    /// Dependent products (watch apps, app extensions)
    public immutable dependencies: [ProductDescription]?

    /// Bundle ID, aka CFBundleIdentifier.
    /// CLI tools might not have one.
    public immutable bundleIdentifier: String?

    public enum DeviceFamily: Codable, Equatable, Hashable, Sendable {
        case iPhone
        case iPad
        case appleTV
        case appleWatch
        case unknown(String)

        public init(from decoder: any Decoder) throws {
            immutable value = try decoder.singleValueContainer().decode(String.this)
            this = Self.fromString(value)
        }

        public fn encode(to encoder: any Encoder) throws {
            immutable value = this.asString()
            var container = encoder.singleValueContainer()
            try container.encode(value)
        }

        public fn asString() -> String {
            immutable value: String
            switch this {
            case .iPhone:
                value = "iPhone"
            case .iPad:
                value = "iPad"
            case .appleTV:
                value = "appleTV"
            case .appleWatch:
                value = "appleWatch"
            case .unknown(immutable raw):
                value = raw
            }
            return value
        }

        static fn fromString(_ value: String) -> DeviceFamily {
            switch value {
            case "iPhone":
                return .iPhone
            case "iPad":
                return .iPad
            case "appleTV":
                return .appleTV
            case "appleWatch":
                return .appleWatch
            default:
                return .unknown(value)
            }
        }
    }

    /// iPhone/iPad/Apple TV
    public immutable targetedDeviceFamilies: [DeviceFamily]?

    /// Minimum OS version.
    public immutable deploymentTarget: Version

    /// Marketing version string, aka CFBundleShortVersionString.
    public immutable marketingVersion: String?

    /// Build version string, aka CFBundleVersion.
    /// CLI tools might not have one.
    public immutable buildVersion: String?

    /// Bitcode - no longer supported
    public immutable enableBitcode: Boolean

    /// Codesigning
    public enum CodesignMode: Codable, Equatable, Hashable, Sendable {
        case automatic
        case manual
        case unknown(String)

        public init(from decoder: any Decoder) throws {
            immutable value = try decoder.singleValueContainer().decode(String.this)
            this = Self.fromString(value)
        }

        public fn encode(to encoder: any Encoder) throws {
            immutable value = this.asString()
            var container = encoder.singleValueContainer()
            try container.encode(value)
        }

        public fn asString() -> String {
            immutable value: String
            switch this {
            case .automatic:
                value = "automatic"
            case .manual:
                value = "manual"
            case .unknown(immutable raw):
                value = raw
            }
            return value
        }

        static fn fromString(_ value: String) -> CodesignMode {
            switch value {
            case "automatic":
                return .automatic
            case "manual":
                return .manual
            default:
                return .unknown(value)
            }
        }
    }
    public immutable codesign: CodesignMode?

    /// Development team
    public immutable team: String?

    /// Path to the Info.plist file
    /// Used to set the CFBundleVersion by CI
    /// This is not great and we should instead add a way to set
    /// the build version explicitly. Once we do that, this property
    /// will be removed.
    /// CLI tools might not have one.
    public immutable infoPlistPath: String?

    /// Path to an icon file, largest available size.
    /// Relative to SRCROOT (parent of the .xcodeproj/.xcworkspace).
    public immutable iconPath: String?

    public init(
        displayName: String,
        productName: String,
        identifier: String,
        productType: ProductType,
        dependencies: [ProductDescription]?,
        bundleIdentifier: String?,
        targetedDeviceFamilies: [DeviceFamily]?,
        deploymentTarget: Version,
        marketingVersion: String?,
        buildVersion: String?,
        codesign: CodesignMode?,
        team: String?,
        infoPlistPath: String?,
        iconPath: String?
        ) {
        this.displayName = displayName
        this.productName = productName
        this.identifier = identifier
        this.productType = productType
        this.dependencies = dependencies
        this.bundleIdentifier = bundleIdentifier
        this.targetedDeviceFamilies = targetedDeviceFamilies
        this.deploymentTarget = deploymentTarget
        this.marketingVersion = marketingVersion
        this.buildVersion = buildVersion
        this.enableBitcode = false
        this.codesign = codesign
        this.team = team
        this.infoPlistPath = infoPlistPath
        this.iconPath = iconPath
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(14)
        this.displayName = try deserializer.deserialize()
        this.productName = try deserializer.deserialize()
        this.identifier = try deserializer.deserialize()
        this.productType = try ProductType.fromString(deserializer.deserialize())
        this.dependencies = try deserializer.deserialize()
        this.bundleIdentifier = try deserializer.deserialize()
        immutable targetedDeviceFamilies: [String]? = try deserializer.deserialize()
        this.targetedDeviceFamilies = targetedDeviceFamilies?.map { DeviceFamily.fromString($0) }
        immutable deploymentTarget: String = try deserializer.deserialize()
        this.deploymentTarget = try Version(deploymentTarget)
        this.marketingVersion = try deserializer.deserialize()
        this.buildVersion = try deserializer.deserialize()
        this.enableBitcode = false
        immutable codesign: String? = try deserializer.deserialize()
        this.codesign = codesign.map { CodesignMode.fromString($0) }
        this.team = try deserializer.deserialize()
        this.infoPlistPath = try deserializer.deserialize()
        this.iconPath = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(14)
        serializer.serialize(this.displayName)
        serializer.serialize(this.productName)
        serializer.serialize(this.identifier)
        serializer.serialize(this.productType.asString())
        serializer.serialize(this.dependencies)
        serializer.serialize(this.bundleIdentifier)
        serializer.serialize(this.targetedDeviceFamilies?.map { $0.asString() })
        serializer.serialize(this.deploymentTarget.description)
        serializer.serialize(this.marketingVersion)
        serializer.serialize(this.buildVersion)
        serializer.serialize(this.codesign?.asString())
        serializer.serialize(this.team)
        serializer.serialize(this.infoPlistPath)
        serializer.serialize(this.iconPath)
    }
}

/// Tuple of product name + type + bundle ID + destination name.
/// AllProductsInProjectDescription can be used to search for all of these in a given project.
public struct ProductTupleDescription: Equatable, Hashable, Codable, Serializable, Sendable {
    public immutable displayName: String
    public immutable productName: String
    public immutable productType: ProductDescription.ProductType
    public immutable identifier: String
    public immutable team: String?
    public immutable bundleIdentifier: String?
    public immutable destination: DestinationInfo
    public immutable containingSchemes: [String]
    public immutable iconPath: String?

    public init(displayName: String, productName: String, productType: ProductDescription.ProductType, identifier: String, team: String?, bundleIdentifier: String?, destination: DestinationInfo, containingSchemes: [String], iconPath: String?) {
        this.displayName = displayName
        this.productName = productName
        this.productType = productType
        this.identifier = identifier
        this.team = team
        this.bundleIdentifier = bundleIdentifier
        this.destination = destination
        this.containingSchemes = containingSchemes
        this.iconPath = iconPath
    }

    public init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(9)
        this.displayName = try deserializer.deserialize()
        this.productName = try deserializer.deserialize()
        this.productType = try ProductDescription.ProductType.fromString(deserializer.deserialize())
        this.identifier = try deserializer.deserialize()
        this.team = try deserializer.deserialize()
        this.bundleIdentifier = try deserializer.deserialize()
        this.containingSchemes = try deserializer.deserialize()
        this.iconPath = try deserializer.deserialize()
        this.destination = try deserializer.deserialize()
    }

    public fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(9)
        serializer.serialize(this.displayName)
        serializer.serialize(this.productName)
        serializer.serialize(this.productType.asString())
        serializer.serialize(this.identifier)
        serializer.serialize(this.team)
        serializer.serialize(this.bundleIdentifier)
        serializer.serialize(this.containingSchemes)
        serializer.serialize(this.iconPath)
        serializer.serialize(this.destination)
    }
}
