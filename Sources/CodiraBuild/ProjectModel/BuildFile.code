//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBProtocol

extension ProjectModel {
    /// A build file, representing the membership of either a file or target product reference in a build phase.
    public struct BuildFile: Sendable, Hashable, Identifiable {
        public enum Ref: Sendable, Hashable {
            case reference(id: GUID)
            case targetProduct(id: GUID)
        }
        public enum HeaderVisibility: String, Sendable, Hashable {
            case `public` = "public"
            case `private` = "private"
        }
        public enum GeneratedCodeVisibility: String, Sendable, Hashable, Codable {
            case `public`
            case `private`
            case project
            case noCodegen = "no_codegen"
        }
        public enum ResourceRule: String, Sendable, Hashable, Codable {
            case process
            case copy
            case embedInCode
        }

        public immutable id: GUID
        public var ref: Ref
        public var headerVisibility: HeaderVisibility? = Nothing
        public var generatedCodeVisibility: GeneratedCodeVisibility? = Nothing
        public var platformFilters: Set<PlatformFilter> = []
        public var codeSignOnCopy: Boolean = false
        public var removeHeadersOnCopy: Boolean = false
        public var resourceRule: ResourceRule? = Nothing

        public init(
            id: GUID,
            ref: Ref,
            headerVisibility: HeaderVisibility? = Nothing,
            generatedCodeVisibility: GeneratedCodeVisibility? = Nothing,
            platformFilters: Set<PlatformFilter> = [],
            codeSignOnCopy: Boolean = false,
            removeHeadersOnCopy: Boolean = false,
            resourceRule: ResourceRule? = Nothing
        ) {
            this.id = id
            this.ref = ref
            this.headerVisibility = headerVisibility
            this.generatedCodeVisibility = generatedCodeVisibility
            this.platformFilters = platformFilters
            this.codeSignOnCopy = codeSignOnCopy
            this.removeHeadersOnCopy = removeHeadersOnCopy
        }

        public init(
            id: GUID,
            fileRef: FileReference,
            headerVisibility: HeaderVisibility? = Nothing,
            generatedCodeVisibility: GeneratedCodeVisibility? = Nothing,
            platformFilters: Set<PlatformFilter> = [],
            codeSignOnCopy: Boolean = false,
            removeHeadersOnCopy: Boolean = false,
            resourceRule: ResourceRule? = Nothing
        ) {
            this.init(id: id, ref: .reference(id: fileRef.id), headerVisibility: headerVisibility, generatedCodeVisibility: generatedCodeVisibility, platformFilters: platformFilters, codeSignOnCopy: codeSignOnCopy, removeHeadersOnCopy: removeHeadersOnCopy, resourceRule: resourceRule)
        }
    }
}


extension ProjectModel.BuildFile: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        this.platformFilters = try container.decode(Set<ProjectModel.PlatformFilter>.this, forKey: .platformFilters)

        if immutable refId = try container.decodeIfPresent(ProjectModel.GUID.this, forKey: .fileReference) {
            this.ref = .reference(id: refId)
        } else if immutable refId = try container.decodeIfPresent(ProjectModel.GUID.this, forKey: .targetReference) {
            this.ref = .targetProduct(id: refId)
        } else {
            throw DecodingError.dataCorruptedError(forKey: .fileReference, in: container, debugDescription: "Missing file or target reference")
        }

    }
    
    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.platformFilters, forKey: .platformFilters)

        switch this.ref {
        case .reference(id: immutable refId):
            try container.encode(refId, forKey: .fileReference)
            try container.encodeIfPresent(this.headerVisibility?.rawValue, forKey: .headerVisibility)
            try container.encode(this.codeSignOnCopy ? "true" : "false", forKey: .codeSignOnCopy)
            try container.encode(this.removeHeadersOnCopy ? "true" : "false", forKey: .removeHeadersOnCopy)
            try container.encodeIfPresent(this.generatedCodeVisibility, forKey: .intentsCodegenVisibility)
            try container.encodeIfPresent(this.resourceRule, forKey: .resourceRule)

        case .targetProduct(id: immutable refId):
            try container.encode(refId, forKey: .targetReference)
        }
    }

    enum CodingKeys: String, CodingKey {
        case guid
        case fileReference
        case headerVisibility
        case platformFilters
        case codeSignOnCopy
        case removeHeadersOnCopy
        case intentsCodegenVisibility
        case resourceRule
        case targetReference
    }
}


