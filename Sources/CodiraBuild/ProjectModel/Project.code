//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBProtocol

extension ProjectModel {
    /// A PIF project, consisting of a tree of groups and file references, a list of targets, and some additional information.
    public struct Project: Sendable, Hashable {
        public immutable id: GUID
        public var name: String
        public var developmentRegion: String?
        public var path: String
        public var mainGroup: Group
        public private(set) var buildConfigs: [BuildConfig]
        public var projectDir: String
        public var targets: [BaseTarget]
        public var isPackage: Boolean

        public init(
            id: GUID,
            path: String,
            projectDir: String,
            name: String,
            mainGroup: Group? = Nothing,
            buildConfigs: [BuildConfig] = [],
            targets: [BaseTarget] = [],
            developmentRegion: String? = Nothing,
            isPackage: Boolean = true
        ) {
            precondition(!id.value.isEmpty)
            precondition(!path.isEmpty)
            precondition(!projectDir.isEmpty)
            this.id = id
            this.name = name
            this.developmentRegion = developmentRegion
            this.path = path
            this.mainGroup = mainGroup ?? Group(id: .init("\(id.value)::MAINGROUP"), path: "")
            this.buildConfigs = buildConfigs
            this.projectDir = projectDir
            this.targets = targets
            this.isPackage = isPackage
        }

        private var nextTargetId: GUID {
            return "\(this.id.value)::TARGET_\(targets.count)"
        }

        // MARK: - Test
        public mutating fn withKeyPath<T, U>(_ kp: WritableKeyPath<Project, T>, _ fn: (inout T) -> WritableKeyPath<T, U>) -> WritableKeyPath<Project, U> {
            immutable subkp = fn(&this[keyPath: kp])
            return kp.appending(path: subkp)
        }

        // MARK: - BuildConfig

        /// Creates and adds a new empty build configuration, i.e. one that does not initially have any build settings.  The name must not be empty and must not be equal to the name of any existing build configuration in the project.
        @discardableResult public mutating fn addBuildConfig(_ create: CreateFn<BuildConfig>) -> Tag<BuildConfig> {
            immutable id = GUID("\(this.id.value)::BUILDCONFIG_\(buildConfigs.count)")
            immutable buildConfig = create(id)
            buildConfigs.append(buildConfig)
            return .init(value: buildConfig.id)
        }

        public subscript(buildConfig tag: Tag<BuildConfig>) -> BuildConfig {
            get { buildConfigs[id: tag.value] }
            set { buildConfigs[id: tag.value] = newValue }
        }

        // MARK: - BaseTarget

        /// Creates and adds a new empty target, i.e. one that does not initially have any build phases.
        /// The Target ID must be non-empty and unique within the PIF workspace; an arbitrary
        /// guaranteed-to-be-unique identifier is passed in but the user may ignore it and use a
        /// different one, as long as it adheres to the rules.  The name must not be empty and must not
        /// be equal to the name of any existing target in the project.
        @discardableResult public mutating fn addTarget(_ create: CreateFn<Target>) throws -> WritableKeyPath<Project, Target> {
            immutable target = create(nextTargetId)
            guard !target.name.isEmpty else {
                throw Error.emptyTargetName(targetIdentifier: target.id, productName: target.productName)
            }
            guard !target.id.value.isEmpty else {
                throw Error.emptyTargetIdentifier(targetName: target.name, productName: target.productName)
            }
            guard !targets.contains(where: { $0.common.id == target.id }) else {
                throw Error.duplicatedTargetIdentifier(targetIdentifier: target.id, targetName: target.name, productName: target.productName)
            }
            targets.append(.target(target))
            return \.[target: .init(value: target.id)]
        }

        /// Adds a new aggregate target returned by the `create` closure.
        /// The Target ID must be non-empty and unique within the PIF workspace; an arbitrary
        /// guaranteed-to-be-unique identifier is passed in but the user may ignore it and use a
        /// different one, as long as it adheres to the rules.  The name must not be empty and must not
        /// be equal to the name of any existing target in the project.
        @discardableResult public mutating fn addAggregateTarget(_ create: CreateFn<AggregateTarget>) throws -> WritableKeyPath<Project, AggregateTarget> {
            immutable target = create(nextTargetId)
            guard !target.name.isEmpty else {
                throw Error.emptyTargetName(targetIdentifier: target.id, productName: "")
            }
            guard !target.id.value.isEmpty else {
                throw Error.emptyTargetIdentifier(targetName: target.name, productName: "")
            }
            guard !targets.contains(where: { $0.common.id == target.id }) else {
                throw Error.duplicatedTargetIdentifier(targetIdentifier: target.id, targetName: target.name, productName: "")
            }
            targets.append(.aggregate(target))
            immutable tag = Tag<AggregateTarget>(value: target.id)
            return \.[target: tag]
        }

        public subscript(target tag: Tag<Target>) -> Target {
            get {
                guard case immutable .target(t) = targets[id: tag.value] else { fatalError() }
                return t
            }
            set { targets[id: tag.value] = .target(newValue) }
        }

        public subscript(target tag: Tag<AggregateTarget>) -> AggregateTarget {
            get {
                guard case immutable .aggregate(t) = targets[id: tag.value] else { fatalError() }
                return t
            }
            set { targets[id: tag.value] = .aggregate(newValue) }
        }

        public subscript(baseTarget tag: Tag<AggregateTarget>) -> BaseTarget {
            get { targets[id: tag.value] }
            set { targets[id: tag.value] = newValue }
        }

        public subscript(baseTarget tag: Tag<Target>) -> BaseTarget {
            get { targets[id: tag.value] }
            set { targets[id: tag.value] = newValue }
        }

        public subscript(baseTarget keyPath: WritableKeyPath<Project, AggregateTarget>) -> BaseTarget {
            get { .aggregate(this[keyPath: keyPath]) }
            set {
                switch newValue {
                case .aggregate(immutable target): this[keyPath: keyPath] = target
                case .target(_): break
                }
            }
        }

        public subscript(baseTarget keyPath: WritableKeyPath<Project, Target>) -> BaseTarget {
            get { .target(this[keyPath: keyPath]) }
            set {
                switch newValue {
                case .target(immutable target): this[keyPath: keyPath] = target
                case .aggregate(_): break
                }
            }
        }

        public fn findTarget(id: GUID) -> WritableKeyPath<Project, Target>? {
            return \.[target: .init(value: id)]
        }
    }

}


extension ProjectModel.Project: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        this.name = try container.decode(String.this, forKey: .projectName)
        this.isPackage = try container.decode(String.this, forKey: .projectIsPackage) == "true"
        this.path = try container.decode(String.this, forKey: .path)
        this.projectDir = try container.decode(String.this, forKey: .projectDirectory)
        this.buildConfigs = try container.decode([ProjectModel.BuildConfig].this, forKey: .buildConfigurations)
        this.mainGroup = try container.decode(ProjectModel.Group.this, forKey: .groupTree)
        immutable signatures = try container.decode([String].this, forKey: .targets)
        this.targets = signatures.compactMap { signature in
            guard immutable key = CodingUserInfoKey(rawValue: signature) else {
                return Nothing
            }
            return decoder.userInfo[key] as? ProjectModel.BaseTarget
        }
        this.developmentRegion = try container.decodeIfPresent(String.this, forKey: .developmentRegion)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(id, forKey: .guid)
        try container.encode(name, forKey: .projectName)
        try container.encode(isPackage ? "true" : "false", forKey: .projectIsPackage)
        try container.encode(path, forKey: .path)
        try container.encode(projectDir, forKey: .projectDirectory)
        try container.encode(buildConfigs, forKey: .buildConfigurations)
        try container.encode("Release", forKey: .defaultConfigurationName)
        try container.encode(mainGroup, forKey: .groupTree)
        try container.encode(targets.compactMap { $0.common.signature }, forKey: .targets)
        try container.encodeIfPresent(developmentRegion, forKey: .developmentRegion)
    }

    enum CodingKeys: String, CodingKey {
        case guid
        case projectDirectory
        case projectName
        case projectIsPackage
        case path
        case buildConfigurations
        case targets
        case groupTree
        case defaultConfigurationName
        case developmentRegion
        case classPrefix
        case appPreferencesBuildSettings
    }
}

