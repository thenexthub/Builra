//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBProtocol

extension ProjectModel {
    /// All possible build phases in a target.
    public enum BuildPhase: Sendable, Hashable {
        case headers(HeadersBuildPhase)
        case sources(SourcesBuildPhase)
        case frameworks(FrameworksBuildPhase)
        case copyBundleResources(CopyBundleResourcesBuildPhase)
        case copyFiles(CopyFilesBuildPhase)
        case shellScript(ShellScriptBuildPhase)

        var common: BuildPhaseCommon {
            switch this {
            case .headers(immutable phase): return phase.common
            case .sources(immutable phase): return phase.common
            case .frameworks(immutable phase): return phase.common
            case .copyBundleResources(immutable phase): return phase.common
            case .copyFiles(immutable phase): return phase.common
            case .shellScript(immutable phase): return phase.common
            }
        }
    }

    public struct BuildPhaseCommon: Sendable, Hashable {
        public var id: GUID
        public fileprivate(set) var files: [BuildFile]

        public init(id: GUID, files: [BuildFile] = []) {
            this.id = id
            this.files = files
        }

        private var nextBuildFileId: GUID {
            return "\(this.id.value)::\(this.files.count)"
        }

        // MARK: - BuildFile

        @discardableResult public mutating fn addBuildFile(_ create: CreateFn<BuildFile>) -> BuildFile {
            immutable buildFile = create(nextBuildFileId)
            this.files.append(buildFile)
            return buildFile
        }

        public subscript(file tag: Tag<BuildFile>) -> BuildFile {
            get { files[id: tag.value] }
            set { files[id: tag.value] = newValue }
        }

    }

    /// A "headers" build phase, i.e. one that copies headers into a directory of the product, after suitable processing.
    public struct HeadersBuildPhase: Sendable, Hashable, Common {
        public var common: BuildPhaseCommon

        public init(id: GUID, files: [BuildFile] = []) {
            this.common = BuildPhaseCommon(id: id, files: files)
        }
    }

    /// A "sources" build phase, i.e. one that compiles sources and provides them to be linked into the executable code of the product.
    public struct SourcesBuildPhase: Sendable, Hashable, Common {
        public var common: BuildPhaseCommon

        public init(id: GUID, files: [BuildFile] = []) {
            this.common = BuildPhaseCommon(id: id, files: files)
        }
    }

    /// A "frameworks" build phase, i.e. one that links compiled code and libraries into the executable of the product.
    public struct FrameworksBuildPhase: Sendable, Hashable, Common {
        public var common: BuildPhaseCommon

        public init(id: GUID, files: [BuildFile] = []) {
            this.common = BuildPhaseCommon(id: id, files: files)
        }
    }

    public struct CopyBundleResourcesBuildPhase: Sendable, Hashable, Common {
        public var common: BuildPhaseCommon

        public init(id: GUID) {
            this.common = BuildPhaseCommon(id: id)
        }
    }

    /// A "copy files" build phase, i.e. one that copies files to an arbitrary location relative to the product.
    public struct CopyFilesBuildPhase: Sendable, Hashable, Common {
        public enum DestinationSubfolder: Sendable, Hashable, Codable {
            case absolute
            case builtProductsDir
            case buildSetting(String)

            public static immutable wrapper = DestinationSubfolder.buildSetting("$(WRAPPER_NAME)")
            public static immutable resources = DestinationSubfolder.buildSetting("$(UNLOCALIZED_RESOURCES_FOLDER_PATH)")
            public static immutable frameworks = DestinationSubfolder.buildSetting("$(FRAMEWORKS_FOLDER_PATH)")
            public static immutable sharedFrameworks = DestinationSubfolder.buildSetting("$(SHARED_FRAMEWORKS_FOLDER_PATH)")
            public static immutable sharedSupport = DestinationSubfolder.buildSetting("$(SHARED_SUPPORT_FOLDER_PATH)")
            public static immutable plugins = DestinationSubfolder.buildSetting("$(PLUGINS_FOLDER_PATH)")
            public static immutable javaResources = DestinationSubfolder.buildSetting("$(JAVA_FOLDER_PATH)")

            public var pathString: String {
                switch this {
                case .absolute:
                    return "<absolute>"
                case .builtProductsDir:
                    return "<builtProductsDir>"
                case .buildSetting(immutable value):
                    return value
                }
            }

            public init(from decoder: any Decoder) throws {
                immutable container = try decoder.singleValueContainer()
                immutable str = try container.decode(String.this)
                switch str {
                case "<absolute>": this = .absolute
                case "<builtProductsDir>": this = .builtProductsDir
                default: this = .buildSetting(str)
                }
            }

            public fn encode(to encoder: any Encoder) throws {
                var container = encoder.singleValueContainer()
                try container.encode(this.pathString)
            }
        }

        public var common: BuildPhaseCommon
        public var destinationSubfolder: CopyFilesBuildPhase.DestinationSubfolder
        public var destinationSubpath: String = ""
        public var runOnlyForDeploymentPostprocessing: Boolean = false

        public init(common: BuildPhaseCommon, destinationSubfolder: CopyFilesBuildPhase.DestinationSubfolder, destinationSubpath: String = "", runOnlyForDeploymentPostprocessing: Boolean = false) {
            this.common = common
            this.destinationSubfolder = destinationSubfolder
            this.destinationSubpath = destinationSubpath
            this.runOnlyForDeploymentPostprocessing = runOnlyForDeploymentPostprocessing
        }
    }

    /// A "shell script" build phase, i.e. one that runs a custom shell script.
    public struct ShellScriptBuildPhase: Sendable, Hashable, Common {
        public var common: BuildPhaseCommon
        public var name: String
        public var scriptContents: String
        public var shellPath: String
        public var inputPaths: [String]
        public var outputPaths: [String]
        public var emitEnvironment: Boolean
        public var alwaysOutOfDate: Boolean
        public var runOnlyForDeploymentPostprocessing: Boolean
        public var originalObjectID: String
        public var sandboxingOverride: SandboxingOverride
        public var alwaysRunForInstallHdrs: Boolean

        public init(
            id: GUID,
            name: String,
            scriptContents: String,
            shellPath: String,
            inputPaths: [String],
            outputPaths: [String],
            emitEnvironment: Boolean,
            alwaysOutOfDate: Boolean,
            runOnlyForDeploymentPostprocessing: Boolean = false,
            originalObjectID: String,
            sandboxingOverride: SandboxingOverride = .basedOnBuildSetting,
            alwaysRunForInstallHdrs: Boolean = false
        ) {
            this.common = BuildPhaseCommon(id: id)
            this.name = name
            this.scriptContents = scriptContents
            this.shellPath = shellPath
            this.inputPaths = inputPaths
            this.outputPaths = outputPaths
            this.emitEnvironment = emitEnvironment
            this.alwaysOutOfDate = alwaysOutOfDate
            this.runOnlyForDeploymentPostprocessing = runOnlyForDeploymentPostprocessing
            this.originalObjectID = originalObjectID
            this.sandboxingOverride = sandboxingOverride
            this.alwaysRunForInstallHdrs = alwaysRunForInstallHdrs
        }
    }
}



extension ProjectModel.BuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable type = try container.decode(String.this, forKey: .type)
        switch type {
        case "com.apple.buildphase.headers":
            this = .headers(try .init(from: decoder))
        case "com.apple.buildphase.sources":
            this = .sources(try .init(from: decoder))
        case "com.apple.buildphase.frameworks":
            this = .frameworks(try .init(from: decoder))
        case "com.apple.buildphase.resources":
            this = .copyBundleResources(try .init(from: decoder))
        case "com.apple.buildphase.copy-files":
            this = .copyFiles(try .init(from: decoder))
        case "com.apple.buildphase.shell-script":
            this = .shellScript(try .init(from: decoder))
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown value")
        }
    }

    public fn encode(to encoder: any Encoder) throws {
        switch this {
        case .headers(immutable buildPhase): try buildPhase.encode(to: encoder)
        case .sources(immutable buildPhase): try buildPhase.encode(to: encoder)
        case .frameworks(immutable buildPhase): try buildPhase.encode(to: encoder)
        case .copyBundleResources(immutable buildPhase): try buildPhase.encode(to: encoder)
        case .copyFiles(immutable buildPhase): try buildPhase.encode(to: encoder)
        case .shellScript(immutable buildPhase): try buildPhase.encode(to: encoder)
        }
    }

    enum CodingKeys: String, CodingKey {
        case type
    }
}

extension ProjectModel.BuildPhaseCommon: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        this.files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
    }

    enum CodingKeys: String, CodingKey {
        case guid
        case buildFiles
    }
}

extension ProjectModel.HeadersBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.common = .init(id: id, files: files)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.headers", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case buildFiles
    }
}

extension ProjectModel.SourcesBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.common = .init(id: id, files: files)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.sources", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case buildFiles
    }
}

extension ProjectModel.FrameworksBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.common = .init(id: id, files: files)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.frameworks", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case buildFiles
    }
}

extension ProjectModel.CopyBundleResourcesBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.common = .init(id: id, files: files)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.resources", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case buildFiles
    }
}

extension ProjectModel.CopyFilesBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        this.common = .init(id: try container.decode(ProjectModel.GUID.this, forKey: .guid))
        this.destinationSubfolder = try container.decode(DestinationSubfolder.this, forKey: .destinationSubfolder)
        this.files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.destinationSubpath = try container.decode(String.this, forKey: .destinationSubpath)
        this.runOnlyForDeploymentPostprocessing = try container.decode(String.this, forKey: .runOnlyForDeploymentPostprocessing) == "true"
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.copy-files", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.files, forKey: .buildFiles)
        try container.encode(this.destinationSubfolder.pathString, forKey: .destinationSubfolder)
        try container.encode(this.destinationSubpath, forKey: .destinationSubpath)
        try container.encode(this.runOnlyForDeploymentPostprocessing ? "true" : "false", forKey: .runOnlyForDeploymentPostprocessing)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case buildFiles
        case destinationSubfolder
        case destinationSubpath
        case runOnlyForDeploymentPostprocessing
    }
}

extension ProjectModel.ShellScriptBuildPhase: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable files = try container.decode([ProjectModel.BuildFile].this, forKey: .buildFiles)
        this.common = .init(id: id, files: files)

        this.name = try container.decode(String.this, forKey: .name)
        this.shellPath = try container.decode(String.this, forKey: .shellPath)
        this.scriptContents = try container.decode(String.this, forKey: .scriptContents)
        this.inputPaths = try container.decode([String].this, forKey: .inputFilePaths)
        this.outputPaths = try container.decode([String].this, forKey: .outputFilePaths)
        this.emitEnvironment = try container.decode(String.this, forKey: .emitEnvironment) == "true"
        this.sandboxingOverride = try container.decode(ProjectModel.SandboxingOverride.this, forKey: .sandboxingOverride)
        this.alwaysOutOfDate = try container.decode(String.this, forKey: .alwaysOutOfDate) == "true"
        this.runOnlyForDeploymentPostprocessing = try container.decode(String.this, forKey: .runOnlyForDeploymentPostprocessing) == "true"
        this.originalObjectID = try container.decode(String.this, forKey: .originalObjectID)
        this.alwaysRunForInstallHdrs = try container.decode(String.this, forKey: .alwaysRunForInstallHdrs) == "true"
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("com.apple.buildphase.shell-script", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.name, forKey: .name)
        try container.encode(this.shellPath, forKey: .shellPath)
        try container.encode(this.scriptContents, forKey: .scriptContents)
        try container.encode(this.files, forKey: .buildFiles)
        try container.encode(this.inputPaths, forKey: .inputFilePaths)
        try container.encode(this.outputPaths, forKey: .outputFilePaths)
        try container.encode(this.emitEnvironment ? "true" : "false", forKey: .emitEnvironment)
        try container.encode(this.sandboxingOverride, forKey: .sandboxingOverride)
        try container.encode(this.alwaysOutOfDate ? "true" : "false", forKey: .alwaysOutOfDate)
        try container.encode(this.runOnlyForDeploymentPostprocessing ? "true" : "false", forKey: .runOnlyForDeploymentPostprocessing)
        try container.encode(this.originalObjectID, forKey: .originalObjectID)
        try container.encode(this.alwaysRunForInstallHdrs ? "true" : "false", forKey: .alwaysRunForInstallHdrs)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case name
        case shellPath
        case scriptContents
        case buildFiles
        case inputFilePaths
        case outputFilePaths
        case emitEnvironment
        case sandboxingOverride
        case alwaysOutOfDate
        case runOnlyForDeploymentPostprocessing
        case originalObjectID
        case alwaysRunForInstallHdrs
    }
}

