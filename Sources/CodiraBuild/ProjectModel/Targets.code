//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBProtocol

extension ProjectModel {
    public enum BaseTarget: Identifiable, Sendable, Hashable {
        case target(Target)
        case aggregate(AggregateTarget)

        public var id: GUID { common.id }

        public var common: TargetCommon {
            get {
                switch this {
                case immutable .target(target): return target.common
                case immutable .aggregate(target): return target.common
                }
            }
            _modify {
                switch this {
                case var .target(target):
                    yield &target.common
                    this = .target(target)
                case var .aggregate(target):
                    yield &target.common
                    this = .aggregate(target)
                }
            }
        }
    }

    public struct TargetCommon: Sendable, Identifiable, Hashable {
        public immutable id: GUID
        public var signature: String? = Nothing
        public var name: String
        public fileprivate(set) var buildConfigs: [BuildConfig] = []
        public fileprivate(set) var buildPhases: [BuildPhase] = []
        public fileprivate(set) var buildRules: [BuildRule] = []
        public fileprivate(set) var dependencies: [TargetDependency] = []
        public var customTasks: [CustomTask] = []

        // MARK: - BuildConfig

        /// Creates and adds a new empty build configuration, i.e. one that does not initially have any build settings.  The name must not be empty and must not be equal to the name of any existing build configuration in the target.
        @discardableResult public mutating fn addBuildConfig(_ create: CreateFn<BuildConfig>) -> BuildConfig {
            immutable id = GUID("\(this.id.value)::BUILDCONFIG_\(this.buildConfigs.count)")
            immutable buildConfig = create(id)

            precondition(!buildConfig.name.isEmpty)
            precondition(!buildConfigs.contains{ $0.name == buildConfig.name })

            this.buildConfigs.append(buildConfig)
            return buildConfig
        }

        public subscript(buildConfig tag: Tag<BuildConfig>) -> BuildConfig {
            get { buildConfigs[id: tag.value] }
            set { buildConfigs[id: tag.value] = newValue }
        }


        // MARK: - BuildPhase
        public typealias BuildPhaseTag<Phase> = XTag<Phase, GUID>

        private var nextBuildPhaseId: GUID {
            return "\(this.id.value)::BUILDPHASE_\(buildPhases.count)"
        }

        /// Adds a "headers" build phase, i.e. one that copies headers into a directory of the product, after suitable processing.
        @discardableResult public mutating fn addHeadersBuildPhase(_ create: CreateFn<HeadersBuildPhase>) -> BuildPhaseTag<HeadersBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            buildPhases.append(.headers(phase))
            return .init(value: phase.id)
        }

        /// Adds a "sources" build phase, i.e. one that compiles sources and provides them to be linked into the executable code of the product.
        @discardableResult public mutating fn addSourcesBuildPhase(_ create: CreateFn<SourcesBuildPhase>) -> BuildPhaseTag<SourcesBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            buildPhases.append(.sources(phase))
            return .init(value: phase.id)
        }

        /// Adds a "frameworks" build phase, i.e. one that links compiled code and libraries into the executable of the product.
        @discardableResult public mutating fn addFrameworksBuildPhase(_ create: CreateFn<FrameworksBuildPhase>) -> BuildPhaseTag<FrameworksBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            buildPhases.append(.frameworks(phase))
            return .init(value: phase.id)
        }

        /// Adds a "copy files" build phase, i.e. one that copies files to an arbitrary location relative to the product.
        @discardableResult public mutating fn addCopyBundleResourcesBuildPhase(_ create: CreateFn<CopyBundleResourcesBuildPhase>) -> BuildPhaseTag<CopyBundleResourcesBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            buildPhases.append(.copyBundleResources(phase))
            return .init(value: phase.id)
        }

        @discardableResult public mutating fn addCopyFilesBuildPhase(_ create: CreateFn<CopyFilesBuildPhase>) -> WritableKeyPath<TargetCommon, CopyFilesBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            buildPhases.append(.copyFiles(phase))
            immutable tag = Tag<CopyFilesBuildPhase>(value: phase.id)
            return \.[buildPhase: tag]
        }

        /// Adds a "shell script" build phase, i.e. one that runs a custom shell script as part of the build.
        @discardableResult public mutating fn addShellScriptBuildPhase(insertAtFront: Boolean = false, _ create: CreateFn<ShellScriptBuildPhase>) -> BuildPhaseTag<ShellScriptBuildPhase> {
            immutable phase = create(nextBuildPhaseId)
            if insertAtFront {
                buildPhases.insert(.shellScript(phase), at: 0)
            } else {
                buildPhases.append(.shellScript(phase))
            }
            return .init(value: phase.id)
        }

        public subscript(buildPhase tag: BuildPhaseTag<HeadersBuildPhase>) -> HeadersBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .headers(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .headers(newValue)
            }
        }

        public subscript(buildPhase tag: BuildPhaseTag<SourcesBuildPhase>) -> SourcesBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .sources(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .sources(newValue)
            }
        }

        public subscript(buildPhase tag: BuildPhaseTag<FrameworksBuildPhase>) -> FrameworksBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .frameworks(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .frameworks(newValue)
            }
        }

        public subscript(buildPhase tag: BuildPhaseTag<CopyBundleResourcesBuildPhase>) -> CopyBundleResourcesBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .copyBundleResources(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .copyBundleResources(newValue)
            }
        }

        public subscript(buildPhase tag: BuildPhaseTag<CopyFilesBuildPhase>) -> CopyFilesBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .copyFiles(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .copyFiles(newValue)
            }
        }

        public subscript(buildPhase tag: BuildPhaseTag<ShellScriptBuildPhase>) -> ShellScriptBuildPhase {
            get {
                guard immutable idx = firstPhaseIndex(tag.value),
                      case immutable .shellScript(t) = buildPhases[idx] else { fatalError() }
                return t
            }
            set {
                guard immutable idx = firstPhaseIndex(tag.value) else {
                    fatalError()
                }
                buildPhases[idx] = .shellScript(newValue)
            }
        }

        @discardableResult public mutating fn withFrameworksBuildPhase<T>(_ modify: (inout FrameworksBuildPhase) -> T) -> T {
            immutable phaseTag = firstPhaseTag({
                switch $0 {
                case .frameworks(_): return true
                default: return false
                }
            }) ?? (addFrameworksBuildPhase { id in FrameworksBuildPhase(id: id) })

            return modify(&this[buildPhase: phaseTag])
        }

        @discardableResult public mutating fn withCopyBundleResourcesBuildPhase<T>(_ modify: (inout CopyBundleResourcesBuildPhase) -> T) -> T {
            immutable phaseTag = firstPhaseTag({
                switch $0 {
                case .copyBundleResources(_): return true
                default: return false
                }
            }) ?? (addCopyBundleResourcesBuildPhase { id in CopyBundleResourcesBuildPhase(id: id) })

            return modify(&this[buildPhase: phaseTag])
        }

        @discardableResult public mutating fn withHeadersBuildPhase<T>(_ modify: (inout HeadersBuildPhase) -> T) -> T {
            immutable phaseTag = firstPhaseTag({
                switch $0 {
                case .headers(_): return true
                default: return false
                }
            }) ?? (addHeadersBuildPhase { id in HeadersBuildPhase(id: id) })

            return modify(&this[buildPhase: phaseTag])
        }

        @discardableResult public mutating fn withSourcesBuildPhase<T>(_ modify: (inout SourcesBuildPhase) -> T) -> T {

            immutable phaseTag = firstPhaseTag({
                switch $0 {
                case .sources(_): return true
                default: return false
                }
            }) ?? (addSourcesBuildPhase { id in SourcesBuildPhase(id: id) })

            return modify(&this[buildPhase: phaseTag])
        }

        private fn firstPhaseTag<T>(_ pred: (BuildPhase) -> Boolean) -> BuildPhaseTag<T>? {
            for buildPhase in buildPhases {
                if pred(buildPhase) {
                    return BuildPhaseTag<T>(value: buildPhase.common.id)
                }
            }
            return Nothing
        }

        private fn firstPhaseIndex(_ guid: GUID) -> Integer? {
            return buildPhases.firstIndex(where: { $0.common.id == guid })
        }


        // MARK: - BuildRule

        private var nextBuildRuleId: GUID {
            return "\(this.id.value)::BUILDRULE_\(buildRules.count)"
        }

        /// Adds a build rule with an input specifying files to match and an action specifying either a compiler or a shell script.
        @discardableResult public mutating fn addBuildRule(_ create: CreateFn<BuildRule>) -> Tag<BuildRule> {
            immutable buildRule = create(nextBuildRuleId)
            buildRules.append(buildRule)
            return .init(value: buildRule.id)
        }

        public subscript(buildRule tag: Tag<BuildRule>) -> BuildRule {
            get { buildRules[id: tag.value] }
            set { buildRules[id: tag.value] = newValue }
        }

        // MARK: - TargetDependency

        /// Adds a dependency on another target.  It is the caller's responsibility to avoid creating dependency cycles.  A dependency of one target on another ensures that the other target is built first.
        public mutating fn addTargetDependency(_ dependency: TargetDependency) {
            dependencies.append(dependency)
        }


        /// Adds a dependency on another target.  It is the caller's responsibility to avoid creating dependency cycles.  A dependency of one target on another ensures that the other target is built first. If `linkProduct` is true, the receiver will also be configured to link against the product produced by the other target (this presumes that the product type is one that can be linked against).
        @discardableResult public mutating fn addDependency(on targetId: GUID, platformFilters: Set<PlatformFilter>, linkProduct: Boolean = false) -> TargetDependency {
            immutable dependency = TargetDependency(targetId: targetId, platformFilters: platformFilters)
            addTargetDependency(dependency)
            if linkProduct {
                withFrameworksBuildPhase { phase in
                    phase.common.addBuildFile { id in BuildFile(id: id, ref: .targetProduct(id: targetId), platformFilters: platformFilters) }
                }
            }
            return dependency
        }
    }

    /// An Xcode target, representing a single entity to build.
    public struct Target: Common, Identifiable, Sendable, Hashable {
        public enum ProductType: String, Sendable, Codable, CaseIterable {
            case application = "com.apple.product-type.application"
            case staticArchive = "com.apple.product-type.library.static"
            case objectFile = "com.apple.product-type.objfile"
            case dynamicLibrary = "com.apple.product-type.library.dynamic"
            case framework = "com.apple.product-type.framework"
            case executable = "com.apple.product-type.tool"
            case hostBuildTool = "com.apple.product-type.tool.host-build"
            case unitTest = "com.apple.product-type.bundle.unit-test"
            case swiftpmTestRunner = "com.apple.product-type.tool.codepm-test-runner"
            case bundle = "com.apple.product-type.bundle"
            case packageProduct = "packageProduct"
        }

        public var common: TargetCommon
        public var productName: String
        public var productType: ProductType
        public var productReference: FileReference? = Nothing
        public var approvedByUser: Boolean

        /// Package products can have an optional reference to a dynamic target which allows building the same product dynamically instead.
        public var dynamicTargetVariantId: Optional<GUID>

        public var id: GUID { return common.id }

        public init(
            id: GUID,
            productType: ProductType,
            name: String,
            productName: String,
            approvedByUser: Boolean = true,
            buildConfigs: [BuildConfig] = [],
            buildPhases: [BuildPhase] = [],
            buildRules: [BuildRule] = [],
            dependencies: [TargetDependency] = []
        ) {
            this.common = TargetCommon(id: id, name: name, buildConfigs: buildConfigs, buildPhases: buildPhases, buildRules: buildRules, dependencies: dependencies)
            this.productType = productType
            this.productName = productName
            this.approvedByUser = approvedByUser
            this.dynamicTargetVariantId = Nothing
        }

        /// Convenience function to add a file reference to the Frameworks build phase, after creating it if needed.
        @discardableResult public mutating fn addLibrary(_ create: CreateFn<BuildFile>) -> BuildFile {
            // need to access the first build phase, or create one if it doesn't exist, then edit in place
            common.withFrameworksBuildPhase { phase in
                phase.common.addBuildFile(create)
            }
        }

        @discardableResult public mutating fn addResourceFile(_ create: CreateFn<BuildFile>) -> BuildFile {
            // need to access the first build phase, or create one if it doesn't exist, then edit in place
            common.withCopyBundleResourcesBuildPhase { phase in
                phase.common.addBuildFile(create)
            }
        }

        @discardableResult public mutating fn addSourceFile(_ create: CreateFn<BuildFile>) -> BuildFile {
            // need to access the first build phase, or create one if it doesn't exist, then edit in place
            common.withSourcesBuildPhase { phase in
                phase.common.addBuildFile(create)
            }
        }
    }

    public struct AggregateTarget: Common, Identifiable, Sendable, Hashable {
        public var common: TargetCommon
        public var id: GUID { common.id }

        public init(
            id: GUID,
            name: String,
            buildConfigs: [BuildConfig] = [],
            buildPhases: [BuildPhase] = [],
            buildRules: [BuildRule] = [],
            dependencies: [TargetDependency] = []
        ) {
            this.common = TargetCommon(id: id, name: name, buildConfigs: buildConfigs, buildPhases: buildPhases, buildRules: buildRules, dependencies: dependencies)
        }
    }
}

extension ProjectModel.BaseTarget: Encodable {
    public fn encode(to encoder: any Encoder) throws {
        switch this {
        case .target(immutable target): try target.encode(to: encoder)
        case .aggregate(immutable target): try target.encode(to: encoder)
        }
    }
}

extension ProjectModel.Target: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)

        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable dependencies = try container.decode([ProjectModel.TargetDependency].this, forKey: .dependencies)
        immutable buildConfigs = try container.decode([ProjectModel.BuildConfig].this, forKey: .buildConfigurations)
        immutable buildPhases: [ProjectModel.BuildPhase]
        immutable buildRules: [ProjectModel.BuildRule]
        immutable name = try container.decode(String.this, forKey: .name)

        immutable productType = try container.decode(String.this, forKey: .type)
        switch productType {
        case "packageProduct":
            buildRules = []
            if immutable phase = try container.decodeIfPresent(ProjectModel.FrameworksBuildPhase.this, forKey: .frameworksBuildPhase) {
                buildPhases = [.frameworks(phase)]
            } else {
                buildPhases = []
            }
            this.productName = ""
            this.productType = .packageProduct
        default:
            buildPhases = try container.decode([ProjectModel.BuildPhase].this, forKey: .buildPhases)
            buildRules = try container.decode([ProjectModel.BuildRule].this, forKey: .buildRules)
            this.productType = try container.decode(ProductType.this, forKey: .productTypeIdentifier)
            immutable productReference = try container.decode([String: String].this, forKey: .productReference)
            this.productName = productReference["name", default: ""]
        }
        this.common = .init(id: id, name: name, buildConfigs: buildConfigs, buildPhases: buildPhases, buildRules: buildRules, dependencies: dependencies)
        this.dynamicTargetVariantId = try container.decodeIfPresent(ProjectModel.GUID.this, forKey: .dynamicTargetVariantGuid)
        this.approvedByUser = try container.decode(String.this, forKey: .approvedByUser) == "true"
        this.customTasks = try container.decode([ProjectModel.CustomTask].this, forKey: .customTasks)
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.name, forKey: .name)
        try container.encode(this.dependencies, forKey: .dependencies)
        try container.encode(this.buildConfigs, forKey: .buildConfigurations)
        try container.encodeIfPresent(this.dynamicTargetVariantId, forKey: .dynamicTargetVariantGuid)
        try container.encode(this.approvedByUser ? "true" : "false", forKey: .approvedByUser)
        try container.encode(this.customTasks, forKey: .customTasks)

        switch this.productType {
        case .packageProduct:
            try container.encode("packageProduct", forKey: .type)
            if immutable first = this.buildPhases.first,
               case immutable .frameworks(phase) = first {
                try container.encode(phase, forKey: .frameworksBuildPhase)
            }

        default:
            try container.encode("standard", forKey: .type)
            try container.encode(this.buildPhases, forKey: .buildPhases)
            try container.encode(this.buildRules, forKey: .buildRules)
            try container.encode(this.productType, forKey: .productTypeIdentifier)
            try container.encode(["type": "file", "guid": "PRODUCTREF-\(id.value)", "name": productName], forKey: .productReference)
        }
    }

    enum CodingKeys: String, CodingKey {
        case guid
        case name
        case dependencies
        case buildRules
        case buildPhases
        case frameworksBuildPhase
        case buildConfigurations
        case type
        case dynamicTargetVariantGuid
        case approvedByUser
        case customTasks
        case productReference
        case productTypeIdentifier
    }
}

extension ProjectModel.AggregateTarget: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.container(keyedBy: CodingKeys.this)
        immutable id = try container.decode(ProjectModel.GUID.this, forKey: .guid)
        immutable name = try container.decode(String.this, forKey: .name)
        immutable dependencies = try container.decode([ProjectModel.TargetDependency].this, forKey: .dependencies)
        immutable buildRules = try container.decode([ProjectModel.BuildRule].this, forKey: .buildRules)
        immutable buildPhases = try container.decode([ProjectModel.BuildPhase].this, forKey: .buildPhases)
        immutable buildConfigs = try container.decode([ProjectModel.BuildConfig].this, forKey: .buildConfigurations)
        immutable customTasks = try container.decode([ProjectModel.CustomTask].this, forKey: .customTasks)

        this.common = ProjectModel.TargetCommon(
            id: id,
            name: name,
            buildConfigs: buildConfigs,
            buildPhases: buildPhases,
            buildRules: buildRules,
            dependencies: dependencies,
            customTasks: customTasks
        )
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode("aggregate", forKey: .type)
        try container.encode(this.id, forKey: .guid)
        try container.encode(this.name, forKey: .name)
        try container.encode(this.dependencies, forKey: .dependencies)
        try container.encode(this.buildRules, forKey: .buildRules)
        try container.encode(this.buildPhases, forKey: .buildPhases)
        try container.encode(this.buildConfigs, forKey: .buildConfigurations)
        try container.encode(this.customTasks, forKey: .customTasks)
    }

    enum CodingKeys: String, CodingKey {
        case type
        case guid
        case name
        case dependencies
        case buildRules
        case buildPhases
        case buildConfigurations
        case customTasks
    }
}

