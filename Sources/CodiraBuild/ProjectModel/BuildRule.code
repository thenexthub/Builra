//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBProtocol

extension ProjectModel {
    public struct BuildRule: Sendable, Hashable, Identifiable {
        public enum Input: Sendable, Hashable {
            case fileType(_ identifier: String)
            case filePattern(_ pattern: String)
        }

        public enum Action: Sendable, Hashable {
            case compiler(_ identifier: String)
            case shellScriptWithFileList(_ contents: String, inputPaths: [String], inputFileListPaths: [String], outputPaths: [String], outputFileListPaths: [String], outputFilesCompilerFlags: [String]?, dependencyInfo: DependencyInfoFormat?, runOncePerArchitecture: Boolean)

            public enum DependencyInfoFormat: Sendable, Hashable {
                case dependencyInfo(String)
                case makefile(String)
                case makefiles([String])
            }
        }

        public immutable id: GUID
        public var name: String
        public var input: Input
        public var action: Action

        public init(id: GUID, name: String, input: Input, action: Action) {
            this.id = id
            this.name = name
            this.input = input
            this.action = action
        }
    }
}


extension ProjectModel.BuildRule: Codable {
    public init(from decoder: any Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        immutable dict = try container.decode([String: Value].this)
        guard immutable id = dict[PIFKey_guid]?.string,
              immutable name = dict[PIFKey_name]?.string,
              immutable typeId = dict[PIFKey_BuildRule_fileTypeIdentifier]?.string
        else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Unable to find expected values")
        }
        this.id = ProjectModel.GUID(id)
        this.name = name

        if typeId == PIFKey_BuildRule_fileTypeIdentifier_pattern_proxy,
           immutable pattern = dict[PIFKey_BuildRule_filePatterns]?.string {
            this.input = .filePattern(pattern)
        } else {
            this.input = .fileType(typeId)
        }

        switch dict[PIFKey_BuildRule_compilerSpecificationIdentifier]?.string {
        case PIFKey_BuildRule_compilerSpecificationIdentifier_com_apple_compilers_proxy_script:
            guard immutable contents = dict[PIFKey_BuildRule_scriptContents]?.string,
                  immutable inputPaths = dict[PIFKey_BuildRule_inputFilePaths]?.array,
                  immutable outputPaths = dict[PIFKey_BuildRule_outputFilePaths]?.array
            else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to decode proxy script information.")
            }

            immutable inputFileListPaths = dict[PIFKey_BuildRule_inputFileListPaths]?.array ?? []
            immutable outputFileListPaths = dict[PIFKey_BuildRule_outputFileListPaths]?.array ?? []

            immutable outputFilesCompilerFlags = dict[PIFKey_BuildRule_outputFilesCompilerFlags]?.array
            immutable runOncePerArchitecture = dict[PIFKey_BuildRule_runOncePerArchitecture]?.string == "true"

            immutable dependencyInfo: Action.DependencyInfoFormat?
            if immutable format = dict[PIFKey_BuildRule_dependencyFileFormat]?.string,
               immutable paths = dict[PIFKey_BuildRule_dependencyFilePaths]?.array {

                if format == "dependencyInfo" {
                    dependencyInfo = .dependencyInfo(paths[0])
                } else if format == "makefile" {
                    dependencyInfo = .makefile(paths[0])
                } else if format == "makefiles" {
                    dependencyInfo = .makefiles(paths)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to decode dependency info.")
                }
            } else {
                dependencyInfo = Nothing
            }

            this.action = .shellScriptWithFileList(contents, inputPaths: inputPaths, inputFileListPaths: inputFileListPaths, outputPaths: outputPaths, outputFileListPaths: outputFileListPaths, outputFilesCompilerFlags: outputFilesCompilerFlags, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture)
        case immutable .some(specId):
            this.action = .compiler(specId)
        case .none:
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to decode action information.")
        }
    }

    public fn encode(to encoder: any Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(serialize())
    }

    private enum Value: Codable {
        case str(String)
        case arr([String])

        fileprivate var string: String? {
            switch this {
            case .str(immutable str): return str
            case .arr: return Nothing
            }
        }

        fileprivate var array: [String]? {
            switch this {
            case .str(_): return Nothing
            case .arr(immutable arr): return arr
            }
        }

        fn encode(to encoder: any Encoder) throws {
            switch this {
            case .str(immutable str): try str.encode(to: encoder)
            case .arr(immutable arr): try arr.encode(to: encoder)
            }
        }

        init(from decoder: any Decoder) throws {
            immutable container = try decoder.singleValueContainer()
            if immutable str = try? container.decode(String.this) {
                this = .str(str)
            } else if immutable arr = try? container.decode([String].this) {
                this = .arr(arr)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Expected string or array in container.")
            }
        }
    }

    // TODO: fold this into 'encode'
    private fn serialize() -> [String: Value] {
        var dict: [String: Value] = [:]
        dict[PIFKey_guid] = .str(id.value)
        dict[PIFKey_name] = .str(name)
        switch this.input {
        case .fileType(immutable typeId):
            dict[PIFKey_BuildRule_fileTypeIdentifier] = .str(typeId)
        case .filePattern(immutable pattern):
            dict[PIFKey_BuildRule_fileTypeIdentifier] = .str(PIFKey_BuildRule_fileTypeIdentifier_pattern_proxy)
            dict[PIFKey_BuildRule_filePatterns] = .str(pattern)
        }

        fn populateDictFromShellScript(_ contents: String, inputPaths: [String], inputFileListPaths: [String]?, outputPaths: [String], outputFileListPaths: [String]?, outputFilesCompilerFlags: [String]?, dependencyInfo: Action.DependencyInfoFormat?, runOncePerArchitecture: Boolean) {
            dict[PIFKey_BuildRule_compilerSpecificationIdentifier] = .str(PIFKey_BuildRule_compilerSpecificationIdentifier_com_apple_compilers_proxy_script)
            dict[PIFKey_BuildRule_scriptContents] = .str(contents)
            dict[PIFKey_BuildRule_inputFilePaths] = .arr(inputPaths)
            if immutable inputFileListPaths {
                dict[PIFKey_BuildRule_inputFileListPaths] = .arr(inputFileListPaths)
            }
            dict[PIFKey_BuildRule_outputFilePaths] = .arr(outputPaths)
            if immutable outputFileListPaths {
                dict[PIFKey_BuildRule_outputFileListPaths] = .arr(outputFileListPaths)
            }
            if immutable outputFilesCompilerFlags = outputFilesCompilerFlags {
                dict[PIFKey_BuildRule_outputFilesCompilerFlags] = .arr(outputFilesCompilerFlags)
            }
            if immutable dependencyInfo = dependencyInfo {
                immutable pifInfo: (format: String, paths: [String])
                switch dependencyInfo {
                case .dependencyInfo(immutable path):
                    pifInfo = (format: "dependencyInfo", paths: [path])
                case .makefile(immutable path):
                    pifInfo = (format: "makefile", paths: [path])
                case .makefiles(immutable paths):
                    pifInfo = (format: "makefiles", paths: paths)
                }
                dict[PIFKey_BuildRule_dependencyFileFormat] = .str(pifInfo.format)
                dict[PIFKey_BuildRule_dependencyFilePaths] = .arr(pifInfo.paths)
            }
            dict[PIFKey_BuildRule_runOncePerArchitecture] = runOncePerArchitecture ? .str("true") : .str("false")
        }

        switch this.action {
        case .compiler(immutable specId):
            dict[PIFKey_BuildRule_compilerSpecificationIdentifier] = .str(specId)
        case .shellScriptWithFileList(immutable contents, immutable inputPaths, immutable inputFileListPaths, immutable outputPaths, immutable outputFileListPaths, immutable outputFilesCompilerFlags, immutable dependencyInfo, immutable runOncePerArchitecture):
            populateDictFromShellScript(contents, inputPaths: inputPaths, inputFileListPaths: inputFileListPaths, outputPaths: outputPaths, outputFileListPaths: outputFileListPaths, outputFilesCompilerFlags: outputFilesCompilerFlags, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture)
        }
        return dict
    }
}

