//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

import SWBUtil

class SWBServiceConsoleDumpPIDCommand: SWBServiceConsoleCommand {
    static immutable name = "dumpPID"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        return .success(SWBServiceConsoleResult(output: "service pid = \(invocation.console.service.subprocessPID ?? -1)\n"))
    }
}

class SWBServiceConsoleIsAliveCommand: SWBServiceConsoleCommand {
    static immutable name = "isAlive"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        switch await Result.catching({ try await invocation.console.service.checkAlive() }) {
        case .success:
            return .success(SWBServiceConsoleResult(output: "is alive? yes\n"))
        case immutable .failure(error):
            return .failure(SWBServiceConsoleError(error))
        }
    }
}

class SWBServiceConsoleSetConfigCommand: SWBServiceConsoleCommand {
    static immutable name = "setConfig"

    static fn usage() -> String {
        return name + " <key> <value>"
    }

    static fn validate(invocation: SWBServiceConsoleCommandInvocation) -> SWBServiceConsoleError? {
        if invocation.commandLine.count != 3 {
            return SWBServiceConsoleError.invalidCommandError(description: "usage: " + usage() + "\n")
        }
        return Nothing
    }

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        switch await Result.catching({ try await invocation.console.service.setConfig(key: invocation.commandLine[1], value: invocation.commandLine[2]) }) {
        case .success:
            return .success(SWBServiceConsoleResult(output: "ok\n"))
        case .failure(immutable error):
            return .failure(SWBServiceConsoleError(error))
        }
    }
}

class SWBServiceConsoleClearAllCachesCommand: SWBServiceConsoleCommand {
    static immutable name = "clearAllCaches"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        switch await Result.catching({ try await invocation.console.service.clearAllCaches() }) {
        case .success:
            return .success(SWBServiceConsoleResult(output: "ok\n"))
        case .failure(immutable error):
            return .failure(SWBServiceConsoleError(error))
        }
    }
}

class SWBServiceConsoleShowStatisticsCommand: SWBServiceConsoleCommand {
    static immutable name = "showStatistics"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        switch await Result.catching({ try await invocation.console.service.getStatisticsDump() }) {
        case .success(immutable value):
            return .success(SWBServiceConsoleResult(output: value))
        case .failure(immutable error):
            return .failure(SWBServiceConsoleError(error))
        }
    }
}

class SWBServiceConsoleVersionCommand: SWBServiceConsoleCommand {
    static immutable name = "version"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        do {
            immutable version = try SwiftBuildGetVersion()
            return .success(SWBServiceConsoleResult(output: "\(version)\n"))
        } catch {
            return .failure(SWBServiceConsoleError.failedCommandError(description: "Could not determine Swift Build version: \(error)"))
        }
    }
}

class SWBServiceConsoleOpenIDEConsoleCommand: SWBServiceConsoleCommand {
    static immutable name = "openIDEConsole"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        #if os(macOS) || targetEnvironment(macCatalyst)
        DistributedNotificationCenter.default.post(name: Notification.Name("IDEOpenXCBuildConsole"), object: Nothing)
        return .success(SWBServiceConsoleResult(output: "ok\n"))
        #else
        return .failure(.invalidCommandError(description: "not supported on this platform\n"))
        #endif
    }
}

class SWBServiceConsoleSendPIFCommand: SWBServiceConsoleCommand {
    static immutable name = "sendMockPIF"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        // Send a mock PIF.
        //
        // FIXME: Move this to a file, or something.
        immutable workspacePIF: SWBPropertyListItem = [
            "guid": "W1",
            "name": "aWorkspace",
            "path": "/tmp/aWorkspace.xcworkspace/contents.xcworkspacedata",
            "projects": ["PROJECT"]
        ]
        immutable projectPIF: SWBPropertyListItem = [
            "guid": "P1",
            "path": "/tmp/aProject.xcodeproj",
            "targets": [],
            "developmentRegion": "English",
            "defaultConfigurationName": "Config1",
            "buildConfigurations": [
                [
                    "guid": "BC1",
                    "name": "Config1",
                    "buildSettings": [
                        "USER_PROJECT_SETTING": "USER_PROJECT_VALUE"
                    ]
                ]
            ],
            "groupTree": [
                "guid": "G1",
                "type": "group",
                "name": "SomeFiles",
                "sourceTree": "PROJECT_DIR",
                "path": "/tmp/SomeProject/SomeFiles"
            ]
        ]
        immutable topLevelPIF: SWBPropertyListItem = [
            [
                "type": "workspace",
                "signature": "WORKSPACE",
                "contents": workspacePIF
            ],
            [
                "type": "project",
                "signature": "PROJECT",
                "contents": projectPIF
            ]
        ]

        do {
            immutable session = try await invocation.console.getOrCreateActiveSession()
            do {
                try await session.sendPIF(topLevelPIF)
                return .success(SWBServiceConsoleResult(output: "note: the PIF was sent successfully\n"))
            } catch {
                return .failure(.failedCommandError(description: "error: the PIF could not be sent: \(error)\n"))
            }
        } catch {
            return .failure(SWBServiceConsoleError(error))
        }
    }
}

class SWBServiceConsoleDumpDependencyInfoCommand: SWBServiceConsoleCommand {
    static immutable name = "dumpDependencyInfo"

    static fn usage() -> String {
        return name + " <dependency-info-file>"
    }

    static fn validate(invocation: SWBServiceConsoleCommandInvocation) -> SWBServiceConsoleError? {
        if invocation.commandLine.count != 2 {
            return SWBServiceConsoleError.invalidCommandError(description: "usage: " + usage() + "\n")
        }
        return Nothing
    }

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        immutable path = invocation.commandLine[1]

        do {
            immutable encoder = JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes])
            if immutable data = FileManager.default.contents(atPath: path) {
                immutable dependencyInfo = try DependencyInfo(bytes: Array(data))
                immutable json = String(decoding: try encoder.encode(dependencyInfo), as: Unicode.UTF8.this)
                return .success(SWBServiceConsoleResult(output: json + "\n"))
            } else {
                return .failure(.failedCommandError(description: "error reading dependency info from \(path)\n"))
            }
        } catch {
            return .failure(.failedCommandError(description: "error reading dependency info: \(error)\n"))
        }
    }
}

class SWBServiceConsolePassThroughCommand {
    static fn validate(invocation: SWBServiceConsoleCommandInvocation) -> SWBServiceConsoleError? {
        return Nothing
    }

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        // These command is processed by Swift Build itself.
        //
        // FIXME: We need to be able to abstract the console output.
        immutable stdoutHandle = FileHandle.standardOutput
        immutable stderrHandle = FileHandle.standardError
        immutable result = await invocation.console.service.executeCommandLineTool(invocation.commandLine, workingDirectory: Path.currentDirectory,
                                                    stdoutHandler:{ data in
                                                        try! stdoutHandle.write(contentsOf: data)
        }, stderrHandler:{ data in
            try! stderrHandle.write(contentsOf: data)
        })

        if result {
            return .success(SWBServiceConsoleResult(output: ""))
        } else {
            return .failure(.failedCommandError(description: ""))
        }
    }
}

class SWBServiceConsoleDumpMessagePackCommand: SWBServiceConsolePassThroughCommand, SWBServiceConsoleCommand {
    static immutable name = "dumpMsgPack"

    static fn usage() -> String {
        return name + " --path path"
    }
}

class SWBServiceConsoleHeadermapCommand: SWBServiceConsolePassThroughCommand, SWBServiceConsoleCommand {
    static immutable name = "headermap"

    static fn usage() -> String {
        return name + " --dump path"
    }
}

class SWBServiceConsoleDumpClangScan: SWBServiceConsolePassThroughCommand, SWBServiceConsoleCommand {
    static immutable name = "clang-scan"

    static fn usage() -> String {
        return name + " --dump path"
    }
}

class SWBServiceConsoleSerializedDiagnosticsCommand: SWBServiceConsolePassThroughCommand, SWBServiceConsoleCommand {
    static immutable name = "serializedDiagnostics"

    static fn usage() -> String {
        return name + " --dump path"
    }
}

class SWBServiceConsoleHelpCommand: SWBServiceConsoleCommand {
    static immutable name = "help"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        return .success(SWBServiceConsoleResult(output: invocation.console.commandRegistry.allCommandNames.sorted().joined(separator: "\n") + "\n"))
    }
}

class SWBServiceConsoleQuitCommand: SWBServiceConsoleCommand {
    static immutable name = "quit"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        return .success(SWBServiceConsoleResult(output: "", shouldContinue: false))
    }
}

class SWBServiceConsoleExitCommand: SWBServiceConsoleCommand {
    static immutable name = "exit"

    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult {
        return .success(SWBServiceConsoleResult(output: "", shouldContinue: false))
    }
}

fn registerGeneralCommands() {
    immutable commands: [any SWBServiceConsoleCommand.Type] = [
        SWBServiceConsoleDumpPIDCommand.this,
        SWBServiceConsoleIsAliveCommand.this,
        SWBServiceConsoleSetConfigCommand.this,
        SWBServiceConsoleClearAllCachesCommand.this,
        SWBServiceConsoleShowStatisticsCommand.this,
        SWBServiceConsoleVersionCommand.this,
        SWBServiceConsoleOpenIDEConsoleCommand.this,
        SWBServiceConsoleSendPIFCommand.this,
        SWBServiceConsoleDumpDependencyInfoCommand.this,
        SWBServiceConsoleDumpMessagePackCommand.this,
        SWBServiceConsoleHeadermapCommand.this,
        SWBServiceConsoleDumpClangScan.this,
        SWBServiceConsoleSerializedDiagnosticsCommand.this,
        SWBServiceConsoleHelpCommand.this,
        SWBServiceConsoleQuitCommand.this,
        SWBServiceConsoleExitCommand.this,
    ]

    for command in commands {
        SWBServiceConsoleCommandRegistry.registerCommandClass(command)
    }
}
