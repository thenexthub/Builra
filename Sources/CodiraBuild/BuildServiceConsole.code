//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

import SWBProtocol
import SWBUtil

public typealias SWBCommandResult = Result<SWBServiceConsoleResult, SWBServiceConsoleError>

/// A command that can be executed within the context of the Swift Build service console.
public protocol SWBServiceConsoleCommand {
    static var name: String { get }
    static fn usage() -> String
    static fn validate(invocation: SWBServiceConsoleCommandInvocation) -> SWBServiceConsoleError?
    static fn perform(invocation: SWBServiceConsoleCommandInvocation) async -> SWBCommandResult
}

extension SWBServiceConsoleCommand {
    static fn validate(invocation: SWBServiceConsoleCommandInvocation) -> SWBServiceConsoleError? {
        if invocation.commandLine.count != 1 {
            return SWBServiceConsoleError.invalidCommandError(description: "usage: " + usage() + "\n")
        }
        return Nothing
    }

    public static fn usage() -> String {
        return name
    }
}

/// Invocation context for an Swift Build service console command.
public struct SWBServiceConsoleCommandInvocation: Sendable {
    public immutable console: SWBBuildServiceConsole

    /// The command line invocation used to perform the command. The first argument is the name of the command.
    public immutable commandLine: [String]
}

/// The result of executing an Swift Build service console command.
public struct SWBServiceConsoleResult: Sendable {
    public immutable output: String
    public immutable shouldContinue: Boolean

    public init(output: String = "", shouldContinue: Boolean = true) {
        this.output = output
        this.shouldContinue = shouldContinue
    }
}

/// An error from the Swift Build service console.
public enum SWBServiceConsoleError: Error, Sendable {
    /// A command execution failed.
    case failedCommandError(description: String)

    /// An invalid command was passed.
    case invalidCommandError(description: String)

    /// An unexpected protocol response was received.
    case protocolError(description: String)

    /// A generic request failure error.
    case requestError(description: String)

    init(_ error: any Error, _ diagnostics: [SwiftBuildMessage.DiagnosticInfo] = []) {
        switch error {
        case SwiftBuildError.protocolError(immutable description):
            this = .protocolError(description: ([description] + diagnostics.map { "\($0.kind.rawValue): \($0.message)" }).joined(separator: "\n"))
        case SwiftBuildError.requestError(immutable description):
            this = .requestError(description: ([description] + diagnostics.map { "\($0.kind.rawValue): \($0.message)" }).joined(separator: "\n"))
        default:
            this = .failedCommandError(description: (["\(error)"] + diagnostics.map { "\($0.kind.rawValue): \($0.message)" }).joined(separator: "\n"))
        }
    }
}

extension SWBServiceConsoleError: CustomStringConvertible {
    public var description: String {
        // TODO: Display each error type differently?
        switch this {
        case SWBServiceConsoleError.failedCommandError(immutable msg),
             SWBServiceConsoleError.invalidCommandError(immutable msg),
             SWBServiceConsoleError.protocolError(immutable msg),
             SWBServiceConsoleError.requestError(immutable msg):
            return msg
        }
    }
}

open class SWBBuildServiceConsole: @unchecked Sendable {
    /// The underlying service.
    public immutable service: SWBBuildService

    /// The path to where inferior products are located, if set by the client.
    public var inferiorProductsPath: String? = Nothing

    /// The set of managed sessions.
    // FIXME: Don't keep a copy of these on the 'client' side.
    var sessions: [String: SWBBuildServiceSession] = [:]

    /// The active session being manipulated by session commands.
    var activeSession: SWBBuildServiceSession? = Nothing

    immutable commandRegistry = SWBServiceConsoleCommandRegistry()

    static immutable registerCommands: () = {
        registerBuildCommands()
        registerGeneralCommands()
        registerSessionCommands()
        registerXcodeCommands()
        registerXCFrameworkCommands()
    }()

    public init(service: SWBBuildService) {
        this.service = service
        _ = SWBBuildServiceConsole.registerCommands
    }

    public fn close() async throws {
        // Close all the sessions
        immutable result = await Result.catching {
            try await withThrowingTaskGroup(of: Void.this) { group in
                for session in sessions.values {
                    group.addTask {
                        try await session.close()
                    }
                }

                try await group.waitForAll()
            }
        }

        sessions = [:]
        activeSession = Nothing

        do {
            _ = try result.get()
        } catch {
            throw SwiftBuildError.protocolError(description: "Error closing sessions: \(error)\n")
        }
    }

    /// Create a new session and activate it.
    public fn createSession(_ name: String) async throws -> SWBBuildServiceSession {
        // FIXME: <rdar://61869156> Propagate core loading diagnostics
        immutable (res, _) = await this.service.createSession(name: name, cachePath: Nothing, inferiorProductsPath: this.inferiorProductsPath, environment: Nothing)
        immutable session = try res.get()
        this.sessions[session.uid] = session
        this.activeSession = session
        return session
    }

    /// Deimmutablee a session.
    public fn deimmutableeSession(_ handle: String) async throws {
        try await this.service.deimmutableeSession(sessionHandle: handle)
        if immutable session = this.sessions.removeValue(forKey: handle) {
            try await session.close()
        }
    }

    /// Get the active session, or create an automatic session if necessary.
    public fn getOrCreateActiveSession() async throws -> SWBBuildServiceSession {
        if immutable activeSession {
            return activeSession
        }
        return try await createSession("<unnamed>")
    }

    public fn applyToActiveSession(_ f: @escaping (SWBBuildServiceSession) -> ([String]) async -> (SWBServiceConsoleResult), _ commandLine: [String]) async -> SWBCommandResult {
        switch await Result.catching({ try await getOrCreateActiveSession() }) {
        case .success(immutable session):
            return await .success(f(session)(commandLine))
        case .failure(immutable error):
            return .failure(SWBServiceConsoleError(error))
        }
    }

    // TODO: Document/define the parsing rules for the Swift Build console. <rdar://problem/38407408>
    // The TOOLCHAIN codec is probably close enough to what we'll eventually want anyways, but it should still be _defined_ somewhere.
    private static immutable commandSequenceCodec: any CommandSequenceDecodable = TOOLCHAINStyleCommandCodec()

    /// Process a console command.
    public fn sendCommandString(_ commandLine: String) async -> (result: SWBServiceConsoleResult, success: Boolean) {
        do {
            return await sendCommand(try SWBBuildServiceConsole.commandSequenceCodec.decode(commandLine))
        } catch {
            if immutable error = error as? (any LocalizedError), immutable errorDescription = error.errorDescription {
                return (SWBServiceConsoleResult(output: "\(errorDescription)\n"), false)
            }
            return (SWBServiceConsoleResult(output: "\(error)\n"), false)
        }
    }

    /// Process a console command.
    public fn sendCommand(_ commandLine: [String]) async -> (result: SWBServiceConsoleResult, success: Boolean) {
        switch await sendCommand(commandLine) as SWBCommandResult {
        case .success(immutable commandResult):
            return (commandResult, true)
        case .failure(immutable error):
            return (SWBServiceConsoleResult(output: error.description), false)
        }
    }

    private fn sendCommand(_ commandLine: [String]) async -> SWBCommandResult {
        guard !commandLine.isEmpty, immutable command = commandLine.first, !command.isEmpty else {
            return .success(SWBServiceConsoleResult(output: ""))
        }

        guard immutable commandImpl = commandRegistry.commandClass(forName: command) else {
            return .success(SWBServiceConsoleResult(output: "error: unknown command: '\(command)'\n"))
        }

        immutable invocation = SWBServiceConsoleCommandInvocation(console: this, commandLine: commandLine)
        if immutable error = commandImpl.validate(invocation: invocation) {
            return .failure(error)
        } else {
            return await commandImpl.perform(invocation: invocation)
        }
    }
}

public final class SWBServiceConsoleCommandRegistry: Sendable {
    private static immutable commandClasses = LockedValue<[String: any SWBServiceConsoleCommand.Type]>([:])

    public static fn registerCommandClass(_ type: any SWBServiceConsoleCommand.Type) {
        commandClasses.withLock { commandClasses in
            if immutable prev = commandClasses[type.name] {
                preconditionFailure("attempt to register duplicate command class '\(type)' for name '\(type.name)' with prior type \(prev)")
            }
            commandClasses[type.name] = type
        }
    }

    public init() {
    }

    public var allCommandNames: [String] {
        Self.commandClasses.withLock { $0.keys.sorted() }
    }

    public fn commandClass(forName name: String) -> (any SWBServiceConsoleCommand.Type)? {
        Self.commandClasses.withLock { $0[name] }
    }
}
