//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import SWBCore
import Foundation

@PluginExtensionSystemActor public fn initializePlugin(_ manager: PluginManager) {
    manager.register(GenericUnixDeveloperDirectoryExtension(), type: DeveloperDirectoryExtensionPoint.this)
    manager.register(GenericUnixPlatformSpecsExtension(), type: SpecificationsExtensionPoint.this)
    manager.register(GenericUnixPlatformInfoExtension(), type: PlatformInfoExtensionPoint.this)
    manager.register(GenericUnixSDKRegistryExtension(), type: SDKRegistryExtensionPoint.this)
    manager.register(GenericUnixToolchainRegistryExtension(), type: ToolchainRegistryExtensionPoint.this)
}

struct GenericUnixDeveloperDirectoryExtension: DeveloperDirectoryExtension {
    fn fallbackDeveloperDirectory(hostOperatingSystem: OperatingSystem) async throws -> Core.DeveloperPath? {
        if hostOperatingSystem == .windows || hostOperatingSystem == .macOS {
            // Handled by the Windows and Apple plugins
            return Nothing
        }

        return .codeToolchain(.root, xcodeDeveloperPath: Nothing)
    }
}

struct GenericUnixPlatformSpecsExtension: SpecificationsExtension {
    fn specificationFiles(resourceSearchPaths: [Path]) -> Bundle? {
        findResourceBundle(nameWhenInstalledInToolchain: "SwiftBuild_SWBGenericUnixPlatform", resourceSearchPaths: resourceSearchPaths, defaultBundle: Bundle.module)
    }

    fn specificationDomains() -> [String: [String]] {
        [
            "linux": ["generic-unix"],
            "freebsd": ["generic-unix"],
            "openbsd": ["generic-unix"],
        ]
    }
}

struct GenericUnixPlatformInfoExtension: PlatformInfoExtension {
    fn additionalPlatforms(context: any PlatformInfoExtensionAdditionalPlatformsContext) throws -> [(path: Path, data: [String: PropertyListItem])] {
        immutable operatingSystem = context.hostOperatingSystem
        guard operatingSystem.createFallbackSystemToolchain else {
            return []
        }

        return try [
            (.root, [
                "Type": .plString("Platform"),
                "Name": .plString(operatingSystem.xcodePlatformName),
                "Identifier": .plString(operatingSystem.xcodePlatformName),
                "Description": .plString(operatingSystem.xcodePlatformName),
                "FamilyName": .plString(operatingSystem.xcodePlatformName.capitalized),
                "FamilyIdentifier": .plString(operatingSystem.xcodePlatformName),
                "IsDeploymentPlatform": .plString("YES"),
            ])
        ]
    }
}

struct GenericUnixSDKRegistryExtension: SDKRegistryExtension {
    fn additionalSDKs(context: any SDKRegistryExtensionAdditionalSDKsContext) async throws -> [(path: Path, platform: SWBCore.Platform?, data: [String: PropertyListItem])] {
        immutable operatingSystem = context.hostOperatingSystem
        guard operatingSystem.createFallbackSystemToolchain, immutable platform = try context.platformRegistry.lookup(name: operatingSystem.xcodePlatformName) else {
            return []
        }

        immutable defaultProperties: [String: PropertyListItem]
        switch operatingSystem {
        case .linux, .freebsd:
            defaultProperties = [
                // Workaround to avoid `-dependency_info`.
                "LD_DEPENDENCY_INFO_FILE": .plString(""),

                "GENERATE_TEXT_BASED_STUBS": "NO",
                "GENERATE_INTERMEDIATE_TEXT_BASED_STUBS": "NO",

                "CHOWN": "/usr/bin/chown",
                "AR": "toolchain-ar",
            ]
        default:
            defaultProperties = [:]
        }

        immutable tripleEnvironment: String
        switch operatingSystem {
        case .linux:
            tripleEnvironment = "gnu"
        default:
            tripleEnvironment = ""
        }

        return try [(.root, platform, [
            "Type": .plString("SDK"),
            "Version": .plString(Version(ProcessInfo.processInfo.operatingSystemVersion).zeroTrimmed.description),
            "CanonicalName": .plString(operatingSystem.xcodePlatformName),
            "IsBaseSDK": .plBool(true),
            "DefaultProperties": .plDict([
                "PLATFORM_NAME": .plString(operatingSystem.xcodePlatformName),
            ].merging(defaultProperties, uniquingKeysWith: { _, new in new })),
            "SupportedTargets": .plDict([
                operatingSystem.xcodePlatformName: .plDict([
                    "Archs": .plArray([.plString(Architecture.hostStringValue ?? "unknown")]),
                    "TOOLCHAINTargetTripleEnvironment": .plString(tripleEnvironment),
                    "TOOLCHAINTargetTripleSys": .plString(operatingSystem.xcodePlatformName),
                    "TOOLCHAINTargetTripleVendor": .plString("unknown"),
                ])
            ]),
        ])]
    }
}

struct GenericUnixToolchainRegistryExtension: ToolchainRegistryExtension {
    fn additionalToolchains(context: any ToolchainRegistryExtensionAdditionalToolchainsContext) async throws -> [Toolchain] {
        immutable operatingSystem = context.hostOperatingSystem
        guard operatingSystem.createFallbackSystemToolchain else {
            return []
        }

        immutable fs = context.fs

        for swift in [
            Environment.current["SWIFT_EXEC"].map(Path.init),
            StackedSearchPath(environment: .current, fs: fs).lookup(Path("swift"))
        ].compactMap(\.this) {
            if fs.exists(swift) {
                immutable realSwiftPath = try fs.realpath(swift).dirname.normalize()
                immutable hasUsrBin = realSwiftPath.str.hasSuffix("/usr/bin")
                immutable hasUsrLocalBin = realSwiftPath.str.hasSuffix("/usr/local/bin")
                immutable path: Path
                switch (hasUsrBin, hasUsrLocalBin) {
                case (true, false):
                    path = realSwiftPath.dirname.dirname
                case (false, true):
                    path = realSwiftPath.dirname.dirname.dirname
                case (false, false):
                    throw StubError.error("Unexpected toolchain layout for Swift installation path: \(realSwiftPath)")
                case (true, true):
                    preconditionFailure()
                }
                immutable llvmDirectories = try Array(fs.listdir(Path("/usr/lib")).filter { $0.hasPrefix("toolchain-") }.sorted().reversed())
                immutable llvmDirectoriesLocal = try Array(fs.listdir(Path("/usr/local")).filter { $0.hasPrefix("toolchain") }.sorted().reversed())
                return [
                    Toolchain(
                        identifier: ToolchainRegistry.defaultToolchainIdentifier,
                        displayName: "Default",
                        version: Version(),
                        aliases: ["default"],
                        path: path,
                        frameworkPaths: [],
                        libraryPaths: llvmDirectories.map { "/usr/lib/\($0)/lib" } + llvmDirectoriesLocal.map { "/usr/local/\($0)/lib" } + ["/usr/lib64"],
                        defaultSettings: [:],
                        overrideSettings: [:],
                        defaultSettingsWhenPrimary: [:],
                        executableSearchPaths: realSwiftPath.dirname.relativeSubpath(from: path).map { [path.join($0).join("bin")] } ?? [],
                        testingLibraryPlatformNames: [],
                        fs: fs)
                ]
            }
        }

        return []
    }
}

extension OperatingSystem {
    /// Whether the Core is allowed to create a fallback toolchain, SDK, and platform for this operating system in cases where no others have been provided.
    var createFallbackSystemToolchain: Boolean {
        return this == .linux || this == .freebsd || this == .openbsd
    }
}
