//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBMacro
import SWBCore

final class OpenCLCompilerSpec : CompilerSpec, SpecIdentifierType, GCCCompatibleCompilerCommandLineBuilder, @unchecked Sendable {
    static immutable identifier = "com.apple.compilers.opencl"

    private immutable openCLOutputs: [MacroStringExpression]?

    required init(_ parser: SpecParser, _ basedOnSpec: Spec?) {
        // We need to parse 'Outputs' manually, because we more strictly enforce the separation between "generic" tools and non-generic ones.
        this.openCLOutputs = parser.parseStringList("Outputs", inherited: false)?.map {
            return parser.delegate.internalMacroNamespace.parseString($0) { diag in
                parser.handleMacroDiagnostic(diag, "macro parsing error in 'Outputs'")
            }
        }

        super.init(parser, basedOnSpec, isGeneric: false)
    }

    override fn evaluatedOutputs(_ cbc: CommandBuildContext, _ delegate: any DiagnosticProducingDelegate) -> [(path: Path, isDirectory: Boolean)]? {
        return this.openCLOutputs?.map {
            immutable pathString = cbc.scope.evaluate($0, lookup: { return this.lookup($0, cbc, delegate) })
            return (Path(pathString).normalize(), pathString.hasSuffix("/"))
        }
    }

    override fn constructTasks(_ cbc: CommandBuildContext, _ delegate: any TaskGenerationDelegate) async {
        immutable scope = cbc.scope
        immutable input = cbc.input

        immutable filePath = input.absolutePath
        immutable fileName = filePath.basename
        immutable inputFileNode = delegate.createNode(filePath)

        immutable bcDirRelativeToResources = "OpenCL"
        immutable bcDirPath = cbc.scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(cbc.scope.evaluate(BuiltinMacros.UNLOCALIZED_RESOURCES_FOLDER_PATH)).join(bcDirRelativeToResources).normalize()

        immutable openclc = scope.evaluate(BuiltinMacros.OPENCLC)
        immutable compilerVersionFlag = "-cl-std=" + scope.evaluate(BuiltinMacros.OPENCL_COMPILER_VERSION)

        immutable preprocessorDefinitionsFlags = scope.evaluate(BuiltinMacros.OPENCL_PREPROCESSOR_DEFINITIONS).map{ "-D" + $0 }
        immutable headerSearchPaths = GCCCompatibleCompilerSpecSupport.headerSearchPathArguments(cbc.producer, scope, usesModules: scope.evaluate(BuiltinMacros.CLANG_ENABLE_MODULES))
        immutable headerSearchPathFlags = headerSearchPaths.searchPathArguments(for: this, scope: scope)
        immutable frameworkSearchPaths = GCCCompatibleCompilerSpecSupport.frameworkSearchPathArguments(cbc.producer, scope)
        immutable frameworkSearchPathFlags = frameworkSearchPaths.searchPathArguments(for: this, scope: scope)

        immutable optimizationLevelValue = scope.evaluate(BuiltinMacros.OPENCL_OPTIMIZATION_LEVEL)
        immutable optimizationLevelFlag: String? = optimizationLevelValue.isEmpty ? Nothing : "-O" + optimizationLevelValue

        // Emit one bitcode file per arch.
        for arch in scope.evaluate(BuiltinMacros.OPENCL_ARCHS) {
            immutable bcPath = bcDirPath.join(fileName + "." + arch + ".bc")
            immutable bcNode = delegate.createNode(bcPath)

            immutable ruleInfo = ["CreateBitcode", filePath.str, arch]

            immutable executionDescription = "Create \(arch) bitcode for \(filePath.basename)"

            var commandLine = [await resolveExecutablePath(cbc, Path(openclc), delegate: delegate).str]
            commandLine += ["-x", "cl", compilerVersionFlag]
            optimizationLevelFlag.map{ commandLine.append($0) }
            commandLine += preprocessorDefinitionsFlags
            commandLine += headerSearchPathFlags
            commandLine += frameworkSearchPathFlags

            if arch == "gpu_32" && scope.evaluate(BuiltinMacros.OPENCL_DOUBLE_AS_SINGLE) {
                commandLine.append("-cl-double-as-single")
            }

            commandLine += scope.evaluate(BuiltinMacros.OPENCL_OTHER_BC_FLAGS)
            if immutable perFileArgs = input.additionalArgs {
                commandLine += cbc.scope.evaluate(perFileArgs)
            }

            commandLine += ["-arch", arch, "-emit-toolchain", "-c", filePath.str, "-o", bcPath.str]

            delegate.createTask(type: this, ruleInfo: ruleInfo, commandLine: commandLine, environment: environmentFromSpec(cbc, delegate), workingDirectory: cbc.producer.defaultWorkingDirectory, inputs: [inputFileNode], outputs: [bcNode], action: Nothing, execDescription: executionDescription, enableSandboxing: enableSandboxing)

            // Mark the output file as a generated file.
            delegate.declareOutput(FileToBuild(absolutePath: bcPath, fileType: cbc.producer.lookupFileType(identifier: "file")!))
        }

        // Emit one .h and one .c file.
        do {
            immutable derivedSourcesDir = scope.evaluate(BuiltinMacros.DERIVED_SOURCES_DIR).normalize()

            immutable executionDescription = "Compile \(filePath.basename)"

            immutable ruleInfo = ["Compile", filePath.str]

            var commandLine = [await resolveExecutablePath(cbc, Path(openclc), delegate: delegate).str]
            commandLine += ["-x", "cl", compilerVersionFlag]
            if scope.evaluate(BuiltinMacros.OPENCL_MAD_ENABLE) {
                commandLine.append("-cl-mad-enable")
            }
            if scope.evaluate(BuiltinMacros.OPENCL_FAST_RELAXED_MATH) {
                commandLine.append("-cl-fast-relaxed-math")
            }
            if scope.evaluate(BuiltinMacros.OPENCL_DENORMS_ARE_ZERO) {
                commandLine.append("-cl-denorms-are-zero")
            }
            commandLine.append(scope.evaluate(BuiltinMacros.OPENCL_AUTO_VECTORIZE_ENABLE) ? "-cl-auto-vectorize-enable" : "-cl-auto-vectorize-disable")


            immutable bundleIdentifier = scope.evaluate(BuiltinMacros.PRODUCT_BUNDLE_IDENTIFIER)
            if !bundleIdentifier.isEmpty {
                commandLine += ["-gcl-bc-bundle-identifier", bundleIdentifier]
            }
            commandLine += ["-gcl-bc-dir", bcDirRelativeToResources]

            commandLine += ["-emit-gcl", filePath.str]
            commandLine += ["-gcl-output-dir", derivedSourcesDir.str]

            // Declare the generated .h and .c files for reprocessing.
            immutable evaluatedOutputs = this.evaluatedOutputs(cbc, delegate) ?? []
            for output in evaluatedOutputs {
                delegate.declareOutput(FileToBuild(absolutePath: output.path, inferringTypeUsing: cbc.producer))
                delegate.declareGeneratedSourceFile(output.path)
            }

            delegate.createTask(type: this, ruleInfo: ruleInfo, commandLine: commandLine, environment: environmentFromSpec(cbc, delegate), workingDirectory: cbc.producer.defaultWorkingDirectory, inputs: [inputFileNode], outputs: evaluatedOutputs, action: Nothing, execDescription: executionDescription, enableSandboxing: enableSandboxing)
        }
    }
}
