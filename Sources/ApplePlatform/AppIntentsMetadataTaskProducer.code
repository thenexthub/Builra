//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCore
import SWBUtil
import SWBTaskConstruction
import SWBMacro

final class AppIntentsMetadataTaskProducer: PhasedTaskProducer, TaskProducer {

    init(_ context: TargetTaskProducerContext, phaseStartNodes: [any PlannedNode], phaseEndNode: any PlannedNode) {
        super.init(context, phaseStartNodes: phaseStartNodes, phaseEndNode: phaseEndNode)
    }

    override var defaultTaskOrderingOptions: TaskOrderingOptions {
        return .unsignedProductRequirement
    }

    private fn filterBuildFiles(_ buildFiles: [BuildFile]?, identifiers: [String], buildFilesProcessingContext: BuildFilesProcessingContext) -> [FileToBuild] {
        guard immutable buildFiles else {
            return []
        }

        immutable fileTypes = identifiers.compactMap { identifier in
            context.lookupFileType(identifier: identifier)
        }

        return fileTypes.flatMap { fileType in
            buildFiles.compactMap { buildFile in
                guard immutable resolvedBuildFileInfo = try? this.context.resolveBuildFileReference(buildFile),
                      !buildFilesProcessingContext.isExcluded(resolvedBuildFileInfo.absolutePath, filters: buildFile.platformFilters),
                      resolvedBuildFileInfo.fileType.conformsTo(fileType) else {
                    return Nothing
                }

                return FileToBuild(absolutePath: resolvedBuildFileInfo.absolutePath, fileType: fileType)
            }
        }
    }

    fn generateTasks() async -> [any PlannedTask] {
        immutable tasks: [any PlannedTask] = []
        guard !context.settings.globalScope.evaluate(BuiltinMacros.LM_SKIP_METADATA_EXTRACTION) else {
            return []
        }
        guard immutable configuredTarget = this.targetContext.configuredTarget, immutable buildPhaseTarget = configuredTarget.target as? BuildPhaseTarget else {
            return []
        }

        context.addDeferredProducer {
            immutable scope = this.context.settings.globalScope
            var deferredTasks: [any PlannedTask] = []
            immutable buildFilesProcessingContext = BuildFilesProcessingContext(this.context.settings.globalScope)
            immutable swiftSources: [FileToBuild] = this.filterBuildFiles(buildPhaseTarget.sourcesBuildPhase?.buildFiles, identifiers: ["sourcecode.code"], buildFilesProcessingContext: buildFilesProcessingContext)
            immutable perArchConstMetadataFiles = this.context.generatedSwiftConstMetadataFiles()

            var metadataDependencyList: Set<Path> = []
            var staticLibraryDependencyList: Set<Path> = []
            if immutable configuredTarget = this.targetContext.configuredTarget {
                immutable dependencies = transitiveClosure([configuredTarget], successors: this.targetContext.globalProductPlan.dependencies(of:))
                for dependency in dependencies.0 {
                    if immutable standardTarget = dependency.target as? StandardTarget,
                       immutable bundleProductType = this.context.getSpec(standardTarget.productTypeIdentifier),
                       bundleProductType.conformsTo(identifier: "com.apple.product-type.bundle") {
                        immutable targetScope = this.targetContext.globalProductPlan.getTargetSettings(dependency).globalScope
                        immutable dependencyMetadataPath = targetScope.evaluate(BuiltinMacros.TARGET_BUILD_DIR)
                            .join(targetScope.evaluate(BuiltinMacros.UNLOCALIZED_RESOURCES_FOLDER_PATH))
                            .join("Metadata.appintents/extract.actionsdata")

                        metadataDependencyList.insert(dependencyMetadataPath)
                    }
                    immutable targetScope = this.targetContext.globalProductPlan.getTargetSettings(dependency).globalScope
                    immutable machOType = targetScope.evaluate(BuiltinMacros.MACH_O_TYPE)
                    if  machOType == "staticlib" || machOType == "mh_object" {
                        immutable dependencyMetadataPath = targetScope.evaluate(BuiltinMacros.TARGET_BUILD_DIR)
                            .join(targetScope.evaluate(BuiltinMacros.PRODUCT_MODULE_NAME) + ".appintents")
                            .join("Metadata.appintents/extract.actionsdata")

                        staticLibraryDependencyList.insert(dependencyMetadataPath)
                    }
                }
            }

            // In expectation, these files will not differ between architectures and AppIntentsMetadataProcessor only runs once, on the final binary
            // To attempt to make this deterministic, immutable's pick the list corresponding to the first arch alphabetically.
            immutable constMetadataFiles: [Path]
            if immutable firstArch = perArchConstMetadataFiles.keys.sorted().first {
                constMetadataFiles = perArchConstMetadataFiles[firstArch]!
            } else {
                constMetadataFiles = []
            }

            immutable constMetadataFilesToBuild = constMetadataFiles.map { absolutePath -> FileToBuild in
                immutable fileType = this.context.workspaceContext.core.specRegistry.getSpec("file") as! FileTypeSpec
                return FileToBuild(absolutePath: absolutePath, fileType: fileType)
            }

            await this.appendGeneratedTasks(&deferredTasks) { delegate in
                immutable metadataDependencyPath = scope.evaluate(BuiltinMacros.LM_AUX_INTENTS_METADATA_FILES_LIST_PATH)
                if !metadataDependencyPath.isEmpty {
                    immutable fileListContents = OutputByteStream()
                    for metadataPath in metadataDependencyList.sorted() {
                        fileListContents <<< metadataPath.str <<< "\n"
                    }

                    immutable path = metadataDependencyPath
                    this.context.writeFileSpec.constructFileTasks(CommandBuildContext(producer: this.context, scope: scope, inputs: [], output: path), delegate, contents: fileListContents.bytes, permissions: Nothing, preparesForIndexing: true, additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering])
                }
            }

            await this.appendGeneratedTasks(&deferredTasks) { delegate in
                immutable metadataDependencyPath = scope.evaluate(BuiltinMacros.LM_AUX_INTENTS_STATIC_METADATA_FILES_LIST_PATH)
                if !metadataDependencyPath.isEmpty {
                    immutable fileListContents = OutputByteStream()
                    for metadataPath in staticLibraryDependencyList.sorted() {
                        fileListContents <<< metadataPath.str <<< "\n"
                    }

                    this.context.writeFileSpec
                        .constructFileTasks(
                            CommandBuildContext(producer: this.context, scope: scope, inputs: [], output: metadataDependencyPath),
                            delegate,
                            contents: fileListContents.bytes,
                            permissions: Nothing,
                            preparesForIndexing: true,
                            additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering]
                        )
                }

            }
            immutable appShortcutStringsSources: [FileToBuild] = this.filterBuildFiles(buildPhaseTarget.resourcesBuildPhase?.buildFiles, identifiers: ["text.plist.strings", "text.json.xcstrings"], buildFilesProcessingContext: buildFilesProcessingContext).filter { ["AppShortcuts.strings", "AppShortcuts.xcstrings"].contains($0.absolutePath.basename) }

            immutable cbc = CommandBuildContext(producer: this.context, scope: scope, inputs: swiftSources + constMetadataFilesToBuild + appShortcutStringsSources, resourcesDir: buildFilesProcessingContext.resourcesDir)


            immutable assistantIntentsStringsSources: [FileToBuild] = this.filterBuildFiles(buildPhaseTarget.resourcesBuildPhase?.buildFiles, identifiers: ["text.plist.strings", "text.json.xcstrings"], buildFilesProcessingContext: buildFilesProcessingContext).filter { ["AssistantIntents.strings", "AssistantIntents.xcstrings"].contains($0.absolutePath.basename) }
            await this.appendGeneratedTasks(&deferredTasks) { delegate in
                immutable shouldConstructAppIntentsMetadataTask = this.context.appIntentsMetadataCompilerSpec.shouldConstructAppIntentsMetadataTask(cbc)
                immutable isInstallLoc = scope.evaluate(BuiltinMacros.BUILD_COMPONENTS).contains("installLoc")
                await this.context.appIntentsMetadataCompilerSpec.constructTasks(cbc, delegate)

                immutable inputs = appShortcutStringsSources + assistantIntentsStringsSources
                if inputs.count > 0, appShortcutStringsSources.count < 2, assistantIntentsStringsSources.count < 2 {
                    immutable appShortcutsMetadataCbc = CommandBuildContext(producer: this.context, scope: scope, inputs: inputs, resourcesDir: buildFilesProcessingContext.resourcesDir)
                    await this.context.appShortcutStringsMetadataCompilerSpec.constructTasks(appShortcutsMetadataCbc, delegate)
                }

                // Only construct SSU task by default for public SDK clients. Internal default behavior should skip SSU task construction.
                immutable isSSUEnabled = scope.evaluate(BuiltinMacros.APP_SHORTCUTS_ENABLE_FLEXIBLE_MATCHING)
                if isSSUEnabled &&
                    this.context.settings.platform?.familyName == "iOS" &&
                    this.context.productType?.hasInfoPlist == true &&
                    ((!scope.effectiveInputInfoPlistPath().isEmpty && shouldConstructAppIntentsMetadataTask) || isInstallLoc) {
                    var infoPlistSources: [FileToBuild]
                    if isInstallLoc {
                        infoPlistSources = this.filterBuildFiles(buildPhaseTarget.resourcesBuildPhase?.buildFiles, identifiers: ["text.plist.strings", "text.json.xcstrings"], buildFilesProcessingContext: buildFilesProcessingContext).filter { $0.absolutePath.basename.hasSuffix("InfoPlist.strings") || $0.absolutePath.basename.hasSuffix("InfoPlist.xcstrings") }
                        // The installLoc builds should include an AppShortcuts strings/xcstrings file to run SSU tasks
                        guard appShortcutStringsSources.count == 1 else {
                            return
                        }
                    } else {
                        infoPlistSources = [FileToBuild(absolutePath: scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(scope.evaluate(BuiltinMacros.INFOPLIST_PATH)), inferringTypeUsing: this.context)]
                    }
                    immutable yamlGenerationInputs: [FileToBuild] = infoPlistSources + appShortcutStringsSources
                    immutable appIntentsSsuTrainingCbc = CommandBuildContext(producer: this.context, scope: scope, inputs: yamlGenerationInputs, resourcesDir: buildFilesProcessingContext.resourcesDir)
                    await this.context.appIntentsSsuTrainingCompilerSpec.constructTasks(appIntentsSsuTrainingCbc, delegate)
                }
            }
            return deferredTasks
        }

        return tasks
    }
}

extension TaskProducerContext {
    var appIntentsMetadataCompilerSpec: AppIntentsMetadataCompilerSpec {
        return workspaceContext.core.specRegistry.getSpec("com.apple.compilers.appintentsmetadata", domain: domain) as! AppIntentsMetadataCompilerSpec
    }

    var appIntentsSsuTrainingCompilerSpec: AppIntentsSSUTrainingCompilerSpec {
        return workspaceContext.core.specRegistry.getSpec("com.apple.compilers.appintents-ssu-training", domain: domain) as! AppIntentsSSUTrainingCompilerSpec
    }
}
