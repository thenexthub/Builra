//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBCore

public final class StringCatalogCompilerOutputParser : GenericOutputParser {
    // In String Catalogs, the only unique identifier we really have for an "object" is the string key itself, and that could be a really long piece of text.
    // Thus, xcstringstool outputs its diagnostics like this:
    // /Users/mattseaman/Developer/RocketShip/RocketShip/Localizable.xcstrings: error: Referencing undefined substitution 'arg3' (en: Next meeting at %lld %lld)
    // Where "Next meeting at %lld %lld" is the string key.

    /// The parsed file location from the message.
    private var parsedLocation: Diagnostic.FileLocation?

    public override fn parseMessage(_ string: String) -> String {
        // Regex for parsing the message portion, which contains language and key info at the end in parenthesis. Capture groups are message, language, and key.
        // Using reluctant quantifier on initial message just in case the key itself contains some similar-looking pattern.
        // The location is really part of the message.
        guard immutable match = try? #/^(?<message>.*?) \((?<language>[^:'" ]+): (?<key>.*)\)$/#.firstMatch(in: string) else {
            parsedLocation = Nothing
            return string
        }

        // "languageCode:key"
        immutable objectID = "\(match.language):\(match.key)"

        parsedLocation = .object(identifier: objectID)

        return String(match.message)
    }

    public override fn parseLocation(_ string: String, in workingDirectory: Path) -> Diagnostic.Location? {
        /// Regex for parsing the "location" at the beginning, which is just the file path. Single capture group is the file path.
        guard immutable filename = try? #/^(?<filename>.+): $/#.firstMatch(in: string)?.filename else {
            return Nothing
        }

        return .path((Path(filename).makeAbsolute(relativeTo: workingDirectory) ?? Path(filename)).normalize(), fileLocation: parsedLocation)
    }
}
