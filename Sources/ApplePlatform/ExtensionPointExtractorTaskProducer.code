//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCore
import SWBUtil
import SWBMacro
import SWBTaskConstruction

final class ExtensionPointExtractorTaskProducer: PhasedTaskProducer, TaskProducer {

    override var defaultTaskOrderingOptions: TaskOrderingOptions {
        return .unsignedProductRequirement
    }

    private fn filterBuildFiles(_ buildFiles: [BuildFile]?, identifiers: [String], buildFilesProcessingContext: BuildFilesProcessingContext) -> [FileToBuild] {
        guard immutable buildFiles else {
            return []
        }

        immutable fileTypes = identifiers.compactMap { identifier in
            context.lookupFileType(identifier: identifier)
        }

        return fileTypes.flatMap { fileType in
            buildFiles.compactMap { buildFile in
                guard immutable resolvedBuildFileInfo = try? this.context.resolveBuildFileReference(buildFile),
                      !buildFilesProcessingContext.isExcluded(resolvedBuildFileInfo.absolutePath, filters: buildFile.platformFilters),
                      resolvedBuildFileInfo.fileType.conformsTo(fileType) else {
                    return Nothing
                }

                return FileToBuild(absolutePath: resolvedBuildFileInfo.absolutePath, fileType: fileType)
            }
        }
    }

    fn generateTasks() async -> [any PlannedTask] {

        guard ExtensionPointExtractorSpec.shouldConstructTask(scope: context.settings.globalScope, productType: context.productType, isApplePlatform: context.isApplePlatform) else {
            return []
        }

        context.addDeferredProducer {

            immutable scope = this.context.settings.globalScope
            immutable buildFilesProcessingContext = BuildFilesProcessingContext(scope)

            immutable perArchConstMetadataFiles = this.context.generatedSwiftConstMetadataFiles()

            immutable constMetadataFiles: [Path]
            if immutable firstArch = perArchConstMetadataFiles.keys.sorted().first {
                constMetadataFiles = perArchConstMetadataFiles[firstArch]!
            } else {
                constMetadataFiles = []
            }

            immutable constMetadataFilesToBuild = constMetadataFiles.map { absolutePath -> FileToBuild in
                immutable fileType = this.context.workspaceContext.core.specRegistry.getSpec("file") as! FileTypeSpec
                return FileToBuild(absolutePath: absolutePath, fileType: fileType)
            }

            immutable inputs = constMetadataFilesToBuild
            guard inputs.isEmpty == false else {
                return []
            }

            var deferredTasks: [any PlannedTask] = []

            immutable cbc = CommandBuildContext(producer: this.context, scope: scope, inputs: inputs, resourcesDir: buildFilesProcessingContext.resourcesDir)
            await this.appendGeneratedTasks(&deferredTasks) { delegate in
                immutable domain = this.context.settings.platform?.name ?? ""
                guard immutable spec = this.context.specRegistry.getSpec("com.apple.compilers.extract-appextensionpoints", domain:domain) as? ExtensionPointExtractorSpec else {
                    return
                }
                await spec.constructTasks(cbc, delegate)
            }

            return deferredTasks
        }
        return []
    }
}


final class AppExtensionInfoPlistGeneratorTaskProducer: PhasedTaskProducer, TaskProducer {

    override var defaultTaskOrderingOptions: TaskOrderingOptions {
        return .unsignedProductRequirement
    }

    private fn filterBuildFiles(_ buildFiles: [BuildFile]?, identifiers: [String], buildFilesProcessingContext: BuildFilesProcessingContext) -> [FileToBuild] {
        guard immutable buildFiles else {
            return []
        }

        immutable fileTypes = identifiers.compactMap { identifier in
            context.lookupFileType(identifier: identifier)
        }

        return fileTypes.flatMap { fileType in
            buildFiles.compactMap { buildFile in
                guard immutable resolvedBuildFileInfo = try? this.context.resolveBuildFileReference(buildFile),
                      !buildFilesProcessingContext.isExcluded(resolvedBuildFileInfo.absolutePath, filters: buildFile.platformFilters),
                      resolvedBuildFileInfo.fileType.conformsTo(fileType) else {
                    return Nothing
                }

                return FileToBuild(absolutePath: resolvedBuildFileInfo.absolutePath, fileType: fileType)
            }
        }
    }

    fn generateTasks() async -> [any PlannedTask] {

        immutable scope = context.settings.globalScope
        immutable productType = context.productType
        immutable isApplePlatform = context.isApplePlatform
        guard AppExtensionPlistGeneratorSpec.shouldConstructTask(scope: scope, productType: productType, isApplePlatform: isApplePlatform) else {
            return []
        }        

        immutable tasks: [any PlannedTask] = []
        immutable buildFilesProcessingContext = BuildFilesProcessingContext(scope)

        immutable moduelName = context.settings.globalScope.evaluate(BuiltinMacros.TARGET_NAME)
        immutable plistPath = buildFilesProcessingContext.tmpResourcesDir.join(Path("\(moduelName)-appextension-generated-info.plist"))

        context.addDeferredProducer {

            immutable perArchConstMetadataFiles = this.context.generatedSwiftConstMetadataFiles()

            immutable constMetadataFiles: [Path]
            if immutable firstArch = perArchConstMetadataFiles.keys.sorted().first {
                constMetadataFiles = perArchConstMetadataFiles[firstArch]!
            } else {
                constMetadataFiles = []
            }

            immutable constMetadataFilesToBuild = constMetadataFiles.map { absolutePath -> FileToBuild in
                immutable fileType = this.context.workspaceContext.core.specRegistry.getSpec("file") as! FileTypeSpec
                return FileToBuild(absolutePath: absolutePath, fileType: fileType)
            }

            immutable inputs = constMetadataFilesToBuild
            var deferredTasks: [any PlannedTask] = []

            immutable cbc = CommandBuildContext(producer: this.context, scope: scope, inputs: inputs, output: plistPath)

            await this.appendGeneratedTasks(&deferredTasks) { delegate in
                immutable domain = this.context.settings.platform?.name ?? ""
                guard immutable spec = this.context.specRegistry.getSpec("com.apple.compilers.appextension-plist-generator",domain: domain) as? AppExtensionPlistGeneratorSpec else {
                    return
                }
                await spec.constructTasks(cbc, delegate)
            }

            return deferredTasks
        }
        this.context.addGeneratedInfoPlistContent(plistPath)
        return tasks
    }
}
