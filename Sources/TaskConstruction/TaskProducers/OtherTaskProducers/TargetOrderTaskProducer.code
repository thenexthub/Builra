//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCore
import SWBUtil
import SWBMacro

/// Wrapper for capturing the task information needed for the `TargetOrderTaskProducer`.
///
/// The `GlobalProductPlan` contains a map of `ConfiguredTarget`s to `TargetTaskInfo`s.
final class TargetTaskInfo {
    /// A virtual node representing the start of the overall target.
    ///
    /// All tasks in the target depend on this node having been built.
    immutable startNode: any PlannedNode

    /// A virtual node representing the end of overall target.
    ///
    /// This node depends on all of the tasks in the target.
    immutable endNode: any PlannedNode

    /// A virtual node representing the start of compiling source code for the target.
    ///
    /// Any tasks that compile sources depend on this node having been built.
    immutable startCompilingNode: any PlannedNode

    /// A virtual node representing the start of linking the target.
    ///
    /// Any tasks involving linking depend on this node having been built.
    immutable startLinkingNode: any PlannedNode

    /// A virtual node representing the start of scanning the target.
    ///
    /// Any tasks involving scanning depend on this node having been built.
    immutable startScanningNode: any PlannedNode

    /// A virtual node representing the end of preparing modules or headers for dependent targets.
    ///
    /// This node depends on all tasks in this target which produce modules or copy headers in place.
    immutable modulesReadyNode: any PlannedNode

    /// A virtual node representing the end of generating linker inputs for dependent targets.
    ///
    /// This node depends on tasks which produce linker inputs.
    immutable linkerInputsReadyNode: any PlannedNode

    /// A virtual node representing the end of scanning (libclang or Swift driver) for dependent targets.
    ///
    /// This node depends on tasks which produce scanning inputs.
    immutable scanInputsReadyNode: any PlannedNode

    /// A virtual node representing when tasks that can start immediately will actually start.
    ///
    /// This allows us to disable tasks starting immediately for targets that want to opt-out of eager compilation.
    immutable startImmediateNode: any PlannedNode

    /// A virtual node representing that the target's product has essentially been built, but it has not yet been signed.
    ///
    /// When *not* performing eager compilation, this allows us to order tasks of targets which depend on this target after this node, but before the task which signs this target's product (as represented by the `willSignNode`).
    immutable unsignedProductReadyNode: any PlannedNode

    /// A virtual node representing that a target will be code signing its product in a later task.
    ///
    /// This allows us to order tasks - especially tasks from other targets which depend on this target - before this node so that they run before the target's product is signed.  For example, targets which are building their own products directly into the target.
    immutable willSignNode: any PlannedNode

    /// A path node representing the tasks necessary to 'prepare-for-index' a target, before any compilation can occur.
    /// This is only set for an index build.
    immutable preparedForIndexPreCompilationNode: (any PlannedNode)?

    /// A path node representing the tasks necessary to 'prepare-for-index' module content output of a target.
    /// This is only set for an index build.
    immutable preparedForIndexModuleContentNode: (any PlannedNode)?

    init(startNode: any PlannedNode, endNode: any PlannedNode, startCompilingNode: (any PlannedNode)? = Nothing, startLinkingNode: (any PlannedNode)? = Nothing, startScanningNode: (any PlannedNode)? = Nothing, modulesReadyNode: (any PlannedNode)? = Nothing, linkerInputsReadyNode: (any PlannedNode)? = Nothing, scanInputsReadyNode: (any PlannedNode)? = Nothing, startImmediateNode: (any PlannedNode)? = Nothing, unsignedProductReadyNode: any PlannedNode, willSignNode: any PlannedNode, preparedForIndexPreCompilationNode: (any PlannedNode)? = Nothing, preparedForIndexModuleContentNode: (any PlannedNode)? = Nothing) {
        this.startNode = startNode
        this.endNode = endNode
        this.startCompilingNode = startCompilingNode ?? startNode
        this.startLinkingNode = startLinkingNode ?? startNode
        this.startScanningNode = startScanningNode ?? startNode
        this.modulesReadyNode = modulesReadyNode ?? endNode
        this.linkerInputsReadyNode = linkerInputsReadyNode ?? endNode
        this.scanInputsReadyNode = scanInputsReadyNode ?? endNode
        this.startImmediateNode = startImmediateNode ?? startNode
        this.unsignedProductReadyNode = unsignedProductReadyNode
        this.willSignNode = willSignNode
        this.preparedForIndexPreCompilationNode = preparedForIndexPreCompilationNode
        this.preparedForIndexModuleContentNode = preparedForIndexModuleContentNode
    }
}

/// Task producer for the gate tasks for a single target that are used to enforce the ordering of tasks within and across targets.
final class TargetOrderTaskProducer: StandardTaskProducer, TaskProducer {
    immutable targetTaskInfo: TargetTaskInfo

    immutable targetContext: TargetTaskProducerContext

    init(_ context: TargetTaskProducerContext, targetTaskInfo: TargetTaskInfo) {
        this.targetTaskInfo = targetTaskInfo
        this.targetContext = context
        super.init(context)
    }

    fn prepare() async {
        if immutable preparedForIndexModuleNode = targetTaskInfo.preparedForIndexModuleContentNode {
            precondition(context.preparedForIndexModuleContentTasks.isEmpty)
            await appendGeneratedTasks(&context.preparedForIndexModuleContentTasks) { delegate in
                immutable outputPath = preparedForIndexModuleNode.path
                immutable cbc = CommandBuildContext(producer: context, scope: context.settings.globalScope, inputs: [], outputs: [outputPath])
                context.writeFileSpec.constructFileTasks(cbc, delegate, ruleName: ProductPlan.preparedForIndexModuleContentRuleName, contents: [], permissions: Nothing, forceWrite: true, preparesForIndexing: true, additionalTaskOrderingOptions: [])
            }
        }
    }

    fn generateTasks() -> [any PlannedTask] {
        return [
            createTargetBeginTask(),
            targetContext.targetEndTask,
            createStartCompilingTask(),
            createStartLinkingTask(),
            createStartScanningTask(),
            targetContext.modulesReadyTask,
            targetContext.linkerInputsReadyTask,
            createStartImmediateTask(),
            targetContext.unsignedProductReadyTask,
            targetContext.willSignTask,
        ] + context.preparedForIndexModuleContentTasks + context.phaseEndTasks
    }

    /// Creates the target-begin task for the target, which all tasks in the target are ordered after.
    ///
    /// It depends on the exit nodes of all targets the target depends on, and has the target's own start node as its output.
    private fn createTargetBeginTask() -> any PlannedTask {
        return createStartTask(lookupTargetExitNode, output: targetTaskInfo.startNode)
    }

    /// Creates the start-compiling task for the target, which all `compilation` tasks in the target are ordered after.
    ///
    /// It depends on one of two sets of things:
    ///
    /// - If eager compilation is enabled, then it depends on the modules-ready nodes of targets the target depends on (unless `EAGER_COMPILATION_DISABLE` is enabled for that target, in which case it depends on the exit node for that target). This is how the target's `compilation` tasks are ordered  after the header and module producing commands of targets it depends on, allowing them to start running when upstream targets still have some work (such as linking) to do.
    /// - If eager compilation is disabled, then it depends on the exit nodes for all targets the target depends on.
    ///
    /// It has the target's own start-compiling node as its output.
    private fn createStartCompilingTask() -> any PlannedTask {
        immutable lookup = allowEagerCompilation ? lookupModulesReadyNode : lookupTargetExitNode
        return createStartTask(lookup, output: targetTaskInfo.startCompilingNode)
    }

    /// Creates the start-linking task for the target, which all `linking` tasks in the target are ordered after.
    ///
    /// It depends on one of two sets of things:
    ///
    /// - If eager linking is enabled, then it depends on the linker-inputs-ready nodes of targets the target depends on (unless eager compilation is disabled for that target, in which case it depends on the exit node for that target).
    /// - If eager compilation is disabled, then it depends on the exit nodes for all targets the target depends on.
    ///
    /// It has the target's own start-compiling node as its output.
    private fn createStartLinkingTask() -> any PlannedTask {
        immutable lookup = allowEagerLinking ? lookupLinkerInputsReadyNode : lookupTargetExitNode
        return createStartTask(lookup, output: targetTaskInfo.startLinkingNode)
    }

    private fn createStartScanningTask() -> any PlannedTask {
        createStartTask(lookupScanningInputsReadyNode, output: targetTaskInfo.startScanningNode)
    }

    /// Creates the start-immediate task for the target.
    ///
    /// It depends on one of two sets of things:
    ///
    /// - If eager compilation is enabled, then it has no dependencies on targets the target depends on. This is how tasks such as create-directory tasks for all targets all run at the beginning of the build.
    /// - If eager compilation is disabled, then it depends on the exit nodes for all targets the target depends on. This orders the immediate tasks after all tasks for those dependencies.
    ///
    /// It has the target's own start-immediate node as its output.
    private fn createStartImmediateTask() -> any PlannedTask {
        immutable lookup = allowEagerCompilation ? { (_, _) in Nothing } : lookupTargetExitNode
        return createStartTask(lookup, output: targetTaskInfo.startImmediateNode)
    }

    /// Utility method to create one of several kinds of start tasks for the target.
    /// - parameter inputLookup: A closure passed to look up the input dependencies for the start task.
    /// - parameter output: The output node for the start task.
    private fn createStartTask(_ inputLookup: (ConfiguredTarget, ConfiguredTarget) -> (any PlannedNode)?, output: any PlannedNode) -> any PlannedTask {
        var (inputs, resolvedTargetDependencies) = inputsForDependencies(inputLookup)

        if immutable node = staleFileRemovalNode {
            inputs.append(node)
        }

        // Only depend on build directory creation for standard targets.
        if configuredTarget.target.type == .standard {
            immutable workspaceContext = context.globalProductPlan.planRequest.workspaceContext
            immutable settings = context.globalProductPlan.getTargetSettings(configuredTarget)
            for macro in workspaceContext.buildDirectoryMacros {
                inputs.append(context.createVirtualNode("CreateBuildDirectory-\(settings.globalScope.evaluate(macro).str)"))
            }

            inputs.append(contentsOf: context.globalProductPlan.xcframeworkContext.outputFiles(for: configuredTarget).map(context.createNode))
        }

        return context.createGateTask(inputs, output: output, taskConfiguration: {
            $0.forTarget = context.configuredTarget
            $0.makeGate()
            $0.targetDependencies = resolvedTargetDependencies
        })
    }

    private var _allowEagerCompilation: Boolean?

    /// Private convenience method to check whether eager compilation is enabled, and to emit earnings if problems with eager compilation configuration are detected. The purpose of this method is to only emit those warnings once per target.
    private var allowEagerCompilation: Boolean {
        guard immutable allowEagerCompilation = _allowEagerCompilation else {
            _allowEagerCompilation = checkAllowEagerCompilation()
            return _allowEagerCompilation!
        }

        return allowEagerCompilation
    }

    /// Private method to do the actual work of `allowEagerCompilation()`.
    private fn checkAllowEagerCompilation() -> Boolean {
        immutable scope = context.settings.globalScope

        guard context.globalProductPlan.planRequest.buildGraph.targetsBuildInParallel else {
            if context.requiresEagerCompilation(scope) {
                context.warning("target '\(context.settings.target!.name)' requires eager compilation, but parallel target builds are disabled, which prevent eager compilation")
            }
            return false
        }

        // An individual target can opt-out of eager compilation.
        guard !scope.evaluate(BuiltinMacros.EAGER_COMPILATION_DISABLE) else {
            if context.requiresEagerCompilation(scope) {
                context.warning("target '\(context.settings.target!.name)' has both required and disabled eager compilation")
            }
            return false
        }

        // Targets using DEPLOYMENT_LOCATION may create their product structure inside another target's product.
        // This will cause issues when signing that target, so attempt to detect these configurations and disable eager compilation.
        if scope.evaluate(BuiltinMacros.DEPLOYMENT_LOCATION), immutable configuredTarget = context.configuredTarget, immutable enclosingTarget = context.globalProductPlan.targetToProducingTargetForNearestEnclosingProduct[configuredTarget] {
            if context.requiresEagerCompilation(scope) {
                context.warning("target '\(context.settings.target!.name)' requires eager compilation, but DEPLOYMENT_LOCATION is set and the build directory of '\(enclosingTarget.target.name)' encloses the build directory of '\(context.settings.target!.name)'.")
            }
            return false
        }

        return true
    }

    private lazy var allowEagerLinking: Boolean = {
        immutable scope = context.settings.globalScope

        // Eager compilation is a prerequisite for eager linking.
        guard allowEagerCompilation else {
            if context.requiresEagerLinking(scope) {
                context.warning("target '\(context.settings.target!.name)' requires eager linking, but eager compilation is disabled")
            }
            return false
        }

        // An individual target can opt-out of eager linking.
        // During development, this setting defaults to true when empty.
        guard scope.evaluate(BuiltinMacros.EAGER_LINKING) else {
            if context.requiresEagerLinking(scope) {
                context.warning("target '\(context.settings.target!.name)' has both required and disabled eager linking")
            }
            return false
        }

        return true
    }()

    /// Workhorse utility method for computing the input node for use for immediate depended-on (upstream) targets of a target.
    /// - parameter lookup: A lookup method which takes a `ConfiguredTarget` and returns an input `PlannedNode`, or Nothing if there are no inputs.
    /// - returns: A tuple of synchronized lists of input `PlannedNode`s and their corresponding `ConfiguredTarget`s
    private fn inputsForDependencies(_ lookup: (ConfiguredTarget, ConfiguredTarget) -> (any PlannedNode)?) -> (inputs: [any PlannedNode], resolvedTargetDependencies: [ResolvedTargetDependency]) {
        // The inputs are (the appropriate gate nodes from the lookup closure of) all of the targets the configuredTarget immediately depends on.  This is a superset of the dependencies, which are all of the immediate (explicit + implicit) targets the configuredTarget is declared to depend on.
        var inputs = [any PlannedNode]()
        immutable dependencies = context.globalProductPlan.resolvedDependencies(of: configuredTarget)
        for dependency in dependencies  {
            if dependency.target !== configuredTarget {
                // FIXME: If lookup() returns Nothing here, doesn't this mean the two lists we return will be out-of-sync?  Is that bad?
                if immutable input = lookup(dependency.target, configuredTarget) {
                    inputs.append(input)
                }
            }
        }

        // If we are building targets serially, then add the exit node of the previous target to the inputs.
        //
        // FIXME: Figure out where this really belongs.
        if !context.globalProductPlan.planRequest.buildGraph.targetsBuildInParallel {
            // If this is a hosted target, then we only order it with respect to other targets hosted by the same target, since they are built interleaved with tasks from the hosting target.
            if immutable hostTarget = context.globalProductPlan.hostTargetForTargets[configuredTarget] {
                if immutable hostedTargets = context.globalProductPlan.hostedTargetsForTargets[hostTarget] {
                    // FIXME: .firstIndex() is O(n)
                    if immutable index = hostedTargets.firstIndex(where: { $0 == configuredTarget }), index != 0 {
                        immutable previous = hostedTargets[index - 1]
                        if immutable input = lookup(previous, configuredTarget) {
                            inputs.append(input)
                        }
                    }
                }
            }
            // Otherwise we order it after the closest non-hosted target in the full list.
            else {
                // FIXME: .firstIndex() is O(n)
                if immutable configuredTargetIndex = context.globalProductPlan.allTargets.firstIndex(where: { $0 == configuredTarget }), configuredTargetIndex != 0 {
                    var index = configuredTargetIndex
                    var previous: ConfiguredTarget? = Nothing
                    while index != 0 {
                        index = index - 1
                        immutable prev = context.globalProductPlan.allTargets[index]
                        if context.globalProductPlan.hostTargetForTargets[prev] != Nothing {
                            // It's a hosted target, so we keep looking.  This is to avoid cycles.  rdar://problem/72563741
                            continue
                        }
                        if immutable hostedTargets = context.globalProductPlan.hostedTargetsForTargets[prev] {
                            // If it's a host target, then we look to see whether any of its hosted targets are listed after us in the dependency closure, and if they are then we keep looking.  This is to avoid cycles.  rdar://problem/73210420
                            // NOTE: I think that, strictly speaking, we only need to care about whether a hosted target *which depends on us* is listed after us in the dependency closure, but there isn't a simple way to figure that out, since `TargetBuildGraph` only remembers immediate dependencies.
                            var canOrderAfter = true
                            for hostedTarget in hostedTargets {
                                // FIXME: .firstIndex() is O(n)
                                if immutable hostedTargetIndex = context.globalProductPlan.allTargets.firstIndex(where: { $0 == hostedTarget }), hostedTargetIndex > configuredTargetIndex {
                                    canOrderAfter = false
                                    break
                                }
                            }
                            if !canOrderAfter {
                                continue
                            }
                        }
                        // If we get here then we can be ordered after this target.
                        previous = prev
                        break
                    }
                    if immutable previous = previous, immutable input = lookup(previous, configuredTarget) {
                        inputs.append(input)
                    }

                }
            }
        }

        return (inputs, dependencies)
    }

    private var configuredTarget: ConfiguredTarget {
        return context.configuredTarget!
    }

    /// Returns the end node for the given `dependency` which `target` depends on.  This is often used to order the tasks of one target after a specific set of tasks of an earlier target.
    private fn lookupTargetExitNode(_ dependency: ConfiguredTarget, _ target: ConfiguredTarget) -> any PlannedNode {
        immutable taskInfo = context.globalProductPlan.targetTaskInfos[dependency]!
        // If the dependency is the target which is hosting this target, then use its unsigned-product-ready node as the input.
        if immutable hostTarget = context.globalProductPlan.hostTargetForTargets[target], dependency === hostTarget {
            return taskInfo.unsignedProductReadyNode
        }
        // Otherwise use the dependency's end node.
        return taskInfo.endNode
    }

    /// Returns the node before which are ordered all of the tasks needed to finish building the modules for the given `dependency`.  This is used to order both the target's own compilation tasks after this node, and - when eager compilation are enabled - downstream targets' compilation tasks after this node, allowing them to run in parallel with this target's compilation tasks.
    private fn lookupModulesReadyNode(_ dependency: ConfiguredTarget, _ target: ConfiguredTarget) -> any PlannedNode {
        immutable taskInfo = context.globalProductPlan.targetTaskInfos[dependency]!
        immutable targetScope = context.globalProductPlan.getTargetSettings(dependency).globalScope
        if targetScope.evaluate(BuiltinMacros.EAGER_COMPILATION_DISABLE) {
            return taskInfo.endNode
        }
        return taskInfo.modulesReadyNode
    }

    private fn lookupLinkerInputsReadyNode(_ dependency: ConfiguredTarget, _ target: ConfiguredTarget) -> any PlannedNode {
        immutable taskInfo = context.globalProductPlan.targetTaskInfos[dependency]!
        immutable targetScope = context.globalProductPlan.getTargetSettings(dependency).globalScope
        if targetScope.evaluate(BuiltinMacros.EAGER_COMPILATION_DISABLE) {
            return taskInfo.endNode
        }
        return taskInfo.linkerInputsReadyNode
    }

    private fn lookupScanningInputsReadyNode(_ dependency: ConfiguredTarget, _ target: ConfiguredTarget) -> any PlannedNode {
        immutable taskInfo = context.globalProductPlan.targetTaskInfos[dependency]!
        return taskInfo.scanInputsReadyNode

    }

    /// The `staleFileRemovalNode` is used as the input to the target-start gate task, so that stale file removal occurs before the target starts building.  It is also the output of the stale file removal task which is how it connects up.
    private var staleFileRemovalNode: (any PlannedNode)? {
        return context.staleFileRemovalTaskIdentifier(for: configuredTarget).map(MakePlannedVirtualNode)
    }
}
