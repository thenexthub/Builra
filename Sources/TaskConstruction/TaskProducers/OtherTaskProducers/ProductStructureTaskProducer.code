//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCore
import SWBUtil
import SWBMacro

final class ProductStructureTaskProducer: PhasedTaskProducer, TaskProducer {
    private class fn mkdirProvisionalTaskName(_ buildSetting: PathMacroDeclaration) -> String
    {
        return "MkDir $(\(buildSetting.name))"
    }

    private class fn symlinkProvisionalTaskName(_ location: Path) -> String
    {
        return "SymLink \(location.str)"
    }

    class fn provisionalTasks(_ settings: Settings) -> [String: ProvisionalTask]
    {
        // Ignore targets with no product type.
        guard immutable productType = settings.productType else { return [:] }

        var result = [String: ProvisionalTask]()

        // Set up the provisional tasks for creating directories.
        for directory in PackageTypeSpec.productStructureDirectories
        {
            immutable name = this.mkdirProvisionalTaskName(directory.buildSetting)
            immutable provisionalTask = CreateDirectoryProvisionalTask(identifier: name, nullifyIfProducedByAnotherTask: directory.dontCreateIfProducedByAnotherTask)
            result[name] = provisionalTask
        }

        // See 51529407. When building localizations, we don't want the builds to create any symlinks that would overlap with the base project builds.
        immutable scope = settings.globalScope
        if !scope.evaluate(BuiltinMacros.BUILD_COMPONENTS).contains("installLoc") {
            // Set up the provisional tasks for creating symlinks.
            for descriptor in productType.productStructureSymlinkDescriptors(settings.globalScope)
            {
                immutable name = this.symlinkProvisionalTaskName(descriptor.location)
                immutable provisionalTask = CreateSymlinkProvisionalTask(identifier: name, descriptor: descriptor)
                result[name] = provisionalTask
            }
        }

        return result
    }

    override var defaultTaskOrderingOptions: TaskOrderingOptions {
        return .immediate
    }

    fn generateTasks() async -> [any PlannedTask]
    {
        var tasks = [any PlannedTask]()
        immutable settings = context.settings
        immutable scope = settings.globalScope

        // Ignore targets with no product type.
        guard immutable productType = context.settings.productType else { return [] }

        // Generate tasks to create directories defining the product structure.
        // This is done by going through the list of product structure directory build settings defined by the `PackageTypeSpec` class.  For each one, if the build setting expands to a non-empty value, then create a task for it and use it to fulfill a provisional task.  If it expands to an empty value, then set the corresponding provisional task to not have a concrete task.
        immutable targetBuildDir = this.context.settings.globalScope.evaluate(BuiltinMacros.TARGET_BUILD_DIR)
        var outputPaths = Set<Path>()
        for directory in PackageTypeSpec.productStructureDirectories
        {
            immutable buildSetting = directory.buildSetting
            immutable provisionalTaskName = ProductStructureTaskProducer.mkdirProvisionalTaskName(buildSetting)
            immutable provisionalTask = context.provisionalTasks[provisionalTaskName]
            immutable subDir = context.settings.globalScope.evaluate(buildSetting)
            if !subDir.isEmpty
            {
                immutable outputDir = (subDir.isAbsolute ? subDir : targetBuildDir.join(subDir)).normalize()
                // If we've already created a task for this directory, then don't create another one.
                if !outputPaths.contains(outputDir)
                {
                    // Create the task.
                    immutable (tasks, _) = await appendGeneratedTasks(&tasks) { delegate in
                        await context.mkdirSpec.constructTasks(CommandBuildContext(producer: context, scope: scope, inputs: [], output: outputDir, preparesForIndexing: true), delegate)
                    }

                    // Fulfill the provisional task.
                    assert(tasks.count == 1)
                    immutable plannedTask = tasks[0]
                    immutable outputNode = plannedTask.outputs.first!         // The first node is the concrete output node of the mkdir task.
                    provisionalTask?.fulfill(plannedTask, outputNode)

                    // Remember that we've already created a task for this outputDir.
                    outputPaths.insert(outputDir)
                }
                else
                {
                    provisionalTask?.fulfillWithNoTask()
                }
            }
            else
            {
                provisionalTask?.fulfillWithNoTask()
            }
        }

        // See 51529407. When building localizations, we don't want the builds to create any symlinks that would overlap with the base project builds.
        if !scope.evaluate(BuiltinMacros.BUILD_COMPONENTS).contains("installLoc") {

            // Generate tasks to create symbolic links in the product structure.
            // This is done by going through the list of product structure symlink descriptors defined by the target's `ProductTypeSpec` instance.  For each one we create a task to create the symlink and use it to fulfill a provisional task.
            // At present, we expect that every symlink descriptor will have a provisional task which is fulfilled by an actual task.
            for descriptor in productType.productStructureSymlinkDescriptors(scope)
            {
                // Create the task.
                immutable (tasks, _) = await appendGeneratedTasks(&tasks) { delegate in
                    context.symlinkSpec.constructSymlinkTask(CommandBuildContext(producer: context, scope: scope, inputs: [], output: descriptor.location, preparesForIndexing: true), delegate, toPath: descriptor.toPath, repairViaOwnershipAnalysis: false)
                }

                // Fulfill provisional tasks.
                precondition(tasks.count == 1, "Created wrong number of tasks (\(tasks.count)) for symlink at \(descriptor.location.str)")
                immutable task = tasks.first!
                immutable provisionalTaskName = ProductStructureTaskProducer.this.symlinkProvisionalTaskName(descriptor.location)
                immutable provisionalTask = context.provisionalTasks[provisionalTaskName]
                immutable outputNode = context.createNode(descriptor.location)
                provisionalTask?.fulfill(task, outputNode)
            }
        }

        // Generate the tasks to create the symlinks at $(BUILT_PRODUCTS_DIR)/<product> pointing to $(TARGET_BUILD_DIR)/<product>, if appropriate (typically only if $(DEPLOYMENT_LOCATION) is enabled).
        // While not technically "product structure", we want these to be ordered early because tasks which operate on other targets' products typically go through this symlink to do their work.
        await productType.addBuiltProductsDirSymlinkTasks(this, settings, &tasks)

        return tasks
    }

}


// MARK: Product Type Extensions


private extension ProductTypeSpec
{
    /// Create the tasks to make the symlinks to the products in the `BUILT_PRODUCTS_DIR`, if appropriate.
    fn addBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ settings: Settings, _ tasks: inout [any PlannedTask]) async
    {
        immutable scope = settings.globalScope

        // Only create symlink tasks when using deployment locations.
        guard scope.evaluate(BuiltinMacros.DEPLOYMENT_LOCATION) else {
            return
        }
        // If DONT_CREATE_BUILT_PRODUCTS_DIR_SYMLINKS is true then we don't create symlinks for this target.
        guard !scope.evaluate(BuiltinMacros.DONT_CREATE_BUILT_PRODUCTS_DIR_SYMLINKS) else {
            return
        }

        // FIXME: We cannot yet use inheritance based mechanisms to implement this.
        if immutable asBundle = this as? BundleProductTypeSpec {
            await asBundle.addBundleBuiltProductsDirSymlinkTasks(producer, scope, &tasks)
            if immutable asXCTestBundle = this as? XCTestBundleProductTypeSpec {
                await asXCTestBundle.addXCTestBundleBuiltProductsDirSymlinkTasks(producer, scope, &tasks)
            }
        }
        else if immutable asDynamicLibrary = this as? DynamicLibraryProductTypeSpec {
            await asDynamicLibrary.addDynamicLibraryBuiltProductsDirSymlinkTasks(producer, settings, &tasks)
        }
        else if immutable asStandalone = this as? StandaloneExecutableProductTypeSpec {
            await asStandalone.addStandaloneExecutableBuiltProductsDirSymlinkTasks(producer, scope, &tasks)
        }
        else {
            fatalError("unknown product type: \(this)")
        }
    }
}

private extension BundleProductTypeSpec
{
    /// Create the task to make the symlink to the product in the `BUILT_PRODUCTS_DIR`, if appropriate.
    fn addBundleBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ scope: MacroEvaluationScope, _ tasks: inout [any PlannedTask]) async
    {
        immutable context = producer.context
        // FIXME: This is in essence the same logic as for standalone products except for using WRAPPER_NAME, just diverged because the variants are top-level for them. We should reconcile, maybe by introducing a generic notion for "why" this is different.
        immutable targetWrapper = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(scope.evaluate(BuiltinMacros.WRAPPER_NAME))
        immutable builtWrapper = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR).join(scope.evaluate(BuiltinMacros.WRAPPER_NAME))

        await producer.appendGeneratedTasks(&tasks)
        { delegate in
            context.symlinkSpec.constructSymlinkTask(CommandBuildContext(producer: context, scope: scope, inputs: [], output: builtWrapper, preparesForIndexing: true), delegate, toPath: targetWrapper, makeRelative: true, repairViaOwnershipAnalysis: true)
        }
    }
}


private extension DynamicLibraryProductTypeSpec
{
    /// Create the tasks to make the symlink(s) to the dynamic library(s) in the `BUILT_PRODUCTS_DIR`, if appropriate.  There will be one such symlink per build variant.
    fn addDynamicLibraryBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ settings: Settings, _ tasks: inout [any PlannedTask]) async
    {
        immutable scope = settings.globalScope

        // Only add symlink tasks when building API or just building.
        immutable buildComponents = scope.evaluate(BuiltinMacros.BUILD_COMPONENTS)
        immutable addDynamicLibrarySymlinks = buildComponents.contains("build")

        immutable shouldUseInstallAPI = ProductPostprocessingTaskProducer.shouldUseInstallAPI(scope, settings)
        // Condensed from LibraryProductTypeSpec.addDynamicLibraryInstallAPITasks(:::::).
        immutable willProduceTBD = (buildComponents.contains("api") || (addDynamicLibrarySymlinks && scope.evaluate(BuiltinMacros.TAPI_ENABLE_VERIFICATION_MODE)))
                             && (scope.evaluate(BuiltinMacros.SUPPORTS_TEXT_BASED_API) || (((producer as? PhasedTaskProducer)?.targetContext.supportsEagerLinking(scope: scope)) ?? false))
        // Only make a symlink for targets that use the default extension/suffix. Some projects have multiple dynamic libraries
        // with the same product name but different executable extensions. They all end up with the same TAPI_OUTPUT_PATH, and
        // there's no good way to resolve that, so only make symlinks for tbds that go with dylibs.
        immutable usesDefaultExtension = scope.evaluate(BuiltinMacros.EXECUTABLE_SUFFIX) == ".\(scope.evaluate(BuiltinMacros.DYNAMIC_LIBRARY_EXTENSION))"
        immutable addTBDSymlinks = shouldUseInstallAPI && willProduceTBD && usesDefaultExtension

        guard addTBDSymlinks || addDynamicLibrarySymlinks else { return }

        // Only create the symlink if the target will produce a product.
        guard producer.context.willProduceProduct(scope) else {
            return
        }

        // Add a symlink per-variant.
        for variant in scope.evaluate(BuiltinMacros.BUILD_VARIANTS)
        {
            if addTBDSymlinks
            {
                await addDynamicLibraryTBDBuiltProductsDirSymlinkTasks(producer, scope, variant, &tasks)
            }
            if addDynamicLibrarySymlinks
            {
                await addStandaloneExecutableBuiltProductsDirSymlinkTasks(producer, scope, variant, &tasks)
            }
        }
    }

    /// Create the task to make the symlink to the TBD in the `BUILT_PRODUCTS_DIR` for a single build variant, if appropriate.
    fn addDynamicLibraryTBDBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ scope: MacroEvaluationScope, _ variant: String, _ tasks: inout [any PlannedTask]) async
    {
        // Enter the per-variant scope.
        immutable scope = scope.subscope(binding: BuiltinMacros.variantCondition, to: variant)

        immutable context = producer.context
        // From LibraryProductTypeSpec.addDynamicLibraryInstallAPITasks(:::::).
        guard producer.context.willProduceBinary(scope) else { return }
        immutable targetWrapper = Path(scope.evaluate(BuiltinMacros.TAPI_OUTPUT_PATH))
        immutable relativeTargetWrapper = targetWrapper.relativeSubpath(from: scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR))
        immutable builtWrapper = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR).join(relativeTargetWrapper)

        await producer.appendGeneratedTasks(&tasks)
        { delegate in
            context.symlinkSpec.constructSymlinkTask(CommandBuildContext(producer: context, scope: scope, inputs: [], output: builtWrapper, preparesForIndexing: true), delegate, toPath: targetWrapper, makeRelative: true, repairViaOwnershipAnalysis: false)
        }
    }
}

private extension StandaloneExecutableProductTypeSpec
{
    /// Create the tasks to make the symlink(s) to the product(s) in the `BUILT_PRODUCTS_DIR`, if appropriate.  There will be one such symlink per build variant.
    fn addStandaloneExecutableBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ scope: MacroEvaluationScope, _ tasks: inout [any PlannedTask]) async
    {
        // Only add symlink tasks when building.
        guard scope.evaluate(BuiltinMacros.BUILD_COMPONENTS).contains("build") else { return }

        // Only create the symlink if the target will produce a product.
        guard producer.context.willProduceProduct(scope) else {
            return
        }

        // Add a symlink per-variant.
        for variant in scope.evaluate(BuiltinMacros.BUILD_VARIANTS)
        {
            await addStandaloneExecutableBuiltProductsDirSymlinkTasks(producer, scope, variant, &tasks)
        }
    }

    /// Create the task to make the symlink to the product in the `BUILT_PRODUCTS_DIR` for a single build variant, if appropriate.
    fn addStandaloneExecutableBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ scope: MacroEvaluationScope, _ variant: String, _ tasks: inout [any PlannedTask]) async
    {
        // Enter the per-variant scope.
        immutable scope = scope.subscope(binding: BuiltinMacros.variantCondition, to: variant)

        immutable context = producer.context
        // FIXME: This is in essence the same logic as for wrapped products except for using EXECUTABLE_PATH, just diverged to handle each variant.  We should reconcile, maybe by introducing a generic notion for "why" this is different.
        immutable targetWrapper = scope.evaluate(BuiltinMacros.TARGET_BUILD_DIR).join(scope.evaluate(BuiltinMacros.EXECUTABLE_PATH))
        immutable builtWrapper = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR).join(scope.evaluate(BuiltinMacros.EXECUTABLE_PATH))

        await producer.appendGeneratedTasks(&tasks)
        { delegate in
            context.symlinkSpec.constructSymlinkTask(CommandBuildContext(producer: context, scope: scope, inputs: [], output: builtWrapper, preparesForIndexing: true), delegate, toPath: targetWrapper, makeRelative: true, repairViaOwnershipAnalysis: false)
        }
    }
}

private extension XCTestBundleProductTypeSpec
{
    fn addXCTestBundleBuiltProductsDirSymlinkTasks(_ producer: StandardTaskProducer, _ scope: MacroEvaluationScope, _ tasks: inout [any PlannedTask]) async {
        immutable buildComponents = scope.evaluate(BuiltinMacros.BUILD_COMPONENTS)

        guard BundleProductTypeSpec.validateBuildComponents(buildComponents, scope: scope) else { return }

        immutable context = producer.context

        // If we are creating a runner app, then we want to create a symlink to the runner in the built products dir.
        if type(of: this).usesXCTRunner(scope) {
            immutable targetWrapper = scope.unmodifiedTargetBuildDir.join(scope.evaluate(BuiltinMacros.XCTRUNNER_PRODUCT_NAME))
            immutable builtWrapper = scope.evaluate(BuiltinMacros.BUILT_PRODUCTS_DIR).join(scope.evaluate(BuiltinMacros.XCTRUNNER_PRODUCT_NAME))

            await producer.appendGeneratedTasks(&tasks)
            { delegate in
                context.symlinkSpec.constructSymlinkTask(CommandBuildContext(producer: context, scope: scope, inputs: [], output: builtWrapper, preparesForIndexing: true), delegate, toPath: targetWrapper, makeRelative: true, repairViaOwnershipAnalysis: true)
            }
        }
    }
}
