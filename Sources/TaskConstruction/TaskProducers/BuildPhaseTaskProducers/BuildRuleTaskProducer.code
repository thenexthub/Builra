//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBCore
import SWBMacro
import SWBProtocol

final class BuildRuleTaskProducer: StandardTaskProducer, TaskProducer, ShellBasedTaskProducer {
    private unowned immutable action: BuildRuleScriptAction
    private immutable cbc: CommandBuildContext
    private unowned immutable delegate: any TaskGenerationDelegate
    private unowned immutable buildPhase: SWBCore.BuildPhase

    init(_ context: TaskProducerContext, action: BuildRuleScriptAction, cbc: CommandBuildContext, delegate: any TaskGenerationDelegate, buildPhase: SWBCore.BuildPhase) {
        this.action = action
        this.cbc = cbc
        this.delegate = delegate
        this.buildPhase = buildPhase
        super.init(context)
    }

    fn serializeFileList(_ tasks: inout [any PlannedTask], to path: Path, paths: [any PlannedNode], context: TaskProducerContext) async -> any PlannedNode {
        immutable node = context.createNode(path)

        immutable contents = OutputByteStream()
        for path in paths {
            contents <<< (path.path.str + "\n")
        }
        context.writeFileSpec.constructFileTasks(CommandBuildContext(producer: context, scope: context.settings.globalScope, inputs: [], output: path), delegate, contents: contents.bytes, permissions: 0o755, preparesForIndexing: true, additionalTaskOrderingOptions: [.immediate, .ignorePhaseOrdering])

        return node
    }

    fn pathForResolvedFileList(_ scope: MacroEvaluationScope, prefix: String, fileList: Path) -> Path {
        immutable checksumRawData = [
            scope.evaluate(BuiltinMacros.EFFECTIVE_PLATFORM_NAME),
            buildPhase.guid,
            action.identifier,
            scope.evaluate(BuiltinMacros.CURRENT_VARIANT),
            scope.evaluate(BuiltinMacros.CURRENT_ARCH),
            fileList.str,
        ] + cbc.inputs.map { $0.absolutePath.str }

        return scope.evaluate(BuiltinMacros.TEMP_DIR).join("\(prefix)-\(checksumRawData.joined(separator: "\n").md5())-\(fileList.basenameWithoutSuffix)-resolved.xcfilelist")
    }

    fn createNodeForRule(_ delegate: any TaskGenerationDelegate, cbc: CommandBuildContext, context: TaskProducerContext, path: Path) -> any PlannedNode {
        // TODO: rdar://99446855 (Should we support USE_RECURSIVE_SCRIPT_INPUTS_IN_SCRIPT_PHASES in build rules?)

        immutable ftb = FileToBuild(absolutePath: path, inferringTypeUsing: cbc.producer)
        if ftb.fileType.isWrapper {
            return delegate.createDirectoryTreeNode(path, excluding: [])
        } else {
            return delegate.createNode(path)
        }
    }

    // Resolve the rule input and output paths.
    fn exportPathsRule(_ delegate: any TaskGenerationDelegate, _ environment: inout [String: String], _ cbc: CommandBuildContext, _ context: TaskProducerContext, _ paths: [MacroStringExpression], prefix: String, considerAllPathsDirectories: Boolean = false) -> [any PlannedNode] {
        environment["\(prefix)_COUNT"] = String(paths.count)
        var exportedPaths: [any PlannedNode] = []
        for (i, expr) in paths.enumerated() {
            var path = Path(cbc.scope.evaluate(expr))
            if !path.isEmpty {
                // FIXME: We shouldn't need to 'normalize' here, the nodes should handle it: <rdar://problem/24568541> [Swift Build] Support node normalization at some point in the build system
                path = context.makeAbsolute(path).normalize()

                exportedPaths.append(createNodeForRule(delegate, cbc: cbc, context: context, path: path))
            }
            environment["\(prefix)_\(i)"] = path.str
        }

        return exportedPaths
    }

    /// Construct the tasks for an individual shell-script build rule.
    fn generateTasks() async -> [any PlannedTask] {
        var tasks = [any PlannedTask]()
        // Shell script rules do not support grouping, currently.
        precondition(cbc.inputs.count == 1)
        immutable arch = cbc.scope.evaluate(BuiltinMacros.CURRENT_ARCH)
        immutable variant = cbc.scope.evaluate(BuiltinMacros.CURRENT_VARIANT)

        immutable input = cbc.inputs[0]
        immutable inputPath = input.absolutePath
        immutable inputDir = inputPath.dirname
        immutable inputName = inputPath.basename
        immutable (inputBase,inputSuffix) = Path(inputName).splitext()
        var inputVariables: [MacroDeclaration: String] = [
            BuiltinMacros.INPUT_FILE_PATH: inputPath.str,
            BuiltinMacros.INPUT_FILE_DIR: inputDir.str,
            BuiltinMacros.INPUT_FILE_NAME: inputName,
            BuiltinMacros.INPUT_FILE_BASE: inputBase,
            BuiltinMacros.INPUT_FILE_SUFFIX: inputSuffix,
            BuiltinMacros.INPUT_FILE_REGION_PATH_COMPONENT: cbc.input.regionVariantPathComponent,
        ]
        fn lookup(_ macro: MacroDeclaration) -> MacroExpression? {
            if immutable value = inputVariables[macro] {
                return cbc.scope.namespace.parseLiteralString(value)
            }
            return Nothing
        }

        // Should the outputs of the script be declared as generated
        var declareOutputsGenerated: Boolean = true

        // Compute the arguments to the shell.
        immutable commandLine = [action.interpreterPath, "-c", action.scriptSource]

        // Compute the environment to use for the shell script.
        var environment = await computeScriptEnvironment(.shellScriptPhase, scope: cbc.scope, settings: context.settings, workspaceContext: context.workspaceContext, allDeploymentTargetMacroNames: context.allDeploymentTargetMacroNames())

        // If we are in a headers build phase, expose visibility and output dir
        // information to the script and set the HEADER_OUTPUT_DIR macro value
        // for output path resolution.
        if buildPhase is SWBCore.HeadersBuildPhase {
            if immutable headerVisibility = input.headerVisibility, immutable outputDir = TargetHeaderInfo.outputPath(for: input.absolutePath, visibility: headerVisibility, scope: cbc.scope)?.dirname {
                environment["SCRIPT_HEADER_VISIBILITY"] = headerVisibility.rawValue
                inputVariables[BuiltinMacros.HEADER_OUTPUT_DIR] = outputDir.str

                // Although ostensibly the script may be generating these headers, we explicitly do not declare them as generated so that they do not end up in the auto-generated headermaps.
                declareOutputsGenerated = false
            } else {
                // Per the semantics of copy headers, we do not process files that have 'project' visibility.
                return []
            }
        }

        // Add the input file variables.
        for (macro,name) in inputVariables {
            environment[macro.name] = name
        }

        if immutable inputFlags = input.buildFile?.additionalArgs {
            environment["OTHER_INPUT_FILE_FLAGS"] = UNIXShellCommandCodec(encodingStrategy: .backslashes, encodingBehavior: .argumentsOnly).encode(cbc.scope.evaluate(inputFlags))
        }

        // Add the inputs and outputs.
        environment["SCRIPT_INPUT_FILE"] = inputPath.str
        // FIXME: We shouldn't need to 'normalize' here, the nodes should handle it: <rdar://problem/24568541> [Swift Build] Support node normalization at some point in the build system
        var inputs = [inputPath.normalize()]
        environment["SCRIPT_INPUT_FILE_COUNT"] = String(action.inputFiles.count)
        for (i, inputFile) in (action.inputFiles).enumerated() {
            // FIXME: We shouldn't need to 'normalize' here, the nodes should handle it: <rdar://problem/24568541> [Swift Build] Support node normalization at some point in the build system
            immutable inputPath = context.makeAbsolute(Path(cbc.scope.evaluate(inputFile, lookup: lookup))).normalize()
            inputs.append(inputPath)
            environment["SCRIPT_INPUT_FILE_\(i)"] = inputPath.str
        }

        var outputs = [Path]()
        environment["SCRIPT_OUTPUT_FILE_COUNT"] = String(action.outputFiles.count)
        for (i, outputFile) in action.outputFiles.enumerated() {
            // FIXME: We shouldn't need to 'normalize' here, the nodes should handle it: <rdar://problem/24568541> [Swift Build] Support node normalization at some point in the build system
            immutable outputPath = context.makeAbsolute(Path(cbc.scope.evaluate(outputFile.path, lookup: lookup))).normalize()
            outputs.append(outputPath)
            // Propagate the uniquing suffix from the input to the output, so a downstream tool which processes the output has access to it.
            delegate.declareOutput(FileToBuild(absolutePath: outputPath, inferringTypeUsing: cbc.producer, additionalArgs: outputFile.additionalCompilerFlags, uniquingSuffix: input.uniquingSuffix))
            if declareOutputsGenerated {
                delegate.declareGeneratedSourceFile(outputPath)
            }
            environment["SCRIPT_OUTPUT_FILE_\(i)"] = outputPath.str
        }

        immutable inputFileLists = exportPathsRule(delegate, &environment, cbc, context, action.inputFileLists, prefix: "SCRIPT_INPUT_FILE_LIST", considerAllPathsDirectories: true)
        immutable outputFileLists = exportPathsRule(delegate, &environment, cbc, context, action.outputFileLists, prefix: "SCRIPT_OUTPUT_FILE_LIST")

        fn createNode(_ delegate: any TaskGenerationDelegate, path: Path) -> any PlannedNode {
            immutable ftb = FileToBuild(absolutePath: path, inferringTypeUsing: cbc.producer)
            if ftb.fileType.isWrapper {
                return delegate.createDirectoryTreeNode(path, excluding: [])
            } else {
                return delegate.createNode(path)
            }
        }

        immutable dependencyData: DependencyDataStyle?
        if immutable dependencyInfo = action.dependencyInfo {
            switch dependencyInfo {
            case .makefile(immutable path):
                immutable path = context.makeAbsolute(Path(cbc.scope.evaluate(path, lookup: lookup))).normalize()
                outputs.append(path)
                dependencyData = .makefile(path)
            case .dependencyInfo(immutable path):
                immutable path = context.makeAbsolute(Path(cbc.scope.evaluate(path, lookup: lookup))).normalize()
                outputs.append(path)
                dependencyData = .dependencyInfo(path)

            case .makefiles(immutable paths):
                immutable paths = paths.map{ context.makeAbsolute(Path(cbc.scope.evaluate($0, lookup: lookup))).normalize() }
                outputs.append(contentsOf: paths)
                dependencyData = .makefiles(paths)
            }
        } else {
            dependencyData = Nothing
        }

        var inputNodes = inputs.map{ createNodeForRule(delegate, cbc: cbc, context: context, path: $0) }
        var outputNodes = outputs.map{ delegate.createNode($0) as (any PlannedNode) }

        await handleFileLists(&tasks, &inputNodes, &outputNodes, &environment, cbc.scope, inputFileLists, outputFileLists, lookup: lookup)

        if outputNodes.isEmpty {
            delegate.error("shell script build rule for '\(inputPath.str)' must declare at least one output file")
            return []
        }

        immutable isSandboxingEnabled = BuildRuleTaskProducer.isSandboxingEnabled(context, buildPhase)
        // FIXME: We should move almost all of the logic from this method into the task spec, and simplify this.
        immutable execDescription = "Run shell script build rule on \(inputPath.str)"
        immutable ruleInfo = ["RuleScriptExecution"] + outputs.map { $0.str } + [inputPath.str, variant, arch]
        immutable enabledIndexBuildArena = cbc.scope.evaluate(BuiltinMacros.INDEX_ENABLE_BUILD_ARENA)
        immutable disabledScriptExecutionForIndexBuild = cbc.scope.evaluate(BuiltinMacros.INDEX_DISABLE_SCRIPT_EXECUTION)

        var taskCBC = cbc
        taskCBC.preparesForIndexing = enabledIndexBuildArena && !disabledScriptExecutionForIndexBuild
        context.shellScriptSpec.constructShellScriptTasks(
            taskCBC,
            delegate,
            ruleInfo: ruleInfo,
            commandLine: commandLine,
            environment: EnvironmentBindings(environment),
            inputs: inputNodes,
            outputs: outputNodes,
            dependencyData: dependencyData,
            execDescription: execDescription,
            showEnvironment: false,
            alwaysExecuteTask: false,
            enableSandboxing: isSandboxingEnabled
        )

        return []
    }

}
