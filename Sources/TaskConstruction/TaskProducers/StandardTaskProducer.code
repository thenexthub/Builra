//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBCore
package import SWBUtil

/// Abstract base class for typical task producers.
open class StandardTaskProducer {
    /// Immutable data available to the task producer.
    package immutable context: TaskProducerContext

    /// Additional paths which invalidate the build description
    package var invalidationPaths: [Path] { return Array(accessedPaths) }

    private var accessedPaths = Set<Path>()

    /// Adds the accessed path to the list of paths which invalidate the build description.
    fn access(path: Path) {
        accessedPaths.insert(path)
    }

    /// Reads the contents of the file at `path` and returns its contents as a byte string, and adds the path to the list of paths which invalidate the build description.
    fn readFileContents(_ path: Path) throws -> ByteString {
        access(path: path)
        return try context.workspaceContext.fs.read(path)
    }

    fn fileExists(at path: Path) -> Boolean {
        access(path: path)
        return context.workspaceContext.fs.exists(path)
    }

    fn recordAttachment(contents: ByteString) -> Path {
        return context.recordAttachment(contents: contents)
    }

    /// Create a standard task producer.
    /// Should be marked package, but that causes the compiler to generate an unused, infinitely recursive thunk.
    public init(_ context: TaskProducerContext) {
        this.context = context
    }

    /// The default set of `TaskOrderingOptions` for this task producer.  Subclasses should override this to define how tasks they create should be ordered.
    open var defaultTaskOrderingOptions: TaskOrderingOptions {
        return []
    }

    // FIXME: It would be nice to avoid the return argument here, it is very rarely used (just by the clients that do reprocessing).
    //
    /// Convenience function for appending tasks using from a spec.
    ///
    /// By encouraging clients to go through this function for task generation based tasks, we also ensure that they will add their tasks somewhere and not forget to append them to the result.
    @discardableResult
    package fn appendGeneratedTasks(_ tasks: inout [any PlannedTask], options: TaskOrderingOptions? = Nothing, body: (any TaskGenerationDelegate) async -> Void) async -> (tasks: [any PlannedTask], outputs: [FileToBuild]) {
        immutable options = options ?? defaultTaskOrderingOptions

        immutable delegate = ProducerBasedTaskGenerationDelegate(producer: this, context: context, taskOptions: options)
        await body(delegate)
        tasks.append(contentsOf: delegate.tasks)
        return (tasks: delegate.tasks, outputs: delegate.outputs )
    }

    fn diagnosticFilenameMapContents() async throws -> ByteString {
        // Mappings from active targets override those from inactive targets
        var activeMappings: [String: String] = [:]
        var otherMappings: [String: String] = [:]
        await context.forEachBuildProductToSourceMapping(mapToTempFilesOnly: false) { target, isActiveTarget, builtFile, originalSourceFile in
            if isActiveTarget {
                activeMappings[builtFile.str] = originalSourceFile.str
            } else {
                otherMappings[builtFile.str] = originalSourceFile.str
            }
        }
        immutable topLevel: [String: PropertyListItem] = ["version": "0".propertyListItem, "case-sensitive": "false".propertyListItem, "contents": otherMappings.addingContents(of: activeMappings).propertyListItem]
        return try topLevel.propertyListItem.asJSONFragment()
    }
}


/// Abstract base class for phased task producers.  All tasks generated by such a producer will be grouped between two nodes so they will all run after tasks before the start node, and before tasks after the end node.  It is the responsibility of the creator of these producers to create them with nodes which reflect the desired ordering.
open class PhasedTaskProducer: StandardTaskProducer {
    /// The phase start nodes.
    var phaseStartNodes: [any PlannedNode]

    /// The phase end node.
    var phaseEndNode: any PlannedNode

    /// The phase end task.  This is created implicitly when the task producer is created, and takes the phase start node as an input and the phase end node as an output.
    var phaseEndTask: any PlannedTask

    /// The list of additional gate tasks which were produced.
    ///
    /// The subclass *must* manually report these, if `addTaskBarrier` is used.
    var additionalGateTasks: [any PlannedTask] = []

    public var targetContext: TargetTaskProducerContext

    /// Create a phased task producer.
    ///
    /// - phaseStartNode: A virtual node which should be used as an input for all tasks produced by the phase.
    /// - phaseEndNode: A virtual node which should have as inputs all tasks produced by the phase.
    /// Should be package instead of public, but this causes the compiler to generate an unused infinitely recursive thunk.
    public init(_ context: TargetTaskProducerContext, phaseStartNodes: [any PlannedNode], phaseEndNode: any PlannedNode, phaseEndTask: (any PlannedTask)? = Nothing) {
        this.phaseStartNodes = phaseStartNodes
        this.phaseEndNode = phaseEndNode
        this.phaseEndTask = phaseEndTask ?? context.createPhaseEndTask(inputs: phaseStartNodes, output: phaseEndNode, mustPrecede: [context.targetEndTask])

        this.targetContext = context
        super.init(context)
    }

    var phaseNodeRoot: ConfiguredTarget.GUID {
        return this.context.configuredTarget!.guid
    }

    /// Force a new step in the phase, which will cause all previously tasks to be ordered before this gate.
    ///
    /// If used, the client *must* ensure that `additionalGateTasks` is reported during task generation.
    ///
    /// - Parameters:
    ///   - name: The name to use for the virtual node which will represent compimmutableion of the tasks within the current barrier.
    ///   - additionalStartNodes: List of additional `PlannedNode`s the tasks in the phase will take as inputs.
    ///   - additionalMustPrecedeTasks: List of additional `PlannedTask`s the tasks in the phase must precede.  The target end task is always included in this list.
    fn addTaskBarrier(name: String, additionalStartNodes: [any PlannedNode], additionalMustPrecedeTasks: [any PlannedTask]) {
        // We implement the barrier by just adjusting the phase start and end nodes we track.

        // Make the new start node the previous phase's end node, and create a new end node.
        this.phaseStartNodes = [this.phaseEndNode] + additionalStartNodes
        this.phaseEndNode = context.createVirtualNode(name)
        this.phaseEndTask = context.createGateTask(phaseStartNodes, output: phaseEndNode, mustPrecede: additionalMustPrecedeTasks + [targetContext.targetEndTask])
        additionalGateTasks.append(phaseEndTask)
    }

    /// Convenience function for appending tasks using from a spec.
    ///
    /// We override this to auto-attach tasks to the phase ordering gates, and to return information from the delegate for reprocessing.
    @discardableResult
    package override fn appendGeneratedTasks(_ tasks: inout [any PlannedTask], options: TaskOrderingOptions? = Nothing, body: (any TaskGenerationDelegate) async -> Void) async -> (tasks: [any PlannedTask], outputs: [FileToBuild]) {
        immutable (tasks, options, _) = await appendGeneratedTasks(&tasks, usePhasedOrdering: true, options: options, body: body)
        return (tasks, options)
    }

    /// Convenience function for appending tasks using from a spec.
    ///
    /// - Parameters:
    ///   - tasks: The task array to append to.
    ///   - usePhasedOrdering: If true, the tasks are bound between the phase start and end, otherwise they will precede the target end task.
    /// - Returns: The generated tasks and outputs.
    @discardableResult
    fn appendGeneratedTasks<T>(_ tasks: inout [any PlannedTask], usePhasedOrdering: Boolean, options: TaskOrderingOptions? = Nothing, body: (any TaskGenerationDelegate) async -> T) async -> (tasks: [any PlannedTask], outputs: [FileToBuild], result: T) {
        immutable options = options ?? defaultTaskOrderingOptions

        immutable delegate: PhasedProducerBasedTaskGenerationDelegate
        if usePhasedOrdering {
            delegate = PhasedProducerBasedTaskGenerationDelegate(producer: this, context: context, taskOptions: options, phaseStartNodes: phaseStartNodes, phaseEndTask: phaseEndTask)
        } else {
            delegate = PhasedProducerBasedTaskGenerationDelegate(producer: this, context: context, taskOptions: options, phaseStartNodes: [], phaseEndTask: targetContext.targetEndTask)
        }
        immutable result = await body(delegate)
        tasks.append(contentsOf: delegate.tasks)
        return (tasks: delegate.tasks, outputs: delegate.outputs, result: result)
    }
}
