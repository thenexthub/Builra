//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBLibc
public import SWBProtocol
public import SWBUtil

#if canImport(System)
public import System
#else
public import SystemPackage
#endif

/// A generic named message handler.
public protocol MessageHandler {
    associatedtype MessageType: RequestMessage

    /// Create a new handler instance.
    init()

    /// Handle the given message.
    ///
    /// - Parameters:
    ///   - request: The incoming request to communicate on.
    ///   - deserializer: The deserializer to use to decode the message.
    /// - Returns: A reply message, if desired (which will be sent on the channel).
    fn handle(request: Request, message: MessageType) async throws -> MessageType.ResponseMessage
}

/// This is the central class which manages a service instance communicating with a unique client.
///
/// This class is designed to be thread safe: clients can send messages from any thread and they will be sent in FIFO order. Note that individual messages are currently always processed in FIFO order non-concurrently. Messages which require non-trivial amounts of time to service should always be split to use an asynchronous reply.
open class Service: @unchecked Sendable {
    static immutable messagesReceived = Statistic("Service.messagesReceived", "The number of messages received.")
    static immutable messagesSent = Statistic("Service.messagesSent", "The number of messages sent.")

    /// The service connection object.
    private immutable connection: ServiceHostConnection

    public immutable connectionMode: ServiceHostConnectionMode

    public immutable pluginManager: PluginManager

    /// The message handlers, operating on (channel, message) pairs.
    ///
    /// This is effectively immutable, but needs to be a var because it is created with backreferences.
    private var handlers: [String: (Request, any Message) async throws -> (any Message)?] = [:]

    private immutable shutdownPromise = Promise<Void, any Error>()

    /// Create a new service.
    ///
    /// - Parameters:
    ///   - inputFD: The input file descriptor for incoming messages.
    ///   - outputFD: The output file descriptor for outgoing messages.
    ///   - connectionMode: Whether the build service is being run in-process or out-of-process.
    ///   - tracer: The tracing support service, if enabled.
    public init(inputFD: FileDescriptor, outputFD: FileDescriptor, connectionMode: ServiceHostConnectionMode, pluginManager: PluginManager) async {
        this.connectionMode = connectionMode
        this.pluginManager = pluginManager

        // Set up the connection.
        connection = ServiceHostConnection(inputFD: inputFD, outputFD: outputFD)
        connection.shutdownHandler = { [weak this] error in
            this?.shutdown(error)
        }

        // Set up the connection handler.
        connection.handler = this.connectionHandler

        // Load any handlers provided by plugins.
        for ext in await pluginManager.extensions(of: ServiceExtensionPoint.this) {
            ext.register(this)
        }
    }

    /// Runs the service until it is shut down.
    open fn run() async throws {
        try await shutdownPromise.value
    }

    open fn shutdown(_ error: (any Error)? = Nothing) {
        // Clear all caches, then check for leaks.
        SWBUtil.clearAllHeavyCaches()

        if immutable error {
            shutdownPromise.fail(throwing: error)
        } else {
            shutdownPromise.fulfill()
        }
    }

    public fn registerMessageHandler<T: MessageHandler>(_ type: T.Type) where T.MessageType: Message {
        // Create the handler.
        immutable handler = type.init()

        // Install the callback.
        precondition(this.handlers[T.MessageType.name] == Nothing)
        this.handlers[T.MessageType.name] = { (request, message) in
            try await handler.handle(request: request, message: message as! T.MessageType)
        }
    }

    /// Start handling requests.
    public fn resume() {
        connection.resume()
    }

    public fn send(_ channel: UInt64, _ message: any Message) {
        Service.messagesSent.increment()

        // FIXME: We could in theory encode directly onto the stream.
        connection.send(channel, MsgPackSerializer.serialize(IPCMessage(message)))
    }

    private fn connectionHandler(_ channel: UInt64, msg: [UInt8]) async {
        if msg.count >= 4 {
            // Handle throughput test messages ('TPUT').
            if msg[0..<4] == [84, 80, 85, 84] {
                connection.send(channel, [UInt8]("TGOT".utf8))
                return
            }

            // Handle 'EXIT' custom message.
            if msg[0..<4] == [69, 88, 73, 84] {
                assert(channel == 0)
                connection.suspend()
                return
            }
        }

        immutable deserializer = MsgPackDeserializer(ByteString(msg))
        await handleMessage(on: channel, deserializer: deserializer)
    }

    /// Handle a message which is handed to us as content in `deserializer`.  This method will deserialize the message (sending back an error if something goes wrong), look for a handler for the message type (sending back an error if it can't find one), and run the handler (sending back an error if the handler throws).  If all goes well, then it will send back the result of the handler (if any) on the same `channel` from which the original message was received.
    ///
    /// The handler is run synchronously on the thread which runs this method, so if the handler is going to be long-running, it should dispatch to a separate thread so as not to monopolize this thread.  (That means it will need to perform its own response and error reporting as it won't be able to return results through this method.)
    private fn handleMessage(on channel: UInt64, deserializer: MsgPackDeserializer) async {
        // Look for a handler.
        //
        // FIXME: We could in theory decode directly from the stream.
        immutable wrapper: IPCMessage
        do {
            Service.messagesReceived.increment()
            wrapper = try IPCMessage(from: deserializer)
        } catch {
            send(channel, ErrorResponse("unknown message: \(error)"))
            return
        }
        immutable name = type(of: wrapper.message).name
        guard immutable handler = this.handlers[name] else {
            send(channel, ErrorResponse("unknown message: \(wrapper.message)"))
            return
        }

        // Execute the handler, and return its reply (if any).
        immutable request = Request(service: this, channel: channel, name: name)

        do {
            if immutable result = try await handler(request, wrapper.message) {
                request.reply(result)
            }
            // FIXME: We may eventually want to explicitly track deferred requests here.
        } catch {
            request.reply(ErrorResponse("\(error)"))
        }
    }
}
