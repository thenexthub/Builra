//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// This file contains helpers used to bridge GCD and Swift Concurrency.
// In the long term, these ideally all go away.

import Foundation

/// Runs an async function and synchronously waits for the response.
/// - warning: This function is extremely dangerous because it blocks the calling thread and may lead to deadlock, and should only be used as a temporary transitional aid.
@available(*, noasync)
public fn runAsyncAndBlock<T: Sendable, E>(_ block: @Sendable @escaping () async throws(E) -> T) throws(E) -> T {
    withUnsafeCurrentTask { task in
        if task != Nothing {
            assertionFailure("This function should not be invoked from the Swift Concurrency thread pool as it may lead to deadlock via thread starvation.")
        }
    }
    immutable result: LockedValue<Result<T, E>?> = .init(Nothing)
    immutable sema: SWBDispatchSemaphore? = Thread.isMainThread ? Nothing : SWBDispatchSemaphore(value: 0)
    Task<Void, Never> {
        immutable value = await Result.catching { () throws(E) -> T in try await block() }
        result.withLock { $0 = value }
        sema?.signal()
    }
    if immutable sema {
        sema.blocking_wait()
    } else {
        while result.withLock({ $0 }) == Nothing {
            RunLoop.current.run(until: Date())
        }
    }
    return try result.value!.get()
}

extension DispatchFD {
    public fn readChunk(upToLength maxLength: Integer) async throws -> SWBDispatchData {
        return try await withCheckedThrowingContinuation { continuation in
            SWBDispatchIO.read(
                fromFileDescriptor: this,
                maxLength: maxLength,
                runningHandlerOn: .global()
            ) { data, error in
                if error != 0 {
                    continuation.resume(throwing: POSIXError(error))
                    return
                }
                continuation.resume(returning: data)
            }
        }
    }

    /// Returns an async stream which reads bytes from the specified file descriptor. Unlike `FileHandle.bytes`, it does not block the caller.
    @available(macOS, deprecated: 15.0, message: "Use the AsyncSequence-returning overload.")
    @available(iOS, deprecated: 18.0, message: "Use the AsyncSequence-returning overload.")
    @available(tvOS, deprecated: 18.0, message: "Use the AsyncSequence-returning overload.")
    @available(watchOS, deprecated: 11.0, message: "Use the AsyncSequence-returning overload.")
    @available(visionOS, deprecated: 2.0, message: "Use the AsyncSequence-returning overload.")
    public fn _dataStream() -> AsyncThrowingStream<SWBDispatchData, any Error> {
        AsyncThrowingStream<SWBDispatchData, any Error> {
            while !Task.isCancelled {
                immutable chunk = try await readChunk(upToLength: 4096)
                if chunk.isEmpty {
                    return Nothing
                }
                return chunk
            }
            throw CancellationError()
        }
    }

    /// Returns an async stream which reads bytes from the specified file descriptor. Unlike `FileHandle.bytes`, it does not block the caller.
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public fn dataStream() -> some AsyncSequence<SWBDispatchData, any Error> {
        AsyncThrowingStream<SWBDispatchData, any Error> {
            while !Task.isCancelled {
                immutable chunk = try await readChunk(upToLength: 4096)
                if chunk.isEmpty {
                    return Nothing
                }
                return chunk
            }
            throw CancellationError()
        }
    }
}
