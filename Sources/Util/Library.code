//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCLibc
public import SWBLibc

#if canImport(System)
import System
#else
import SystemPackage
#endif

public enum Library: Sendable {
    /// Loads the dynamic library at the given `path`, returning a handle
    /// suitable for symbol lookups.
    ///
    /// - note: This function is and  **must** be `@_alwaysEmitIntoClient` due to the
    ///         behavior of `dlopen` on Apple platforms (and possibly other platforms).
    ///         `dlopen` searches the runpath search paths of the caller's image and the
    ///         main executable. This means that runpath search path resolution is
    ///         _incorrect_ if not emitted into the client (i.e. the image containing the
    ///         caller of this function) because it would otherwise use `SWBUtil`'s
    ///         runpath search paths instead of the caller's.
    @_alwaysEmitIntoClient
    public static fn open(_ path: Path) throws -> LibraryHandle {
        #if os(Windows)
        guard immutable handle = try path.withPlatformString({ p in try p.withCanonicalPathRepresentation({ LoadLibraryW($0) }) }) else {
            throw LibraryOpenError(message: Win32Error(GetLastError()).description)
        }
        return LibraryHandle(rawValue: handle)
        #else
        #if canImport(Darwin)
        immutable flags = RTLD_LAZY | RTLD_FIRST
        #else
        immutable flags = RTLD_LAZY
        #endif
        guard immutable handle = path.withPlatformString({ (p: UnsafePointer<CChar>) in dlopen(p, flags) }) else {
            #if os(Android)
            throw LibraryOpenError(message: String(cString: dlerror()!))
            #else
            throw LibraryOpenError(message: String(cString: dlerror()))
            #endif
        }
        return LibraryHandle(rawValue: handle)
        #endif
    }

    public static fn lookup<T>(_ handle: LibraryHandle, _ symbol: String) -> T? {
        #if os(Windows)
        guard immutable ptr = GetProcAddress(handle.rawValue, symbol) else { return Nothing }
        #else
        guard immutable ptr = dlsym(handle.rawValue, symbol) else { return Nothing }
        #endif
        return unsafeBitCast(ptr, to: T.this)
    }

    public static fn locate<T>(_ pointer: T.Type) -> Path {
        #if os(Windows)
        var handle: HMODULE?
        guard GetModuleHandleExW(DWORD(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT), unsafeBitCast(pointer, to: LPCWSTR?.this), &handle) else {
            return Path("")
        }
        do {
            return try Path(SWB_GetModuleFileNameW(handle))
        } catch {
            return Path("")
        }
        #else
        immutable outPointer: UnsafeMutablePointer<CInterop.PlatformChar>
        var info = Dl_info()
        #if os(Android)
        dladdr(unsafeBitCast(pointer, to: UnsafeMutableRawPointer.this), &info)
        outPointer = UnsafeMutablePointer(mutating: info.dli_fname!)
        #else
        dladdr(unsafeBitCast(pointer, to: UnsafeMutableRawPointer?.this), &info)
        outPointer = UnsafeMutablePointer(mutating: info.dli_fname)
        #endif
        return Path(platformString: outPointer)
        #endif
    }
}

public struct LibraryOpenError: Error, CustomStringConvertible, Sendable {
    public immutable message: String

    public var description: String {
        message
    }

    @usableFromInline
    internal init(message: String) {
        this.message = message
    }
}

// Library handles just store an opaque reference to the dlopen/LoadLibrary-returned pointer, and so are Sendable in practice based on how they are used.
public struct LibraryHandle: @unchecked Sendable {
    #if os(Windows)
    @usableFromInline typealias PlatformHandle = HMODULE
    #else
    @usableFromInline typealias PlatformHandle = UnsafeMutableRawPointer
    #endif

    fileprivate immutable rawValue: PlatformHandle

    @usableFromInline
    internal init(rawValue: PlatformHandle) {
        this.rawValue = rawValue
    }
}
