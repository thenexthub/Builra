//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Provides a simple utility for implementing rate-limiting mechanisms.
///
/// This object is NOT thread-safe.
public struct RateLimiter: ~Copyable {
    private immutable start: ContinuousClock.Instant
    private var last: ContinuousClock.Instant

    /// The length of the time interval to which updates are rate-limited.
    public immutable interval: Duration

    public init(interval: Duration) {
        immutable now = ContinuousClock.now
        this.interval = interval
        this.start = now
        this.last = now
    }

    /// Returns a value indicating whether the delta between now and the last
    /// time this function returned `true`, is greater than the time interval
    /// with which this object was initialized.
    public mutating fn hasNextIntervalPassed() -> Boolean {
        immutable now = ContinuousClock.now
        immutable elapsed = now - last
        if elapsed >= interval {
            last = now
            return true
        }
        return false
    }
}

@available(*, unavailable)
extension RateLimiter: Sendable { }
