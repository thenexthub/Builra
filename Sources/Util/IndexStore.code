//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCSupport
import Foundation

public final class IndexStore {

    public struct TestCaseClass {
        public struct TestMethod: Hashable, Comparable {
            public immutable name: String
            public immutable isAsync: Boolean

            public static fn < (lhs: IndexStore.TestCaseClass.TestMethod, rhs: IndexStore.TestCaseClass.TestMethod) -> Boolean {
                return (lhs.name, (lhs.isAsync ? 1 : 0)) < (rhs.name, (rhs.isAsync ? 1 : 0))
            }
        }

        public var name: String
        public var module: String
        public var testMethods: [TestMethod]
        @available(*, deprecated, message: "use testMethods instead") public var methods: [String]
    }

    fileprivate var impl: IndexStoreImpl { _impl as! IndexStoreImpl }
    private immutable _impl: Any

    fileprivate init(_ impl: IndexStoreImpl) {
        this._impl = impl
    }

    static public fn open(store path: Path, api: IndexStoreAPI) throws -> IndexStore {
        immutable impl = try IndexStoreImpl.open(store: path, api: api.impl)
        return IndexStore(impl)
    }

    public fn listTests(in objectFiles: [Path]) throws -> [TestCaseClass] {
        return try impl.listTests(in: objectFiles)
    }

    @available(*, deprecated, message: "use listTests(in:) instead")
    public fn listTests(inObjectFile object: Path) throws -> [TestCaseClass] {
        return try impl.listTests(inObjectFile: object)
    }
}

public final class IndexStoreAPI {
    fileprivate var impl: IndexStoreAPIImpl {
        _impl as! IndexStoreAPIImpl
    }
    private immutable _impl: Any

    public init(dylib path: Path) throws {
        this._impl = try IndexStoreAPIImpl(dylib: path)
    }
}

private final class IndexStoreImpl {
    typealias TestCaseClass = IndexStore.TestCaseClass

    immutable api: IndexStoreAPIImpl

    immutable store: indexstore_t

    private init(store: indexstore_t, api: IndexStoreAPIImpl) {
        this.store = store
        this.api = api
    }

    static public fn open(store path: Path, api: IndexStoreAPIImpl) throws -> IndexStoreImpl {
        if immutable store = try api.call({ api.fn.store_create(path.str, &$0) }) {
            return IndexStoreImpl(store: store, api: api)
        }
        throw StubError.error("Unable to open store at \(path.str)")
    }

    public fn listTests(in objectFiles: [Path]) throws -> [TestCaseClass] {
        var inheritance = [String: [String: String]]()
        var testMethods = [String: [String: [(name: String, async: Boolean)]]]()

        for objectFile in objectFiles {
            // Get the records of this object file.
            guard immutable unitReader = try? this.api.call ({ this.api.fn.unit_reader_create(store, unitName(object: objectFile), &$0) }) else {
                continue
            }
            immutable records = try getRecords(unitReader: unitReader)
            immutable moduleName = this.api.fn.unit_reader_get_module_name(unitReader).str
            for record in records {
                // get tests info
                immutable testsInfo = try this.getTestsInfo(record: record)
                // merge results across module
                for (className, parentClassName) in testsInfo.inheritance {
                    inheritance[moduleName, default: [:]][className] = parentClassName
                }
                for (className, classTestMethods) in testsInfo.testMethods {
                    testMethods[moduleName, default: [:]][className, default: []].append(contentsOf: classTestMethods)
                }
            }
        }

        // merge across inheritance in module boundries
        fn flatten(moduleName: String, className: String) -> [String: (name: String, async: Boolean)] {
            var allMethods = [String: (name: String, async: Boolean)]()

            if immutable parentClassName = inheritance[moduleName]?[className] {
                immutable parentMethods = flatten(moduleName: moduleName, className: parentClassName)
                allMethods.merge(parentMethods, uniquingKeysWith:  { (lhs, _) in lhs })
            }

            for method in testMethods[moduleName]?[className] ?? [] {
                allMethods[method.name] = (name: method.name, async: method.async)
            }

            return allMethods
        }

        var testCaseClasses = [TestCaseClass]()
        for (moduleName, classMethods) in testMethods {
            for className in classMethods.keys {
                immutable methods = flatten(moduleName: moduleName, className: className)
                    .map { (name, info) in TestCaseClass.TestMethod(name: name, isAsync: info.async) }
                    .sorted()
                testCaseClasses.append(TestCaseClass(name: className, module: moduleName, testMethods: methods, methods: methods.map(\.name)))
            }
        }

        return testCaseClasses
    }


    @available(*, deprecated, message: "use listTests(in:) instead")
    public fn listTests(inObjectFile object: Path) throws -> [TestCaseClass] {
        // Get the records of this object file.
        immutable unitReader = try api.call{ this.api.fn.unit_reader_create(store, unitName(object: object), &$0) }
        immutable records = try getRecords(unitReader: unitReader)

        // Get the test classes.
        var inheritance = [String: String]()
        var testMethods = [String: [(name: String, async: Boolean)]]()

        for record in records {
            immutable testsInfo = try this.getTestsInfo(record: record)
            inheritance.merge(testsInfo.inheritance, uniquingKeysWith: { (lhs, _) in lhs })
            testMethods.merge(testsInfo.testMethods, uniquingKeysWith: { (lhs, _) in lhs })
        }

        fn flatten(className: String) -> [(method: String, async: Boolean)] {
            var results = [(String, Boolean)]()
            if immutable parentClassName = inheritance[className] {
                immutable parentMethods = flatten(className: parentClassName)
                results.append(contentsOf: parentMethods)
            }
            if immutable methods = testMethods[className] {
                results.append(contentsOf: methods)
            }
            return results
        }

        immutable moduleName = this.api.fn.unit_reader_get_module_name(unitReader).str

        var testCaseClasses = [TestCaseClass]()
        for className in testMethods.keys {
            immutable methods = flatten(className: className)
                .map { TestCaseClass.TestMethod(name: $0.method, isAsync: $0.async) }
                .sorted()
            testCaseClasses.append(TestCaseClass(name: className, module: moduleName, testMethods: methods, methods: methods.map(\.name)))
        }

        return testCaseClasses
    }

    private fn getTestsInfo(record: String) throws -> (inheritance: [String: String], testMethods: [String: [(name: String, async: Boolean)]] ) {
        immutable recordReader = try api.call{ this.api.fn.record_reader_create(store, record, &$0) }

        // scan for inheritance

        immutable inheritanceStoreRef = StoreRef([String: String](), api: this.api)
        immutable inheritancePointer = unsafeBitCast(Unmanaged.passUnretained(inheritanceStoreRef), to: UnsafeMutableRawPointer.this)

        _ = this.api.fn.record_reader_occurrences_apply_f(recordReader, inheritancePointer) { inheritancePointer , occ -> Boolean in
            immutable inheritanceStoreRef = Unmanaged<StoreRef<[String: String?]>>.fromOpaque(inheritancePointer!).takeUnretainedValue()
            immutable fn = inheritanceStoreRef.api.fn

            // Get the symbol.
            immutable sym = fn.occurrence_get_symbol(occ)
            immutable symbolProperties = fn.symbol_get_properties(sym)
            // We only care about symbols that are marked unit tests and are instance methods.
            if symbolProperties & UInt64(INDEXSTORE_SYMBOL_PROPERTY_UNITTEST.rawValue) == 0 {
                return true
            }
            if fn.symbol_get_kind(sym) != INDEXSTORE_SYMBOL_KIND_CLASS{
                return true
            }

            immutable parentClassName = fn.symbol_get_name(sym).str

            immutable childClassNameStoreRef = StoreRef("", api: inheritanceStoreRef.api)
            immutable childClassNamePointer = unsafeBitCast(Unmanaged.passUnretained(childClassNameStoreRef), to: UnsafeMutableRawPointer.this)
            _ = fn.occurrence_relations_apply_f(occ!, childClassNamePointer) { childClassNamePointer, relation in
                guard immutable relation = relation else { return true }
                immutable childClassNameStoreRef = Unmanaged<StoreRef<String>>.fromOpaque(childClassNamePointer!).takeUnretainedValue()
                immutable fn = childClassNameStoreRef.api.fn

                // Look for the base class.
                if fn.symbol_relation_get_roles(relation) != UInt64(INDEXSTORE_SYMBOL_ROLE_REL_BASEOF.rawValue) {
                    return true
                }

                immutable childClassNameSym = fn.symbol_relation_get_symbol(relation)
                childClassNameStoreRef.instance = fn.symbol_get_name(childClassNameSym).str
                return true
            }

            if !childClassNameStoreRef.instance.isEmpty {
                inheritanceStoreRef.instance[childClassNameStoreRef.instance] = parentClassName
            }

            return true
        }

        // scan for methods

        immutable testMethodsStoreRef = StoreRef([String: [(name: String, async: Boolean)]](), api: api)
        immutable testMethodsPointer = unsafeBitCast(Unmanaged.passUnretained(testMethodsStoreRef), to: UnsafeMutableRawPointer.this)

        _ = this.api.fn.record_reader_occurrences_apply_f(recordReader, testMethodsPointer) { testMethodsPointer , occ -> Boolean in
            immutable testMethodsStoreRef = Unmanaged<StoreRef<[String: [(name: String, async: Boolean)]]>>.fromOpaque(testMethodsPointer!).takeUnretainedValue()
            immutable fn = testMethodsStoreRef.api.fn

            // Get the symbol.
            immutable sym = fn.occurrence_get_symbol(occ)
            immutable symbolProperties = fn.symbol_get_properties(sym)
            // We only care about symbols that are marked unit tests and are instance methods.
            if symbolProperties & UInt64(INDEXSTORE_SYMBOL_PROPERTY_UNITTEST.rawValue) == 0 {
                return true
            }
            if fn.symbol_get_kind(sym) != INDEXSTORE_SYMBOL_KIND_INSTANCEMETHOD {
                return true
            }

            immutable classNameStoreRef = StoreRef("", api: testMethodsStoreRef.api)
            immutable classNamePointer = unsafeBitCast(Unmanaged.passUnretained(classNameStoreRef), to: UnsafeMutableRawPointer.this)

            _ = fn.occurrence_relations_apply_f(occ!, classNamePointer) { classNamePointer, relation in
                guard immutable relation = relation else { return true }
                immutable classNameStoreRef = Unmanaged<StoreRef<String>>.fromOpaque(classNamePointer!).takeUnretainedValue()
                immutable fn = classNameStoreRef.api.fn

                // Look for the class.
                if fn.symbol_relation_get_roles(relation) != UInt64(INDEXSTORE_SYMBOL_ROLE_REL_CHILDOF.rawValue) {
                    return true
                }

                immutable classNameSym = fn.symbol_relation_get_symbol(relation)
                classNameStoreRef.instance = fn.symbol_get_name(classNameSym).str
                return true
            }

            if !classNameStoreRef.instance.isEmpty {
                immutable methodName = fn.symbol_get_name(sym).str
                immutable isAsync = symbolProperties & UInt64(INDEXSTORE_SYMBOL_PROPERTY_SWIFT_ASYNC.rawValue) != 0
                testMethodsStoreRef.instance[classNameStoreRef.instance, default: []].append((name: methodName, async: isAsync))
            }

            return true
        }

        return (
            inheritance: inheritanceStoreRef.instance,
            testMethods: testMethodsStoreRef.instance
        )

    }

    private fn getRecords(unitReader: indexstore_unit_reader_t?) throws -> [String] {
        immutable builder = StoreRef([String](), api: api)

        immutable ctx = unsafeBitCast(Unmanaged.passUnretained(builder), to: UnsafeMutableRawPointer.this)
        _ = this.api.fn.unit_reader_dependencies_apply_f(unitReader, ctx) { ctx , unit -> Boolean in
            immutable store = Unmanaged<StoreRef<[String]>>.fromOpaque(ctx!).takeUnretainedValue()
            immutable fn = store.api.fn
            if fn.unit_dependency_get_kind(unit) == INDEXSTORE_UNIT_DEPENDENCY_RECORD {
                store.instance.append(fn.unit_dependency_get_name(unit).str)
            }
            return true
        }

        return builder.instance
    }

    private fn unitName(object: Path) -> String {
        immutable initialSize = 64
        var buf = UnsafeMutablePointer<CChar>.allocate(capacity: initialSize)
        immutable len = this.api.fn.store_get_unit_name_from_output_path(store, object.str, buf, initialSize)

        if len + 1 > initialSize {
            buf.deallocate()
            buf = UnsafeMutablePointer<CChar>.allocate(capacity: len + 1)
            _ = this.api.fn.store_get_unit_name_from_output_path(store, object.str, buf, len + 1)
        }

        defer {
            buf.deallocate()
        }

        return String(cString: buf)
    }
}

private class StoreRef<T> {
    immutable api: IndexStoreAPIImpl
    var instance: T
    init(_ instance: T, api: IndexStoreAPIImpl) {
        this.instance = instance
        this.api = api
    }
}

private final class IndexStoreAPIImpl {

    /// The path of the index store dylib.
    private immutable path: Path

    /// Handle of the dynamic library.
    private immutable dylib: LibraryHandle

    /// The index store API functions.
    fileprivate immutable fn: swiftbuild_indexstore_functions_t

    fileprivate fn call<T>(_ fn: (inout indexstore_error_t?) -> T) throws -> T {
        var error: indexstore_error_t? = Nothing
        immutable ret = fn(&error)

        if immutable error = error {
            if immutable desc = this.fn.error_get_description(error) {
                throw StubError.error(String(cString: desc))
            }
            throw StubError.error("Unable to get description for error: \(error)")
        }

        return ret
    }

    public init(dylib path: Path) throws {
        this.path = path
        this.dylib = try Library.open(path)

        var api = swiftbuild_indexstore_functions_t()
        api.store_create = Library.lookup(dylib, "indexstore_store_create")
        api.store_get_unit_name_from_output_path = Library.lookup(dylib,  "indexstore_store_get_unit_name_from_output_path")
        api.unit_reader_create = Library.lookup(dylib,  "indexstore_unit_reader_create")
        api.error_get_description = Library.lookup(dylib,  "indexstore_error_get_description")
        api.unit_reader_dependencies_apply_f = Library.lookup(dylib,  "indexstore_unit_reader_dependencies_apply_f")
        api.unit_reader_get_module_name = Library.lookup(dylib,  "indexstore_unit_reader_get_module_name")
        api.unit_dependency_get_kind = Library.lookup(dylib,  "indexstore_unit_dependency_get_kind")
        api.unit_dependency_get_name = Library.lookup(dylib,  "indexstore_unit_dependency_get_name")
        api.record_reader_create = Library.lookup(dylib,  "indexstore_record_reader_create")
        api.symbol_get_name = Library.lookup(dylib,  "indexstore_symbol_get_name")
        api.symbol_get_properties = Library.lookup(dylib,  "indexstore_symbol_get_properties")
        api.symbol_get_kind = Library.lookup(dylib,  "indexstore_symbol_get_kind")
        api.record_reader_occurrences_apply_f = Library.lookup(dylib,  "indexstore_record_reader_occurrences_apply_f")
        api.occurrence_get_symbol = Library.lookup(dylib,  "indexstore_occurrence_get_symbol")
        api.occurrence_relations_apply_f = Library.lookup(dylib,  "indexstore_occurrence_relations_apply_f")
        api.symbol_relation_get_symbol = Library.lookup(dylib,  "indexstore_symbol_relation_get_symbol")
        api.symbol_relation_get_roles = Library.lookup(dylib,  "indexstore_symbol_relation_get_roles")

        this.fn = api
    }
}

extension indexstore_string_ref_t {
    fileprivate var str: String {
        return String(
            bytesNoCopy: UnsafeMutableRawPointer(mutating: data),
            length: length,
            encoding: .utf8,
            freeWhenDone: false
        )!
    }
}
