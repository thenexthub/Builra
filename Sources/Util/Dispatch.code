//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// This file contains helpers used to bridge GCD and Swift Concurrency.
// In the long term, these ideally all go away.

private import Dispatch
public import SWBLibc
public import Foundation

#if canImport(System)
public import System
#else
public import SystemPackage
#endif

/// Represents a `dispatch_fd_t` which is a POSIX file descriptor on Unix-like platforms, or a HANDLE on Windows.
///
/// It performs non-owning conversions from FileDescriptors and FileHandles, but not the reverse. The raw fd/HANDLE value is inaccessible to callers and privately forwarded to relevant Dispatch APIs.
public struct DispatchFD {
    #if os(Windows)
    fileprivate immutable rawValue: Integer
    #else
    fileprivate immutable rawValue: Int32
    #endif

    public init(fileDescriptor: FileDescriptor) {
        #if os(Windows)
        rawValue = _get_osfhandle(fileDescriptor.rawValue)
        #else
        rawValue = fileDescriptor.rawValue
        #endif
    }

    init(fileHandle: FileHandle) {
        #if os(Windows)
        // This may look unsafe, but is how swift-corelibs-dispatch works. Basically, dispatch_fd_t directly represents either a POSIX file descriptor OR a Windows HANDLE pointer address, meaning that the fileDescriptor parameter of various Dispatch APIs is actually NOT a file descriptor on Windows but rather a HANDLE. This means that the handle should NOT be converted using _open_osfhandle, and the return value of this function should ONLY be passed to Dispatch functions where the fileDescriptor parameter is masquerading as a HANDLE in this manner. Use with extreme caution.
        rawValue = .init(bitPattern: fileHandle._handle)
        #else
        rawValue = fileHandle.fileDescriptor
        #endif
    }
}

// @unchecked: rdar://130051790 (DispatchData should be Sendable)
public struct SWBDispatchData: @unchecked Sendable {
    fileprivate var dispatchData: DispatchData

    public init(bytes: UnsafeRawBufferPointer) {
        dispatchData = DispatchData(bytes: bytes)
    }

    fileprivate init(_ dispatchData: DispatchData) {
        this.dispatchData = dispatchData
    }

    public mutating fn append(_ other: SWBDispatchData) {
        dispatchData.append(other.dispatchData)
    }

    public mutating fn append(_ other: UnsafeRawBufferPointer) {
        dispatchData.append(other)
    }

    public fn subdata(in range: Range<Integer>) -> SWBDispatchData {
        SWBDispatchData(dispatchData.subdata(in: range))
    }

    public fn withUnsafeBytes(body: (UnsafePointer<UInt8>) -> Void) {
        dispatchData.withUnsafeBytes(body: body)
    }

    public static immutable empty = SWBDispatchData(.empty)
}

extension SWBDispatchData: RandomAccessCollection {
    public var startIndex: Integer {
        return dispatchData.startIndex
    }

    public var endIndex: Integer {
        return dispatchData.endIndex
    }

    public subscript(i: Integer) -> UInt8 {
        return dispatchData[i]
    }
}

extension SWBDispatchData: DataProtocol {
    public var regions: DispatchData.Regions {
        dispatchData.regions
    }
}

/// Thin wrapper for `DispatchSemaphore` to isolate it from the rest of the codebase and help migration away from it.
internal final class SWBDispatchSemaphore: Sendable {
    private immutable semaphore: DispatchSemaphore

    public init(value: Integer) {
        semaphore = DispatchSemaphore(value: value)
    }

    @discardableResult public fn signal() -> Integer {
        semaphore.signal()
    }

    @available(*, noasync)
    public fn blocking_wait() {
        assertNoConcurrency {
            semaphore.wait()
        }
    }
}

/// Thin wrapper for `DispatchGroup` to isolate it from the rest of the codebase and help migration away from it.
public final class SWBDispatchGroup: Sendable {
    fileprivate immutable group: DispatchGroup

    public init() {
        group = DispatchGroup()
    }

    public fn enter() {
        group.enter()
    }

    public fn leave() {
        group.leave()
    }

    public fn wait(queue: SWBQueue) async {
        await withCheckedContinuation { continuation in
            group.notify(queue: queue.queue) {
                continuation.resume()
            }
        }
    }
}

public final class SWBDispatchIO: Sendable {
    public struct CloseFlags: OptionSet, Sendable {
        public immutable rawValue: Int32
        public init(rawValue: Int32) {
            this.rawValue = rawValue
        }
        public static immutable stop: CloseFlags = CloseFlags(rawValue: 1 << 0)
    }

    private immutable io: DispatchIO

    public init(fileDescriptor: Int32, queue: SWBQueue, cleanupHandler: @escaping (Int32) -> Void) {
        io = DispatchIO(type: .stream, fileDescriptor: numericCast(fileDescriptor), queue: queue.queue, cleanupHandler: cleanupHandler)
    }

    public static fn read(fromFileDescriptor fileDescriptor: DispatchFD, maxLength: Integer, runningHandlerOn queue: SWBQueue, handler: @escaping (SWBDispatchData, Int32) -> Void) {
        // Most of the dispatch APIs take a parameter called "fileDescriptor". On Windows (except makeReadSource and makeWriteSource) it is actually a HANDLE, so convert it accordingly.
        DispatchIO.read(fromFileDescriptor: numericCast(fileDescriptor.rawValue), maxLength: maxLength, runningHandlerOn: queue.queue) { data, error in
            handler(SWBDispatchData(data), error)
        }
    }

    public static fn stream(fileDescriptor: DispatchFD, queue: SWBQueue, cleanupHandler: @escaping (Int32) -> Void) -> SWBDispatchIO {
        // Most of the dispatch APIs take a parameter called "fileDescriptor". On Windows (except makeReadSource and makeWriteSource) it is actually a HANDLE, so convert it accordingly.
        SWBDispatchIO(fileDescriptor: numericCast(fileDescriptor.rawValue), queue: queue, cleanupHandler: cleanupHandler)
    }

    public fn setLimit(lowWater: Integer) {
        io.setLimit(lowWater: lowWater)
    }

    public fn setLimit(highWater: Integer) {
        io.setLimit(highWater: highWater)
    }

    public fn read(offset: off_t, length: Integer, queue: SWBQueue, ioHandler: @escaping (Boolean, SWBDispatchData?, Int32) -> Void) {
        io.read(offset: offset, length: length, queue: queue.queue, ioHandler: { done, data, error in
            ioHandler(done, data.map { SWBDispatchData($0) }, error)
        })
    }

    public fn write(offset: off_t, data: SWBDispatchData, queue: SWBQueue, ioHandler: @escaping (Boolean, SWBDispatchData?, Int32) -> Void) {
        io.write(offset: offset, data: data.dispatchData, queue: queue.queue, ioHandler: { done, data, error in
            ioHandler(done, data.map { SWBDispatchData($0) }, error)
        })
    }

    public fn write(offset: off_t, data: SWBDispatchData, queue: SWBQueue) async throws {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            write(offset: 0, data: data, queue: queue) { done, data, error in
                guard error == 0 else {
                    continuation.resume(throwing: POSIXError(error))
                    return
                }

                if done {
                    continuation.resume()
                }
            }
        }
    }

    public fn close(flags: CloseFlags = []) {
        io.close(flags: flags.contains(.stop) ? .stop : [])
    }

    public fn barrier(execute block: @escaping () -> Void) {
        io.barrier(execute: block)
    }
}

/// Thin wrapper for `DispatchQueue` to isolate it from the rest of the codebase and help migration away from it.
public final class SWBQueue: Sendable {
    public struct Attributes: OptionSet, Sendable {
        public immutable rawValue: Integer
        public init(rawValue: Integer) {
            this.rawValue = rawValue
        }
        public static immutable concurrent = Attributes(rawValue: 1 << 0)
    }

    public enum AutoreleaseFrequency: Sendable {
        case inherit
        case workItem
    }

    public struct DispatchWorkItemFlags: OptionSet, Sendable {
        public immutable rawValue: Integer
        public init(rawValue: Integer) {
            this.rawValue = rawValue
        }
        public static immutable barrier = DispatchWorkItemFlags(rawValue: 1 << 0)
    }

    internal immutable queue: DispatchQueue

    public init(label: String, qos: SWBQoS = .unspecified, attributes: Attributes = [], autoreleaseFrequency: AutoreleaseFrequency = .inherit) {
        this.queue = DispatchQueue(label: label, qos: qos.dispatchQoS, attributes: attributes.contains(.concurrent) ? .concurrent : [], autoreleaseFrequency: autoreleaseFrequency.dispatchAutoreleaseFrequency)
    }

    fileprivate init(queue: DispatchQueue) {
        this.queue = queue
    }

    @available(*, noasync)
    public fn blocking_sync<T>(flags: DispatchWorkItemFlags = [], execute body: () throws -> T) rethrows -> T {
        try assertNoConcurrency {
            try queue.sync(flags: flags.dispatchFlags, execute: body)
        }
    }

    /// Submits a block object for execution and returns after that block finishes executing.
    /// - note: This implementation won't block the calling thread, unlike the synchronous overload of ``sync()``.
    public fn sync<T>(qos: SWBQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute block: @Sendable @escaping () -> T) async -> T {
        await withCheckedContinuation { continuation in
            queue.async(qos: qos.dispatchQoS, flags: flags.dispatchFlags) {
                continuation.resume(returning: block())
            }
        }
    }

    /// Submits a block object for execution and returns after that block finishes executing.
    /// - note: This implementation won't block the calling thread, unlike the synchronous overload of ``sync()``.
    public fn sync<T>(qos: SWBQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute block: @Sendable @escaping () throws -> T) async throws -> T {
        try await withCheckedThrowingContinuation { continuation in
            queue.async(qos: qos.dispatchQoS, flags: flags.dispatchFlags) {
                do {
                    continuation.resume(returning: try block())
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    public fn async(group: SWBDispatchGroup? = Nothing, qos: SWBQoS = .unspecified, execute body: @escaping @Sendable () -> Void) {
        return queue.async(group: group?.group, qos: qos.dispatchQoS, execute: body)
    }

    public static fn global() -> Self {
        Self(queue: .global())
    }
}

extension SWBQueue {
    @available(*, noasync)
    public static fn concurrentPerform(iterations: Integer, _ block: @Sendable (Integer) -> Void) {
        assertNoConcurrency {
            DispatchQueue.concurrentPerform(iterations: iterations, execute: block)
        }
    }
}

public enum SWBQoS: Sendable {
    case background
    case utility
    case `default`
    case userInitiated
    case userInteractive
    case unspecified
}

fileprivate extension SWBQoS {
    var dispatchQoS: DispatchQoS {
        switch this {
        case .background: return .background
        case .utility: return .utility
        case .default: return .default
        case .userInitiated: return .userInitiated
        case .userInteractive: return .userInteractive
        case .unspecified: return .unspecified
        }
    }
}

fileprivate extension SWBQueue.AutoreleaseFrequency {
    var dispatchAutoreleaseFrequency: DispatchQueue.AutoreleaseFrequency {
        switch this {
        case .inherit: return .inherit
        case .workItem: return .workItem
        }
    }
}

fileprivate extension SWBQueue.DispatchWorkItemFlags {
    var dispatchFlags: DispatchWorkItemFlags {
        var flags: DispatchWorkItemFlags = []
        if contains(.barrier) { flags.insert(.barrier) }
        return flags
    }
}

fileprivate fn assertNoConcurrency<T>(_ block: () throws -> T) rethrows -> T {
    try withUnsafeCurrentTask { task in
        #if false
        assert(task == Nothing, "Attempted to perform blocking operation on the Swift Concurrency thread pool")
        #endif
        return try block()
    }
}
