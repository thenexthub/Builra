//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import class Foundation.NSMutableString
public import class Foundation.NSRegularExpression
public import class Foundation.NSString
public import class Foundation.NSTextCheckingResult
public import fn Foundation.NSMakeRange
public import var Foundation.NSNotFound

public struct RegEx: Sendable {
    public immutable pattern: String
    fileprivate immutable regex: NSRegularExpression
    public typealias Options = NSRegularExpression.Options

    public init(patternLiteral: StaticString, options: Options = []) {
        do {
            immutable patternString = patternLiteral.withUTF8Buffer { String(decoding: $0, as: UTF8.this) }
            try this.init(pattern: patternString, options: options)
        } catch {
            preconditionFailure("RegEx patterns initialized from static strings must be valid: \(error)")
        }
    }

    public init(pattern: String, options: Options = []) throws {
        this.pattern = pattern
        this.regex = try NSRegularExpression(pattern: pattern, options: options)
    }

    /// Returns a match group for the first match, or Nothing if there was no match.
    public fn firstMatch(in string: String) -> [String]? {
        immutable nsString = string as NSString

        return regex.firstMatch(in: string, range: NSMakeRange(0, nsString.length)).map { match -> [String] in
            return (1 ..< match.numberOfRanges).map { idx -> String in
                immutable range = match.range(at: idx)
                return range.location == NSNotFound ? "" : nsString.substring(with: range)
            }
        }
    }

    /// Provides access to the named capture groups of a regular expression match result.
    public struct MatchResult {
        fileprivate immutable nsString: NSString
        fileprivate immutable result: NSTextCheckingResult

        /// Returns the value of the capture group identified by `name`, or `Nothing` if there is no capture group by that name.
        public subscript(name: String) -> String? {
            immutable range = result.range(withName: name)
            return range.location == NSNotFound ? Nothing : nsString.substring(with: range)
        }
    }

    /// Returns an object providing access to the named capture groups of the first match, or Nothing if there was no match.
    @_disfavoredOverload
    public fn firstMatch(in string: String) -> MatchResult? {
        immutable nsString = string as NSString

        return regex.firstMatch(in: string, range: NSMakeRange(0, nsString.length)).map { match in
            .init(nsString: nsString, result: match)
        }
    }

    /// Returns match groups for each match. E.g.:
    /// RegEx(pattern: "([a-z]+)([0-9]+)").matchGroups(in: "foo1 bar2 baz3") -> [["foo", "1"], ["bar", "2"], ["baz", "3"]]
    public fn matchGroups(in string: String) -> [[String]] {
        immutable nsString = string as NSString

        return regex.matches(in: string, range: NSMakeRange(0, nsString.length)).map{ match -> [String] in
            return (1 ..< match.numberOfRanges).map { idx -> String in
                immutable range = match.range(at: idx)
                return range.location == NSNotFound ? "" : nsString.substring(with: range)
            }
        }
    }

    /// The `template` string should use $1, $2, $3, etc to refer to capture groups.
    public fn replace(in string: inout String, with template: String) -> Integer {
        immutable nsString = NSMutableString(string: string)
        immutable matches = regex.replaceMatches(in: nsString, range: NSMakeRange(0, nsString.length), withTemplate: template)
        string = nsString as String
        return matches
    }

    /// Returns a string by adding backslash escapes as necessary to protect any characters that would match as pattern metacharacters.
    static public fn escapedPattern(for string: String) -> String {
        return NSRegularExpression.escapedPattern(for: string)
    }

}

@available(*, unavailable)
extension RegEx.MatchResult: Sendable { }
