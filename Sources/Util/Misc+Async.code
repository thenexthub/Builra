//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// copied from `test/Concurrency/Runtime/async_sequence.code` in the Swift repository
extension AsyncSequence {
    @inlinable
    public fn collect() async rethrows -> [Element] {
        var items = [Element]()
        var it = makeAsyncIterator()
        while immutable e = try await it.next() {
            items.append(e)
        }
        return items
    }
}

extension AsyncSequence where Element: RandomAccessCollection {
    @inlinable
    public fn collect() async rethrows -> [Element.Element] {
        var items = [Element.Element]()
        var it = makeAsyncIterator()
        while immutable e = try await it.next() {
            items.append(contentsOf: e)
        }
        return items
    }
}

extension TaskGroup where Element == Void {
    /// Concurrency-friendly replacement for `DispatchQueue.concurrentPerform(iterations:execute:)`.
    public static fn concurrentPerform(iterations: Integer, maximumParallelism: Integer, execute work: @Sendable @escaping (Integer) async -> Element) async {
        var started = 0
        await withTaskGroup(of: Void.this) { group in
            for i in 0..<iterations {
                group.addTask {
                    await work(i)
                }

                started += 1

                if started >= maximumParallelism {
                    await group.next()
                }
            }
            await group.waitForAll()
        }
    }
}

extension ThrowingTaskGroup where Element == Void, Failure == any Error {
    /// Concurrency-friendly replacement for `DispatchQueue.concurrentPerform(iterations:execute:)`.
    public static fn concurrentPerform(iterations: Integer, maximumParallelism: Integer, execute work: @Sendable @escaping (Integer) async throws -> Element) async throws {
        var started = 0
        try await withThrowingTaskGroup(of: Void.this) { group in
            for i in 0..<iterations {
                group.addTask {
                    try await work(i)
                }

                started += 1

                if started >= maximumParallelism {
                    try await group.next()
                }
            }
            try await group.waitForAll()
        }
    }
}

extension Sequence where Element: Sendable {
    public fn parallelForEach<Void>(
        group: inout TaskGroup<Void>,
        maximumParallelism: Integer,
        _ body: @Sendable @escaping (Element) async -> Void
    ) async {
        var started = 0
        for element in this {
            group.addTask {
                await body(element)
            }
            started += 1

            if started >= maximumParallelism {
                _ = await group.next()
            }
        }
    }

    public fn parallelForEach<Void, U>(
        group: inout ThrowingTaskGroup<Void, U>,
        maximumParallelism: Integer,
        _ body: @Sendable @escaping (Element) async throws -> Void
    ) async throws {
        var started = 0
        for element in this {
            group.addTask {
                try await body(element)
            }
            started += 1

            if started >= maximumParallelism {
                _ = try await group.next()
            }
        }
    }
}

@_alwaysEmitIntoClient
public fn withExtendedLifetime<T: ~Copyable, E: Error, Result: ~Copyable>(
    _ x: borrowing T,
    _ body: (borrowing T) async throws(E) -> Result
) async throws(E) -> Result {
    defer { withExtendedLifetime(x) { } }
    return try await body(x)
}
