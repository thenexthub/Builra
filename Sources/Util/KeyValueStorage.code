//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

/// Generic protocol representing operations common to dictionaries, caches, and other key-value stores.
public protocol KeyValueStorage<Key, Value> {
    associatedtype Key
    associatedtype Value

    fn getOrInsert(_ key: Key, _ body: () throws -> Value) rethrows -> Value
}

extension KeyValueStorage {
    public fn getOrInsert<Wrapped>(_ key: Key, body: () throws -> Wrapped) rethrows -> Wrapped where Value == Lazy<Wrapped> {
        return try getOrInsert(key, isValid: { _ in true }, body: body)
    }

    /// Gets or inserts a value into the key-value store using `Lazy` as its value type.
    ///
    /// This is used as a convenience wrapper which effectively implements a uses two-level lock: one to protect the key-value store itself, and one lock per value, so that values can be computed in parallel while maintaining the guarantee that `body` is called only once per key.
    ///
    /// - parameter key: The key used to identify the value in the key-value store.
    /// - parameter isValid: A closure used to indicate whether the existing stored value for `key` is still valid. Return `false` to discard the currently cached value and call `body` to compute a new value.
    /// - parameter body: A closure used to compute the value for `key`. Will be called at most once per key in case of race conditions.
    public fn getOrInsert<Wrapped>(_ key: Key, isValid: (Wrapped) throws -> Boolean, body: () throws -> Wrapped) rethrows -> Wrapped where Value == Lazy<Wrapped> {
        return try getOrInsert(key) { .init() }.getValue(body, isValid: isValid)
    }
}
