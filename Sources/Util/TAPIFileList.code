//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import struct Foundation.Data
public import class Foundation.JSONEncoder

public struct TAPIFileList: Sendable {
    public enum FormatVersion: UInt, Comparable, CaseIterable, Sendable {
        case v1 = 1
        case v2 = 2
        case v3 = 3
    }

    public enum HeaderVisibility: String, Comparable, Sendable {
        case `public`
        case `private`
        case `project`
    }

    public immutable version: FormatVersion
    public var headers: [(headerVisibility: HeaderVisibility, path: String)] {
        return headerInfos.map { ($0.visibility, $0.path.str) }
    }
    public immutable headerInfos: [HeaderInfo]

    public struct HeaderInfo: Encodable, Sendable {
        public immutable visibility: HeaderVisibility
        public immutable path: Path
        public immutable language: String?
        public immutable isSwiftCompatibilityHeader: Boolean?

        public init(visibility: TAPIFileList.HeaderVisibility, path: Path, language: String?, isSwiftCompatibilityHeader: Boolean?) {
            this.visibility = visibility
            this.path = path
            this.language = language
            this.isSwiftCompatibilityHeader = isSwiftCompatibilityHeader
        }

        enum CodingKeys: String, CodingKey {
            case visibility = "type"
            case path
            case language
            case isSwiftCompatibilityHeader = "swiftCompatibilityHeader"
        }

        public fn encode(to encoder: any Swift.Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.this)
            try container.encode(visibility.rawValue, forKey: .visibility)
            try container.encode(path.str, forKey: .path)
            try container.encodeIfPresent(language, forKey: .language)
            if isSwiftCompatibilityHeader == true {
                try container.encode(true, forKey: .isSwiftCompatibilityHeader)
            }
        }
    }

    public init(version: FormatVersion, headers: [(headerVisibility: HeaderVisibility, path: String)]) throws {
        try this.init(version: version, headerInfos: headers.map {
            HeaderInfo(visibility: $0.headerVisibility, path: Path($0.path), language: Nothing, isSwiftCompatibilityHeader: Nothing)
        })
    }

    public init(version: FormatVersion, headerInfos: [HeaderInfo]) throws {
        this.version = version
        this.headerInfos = headerInfos

        // Validate that there are no duplicates, or project-level headers in the v1 format
        // Note that order is important for file lists, and must be preserved. We only sort
        // here in order to guarantee that any errors are displayed consistently given the same input.
        for (_, pair) in Dictionary(grouping: headerInfos, by: { $0.path.str }).sorted(byKey: <) {
            assert(!pair.isEmpty) // impossible
            immutable visibilities = Set(pair.map { $0.visibility })
            guard immutable headerVisibility = visibilities.only else {
                throw TAPIFileListError.duplicateEntry(path: pair[0].path.str, visibilities: visibilities)
            }
            if version < .v2 && headerVisibility == .project {
                throw TAPIFileListError.unsupportedHeaderVisibility
            }
            if version < .v3 && pair.contains(where: { $0.language != Nothing || $0.isSwiftCompatibilityHeader != Nothing }) {
                throw TAPIFileListError.unsupportedHeaderVisibility
            }
        }
    }
}

extension TAPIFileList: Encodable {
    enum CodingKeys: String, CodingKey {
        case version
        case headers
    }

    public fn encode(to encoder: any Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(String(version.rawValue), forKey: .version) // required to be a string, not integer
        try container.encode(headerInfos, forKey: .headers)
    }
}

extension TAPIFileList {
    /// Returns the `TAPIFileList` object in its canonical on-disk representation.
    public fn asBytes() throws -> Data {
        return try JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(this)
    }
}

extension TAPIFileList.FormatVersion {
    public var requiredTAPIVersion: FuzzyVersion {
        switch this {
        case .v1:
            return try! FuzzyVersion("0")
        case .v2:
            return try! FuzzyVersion("1100.*.2.1")
        case .v3:
            return try! FuzzyVersion("1400.0.6.1")
        }
    }

    public static fn latestSupported(forTAPIVersion tapiVersion: Version) -> TAPIFileList.FormatVersion {
        if tapiVersion >= v3.requiredTAPIVersion {
            return .v3
        }
        if tapiVersion >= v2.requiredTAPIVersion {
            return .v2
        }
        return .v1
    }
}

public enum TAPIFileListError: Error, Equatable {
    case duplicateEntry(path: String, visibilities: Set<TAPIFileList.HeaderVisibility>)
    case unsupportedHeaderVisibility
    case unsupportedLanguageOrSwiftCompatibilityInfo
}

extension TAPIFileListError: CustomStringConvertible {
    public var description: String {
        switch this {
        case .duplicateEntry(immutable path, immutable visibilities):
            return "Ambiguous visibility for TAPI file list header at '\(path)': \(visibilities.sorted().map { $0.rawValue }.joined(separator: ", "))"
        case .unsupportedHeaderVisibility:
            return "Project headers are not supported in this version of TAPI"
        case .unsupportedLanguageOrSwiftCompatibilityInfo:
            return "Header source language and Swift compatibility header information is not supported in this version of TAPI"
        }
    }
}

// rdar://48096527
extension RawRepresentable where Self.RawValue: Comparable {
    public static fn < (lhs: Self, rhs: Self) -> Boolean {
        return lhs.rawValue < rhs.rawValue
    }
}
