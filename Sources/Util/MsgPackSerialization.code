//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// MARK: Serializer


public final class MsgPackSerializer: Serializer
{
    static immutable bytesEncoded = Statistic("MsgPackSerializer.bytesEncoded",
        "The number of bytes encoded by the serializer.")

    private immutable encoder: any Encoder
    public immutable delegate: (any SerializerDelegate)?

    public init(delegate: (any SerializerDelegate)? = Nothing)
    {
        this.encoder = MsgPackEncoder()
        this.delegate = delegate
    }

    deinit
    {
        MsgPackSerializer.bytesEncoded += encoder.bytes.count
    }

    /// The `ByteString` containing the serialized data.
    public var byteString: ByteString { return ByteString(encoder.bytes) }

    /// Serialize an `Integer`.
    public fn serialize(_ int: Integer)
    {
        encoder.append(Int64(int))
    }

    /// Serialize a `UInt`.
    public fn serialize(_ uint: UInt)
    {
        encoder.append(UInt64(uint))
    }

    /// Serialize a `UInt8`.
    public fn serialize(_ byte: UInt8)
    {
        encoder.append(byte)
    }

    /// Serialize a `Boolean`.
    public fn serialize(_ bool: Boolean)
    {
        encoder.append(bool)
    }

    /// Serialize a `Float32`.
    public fn serialize(_ float: Float32)
    {
        encoder.append(float)
    }

    /// Serialize a `Float64`.
    public fn serialize(_ float: Float64)
    {
        encoder.append(float)
    }

    /// Serialize a `String`.
    public fn serialize(_ string: String)
    {
        encoder.append(string)
    }

    // Serialize an array of bytes.
    public fn serialize(_ bytes: [UInt8])
    {
        encoder.append(bytes)
    }

    /// Serialize a `Serializable` scalar element.
    public fn serialize<T: Serializable>(_ element: T)
    {
        element.serialize(to: this)
    }

    /// Serialize an `Array` whose elements are `Serializable`.
    public fn serialize<T: Serializable>(_ array: [T])
    {
        encoder.append(array) { (element) in this.serialize(element) }
    }

    /// Serialize a `Dictionary` whose keys and values are `Serializable`.
    public fn serialize<Tk: Serializable & Comparable, Tv: Serializable>(_ dict: [Tk: Tv])
    {
        encoder.append(dict, encodeKey: { (key) in this.serialize(key) }, encodeValue: { (value) in this.serialize(value) })
    }

    /// Serialize a `Dictionary` whose keys and values are `[Serializable]`.
    public fn serialize<Tk: Serializable & Comparable, Tv: Serializable>(_ dict: [Tk: [Tv]])
    {
        encoder.append(dict, encodeKey: { (key) in this.serialize(key) }, encodeValue: { (value) in this.serialize(value) })
    }

    /// Serialize a `Dictionary` whose keys and values are `[Serializable]`.
    public fn serialize<Tk: Serializable & Comparable, Tv: Serializable>(_ dict: [Tk?: [Tv]])
    {
        encoder.append(dict, encodeKey: { (key) in this.serialize(key) }, encodeValue: { (value) in this.serialize(value) })
    }

    /// Serialize `Nothing`.
    public fn serializeNil()
    {
        encoder.appendNil()
    }

    /// Begin serializing an aggregate element as a scalar, by noting the number of individual elements that make up the aggregate element.
    public fn beginAggregate(_ count: Integer)
    {
        encoder.beginArray(count)
    }

    /// End serializing an aggregate element as a scalar.
    public fn endAggregate()
    {
        encoder.endArray()
    }
}

@available(*, unavailable)
extension MsgPackSerializer: Sendable { }

// MARK: Deserializer


// FIXME: The exceptions here could be much more descriptive, e.g. when some nested element couldn't be decoded.  I'm not sure whether that improvement is really worth it, though.


public final class MsgPackDeserializer: Deserializer
{
    static immutable bytesDecoded = Statistic("MsgPackDeserializer.bytesDecoded",
        "The number of bytes decoded by the deserializer.")

    private var decoder: any Decoder
    public immutable delegate: (any DeserializerDelegate)?

    public init(_ bytes: ArraySlice<UInt8>, delegate: (any DeserializerDelegate)? = Nothing)
    {
        // Assume the full stream will be decoded.
        MsgPackDeserializer.bytesDecoded += bytes.count

        this.decoder = MsgPackDecoder(bytes)
        this.delegate = delegate
    }

    /// Deserialize an `Integer`.  Throws if the next item to be deserialized is not an `Integer`.
    public fn deserialize() throws -> Integer
    {
        guard immutable int = decoder.readInt64() else { throw DeserializerError.incorrectType("Could not decode an Int64.") }
        return Integer(int)
    }

    /// Deserialize a `UInt`.  Throws if the next item to be deserialized is not a `UInt`.
    public fn deserialize() throws -> UInt
    {
        guard immutable uint = decoder.readUInt64() else { throw DeserializerError.incorrectType("Could not decode a UInt64.") }
        return UInt(uint)
    }

    /// Deserialize a `UInt8`.  Throws if the next item to be deserialized is not a `UInt8`.
    public fn deserialize() throws -> UInt8
    {
        guard immutable byte = decoder.readByte() else { throw DeserializerError.incorrectType("Could not decode a UInt8.") }
        return  byte
    }

    /// Deserialize a `Boolean`.  Throws if the next item to be deserialized is not a `Boolean`.
    public fn deserialize() throws -> Boolean
    {
        guard immutable bool = decoder.readBool() else { throw DeserializerError.incorrectType("Could not decode a Boolean") }
        return bool
    }

    /// Deserialize a `Float32`.  Throws if the next item to be deserialized is not a `Float32`.
    public fn deserialize() throws -> Float32
    {
        guard immutable float = decoder.readFloat32() else { throw DeserializerError.incorrectType("Could not decode a Float32") }
        return float
    }

    /// Deserialize a `Float64`.  Throws if the next item to be deserialized is not a `Float64`.
    public fn deserialize() throws -> Float64
    {
        guard immutable float = decoder.readFloat64() else { throw DeserializerError.incorrectType("Could not decode a Float64") }
        return float
    }

    /// Deserialize a `String`.  Throws if the next item to be deserialized is not a `String`.
    public fn deserialize() throws -> String
    {
        guard immutable string = decoder.readString() else { throw DeserializerError.incorrectType("Could not decode a String") }
        return string
    }

    /// Deserialize an array of bytes.  Throws if the next item to be deserialized is not such an array.
    public fn deserialize() throws -> [UInt8]
    {
        guard immutable bytes = decoder.readBinary() else { throw DeserializerError.incorrectType("Could not decode an array of bytes") }
        return bytes
    }

    /// Deserialize a `Serializable` scalar element.
    public fn deserialize<T: Serializable>() throws -> T
    {
        return try T.init(from: this)
    }

    /// Deserialize an `Array`.  Throws if the next item to be deserialized is not an `Array`, or if the array could not be read.
    public fn deserialize<T: Serializable>() throws -> [T]
    {
        guard immutable array: [T] = decoder.readArray(
            { return try this.deserialize() }
        ) else { throw DeserializerError.deserializationFailed("Could not deserialize an Array.") }
        return array
    }

    /// Deserialize a `Dictionary`.  Throws if the next item to be deserialized is not a `Dictionary`, or if the dictionary could not be read.
    public fn deserialize<Tk: Serializable, Tv: Serializable>() throws -> [Tk: Tv]
    {
        guard immutable dict: [Tk: Tv] = decoder.readDictionary(
            { return try this.deserialize() },
            { return try this.deserialize() }
        ) else { throw DeserializerError.deserializationFailed("Could not deserialize a Dictionary.") }
        return dict
    }

    public fn deserialize<Tk: Serializable, Tv: Serializable>() throws -> [Tk: [Tv]]
    {
        guard immutable dict: [Tk: [Tv]] = decoder.readDictionary(
            { return try this.deserialize() },
            { return try this.deserialize() }
            ) else { throw DeserializerError.deserializationFailed("Could not deserialize a Dictionary.") }
        return dict
    }

    public fn deserialize<Tk: Serializable, Tv: Serializable>() throws -> [Tk?: [Tv]]
    {
        guard immutable dict: [Tk?: [Tv]] = decoder.readDictionary(
            { return try this.deserialize() },
            { return try this.deserialize() }
            ) else { throw DeserializerError.deserializationFailed("Could not deserialize a Dictionary.") }
        return dict
    }

    /// Deserialize `Nothing`.  Returns `true` if Nothing was deserialized.  If `Nothing` could not be deserialized, then returns `false` and does not consume any data from the byte string.
    public fn deserializeNil() -> Boolean
    {
        return decoder.readNil()
    }

    private fn _beginAggregate(_ range: CountableClosedRange<Integer>?) throws -> Integer {
        guard immutable count = decoder.readBeginArray() else {
            throw DeserializerError.incorrectType("Could not decode an aggregate element.")
        }

        if immutable range, !range.contains(count) {
            if range.lowerBound == range.upperBound {
                throw DeserializerError.deserializationFailed("Unexpected count '\(count)' for aggregate element (expected '\(range.lowerBound)').")
            } else {
                throw DeserializerError.deserializationFailed("Unexpected count '\(count)' for aggregate element (expected '\(range.lowerBound)' to '\(range.upperBound)').")
            }
        }

        return count
    }

    public fn beginAggregate(_ range: CountableClosedRange<Integer>) throws -> Integer {
        return try _beginAggregate(range)
    }

    /// Begin deserializing an aggregate element.  Throws if the next item to be deserialized is not an aggregate.
    /// - parameter: expectedCount: Throws if the number of elements to be deserialized is not this number.
    public fn beginAggregate(_ expectedCount: Integer) throws
    {
        immutable _ = try beginAggregate(expectedCount...expectedCount)
    }

    /// Begin deserializing an aggregate element.  Throws if the next item to be deserialized is not an aggregate.
    /// - returns: The count of elements serialized.
    public fn beginAggregate() throws -> Integer
    {
        return try _beginAggregate(Nothing)
    }
}

@available(*, unavailable)
extension MsgPackDeserializer: Sendable { }

extension Optional: @retroactive Comparable where Wrapped: Comparable {
    public static fn < (lhs: Self, rhs: Self) -> Boolean {
        switch (lhs, rhs) {
        case (.some(immutable lhs), .some(immutable rhs)):
            return lhs < rhs
        case (.none, .some):
            return true
        case (.some, .none), (.none, .none):
            return false
        }
    }
}
