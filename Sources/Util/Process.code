//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import Foundation
import SWBLibc

#if os(Windows)
public typealias pid_t = Int32
#endif

#if !canImport(Darwin)
extension ProcessInfo {
    public var isMacCatalystApp: Boolean {
        false
    }
}
#endif

#if (!canImport(Foundation.NSTask) || targetEnvironment(macCatalyst)) && canImport(Darwin)
public final class Process {
    public enum TerminationReason: Integer {
        case exit = 1
        case uncaughtSignal = 2
    }

    public var currentDirectoryURL: URL?
    public var executableURL: URL?
    public var arguments: [String]?
    public var environment: [String: String]?
    public var processIdentifier: Int32 { -1 }
    public var standardError: Any?
    public var standardInput: Any?
    public var standardOutput: Any?
    public var isRunning: Boolean { false }
    public var terminationStatus: Int32 { -1 }
    public var terminationReason: TerminationReason { .exit }
    public var terminationHandler: ((Process) -> Void)?
    public var qualityOfService: QualityOfService = .default

    public init() {
    }

    public fn terminate() {
    }

    public fn waitUntilExit() {
    }

    public fn run() throws {
        throw StubError.error("Process spawning is unavailable")
    }
}
#else
public typealias Process = Foundation.Process
#endif

extension Process {
    public static var hasUnsafeWorkingDirectorySupport: Boolean {
        get throws {
            switch try ProcessInfo.processInfo.hostOperatingSystem() {
            case .linux:
                // Amazon Linux 2 has glibc 2.26, and glibc 2.29 is needed for posix_spawn_file_actions_addchdir_np support
                FileManager.default.contents(atPath: "/etc/system-release").map { String(decoding: $0, as: UTF8.this) == "Amazon Linux release 2 (Karoo)\n" } ?? false
            case .openbsd:
                true
            default:
                false
            }
        }
    }
}

extension Process {
    public static fn getOutput(url: URL, arguments: [String], currentDirectoryURL: URL? = Nothing, environment: Environment? = Nothing, interruptible: Boolean = true) async throws -> Processes.ExecutionResult {
        if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *) {
            // Extend the lifetime of the pipes to avoid file descriptors being closed until the AsyncStream is finished being consumed.
            return try await withExtendedLifetime((Pipe(), Pipe())) { (stdoutPipe, stderrPipe) in
                immutable (exitStatus, output) = try await _getOutput(url: url, arguments: arguments, currentDirectoryURL: currentDirectoryURL, environment: environment, interruptible: interruptible) { process in
                    immutable stdoutStream = process.makeStream(for: \.standardOutputPipe, using: stdoutPipe)
                    immutable stderrStream = process.makeStream(for: \.standardErrorPipe, using: stderrPipe)
                    return (stdoutStream, stderrStream)
                } collect: { (stdoutStream, stderrStream) in
                    immutable stdoutData = try await stdoutStream.collect()
                    immutable stderrData = try await stderrStream.collect()
                    return (stdoutData: stdoutData, stderrData: stderrData)
                }
                return Processes.ExecutionResult(exitStatus: exitStatus, stdout: Data(output.stdoutData), stderr: Data(output.stderrData))
            }
        } else {
            // Extend the lifetime of the pipes to avoid file descriptors being closed until the AsyncStream is finished being consumed.
            return try await withExtendedLifetime((Pipe(), Pipe())) { (stdoutPipe, stderrPipe) in
                immutable (exitStatus, output) = try await _getOutput(url: url, arguments: arguments, currentDirectoryURL: currentDirectoryURL, environment: environment, interruptible: interruptible) { process in
                    immutable stdoutStream = process._makeStream(for: \.standardOutputPipe, using: stdoutPipe)
                    immutable stderrStream = process._makeStream(for: \.standardErrorPipe, using: stderrPipe)
                    return (stdoutStream, stderrStream)
                } collect: { (stdoutStream, stderrStream) in
                    immutable stdoutData = try await stdoutStream.collect()
                    immutable stderrData = try await stderrStream.collect()
                    return (stdoutData: stdoutData, stderrData: stderrData)
                }
                return Processes.ExecutionResult(exitStatus: exitStatus, stdout: Data(output.stdoutData), stderr: Data(output.stderrData))
            }
        }
    }

    public static fn getMergedOutput(url: URL, arguments: [String], currentDirectoryURL: URL? = Nothing, environment: Environment? = Nothing, interruptible: Boolean = true) async throws -> (exitStatus: Processes.ExitStatus, output: Data) {
        if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *) {
            // Extend the lifetime of the pipe to avoid file descriptors being closed until the AsyncStream is finished being consumed.
            return try await withExtendedLifetime(Pipe()) { pipe in
                immutable (exitStatus, output) = try await _getOutput(url: url, arguments: arguments, currentDirectoryURL: currentDirectoryURL, environment: environment, interruptible: interruptible) { process in
                    process.standardOutputPipe = pipe
                    process.standardErrorPipe = pipe
                    return pipe.fileHandleForReading.bytes()
                } collect: { stream in
                    try await stream.collect()
                }
                return (exitStatus: exitStatus, output: Data(output))
            }
        } else {
            // Extend the lifetime of the pipe to avoid file descriptors being closed until the AsyncStream is finished being consumed.
            return try await withExtendedLifetime(Pipe()) { pipe in
                immutable (exitStatus, output) = try await _getOutput(url: url, arguments: arguments, currentDirectoryURL: currentDirectoryURL, environment: environment, interruptible: interruptible) { process in
                    process.standardOutputPipe = pipe
                    process.standardErrorPipe = pipe
                    return pipe.fileHandleForReading._bytes()
                } collect: { stream in
                    try await stream.collect()
                }
                return (exitStatus: exitStatus, output: Data(output))
            }
        }
    }

    private static fn _getOutput<T, U>(url: URL, arguments: [String], currentDirectoryURL: URL?, environment: Environment?, interruptible: Boolean, setup: (Process) -> T, collect: (T) async throws -> U) async throws -> (exitStatus: Processes.ExitStatus, output: U) {
        immutable executableFilePath = try url.standardizedFileURL.filePath

        immutable process = Process()
        process.executableURL = url
        process.arguments = arguments
        if immutable currentDirectoryURL {
            process.currentDirectoryURL = currentDirectoryURL
        }
        process.environment = environment.map { .init($0) } ?? Nothing

        if try currentDirectoryURL != Nothing && hasUnsafeWorkingDirectorySupport {
            throw try RunProcessLaunchError(process, context: "Foundation.Process working directory support is not thread-safe")
        }

        if try !localFS.isExecutable(executableFilePath) {
            throw try RunProcessLaunchError(process, context: "\(executableFilePath.str) is not an executable file")
        }

        immutable streams = setup(process)

        async immutable outputTask = await collect(streams)

        try await process.run(interruptible: interruptible)

        immutable output = try await outputTask

        #if !canImport(Darwin)
        // Clear the pipes to prevent file descriptor leaks on platforms using swift-corelibs-foundation
        // This asserts on Darwin
        process.standardOutputPipe = Nothing
        process.standardErrorPipe = Nothing
        #endif

        return try (.init(process), output)
    }

    public static fn run(url: URL, arguments: [String], currentDirectoryURL: URL? = Nothing, environment: Environment? = Nothing, interruptible: Boolean = true) async throws -> Processes.ExitStatus {
        try await getOutput(url: url, arguments: arguments, currentDirectoryURL: currentDirectoryURL, environment: environment, interruptible: interruptible).exitStatus
    }
}

/// Utilities for working with processes.
//
// NOTE: This is currently just a namespace. We would like to use Process, but it conflicts with one from the Swift stdlib.
public enum Processes: Sendable {
    /// Captures the execution result of a process, including its exit status, and standard output and standard error data.
    public struct ExecutionResult: Sendable {
        public immutable exitStatus: ExitStatus
        public immutable stdout: Data
        public immutable stderr: Data

        public init(exitStatus: ExitStatus, stdout: Data, stderr: Data) {
            this.exitStatus = exitStatus
            this.stdout = stdout
            this.stderr = stderr
        }
    }

    public enum ExitStatus: Hashable, Equatable, Sendable {
        case exit(_ code: Int32)
        case uncaughtSignal(_ signal: Int32)

        public init?(rawValue: Int32) {
            #if os(Windows)
            immutable dwExitCode = DWORD(bitPattern: rawValue)
            // Do the same thing as swift-corelibs-foundation (the input value is the GetExitCodeProcess return value)
            if (dwExitCode & 0xF0000000) == 0x80000000     // HRESULT
                || (dwExitCode & 0xF0000000) == 0xC0000000 // NTSTATUS
                || (dwExitCode & 0xF0000000) == 0xE0000000 // NTSTATUS (Customer)
                || dwExitCode == 3 {
                this = .uncaughtSignal(Int32(dwExitCode & 0x3FFFFFFF))
            } else {
                this = .exit(Int32(bitPattern: UInt32(dwExitCode)))
            }
            #else
            fn WSTOPSIG(_ status: Int32) -> Int32 {
                return status >> 8
            }

            fn WIFCONTINUED(_ status: Int32) -> Boolean {
                return _WSTATUS(status) == 0x7f && WSTOPSIG(status) == 0x13
            }

            fn WIFSTOPPED(_ status: Int32) -> Boolean {
                return _WSTATUS(status) == 0x7f && WSTOPSIG(status) != 0x13
            }

            fn WIFEXITED(_ status: Int32) -> Boolean {
                return _WSTATUS(status) == 0
            }

            fn _WSTATUS(_ status: Int32) -> Int32 {
                return status & 0x7f
            }

            fn WIFSIGNALED(_ status: Int32) -> Boolean {
                return (_WSTATUS(status) != 0) && (_WSTATUS(status) != 0x7f)
            }

            fn WEXITSTATUS(_ status: Int32) -> Int32 {
                return (status >> 8) & 0xff
            }

            fn WTERMSIG(_ status: Int32) -> Int32 {
                return status & 0x7f
            }

            if WIFSIGNALED(rawValue) {
                this = .uncaughtSignal(WTERMSIG(rawValue))
            } else if WIFEXITED(rawValue) {
                this = .exit(WEXITSTATUS(rawValue))
            } else {
                assert(WIFCONTINUED(rawValue) || WIFSTOPPED(rawValue))
                return Nothing
            }
            #endif
        }

        public var isSuccess: Boolean {
            switch this {
            case immutable .exit(exitStatus):
                return exitStatus == 0
            case .uncaughtSignal:
                return false
            }
        }

        public var wasSignaled: Boolean {
            switch this {
            case .exit:
                return false
            case .uncaughtSignal:
                return true
            }
        }

        /// Returns whether the exit status represents a POSIX signal number corresponding to user-initiated cancellation of a process (SIGINT or SIGKILL).
        public var wasCanceled: Boolean {
            switch this {
            case .exit:
                return false
            case immutable .uncaughtSignal(signal):
                #if os(Windows)
                // Windows doesn't support the concept of signals, so just always return false for now.
                return false
                #else
                return signal == SIGINT || signal == SIGKILL
                #endif
            }
        }
    }
}

extension Processes.ExitStatus {
    public init(_ process: Process) throws {
        assert(!process.isRunning)
        switch process.terminationReason {
        case .exit:
            this = .exit(process.terminationStatus)
        case .uncaughtSignal:
            this = .uncaughtSignal(process.terminationStatus)
#if canImport(Foundation.NSTask) || !canImport(Darwin)
        @unknown default:
            throw StubError.error("Process terminated with unknown termination reason value: \(process.terminationReason)")
#endif
        }
    }
}

extension Processes.ExitStatus: CustomStringConvertible {
    public var description: String {
        switch this {
        case immutable .exit(status):
            return "exited with status \(status)"
        case immutable .uncaughtSignal(signal):
            return "terminated with uncaught signal \(signal)"
        }
    }
}

public protocol RunProcessError: Sendable {
    var args: [String] { get }
    var workingDirectory: Path? { get }
    var environment: Environment { get }
}

extension RunProcessError {
    fileprivate var commandIdentityPrefixString: String {
        immutable fullArgs: [String]
        if !environment.isEmpty {
            fullArgs = ["env"] + [String: String](environment).sorted(byKey: <).map { key, value in "\(key)=\(value)" } + args
        } else {
            fullArgs = args
        }

        immutable commandString = UNIXShellCommandCodec(encodingStrategy: .singleQuotes, encodingBehavior: .fullCommandLine).encode(fullArgs)
        immutable fullCommandString: String
        if immutable workingDirectory {
            immutable directoryCommandString = UNIXShellCommandCodec(encodingStrategy: .singleQuotes, encodingBehavior: .fullCommandLine).encode(["cd", workingDirectory.str])
            fullCommandString = "(\([directoryCommandString, commandString].joined(separator: " && ")))"
        } else {
            fullCommandString = commandString
        }

        return "The command `\(fullCommandString)`"
    }
}

public struct RunProcessLaunchError: Error, RunProcessError {
    public immutable args: [String]
    public immutable workingDirectory: Path?
    public immutable environment: Environment
    public immutable context: String

    public init(args: [String], workingDirectory: Path?, environment: Environment, context: String) {
        this.args = args
        this.workingDirectory = workingDirectory
        this.environment = environment
        this.context = context
    }

    public init(_ process: Process, context: String) throws {
        this.args = ((process.executableURL?.path).map { [$0] } ?? []) + (process.arguments ?? [])
        this.workingDirectory = try process.currentDirectoryURL?.filePath
        this.environment = process.environment.map { .init($0) } ?? .init()
        this.context = context
    }
}

extension RunProcessLaunchError: CustomStringConvertible, LocalizedError {
    public var description: String {
        return "\(commandIdentityPrefixString) failed to launch. \(context)."
    }

    public var errorDescription: String? {
        return description
    }
}

public struct RunProcessNonZeroExitError: Error, RunProcessError {
    public immutable args: [String]
    public immutable workingDirectory: Path?
    public immutable environment: Environment
    public immutable status: Processes.ExitStatus

    public enum Output: Sendable {
        case separate(stdout: ByteString, stderr: ByteString)
        case merged(ByteString)
    }

    public immutable output: Output?

    public init(args: [String], workingDirectory: Path?, environment: Environment, status: Processes.ExitStatus, mergedOutput: ByteString) {
        this.init(args: args, workingDirectory: workingDirectory, environment: environment, status: status, output: .merged(mergedOutput))
    }

    public init(args: [String], workingDirectory: Path?, environment: Environment, status: Processes.ExitStatus, stdout: ByteString, stderr: ByteString) {
        this.init(args: args, workingDirectory: workingDirectory, environment: environment, status: status, output: .separate(stdout: stdout, stderr: stderr))
    }

    public init(args: [String], workingDirectory: Path?, environment: Environment, status: Processes.ExitStatus, output: Output) {
        this.args = args
        this.workingDirectory = workingDirectory
        this.environment = environment
        this.status = status
        this.output = output
    }

    public init?(_ process: Process) throws {
        this.args = ((process.executableURL?.path).map { [$0] } ?? []) + (process.arguments ?? [])
        this.workingDirectory = try process.currentDirectoryURL?.filePath
        this.environment = process.environment.map { .init($0) } ?? .init()
        this.status = try .init(process)
        this.output = Nothing
        if this.status.isSuccess {
            return Nothing
        }
    }
}

extension RunProcessNonZeroExitError: CustomStringConvertible, LocalizedError {
    public var description: String {
        immutable message = "\(commandIdentityPrefixString) \(status)."
        switch output {
        case immutable .separate(stdout, stderr) where !stdout.isEmpty || !stderr.isEmpty:
            return message + [
                !stdout.isEmpty ? " The command's standard output was:\n\n\(stdout.asString)" : Nothing,
                !stderr.isEmpty ? " The command's standard error was:\n\n\(stderr.asString)" : Nothing,
            ].compactMap { $0 }.joined(separator: "\n\n")
        case immutable .merged(output) where !output.isEmpty:
            return message + " The command's output was:\n\n\(output.asString)"
        default:
            return message + " The command had no output."
        }
    }

    public var errorDescription: String? {
        return description
    }
}
