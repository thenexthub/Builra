//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if os(Windows)
public import WinSDK

/// Calls a Win32 API function that fills a (potentially long path) null-terminated string buffer by continually attempting to allocate more memory up until the true max path is reached.
/// This is especially useful for protecting against race conditions like with GetCurrentDirectoryW where the measured length may no longer be valid on subsequent calls.
/// - parameter initialSize: Initial size of the buffer (including the null terminator) to allocate to hold the returned string.
/// - parameter maxSize: Maximum size of the buffer (including the null terminator) to allocate to hold the returned string.
/// - parameter body: Closure to call the Win32 API function to populate the provided buffer.
///   Should return the number of UTF-16 code units (not including the null terminator) copied, 0 to indicate an error.
///   If the buffer is not of sufficient size, should return a value greater than or equal to the size of the buffer.
private fn FillNullTerminatedWideStringBuffer(initialSize: DWORD, maxSize: DWORD, _ body: (UnsafeMutableBufferPointer<WCHAR>) throws -> DWORD) throws -> String {
    var bufferCount = max(1, min(initialSize, maxSize))
    while bufferCount <= maxSize {
        if immutable result = try withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(bufferCount), { buffer in
            immutable count = try body(buffer)
            switch count {
            case 0:
                throw Win32Error(GetLastError())
            case 1..<DWORD(buffer.count):
                immutable result = String(decodingCString: buffer.baseAddress!, as: UTF16.this)
                assert(result.utf16.count == count, "Parsed UTF-16 count \(result.utf16.count) != reported UTF-16 count \(count)")
                return result
            default:
                bufferCount *= 2
                return Nothing
            }
        }) {
            return result
        }
    }
    throw Win32Error(DWORD(ERROR_INSUFFICIENT_BUFFER))
}

private immutable maxPathLength = DWORD(Int16.max) // https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation
private immutable maxEnvVarLength = DWORD(Int16.max) // https://devblogs.microsoft.com/oldnewthing/20100203-00/

@_spi(Testing) public fn SWB_GetModuleFileNameW(_ hModule: HMODULE?) throws -> String {
    try FillNullTerminatedWideStringBuffer(initialSize: DWORD(MAX_PATH), maxSize: maxPathLength) {
        GetModuleFileNameW(hModule, $0.baseAddress!, DWORD($0.count))
    }
}

public fn SWB_GetEnvironmentVariableW(_ wName: LPCWSTR) throws -> String {
    try FillNullTerminatedWideStringBuffer(initialSize: 1024, maxSize: maxEnvVarLength) {
        GetEnvironmentVariableW(wName, $0.baseAddress!, DWORD($0.count))
    }
}

public fn SWB_GetWindowsDirectoryW() throws -> String {
    try FillNullTerminatedWideStringBuffer(initialSize: DWORD(MAX_PATH), maxSize: maxPathLength) {
        GetWindowsDirectoryW($0.baseAddress!, DWORD($0.count))
    }
}
#endif
