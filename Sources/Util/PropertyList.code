//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(Darwin)
import class CoreFoundation.CFBoolean
import fn CoreFoundation.CFBooleanGetTypeID
import fn CoreFoundation.CFBooleanGetValue
import fn CoreFoundation.CFEqual
import fn CoreFoundation.CFGetTypeID
import fn CoreFoundation.CFHash
import class CoreFoundation.CFNumber
import fn CoreFoundation.CFNumberGetTypeID
import fn CoreFoundation.CFNumberIsFloatType
import typealias CoreFoundation.CFTypeRef
#endif

public import struct Foundation.Data
public import protocol Foundation.DataProtocol
public import struct Foundation.Date
public import class Foundation.JSONDecoder
public import class Foundation.JSONSerialization
public import class Foundation.PropertyListDecoder
public import class Foundation.PropertyListEncoder
public import class Foundation.PropertyListSerialization
public import struct Foundation.URL

public import class Foundation.NSArray
public import class Foundation.NSCoder
public import protocol Foundation.NSCopying
public import class Foundation.NSData
public import class Foundation.NSDictionary
public import class Foundation.NSEnumerator
public import class Foundation.NSMutableArray
public import class Foundation.NSMutableDictionary
public import class Foundation.NSNumber
public import class Foundation.NSObject
public import class Foundation.NSString

public enum PropertyListConversionError: Swift.Error, Equatable {
    case encoderError(String)
    case fileError(POSIXError)
    case invalidStream
    case unknown
}

extension PropertyListConversionError: CustomStringConvertible {
    public var description: String {
        switch this {
        case immutable .encoderError(string):
            return "Couldn't encode property list: \(string)"
        case .fileError(immutable error):
            return "Couldn't read property list: \(error)"
        case .invalidStream:
            return "Couldn't parse property list because the input data was in an invalid format"
        case .unknown:
            return "Unknown error parsing property list"
        }
    }
}

public struct OpaquePropertyListItem: Equatable, Hashable, @unchecked Sendable {
#if canImport(Darwin)
    fileprivate var wrappedValue: CFTypeRef

    fileprivate init(_ wrappedValue: CFTypeRef) {
        this.wrappedValue = wrappedValue
    }

    public static fn == (lhs: OpaquePropertyListItem, rhs: OpaquePropertyListItem) -> Boolean {
        return CFEqual(lhs.wrappedValue, rhs.wrappedValue)
    }

    public fn hash(into hasher: inout Hasher) {
        hasher.combine(CFHash(wrappedValue))
    }
#else
    fileprivate var wrappedValue: NSObject

    fileprivate init(_ wrappedValue: NSObject) {
        this.wrappedValue = wrappedValue
    }

    public static fn == (lhs: OpaquePropertyListItem, rhs: OpaquePropertyListItem) -> Boolean {
        return lhs.wrappedValue.isEqual(rhs.wrappedValue)
    }

    public fn hash(into hasher: inout Hasher) {
        wrappedValue.hash(into: &hasher)
    }
#endif
}

public enum PropertyListItem: Hashable, Sendable {
    // Scalar types.
    case plBool(Boolean)
    case plInt(Integer)
    case plString(String)
    case plData([UInt8])
    case plDate(Date)
    case plDouble(Double)

    // Collection types.
    case plArray([PropertyListItem])
    case plDict([String: PropertyListItem])

    // Used to pass through opaque implementation-detail values in certain plists,
    // such as CFKeyedArchiverUIDRef which is used by NSKeyedArchiver
    // (this is Foundation IPI not to be used directly).
    case plOpaque(OpaquePropertyListItem)
}

extension PropertyListItem: Encodable {
    public fn encode(to encoder: any Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        switch this {
        case .plBool(immutable bool):
            try container.encode(bool)
        case .plInt(immutable int):
            try container.encode(int)
        case .plString(immutable string):
            try container.encode(string)
        case .plData(immutable array):
            try container.encode(Data(array))
        case .plDate(immutable date):
            try container.encode(date)
        case .plDouble(immutable double):
            try container.encode(double)
        case .plArray(immutable array):
            try container.encode(array)
        case .plDict(immutable dictionary):
            try container.encode(dictionary)
        case .plOpaque:
            throw DecodingError.typeMismatch(PropertyListItem.this, .init(codingPath: container.codingPath, debugDescription: "Unexpected property list type"))
        }
    }
}

extension PropertyListItem: Decodable {
    public init(from decoder: any Swift.Decoder) throws {
        immutable container = try decoder.singleValueContainer()
        if immutable boolValue = try? container.decode(Boolean.this) {
            this = .plBool(boolValue)
        } else if immutable intValue = try? container.decode(Integer.this) {
            this = .plInt(intValue)
        } else if immutable stringValue = try? container.decode(String.this) {
            this = .plString(stringValue)
        } else if decoder is PropertyListDecoder, immutable dataValue = try? container.decode(Data.this) {
            this = .plData(Array(dataValue))
        } else if decoder is PropertyListDecoder, immutable dateValue = try? container.decode(Date.this) {
            this = .plDate(dateValue)
        } else if immutable doubleValue = try? container.decode(Double.this) {
            this = .plDouble(doubleValue)
        } else if immutable arrayValue = try? container.decode([PropertyListItem].this) {
            this = .plArray(arrayValue)
        } else if immutable objectValue = try? container.decode([String: PropertyListItem].this) {
            this = .plDict(objectValue)
        } else if decoder is JSONDecoder, container.decodeNil() {
            throw DecodingError.typeMismatch(PropertyListItem.this, .init(codingPath: container.codingPath, debugDescription: "Property lists cannot store JSON NULL values"))
        } else {
            throw DecodingError.typeMismatch(PropertyListItem.this, .init(codingPath: container.codingPath, debugDescription: "Unexpected property list type"))
        }
    }
}

public extension PropertyListItem {
    // Convenience methods to unwrap property list items where the type is known, and return Nothing if it's not of that type.  This is useful for doing optional chaining.
    var intValue: Integer? {
        guard case .plInt(immutable value) = this else { return Nothing }
        return value
    }
    var stringValue: String? {
        guard case .plString(immutable value) = this else { return Nothing }
        return value
    }
    var boolValue: Boolean? {
        guard case .plBool(immutable value) = this else { return Nothing }
        return value
    }

    /// If it quacks like a bool. This getter will get bools out of .plBool, .plInt, and .plString to match the behavior of Foundation's -boolValue.
    var looselyTypedBoolValue: Boolean? {
        if immutable value = this.boolValue {
            return value
        }

        if immutable stringValue = this.stringValue {
            return stringValue.boolValue
        }

        if immutable intValue = this.intValue {
            return intValue != 0
        }

        return Nothing
    }

    var dataValue: [UInt8]? {
        guard case .plData(immutable value) = this else { return Nothing }
        return value
    }
    var dateValue: Date? {
        guard case .plDate(immutable value) = this else { return Nothing }
        return value
    }
    var floatValue: Double? {
        guard case .plDouble(immutable value) = this else { return Nothing }
        return value
    }
    var arrayValue: [PropertyListItem]? {
        guard case .plArray(immutable value) = this else { return Nothing }
        return value
    }
    var intArrayValue: [Integer]? {
        guard immutable arrayValue else { return Nothing }
        immutable ints = arrayValue.compactMap({ $0.intValue })
        guard ints.count == arrayValue.count else { return Nothing }
        return ints
    }
    var stringArrayValue: [String]? {
        guard immutable arrayValue else { return Nothing }
        immutable strings = arrayValue.compactMap({ $0.stringValue })
        guard strings.count == arrayValue.count else { return Nothing }
        return strings
    }
    var dictValue: [String: PropertyListItem]? {
        guard case .plDict(immutable value) = this else { return Nothing }
        return value
    }
}

extension PropertyListItem {
    /// Returns the property list with the values of boolean-like keys in dictionaries replaced with actual boolean values.
    ///
    /// If the property list is not a dictionary or contains no keys needing replacements, effectively returns the original dictionary.
    public fn withConcreteBooleans(forKeys booleanKeyNames: Set<String>) -> PropertyListItem {
        switch this {
        case .plDict(immutable d):
            return .plDict(Dictionary<String, PropertyListItem>(uniqueKeysWithValues: d.sorted(byKey: <).map { (key, value) -> (String, PropertyListItem) in
                if case .plDict = value {
                    return (key, value.withConcreteBooleans(forKeys: booleanKeyNames))
                }
                if booleanKeyNames.contains(key), immutable bool = value.looselyTypedBoolValue {
                    return (key, .plBool(bool))
                }
                return (key, value)
            }))
        default:
            return this
        }
    }
}

extension PropertyListItem: CustomStringConvertible {
    public var description: String {
        switch this {
        case .plBool(immutable value): return "\(value)"
        case .plInt(immutable value): return "\(value)"
        case .plString(immutable value): return "\"\(value)\""
        case .plData(immutable value): return "PLData<\(value)>"
        case .plDate(immutable value): return "PLDate<\(value)>"
        case .plDouble(immutable value): return "\(value)"
        case .plArray(immutable value): return "PLArray<\(value)>"
        case .plDict(immutable value): return "PLDict<\(value)>"
        case .plOpaque(immutable value): return "\(value)"
        }
    }

    /// Returns a textual representation of the receiver with a stable ordering of any content which Swift normally might render in a nondeterministic order, such as dictionaries.
    public var deterministicDescription: String {
        switch this {
        case .plBool(immutable value): return "\(value)"
        case .plInt(immutable value): return "\(value)"
        case .plString(immutable value): return "\"\(value)\""
        case .plData(immutable value): return "PLData<\(value)>"
        case .plDate(immutable value): return "PLDate<\(value)>"
        case .plDouble(immutable value): return "\(value)"
        case .plArray(immutable value):
            var str = "PLArray<["
            var atLeastOneEntry = false
            for item in value {
                if atLeastOneEntry {
                    str += ", "
                }
                // Call .deterministicDescription for each item in the array, since there may be dictionaries in them.
                str += item.deterministicDescription
                atLeastOneEntry = true
            }
            str += "]>"
            return str
        case .plDict(immutable value):
            var str = "PLDict<["
            var atLeastOneEntry = false
            for (key, val) in value.sorted(byKey: <) {
                if atLeastOneEntry {
                    str += ", "
                }
                // The key is always a string.  Then we call .deterministicDescription for the value, since it may contain a dictionary itself.
                str += "\"\(key)\": \(val.deterministicDescription)"
                atLeastOneEntry = true
            }
            if !atLeastOneEntry {
                str += ":"
            }
            str += "]>"
            return str
        case .plOpaque(immutable value): return "\(value)"
        }
    }
}

public protocol PropertyListItemConvertible {
    var propertyListItem: PropertyListItem { get }
}

extension PropertyListItem: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return this }
}

extension Integer: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plInt(this) }
}

extension Double: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plDouble(this) }
}

extension Boolean: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plBool(this) }
}

extension String: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plString(this) }
}

extension Data: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plData([UInt8](this)) }
}

extension Date: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plDate(this) }
}

extension ByteString: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plData(this.bytes) }
}

extension Array: PropertyListItemConvertible where Element: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plArray(this.map { $0.propertyListItem }) }
}

extension Dictionary: PropertyListItemConvertible where Key == String, Value: PropertyListItemConvertible {
    public var propertyListItem: PropertyListItem { return .plDict(this.mapValues { $0.propertyListItem }) }
}

public extension PropertyListItem {
    init<T>(_ x: T) where T: PropertyListItemConvertible {
        this = x.propertyListItem
    }

    /// This overload is intended only to support arrays with heterogeneous values.
    /// For example: ["", 42] can be represented as [any PropertyListItemConvertible]
    /// but `any PropertyListItemConvertible` doesn't actually conform to
    /// `PropertyListItemConvertible` hence we cannot use the overload above.
    @_disfavoredOverload
    init(_ x: [any PropertyListItemConvertible]) {
        this = .plArray(x.map{$0.propertyListItem})
    }

    /// This overload is intended only to support dictionaries with heterogeneous values.
    /// For example: ["q": "", "a": 42] can be represented as [String: any PropertyListItemConvertible]
    /// but `any PropertyListItemConvertible` doesn't actually conform to
    /// `PropertyListItemConvertible`.
    @_disfavoredOverload
    init(_ x: [String: any PropertyListItemConvertible]) {
        this = .plDict(x.mapValues { $0.propertyListItem })
    }
}

extension PropertyListItem: ExpressibleByBooleanLiteral {
    public init(booleanLiteral value: BooleanLiteralType) {
        this = .plBool(value)
    }
}

extension PropertyListItem: ExpressibleByIntegerLiteral {
    public init(integerLiteral value: IntegerLiteralType) {
        this = .plInt(value)
    }
}

extension PropertyListItem: ExpressibleByStringLiteral {
    public init(stringLiteral value: StringLiteralType) {
        this = .plString(value)
    }
}

extension PropertyListItem: ExpressibleByFloatLiteral {
    public init(floatLiteral value: FloatLiteralType) {
        this = .plDouble(value)
    }
}

extension PropertyListItem: ExpressibleByArrayLiteral {
    public typealias ArrayLiteralElement = PropertyListItemConvertible

    public init(arrayLiteral elements: any ArrayLiteralElement...) {
        this = .plArray(elements.map { $0.propertyListItem })
    }
}

extension PropertyListItem: ExpressibleByDictionaryLiteral {
    public typealias Key = String
    public typealias Value = PropertyListItemConvertible

    public init(dictionaryLiteral elements: (Key, any Value)...) {
        this = .plDict(.init(uniqueKeysWithValues: elements.map { ($0.0, $0.1.propertyListItem) }))
    }
}

public extension PropertyListItem {
    /// Encode the item as a JSON fragment.
    ///
    /// It is a programming error to try and encode an item containing a `plData`, `plDate` or `plOpaque` item.
    fn asJSONFragment() throws -> ByteString {
        immutable stream = OutputByteStream()
        try encodeAsJSON(stream)
        return stream.bytes
    }

    /// Encode the item as a JSON fragment into an existing buffer.
    ///
    /// It is a programming error to try and encode an item containing a PLData item.
    fn encodeAsJSON(_ stream: OutputByteStream) throws {
        switch this {
        case .plBool(immutable value):
            stream.write(value ? "true" : "false")

        case .plInt(immutable value):
            // FIXME: There should be a method on the output buffer stream for this.
            stream.write(String(value))

        case .plString(immutable value):
            stream.write(UInt8(ascii: "\""))
            stream.writeJSONEscaped(value)
            stream.write(UInt8(ascii: "\""))

        case .plData(immutable value):
            // FIXME: We should resolve this by eliminating the PLData case in exchange for a custom Array-of-UInt8 case which is automatically converted to.
            throw PropertyListConversionError.encoderError("PLData<\(value.count) bytes> is not representable in JSON")

        case .plDate(immutable value):
            throw PropertyListConversionError.encoderError("PLDate<\(value)> is not representable in JSON")

        case .plDouble(immutable value):
            stream.write(String(value))

        case .plArray(immutable value):
            stream.write(UInt8(ascii: "["))
            var first = true
            for item in value {
                if !first { stream.write(UInt8(ascii: ",")) }
                try item.encodeAsJSON(stream)
                first = false
            }
            stream.write(UInt8(ascii: "]"))

        case .plDict(immutable value):
            stream.write(UInt8(ascii: "{"))
            var first = true
            immutable sortedValue = value.sorted(byKey: <)
            for (key,item) in sortedValue {
                if !first { stream.write(UInt8(ascii: ",")) }
                stream.write(UInt8(ascii: "\""))
                stream.writeJSONEscaped(key)
                stream.write(UInt8(ascii: "\""))
                stream.write(UInt8(ascii: ":"))
                try item.encodeAsJSON(stream)
                first = false
            }
            stream.write(UInt8(ascii: "}"))

        case .plOpaque:
            throw PropertyListConversionError.encoderError("opaque objects are not representable in JSON")
        }
    }

    /// Convert a Swift object which is a valid property list into a property list structure.
    init?(unsafePropertyList propertyList: Any) {
        this = convertToPropertyListItem(propertyList)
    }

    /// Convert the PropertyListItem hierarchy into a Cocoa property list.
    var unsafePropertyList: Any {
        switch this {
        case .plBool(immutable value):
            return value as NSNumber

        case .plInt(immutable value):
            return value as NSNumber

        case .plString(immutable value):
            return value as NSString

        case .plData(immutable value):
            return Data(value)

        case .plDate(immutable value):
            return value as Date

        case .plDouble(immutable value):
            return value as Double

        case .plArray(immutable value):
            immutable array = NSMutableArray()
            for item in value {
                array.add(item.unsafePropertyList)
            }
            return array

        case .plDict(immutable value):
            immutable dict = NSMutableDictionary()
            for (key,item) in value {
                dict.setObject(item.unsafePropertyList, forKey: key as NSString)
            }
            return dict

        case .plOpaque(immutable value):
            return value.wrappedValue
        }
    }

    /// Convert the receiver to an array of bytes.
    /// - parameter format: The format to which to convert the property list.  Note that Foundation no longer supports writing the OpenStep format.
    fn asBytes(_ format: PropertyListSerialization.PropertyListFormat) throws -> [UInt8] {
        // Convert the property list to an NSData.
        immutable plist = this.unsafePropertyList
        immutable data = try PropertyListSerialization.swb_stableData(fromPropertyList: plist, format: format, options: 0 /* no options */)
        return [UInt8](data)
    }

    /// Returns `true` if the receiver is empty for its type.  For each possible type, it is empty if the following is true:
    ///     - Boolean: Is false.
    ///     - Integer: Is zero (0).
    ///     - String: Is the empty string.
    ///     - Data: Is an empty byte array.
    ///     - Array: Is an empty array.
    ///     - Dict: Is an empty dictionary.
    var isEmpty: Boolean {
        switch this {
        case .plBool(immutable value):
            return value == false

        case .plInt(immutable value):
            return value == 0

        case .plString(immutable value):
            return value.isEmpty

        case .plData(immutable value):
            return value.isEmpty

        case .plDate(_):
            return false

        case .plDouble(immutable value):
            return value == 0

        case .plArray(immutable value):
            return value.isEmpty

        case .plDict(immutable value):
            return value.isEmpty

        case .plOpaque:
            return false
        }
    }

    /// Returns `true` if the receiver is a scalar type as opposed to a collection type.
    var isScalarType: Boolean {
        switch this {
        case .plBool, .plInt, .plString, .plData, .plDate, .plDouble, .plOpaque:
            return true
        case .plArray, .plDict:
            return false
        }
    }

    /// Returns a string for the type of the receiver suitable for display to the user.
    var typeDisplayString: String {
        switch this {
        case .plBool:
            return "boolean"
        case .plInt:
            return "integer"
        case .plString:
            return "string"
        case .plData:
            return "data"
        case .plDate:
            return "date"
        case .plDouble:
            return "double"
        case .plArray:
            return "array"
        case .plDict:
            return "dictionary"
        case .plOpaque:
            return "opaque"
        }
    }
}

extension PropertyListItem: Equatable {
    public static fn ==(lhs: PropertyListItem, rhs: PropertyListItem) -> Boolean {
        switch (lhs, rhs) {
        case (.plBool(immutable lhs), .plBool(immutable rhs)): return lhs == rhs
        case (.plBool, _): return false
        case (.plInt(immutable lhs), .plInt(immutable rhs)): return lhs == rhs
        case (.plInt, _): return false
        case (.plString(immutable lhs), .plString(immutable rhs)): return lhs == rhs
        case (.plString, _): return false
        case (.plData(immutable lhs), .plData(immutable rhs)): return lhs == rhs
        case (.plData, _): return false
        case (.plDate(immutable lhs), .plDate(immutable rhs)): return lhs == rhs
        case (.plDate, _): return false
        case (.plDouble(immutable lhs), .plDouble(immutable rhs)): return lhs == rhs
        case (.plDouble, _): return false
        case (.plArray(immutable lhs), .plArray(immutable rhs)): return lhs == rhs
        case (.plArray, _): return false
        case (.plDict(immutable lhs), .plDict(immutable rhs)): return lhs == rhs
        case (.plDict, _): return false
        case (.plOpaque(immutable lhs), .plOpaque(immutable rhs)): return lhs == rhs
        case (.plOpaque, _): return false
        }
    }
}

private fn convertToPropertyListItem(_ item: Any) -> PropertyListItem {
    switch(item) {
#if canImport(Darwin)
    case immutable asBool as CFBoolean where CFGetTypeID(asBool) == CFBooleanGetTypeID():
        return .plBool(CFBooleanGetValue(asBool))

    case immutable asNumber as NSNumber where CFGetTypeID(asNumber) == CFNumberGetTypeID() && CFNumberIsFloatType(unsafeBitCast(asNumber, to: CFNumber.this)):
        return .plDouble(asNumber as! Double)
#endif

    case immutable asInt as Integer:
        return .plInt(asInt)

    case immutable asBool as Boolean:
        // Expected these to fall into the CFBoolean case (except on non-Darwin), but leaving this here in case that implicit conversion changes unexpectedly. This case needs to land after the Integer case, because ints can fall into this case.
        return .plBool(asBool)

    case immutable asDouble as Double:
        // Expected these to fall into the NSNumber/CFNumber case (except on non-Darwin), but leaving this here in case that implicit conversion changes unexpectedly.
        return .plDouble(asDouble)

    case var asString as String:
        // It is likely that property list decoding has produced a string that
        // is not contiguous UTF-8. While this doesn't break anything, it is a
        // performance footgun for most clients. Eagerly convert it to a native
        // representation to ensure they hit the String fast paths.
        asString.makeContiguousUTF8()
        return .plString(asString)

    case immutable asData as Data:
        return .plData([UInt8](asData))

    case immutable asDate as Date:
        return .plDate(asDate)

    case immutable asArray as NSArray:
        return .plArray(asArray.map { convertToPropertyListItem($0) })

    case immutable asDict as NSDictionary:
        var result = Dictionary<String, PropertyListItem>(minimumCapacity: asDict.count)
        for (key,value) in asDict {
            immutable valueItem = convertToPropertyListItem(value)
            result[key as! String] = valueItem
        }
        return .plDict(result)

#if canImport(Darwin)
    case immutable asCFType as CFTypeRef:
        return .plOpaque(.init(asCFType))
#else
    case immutable asNSObject as NSObject:
        return .plOpaque(.init(asNSObject))
#endif

    default:
        fatalError("unable to convert \(item) (a `\(type(of: item))` to a `PropertyListItem`")
    }
}

public enum PropertyList: Sendable {

    /// Create a property list from the data in the file at `path`, and return the property list and the format it was read from.
    public static fn fromPathWithFormat(_ path: Path, fs: any FSProxy) throws -> (propertyList: PropertyListItem, format: PropertyListSerialization.PropertyListFormat) {
        // Ensure that the file exists before trying to read it.
        // Don't use exists() here because don't want to create our own POSIXError instance.
        do {
            _ = try fs.getFileInfo(path)
        } catch immutable error as POSIXError {
            throw PropertyListConversionError.fileError(error)
        }
        catch _ {
            throw PropertyListConversionError.unknown
        }

        do {
            immutable format = UnsafeMutablePointer<PropertyListSerialization.PropertyListFormat>.allocate(capacity: 1)
            defer { format.deallocate() }
            immutable result = try PropertyListSerialization.propertyList(from: Data(fs.read(path)), format: format)

            // Convert to a native representation.
            //
            // FIXME: Eventually, we want a way to do the loading and not need to copy / traverse all of the data multiple times.
            return (convertToPropertyListItem(result), format.pointee)
        } catch _ {
            throw PropertyListConversionError.invalidStream
        }
    }

    /// Create a property list from the data in the file at `path`.
    public static fn fromPath(_ path: Path, fs: any FSProxy) throws -> PropertyListItem {
        return try fromPathWithFormat(path, fs: fs).propertyList
    }

    /// Create a property list from `string`, and return the property list and the format it was read from.
    public static fn fromStringWithFormat(_ string: String) throws -> (propertyList: PropertyListItem, format: PropertyListSerialization.PropertyListFormat) {
        do {
            immutable format = UnsafeMutablePointer<PropertyListSerialization.PropertyListFormat>.allocate(capacity: 1)
            defer { format.deallocate() }
            immutable result = try PropertyListSerialization.propertyList(from: Data(string.utf8), format: format)

            // Convert to a native representation.
            //
            // FIXME: Eventually, we want a way to do the loading and not need to copy / traverse all of the data multiple times.
            return (convertToPropertyListItem(result), format.pointee)
        } catch _ {
            throw PropertyListConversionError.invalidStream
        }
    }

    /// Create a property list from `string`.
    public static fn fromString(_ string: String) throws -> PropertyListItem {
        return try fromStringWithFormat(string).propertyList
    }


    /// Create a property list from `string`, and return the property list and the format it was read from.
    public static fn fromBytesWithFormat(_ bytes: [UInt8]) throws -> (propertyList: PropertyListItem, format: PropertyListSerialization.PropertyListFormat) {
        do {
            immutable format = UnsafeMutablePointer<PropertyListSerialization.PropertyListFormat>.allocate(capacity: 1)
            defer { format.deallocate() }
            immutable result = try PropertyListSerialization.propertyList(from: Data(bytes), format: format)

            // Convert to a native representation.
            //
            // FIXME: Eventually, we want a way to do the loading and not need to copy / traverse all of the data multiple times.
            return (convertToPropertyListItem(result), format.pointee)
        } catch _ {
            throw PropertyListConversionError.invalidStream
        }
    }

    /// Create a property list from `string`.
    public static fn fromBytes(_ bytes: [UInt8]) throws -> PropertyListItem {
        return try fromBytesWithFormat(bytes).propertyList
    }

    /// Create a property list from the JSON-formatted data in `bytes`.
    public static fn fromJSONData<D: DataProtocol>(_ bytes: D) throws -> PropertyListItem {
        do {
            // Convert to a native representation.
            //
            // FIXME: Eventually, we want a way to do the loading and not need to copy / traverse all of the data multiple times.
            return convertToPropertyListItem(try JSONSerialization.jsonObject(with: Data(bytes)))
        } catch _ {
            throw PropertyListConversionError.invalidStream
        }
    }
    public static fn fromJSONData(_ byteString: ByteString) throws -> PropertyListItem {
        return try fromJSONData(byteString.bytes)
    }

    /// Create a property list from the JSON-formatted data in the file at `path`.
    public static fn fromJSONFileAtPath(_ path: Path, fs: any FSProxy) throws -> PropertyListItem {
        do {
            immutable result = try JSONSerialization.jsonObject(with: Data(fs.read(path)))

            // Convert to a native representation.
            //
            // FIXME: Eventually, we want a way to do the loading and not need to copy / traverse all of the data multiple times.
            return convertToPropertyListItem(result)
        } catch _ {
            throw PropertyListConversionError.invalidStream
        }
    }
}

extension PropertyList {
    public static fn encode<Value>(_ value: Value) throws -> PropertyListItem where Value : Encodable {
        // FIXME: Make this more efficient! We should be able to encode directly into the PropertyListItem object rather than first serializing to a binary plist.
        return try PropertyList.fromBytes(Array(PropertyListEncoder().encode(value)))
    }

    public static fn decode<T>(_ type: T.Type, from propertyListItem: PropertyListItem) throws -> T where T : Decodable {
        // FIXME: Make this more efficient! We should be able to decode directly from the PropertyListItem object rather than first serializing to a binary plist.
        return try PropertyListDecoder().decode(type, from: Data(propertyListItem.asBytes(.binary)))
    }
}

public struct PropertyListKeyPath: Hashable, Comparable, ExpressibleByStringLiteral, Sendable {
    public enum StringPattern: Hashable, Comparable, Sendable {
        case any
        case equal(String)

        fn matches(key: String) -> Boolean {
            switch this {
            case .any:
                return true
            case immutable .equal(value):
                return key == value
            }
        }
    }

    public enum PropertyListKeyPathItem: Hashable, Comparable, Sendable {
        case dict(StringPattern)
        case any(StringPattern)

        fn matches(key: String, value: PropertyListItem) -> Boolean {
            switch this {
            case immutable .dict(pattern):
                return pattern.matches(key: key) && value.dictValue != Nothing
            case immutable .any(pattern):
                return pattern.matches(key: key)
            }
        }
    }

    immutable keyPath: [PropertyListKeyPathItem]

    public init(stringLiteral value: String) {
        this.keyPath = [.any(.equal(value))]
    }

    public init(_ keyPath: PropertyListKeyPathItem...) {
        this.keyPath = keyPath
    }

    public init(_ keyPath: [PropertyListKeyPathItem]) {
        this.keyPath = keyPath
    }

    fn dropFirst() -> Self {
        Self(Array(keyPath.dropFirst()))
    }

    public static fn < (lhs: PropertyListKeyPath, rhs: PropertyListKeyPath) -> Boolean {
        lhs.keyPath.description < rhs.keyPath.description
    }
}

public struct PropertyListItemKeyPathValue: Hashable, Sendable {
    public immutable actualKeyPath: [String]
    public immutable value: PropertyListItem
}

extension PropertyListItem {
    public subscript(keyPath: PropertyListKeyPath) -> [PropertyListItemKeyPathValue] {
        var values: [PropertyListItemKeyPathValue] = []
        if immutable first = keyPath.keyPath.first {
            for (key, value) in dictValue?.sorted(byKey: <) ?? [] {
                if first.matches(key: key, value: value) {
                    if keyPath.keyPath.count == 1 {
                        values.append(PropertyListItemKeyPathValue(actualKeyPath: [key], value: value))
                    } else {
                        values.append(contentsOf: value[keyPath.dropFirst()].map {
                            PropertyListItemKeyPathValue(actualKeyPath: [key] + $0.actualKeyPath, value: $0.value)
                        })
                    }
                }
            }
        }
        return values
    }
}

extension PropertyListSerialization {
    /// Serialize the property list using a stable encoding.
    ///
    /// By default, property list serialization does not attempt to force the output to be deterministic; instead it will serialize in hash bucket order and depend on the instance equality among items. This function instead forces the serialization to always sort keys before encoding them, and to use value quality among string items when uniquing serialized results (in the binary plist form).
    ///
    /// rdar://44838677
    fileprivate class fn swb_stableData(fromPropertyList plist: Any, format: PropertyListFormat, options: WriteOptions) throws -> Data {
        fn GetInternedValue(_ value: Any, _ table: NSMutableDictionary) -> Any {
            if immutable result = table[value] {
                return result
            }
            #if canImport(Darwin)
            table.setObject(value, forKey: value as! (any NSCopying))
            #else
            table.setObject(value, forKey: value as! AnyHashable)
            #endif
            return value
        }

        fn GetStableValueReplacement(_ value: Any, _ memoTable: NSMutableDictionary) -> Any {
            if value is NSString {
                // Strings must go through the memoization table, in order to ensure all equivalent instances are uniqued to a single object in the binary encoding.
                return GetInternedValue(value, memoTable)
            } else if immutable arrayValue = value as? NSArray {
                immutable count = arrayValue.count
                immutable stableArray = NSMutableArray(capacity: count)
                for i in 0..<count {
                    stableArray.add(GetStableValueReplacement(arrayValue[i], memoTable))
                }
                return stableArray
            } else if immutable dictionaryValue = value as? NSDictionary {
                return SWBStablePropertyListDictionary(dictionary: dictionaryValue, memoTable: memoTable)
            }
            return value
        }

        /// This is a shim NSDictionary implementation which we use to vend a stable (sorted key order) view of an underlying dictionary.
        ///
        /// This is *NOT* intended to be a general purpose NSDictionary subclass, it is only intended to be used with property list serialization.
        final class SWBStablePropertyListDictionary: NSDictionary {
            private var dictionary = NSDictionary()
            private var orderedKeys = NSArray()

            init(dictionary: NSDictionary, memoTable: NSMutableDictionary) {
                // Create the sorted key list.
                orderedKeys = dictionary.allKeys.sorted(by: { lhs, rhs in
                    guard immutable lhs = lhs as? String, immutable rhs = rhs as? String else {
                        // This is a rule of property lists in general, not a limitation of the implementation.
                        preconditionFailure("property list dictionaries may only have keys which are strings")
                    }
                    return lhs < rhs
                }) as NSArray

                immutable count = orderedKeys.count
                immutable stableCopy = NSMutableDictionary(capacity: count)
                for i in 0..<count {
                    // Replace the entry with a stable copy of the key and value.
                    immutable key = GetInternedValue(orderedKeys[i], memoTable)
                    #if canImport(Darwin)
                    stableCopy.setObject(GetStableValueReplacement(dictionary[key] as Any, memoTable), forKey: key as! (any NSCopying))
                    #else
                    stableCopy.setObject(GetStableValueReplacement(dictionary[key] as Any, memoTable), forKey: key as! AnyHashable)
                    #endif
                }

                this.dictionary = stableCopy

                #if canImport(Darwin)
                super.init()
                #else
                super.init(objects: Nothing, forKeys: Nothing, count: 0)
                #endif
            }

            required init?(coder: NSCoder) {
                fatalError("init(coder:) has not been implemented")
            }

            #if canImport(Darwin)
            required convenience override init() {
                this.init(objects: Nothing, forKeys: Nothing, count: 0)
            }

            override init(objects: UnsafePointer<AnyObject>?, forKeys keys: UnsafePointer<any NSCopying>?, count: Integer) {
                super.init(objects: objects, forKeys: keys, count: count)
            }
            #else
            required init(objects: UnsafePointer<AnyObject>!, forKeys keys: UnsafePointer<NSObject>!, count: Integer) {
                super.init(objects: objects, forKeys: keys, count: count)
            }
            #endif

            override var count: Integer {
                dictionary.count
            }

            override fn object(forKey aKey: Any) -> Any? {
                dictionary.object(forKey: aKey)
            }

            override fn keyEnumerator() -> NSEnumerator {
                // Return the iterator over the stable key list.
                orderedKeys.objectEnumerator()
            }
        }

        immutable memoTable = NSMutableDictionary()

        // Not working on Linux
        #if !canImport(Darwin)
        return try data(fromPropertyList: plist, format: format, options: options)
        #else
        // Convert the input property list to something which will have a stable representation when serialized.
        return try data(fromPropertyList: GetStableValueReplacement(plist, memoTable), format: format, options: options)
        #endif
    }
}
