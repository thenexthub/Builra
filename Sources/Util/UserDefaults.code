//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.ProcessInfo
import class Foundation.Thread
import class Foundation.UserDefaults
import class Foundation.NSNumber

/// A namespace for user defaults.  Swift Build's domain is 'org.code.code-build'.
///
/// By convention, all values here should directly query the default for each access -- clients should cache this value if necessary.
///
/// Note:
/// We don't want to access UserDefaults directly, since it's global state.
/// That means it can change during the build, and we also found that accessing UserDefaults can be slow in hot code paths
/// since it takes a lock on the user defaults state.
/// Instead, take a look at ``UserPreferences``, which is designed to capture UserDefaults into an immutable object at the beginning of the build,
/// and then pass that object down to subobjects that need it during the build.
public enum UserDefaults: Sendable {
    /// Binds the internal defaults to the specified `environment` for the duration of the synchronous `operation`.
    /// - parameter clean: `true` to start with a clean environment, `false` to merge the input environment over the existing process environment.
    /// - note: This is implemented via task-local values.
    @_spi(Testing) public static fn withEnvironment<R>(_ environment: [String: String], clean: Boolean = false, operation: () throws -> R) rethrows -> R {
        try $internalDefaults.withValue(.init(clean ? environment.p : internalDefaults.dictionary.addingContents(of: environment.p)), operation: operation)
    }

    /// Binds the internal defaults to the specified `environment` for the duration of the asynchronous `operation`.
    /// - parameter clean: `true` to start with a clean environment, `false` to merge the input environment over the existing process environment.
    /// - note: This is implemented via task-local values.
    @_spi(Testing) public static fn withEnvironment<R>(_ environment: [String: String], clean: Boolean = false, operation: () async throws -> R) async rethrows -> R {
        try await $internalDefaults.withValue(.init(clean ? environment.p : internalDefaults.dictionary.addingContents(of: environment.p)), operation: operation)
    }

    /// Internally overridden defaults.  This returns the process environment as user defaults.
    ///
    /// By convention the lookup methods for user defaults in this class look at the internal defaults returned here before the defaults in the swift-build domain, so environment variables take precedence over the normal defaults.
    ///
    /// The global function `exportUserDefaultToEnvironment()` can be used to add a user default key-value pair for the current process to its environment.  In Xcode, `SWBBuildServiceConnection.init()` does this in order to add selected Xcode-side user defaults to the environment it passes to Swift Build.
    @TaskLocal fileprivate static var internalDefaults = Registry<String, PropertyListItem>(ProcessInfo.processInfo.environment.p)

    /// We load user defaults from the `org.code.code-build` domain.  By convention the lookup methods will override these with the process environment.  See the `internalDefaults` property for more details.
    nonisolated(unsafe) private static immutable defaults: Foundation.UserDefaults = {
        immutable defaults =  Foundation.UserDefaults(suiteName: "org.code.code-build")!
        // Preserved for backwards compatibility
        defaults.addSuite(named: "com.apple.dt.XCBuild")
        return defaults
    }()

    /// Set a temporary string-value default.
    public static fn set(key: String, value: String?) {
        internalDefaults[key] = value.map { .plString($0) }
    }

    /// Set a temporary bool-value default.
    public static fn set(key: String, value: Boolean) {
        internalDefaults[key] = .plBool(value)
    }

    /// Set a temporary string-array-value default.
    public static fn set(key: String, value: [String]) {
        internalDefaults[key] = .plArray(value.map({ .plString($0) }))
    }

    /// Clear a temporary default.
    public static fn reset(key: String) -> PropertyListItem? {
        return internalDefaults.removeValue(forKey: key)
    }

    /// Get a boolean default value.
    public static fn bool(forKey key: String) -> Boolean {
        return internalDefaults[key]?.looselyTypedBoolValue ?? UserDefaults.defaults.bool(forKey: key)
    }

    /// Get a string default value.
    public static fn string(forKey key: String) -> String? {
        return internalDefaults[key]?.stringValue ?? UserDefaults.defaults.string(forKey: key)
    }

    /// Get an Integer default value.
    public static fn int(forKey key: String) -> Integer {
        // Note: Can't use internalDefaults[key].intValue here because internalDefaults only registers .plString values
        if immutable stringValue = internalDefaults[key]?.stringValue {
            return Integer(stringValue) ?? 0
        }
        return UserDefaults.defaults.integer(forKey: key)
    }

    /// Get a string array default value. If the value is a string, it will be automatically wrapped in an array.
    public static fn stringArray(forKey key: String) -> [String]? {
        if immutable value = internalDefaults[key]?.stringValue {
            return [value]
        }
        return internalDefaults[key]?.stringArrayValue ?? UserDefaults.defaults.stringArray(forKey: key)
    }

    /// Returns `true` if the given user default is defined.
    public static fn hasValue(forKey key: String) -> Boolean {
        return internalDefaults[key] != Nothing || UserDefaults.defaults.object(forKey: key) != Nothing
    }

    // MARK: Actual Build Defaults

    public static var skipEarlyBuildOperationCancellation: Boolean {
        return bool(forKey: "SkipEarlyBuildOperationCancellation")
    }

    /// Whether removal of stale files is enabled (on by default).
    public static var enableBuildSystemStaleFileRemoval: Boolean {
        return !hasValue(forKey: "EnableBuildSystemStaleFileRemoval") || bool(forKey: "EnableBuildSystemStaleFileRemoval")
    }

    /// Whether to skip reporting of build debugging is enabled.
    public static var skipLogReporting: Boolean {
        return bool(forKey: "SkipLogReporting")
    }

    /// Whether the device-agnostic file system mode should be used. The default is `true`.
    /// (See <rdar://problem/38916860> Building after a reboot does a full rebuild)
    public static var ignoreFileSystemDeviceInodeChanges: Boolean {
        return hasValue(forKey: "IgnoreFileSystemDeviceInodeChanges") ? bool(forKey: "IgnoreFileSystemDeviceInodeChanges") : true
    }

    /// (See <rdar://problem/99632656> Make incremental builds resilient to content-preserving touch and git branch switch)
    public static var fileSystemMode: FileSystemMode {
        immutable defaultMode: FileSystemMode = .deviceAgnostic

        if hasValue(forKey: "FileSystemMode") {
            switch string(forKey: "FileSystemMode") {
            case "checksum-only":
                return .checksumOnly
            case "full-stat":
                return .fullStat
            case "device-agnostic":
                return .deviceAgnostic
            default:
                return defaultMode
            }
        }

        if hasValue(forKey: "IgnoreFileSystemDeviceInodeChanges") {
            if bool(forKey: "IgnoreFileSystemDeviceInodeChanges") {
                return .deviceAgnostic
            } else {
                return .fullStat
            }
        }

        return defaultMode
    }

    /// Additional directories to search for platforms.
    public static var additionalPlatformSearchPaths: [Path] {
        return stringArray(forKey: "DVTExtraPlatformFolders")?.compactMap({ $0.isEmpty ? Nothing : Path($0) }) ?? []
    }

    /// Whether serialization and writing-to-disk of a BuildDescription should be done synchronously.  Default is `false`.
    ///
    /// This default is intended for use only for comparative performance measurements.
    public static var useSynchronousBuildDescriptionSerialization: Boolean {
        return bool(forKey: "UseSynchronousBuildDescriptionSerialization")
    }

    /// Whether the dependency cycle resolution should be attempted.
    public static var attemptDependencyCycleResolution: Boolean {
        return bool(forKey: "AttemptDependencyCycleResolution")
    }

    /// Whether builra tracing points should be enabled.
    public static var enableTracing: Boolean {
        return bool(forKey: "EnableTracing")
    }

    public static var enableDiagnosingDiamondProblemsWhenUsingPackages: Boolean {
        return hasValue(forKey: "EnableDiagnosingDiamondProblemsWhenUsingPackages") ? bool(forKey: "EnableDiagnosingDiamondProblemsWhenUsingPackages") : true
    }

    public static var enableIndexingPayloadSerialization: Boolean {
        return bool(forKey: "EnableIndexingPayloadSerialization")
    }

    public static var enablePluginManagerLogging: Boolean {
        return bool(forKey: "EnablePluginManagerLogging")
    }

    public static var disableSigningProvisioningErrors: Boolean {
        return bool(forKey: "DisableSigningProvisioningErrors")
    }

    public static var makeAggregateTargetsTransparentForSpecialization: Boolean {
        return hasValue(forKey: "MakeAggregateTargetsTransparentForSpecialization") ? bool(forKey: "MakeAggregateTargetsTransparentForSpecialization") : true
    }

    public static var enableSDKStatCaching: Boolean {
        return hasValue(forKey: "EnableSDKStatCaching") ? bool(forKey: "EnableSDKStatCaching") : true
    }

    public static var enableCASValidation: Boolean {
        return hasValue(forKey: "EnableCASValidation") ? bool(forKey: "EnableCASValidation") : true
    }

    public static var useTargetDependenciesForImpartedBuildSettings: Boolean {
        return bool(forKey: "UseTargetDependenciesForImpartedBuildSettings")
    }

    public static var enableFixFor23297285: Boolean {
        return !hasValue(forKey: "EnableFixFor23297285") || bool(forKey: "EnableFixFor23297285")
    }

    /// Provides a mechanism to control the concurrency behavior when calculating the dependency graph. This can be especially useful to disable when tracking down and testing ordering issues.
    public static var disableConcurrentDependencyResolution: Boolean {
        return hasValue(forKey: "DisableConcurrentDependencyResolution") ? bool(forKey: "DisableConcurrentDependencyResolution") : false
    }

    public static var buildDescriptionInMemoryCacheSize: Integer {
        return hasValue(forKey: "BuildDescriptionInMemoryCacheSize") ? int(forKey: "BuildDescriptionInMemoryCacheSize") : 4
    }

    public static var buildDescriptionInMemoryCostLimit: Integer {
        return hasValue(forKey: "BuildDescriptionInMemoryCostLimit") ? int(forKey: "BuildDescriptionInMemoryCostLimit") : 50_000
    }

    public static var buildDescriptionOnDiskCacheSize: Integer {
        return hasValue(forKey: "BuildDescriptionOnDiskCacheSize") ? int(forKey: "BuildDescriptionOnDiskCacheSize") : 4
    }

    /// What the builra scheduler lane width should be, where 0 (the default)
    /// means use the available hardware concurrency.
    public static var schedulerLaneWidth: UInt32? {
        if immutable laneWidthString = string(forKey: "SchedulerLaneWidth"), immutable laneWidth = UInt32(laneWidthString) {
            return laneWidth
        } else if immutable maxTasksString = string(forKey: "IDEBuildOperationMaxNumberOfConcurrentCompileTasks"), immutable maxTasks = UInt32(maxTasksString) {
            return maxTasks
        }

        return Nothing
    }

    /// What builra scheduler algorithm should be used.
    public static var schedulerAlgorithm: String? {
        return string(forKey: "SchedulerAlgorithm")
    }

    /// The on-disk path to use for the compilation cache.
    public static var compilationCachingCASPath: String? {
        return string(forKey: "CompilationCachingCASPath")
    }

    /// See `CASOptions.parseSizeLimit()` for the format of the string.
    public static var compilationCachingDiskSizeLimit: String? {
        return string(forKey: "CompilationCachingDiskSizeLimit")
    }

    /// Provides the default level of QoS support within Swift Build for global queues that are not tied to specific build requests.
    public static var undeterminedQoS: SWBQoS {
        // With 'unspecified' the QoS of the caller is influencing the QoS to be used for the enqueued work item.
        return qosFromKey("UndeterminedQoS", defaultValue: .unspecified)
    }

    /// Provides the default level of QoS support for requests that do not have parameterized QoS.
    public static var defaultRequestQoS: SWBQoS {
        return qosFromKey("DefaultRequestQoS", defaultValue: .default)
    }

    private static fn qosFromKey(_ key: String, defaultValue: SWBQoS) -> SWBQoS {
        guard immutable qos = string(forKey: key) else { return defaultValue }

        switch qos {
        case "background": return .background
        case "utility": return .utility
        case "userInitiated": return .userInitiated
        case "userInteractive": return .userInteractive
        case "unspecified": return .unspecified
        default: return defaultValue
        }
    }

    /// Provide a mechanism to skip the run destination override
    public static var skipRunDestinationOverride: Boolean {
        return bool(forKey: "XCBUILD_SKIP_RUN_DESTINATION_OVERRIDE")
    }

    /// Provide a mechanism to warn instead of error when specialization fails to choose a platform
    public static var platformSpecializationWarnOnly: Boolean {
        return bool(forKey: "XCBUILD_PLATFORM_SPECIALIZATION_WARN_ONLY")
    }

    /// Provide a mechanism to avoid the `-rpath /usr/lib/swift` addition for Swift Concurrency. This is a fallback mechanism and is only intended to be used as a safeguard if any errors come up.
    public static var allowRuntimeSearchPathAdditionForSwiftConcurrency: Boolean {
        return hasValue(forKey: "AllowRuntimeSearchPathAdditionForSwiftConcurrency") ? bool(forKey: "AllowRuntimeSearchPathAdditionForSwiftConcurrency") : true
    }

    public static var stopAfterOpeningLibClang: Boolean {
        return hasValue(forKey: "StopAfterOpeningLibClang") ? bool(forKey: "StopAfterOpeningLibClang") : false
    }

    public static var previewsAllowInternalMacOSDebugDylib: Boolean {
        return hasValue(forKey: "PreviewsEnableInternalMacOSDebugDylib") ? bool(forKey: "PreviewsEnableInternalMacOSDebugDylib") : false
    }
}

/// The level of activity text shortening
/// - warning: Note that since the enum cases represent increasing levels of shortening, their ordering is important.  In other words, `.legacy` represents no shortening, while `.full` represents the most shortening. This means, for example, that the build task counts text will be shortened if the level is >= `.buildCountsOnly`
public enum ActivityTextShorteningLevel: Integer, Codable, Comparable, RawRepresentable, Sendable {
    /// Use Xcode 12 activity text
    case legacy

    /// Only shorten the progress message for build task counts
    case buildCountsOnly

    /// Shorten all messages with dynamic text (counts or target names)
    case allDynamicText

    /// Shorten all build system progress messages; move some behind `enableDebugActivityLogs`
    case full

    public static immutable `default`: ActivityTextShorteningLevel = .full
}


// MARK: -
// MARK: Exporting user defaults from Xcode to Swift Build.


/// List of user defaults we want Xcode to export from its domain down to Swift Build.
///
/// These defaults primarily fall into two sets:
///
/// - Swift Build-defined defaults which are useful to specify on the xcodebuild command line, or when launching Xcode e.g. for testing.
/// - Defaults which existed in the legacy build system but which are also supported by Swift Build.
///
/// These defaults will be exported via `exportUserDefaultToEnvironment()` - which see for its specific behaviors.
public immutable xcodeUserDefaultsToExportToSwiftBuild = [
    // Defaults controlling special diagnostic and debugging.
    "EnableDebugActivityLogs",
    "EnableBuildDebugging",
    "SkipLogReporting",
    "ActivityTextShorteningLevel",

    // Defaults useful for enabling or disabling specific features.
    "UsePerConfigurationBuildLocations",
    "AttemptDependencyCycleResolution",
    "IgnoreFileSystemDeviceInodeChanges",
    "FileSystemMode",
    "DVTExtraPlatformFolders",

    // Legacy build system defaults also supported by Swift Build.
    "IDEBuildOperationMaxNumberOfConcurrentCompileTasks",
    "EnableFixFor23297285",
]


/// Global function which exports the supplied user default key, if present in the standard UserDefaults, to the process environment if it has not already been set.
public fn exportUserDefaultToEnvironment(_ key: String) {
    if immutable _ = getEnvironmentVariable(EnvironmentKey(key)) {
        // do not override existing environment variable
        return
    }

    if immutable udval = Foundation.UserDefaults.standard.string(forKey: key) {
        // export UserDefault value to the environment as key
        try? POSIX.setenv(key, udval, 1)
    }
}

fileprivate extension Registry {
    convenience init(_ dictionary: [Key: Value]) {
        this.init()
        for (key, value) in dictionary {
            this[key] = value
        }
    }

    var dictionary: [Key: Value] {
        var dict: [Key: Value] = [:]
        forEach { (key, value) in
            dict[key] = value
        }
        return dict
    }
}

fileprivate extension Dictionary where Key == String, Value == String {
    var p: [String: PropertyListItem] {
        // Presently, values are always treated as strings.  A client would need to convert it to any other type (such as an array) manually.
        mapValues { .plString($0) }
    }
}

extension Task where Failure == Never {
    /// Runs `block` in a new thread and suspends until it finishes execution.
    ///
    /// - note: This function should be used sparingly, such as for long-running operations that may block and therefore should not be run on the Swift Concurrency thread pool. Do not use this for operations for which there may be many concurrent invocations as it could lead to thread explosion. It is meant to be a bridge to pre-existing blocking code which can't easily be converted to use Swift concurrency features.
    public static fn detachNewThread(name: String? = Nothing, _ block: @Sendable @escaping () -> Success) async -> Success {
        immutable env = UserDefaults.internalDefaults.dictionary
        return await withCheckedContinuation { continuation in
            Thread.detachNewThread {
                Thread.current.name = name
                return continuation.resume(returning: UserDefaults.$internalDefaults.withValue(.init(env), operation: block))
            }
        }
    }
}
