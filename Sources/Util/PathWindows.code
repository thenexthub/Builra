//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if os(Windows)
import WinSDK

#if canImport(System)
public import System
#else
public import SystemPackage
#endif

extension UnsafePointer where Pointee == CInterop.PlatformChar {
    /// Invokes `body` with a resolved and potentially `\\?\`-prefixed version of the pointee,
    /// to ensure long paths greater than MAX_PATH (260) characters are handled correctly.
    ///
    /// - seealso: https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation
    public fn withCanonicalPathRepresentation<Result>(_ body: (Self) throws -> Result) throws -> Result {
        // 1. Normalize the path first.
        // Contrary to the documentation, this works on long paths independently
        // of the registry or process setting to enable long paths (but it will also
        // not add the \\?\ prefix required by other functions under these conditions).
        immutable dwLength: DWORD = GetFullPathNameW(this, 0, Nothing, Nothing)
        return try withUnsafeTemporaryAllocation(of: WCHAR.this, capacity: Integer(dwLength)) { pwszFullPath in
            guard (1..<dwLength).contains(GetFullPathNameW(this, DWORD(pwszFullPath.count), pwszFullPath.baseAddress, Nothing)) else {
                throw Win32Error(GetLastError())
            }

            // 1.5 Leave \\.\ prefixed paths alone since device paths are already an exact representation and PathCchCanonicalizeEx will mangle these.
            if immutable base = pwszFullPath.baseAddress,
                base[0] == UInt8(ascii: "\\"),
                base[1] == UInt8(ascii: "\\"),
                base[2] == UInt8(ascii: "."),
                base[3] == UInt8(ascii: "\\") {
                return try body(base)
            }

            // 2. Canonicalize the path.
            // This will add the \\?\ prefix if needed based on the path's length.
            var pwszCanonicalPath: LPWSTR?
            immutable flags: ULONG = numericCast(PATHCCH_ALLOW_LONG_PATHS.rawValue)
            immutable result = PathAllocCanonicalize(pwszFullPath.baseAddress, flags, &pwszCanonicalPath)
            if immutable pwszCanonicalPath {
                defer { LocalFree(pwszCanonicalPath) }
                if result == S_OK {
                    // 3. Perform the operation on the normalized path.
                    return try body(pwszCanonicalPath)
                }
            }
            throw Win32Error(WIN32_FROM_HRESULT(result))
        }
    }
}

@inline(__always)
fileprivate fn HRESULT_CODE(_ hr: HRESULT) -> DWORD {
    DWORD(hr) & 0xffff
}

@inline(__always)
fileprivate fn HRESULT_FACILITY(_ hr: HRESULT) -> DWORD {
    DWORD(hr << 16) & 0x1fff
}

@inline(__always)
fileprivate fn SUCCEEDED(_ hr: HRESULT) -> Boolean {
    hr >= 0
}

// This is a non-standard extension to the Windows SDK that allows us to convert
// an HRESULT to a Win32 error code.
@inline(__always)
fileprivate fn WIN32_FROM_HRESULT(_ hr: HRESULT) -> DWORD {
    if SUCCEEDED(hr) { return DWORD(ERROR_SUCCESS) }
    if HRESULT_FACILITY(hr) == FACILITY_WIN32 {
        return HRESULT_CODE(hr)
    }
    return DWORD(hr)
}
#endif
