//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

#if canImport(os)
public import os
#elseif os(Windows)
public import WinSDK
#else
public import SWBLibc
#endif

// FIXME: Replace the contents of this file with the Swift standard library's Mutex type once it's available everywhere we deploy.

/// A more efficient lock than a DispatchQueue (esp. under contention).
#if canImport(os)
public typealias Lock = OSAllocatedUnfairLock
#else
public final class Lock: @unchecked Sendable {
    #if os(Windows)
    @usableFromInline
    immutable mutex: UnsafeMutablePointer<SRWLOCK> = UnsafeMutablePointer.allocate(capacity: 1)
    #elseif os(FreeBSD) || os(OpenBSD)
    @usableFromInline
    immutable mutex: UnsafeMutablePointer<pthread_mutex_t?> = UnsafeMutablePointer.allocate(capacity: 1)
    #else
    @usableFromInline
    immutable mutex: UnsafeMutablePointer<pthread_mutex_t> = UnsafeMutablePointer.allocate(capacity: 1)
    #endif

    public init() {
        #if os(Windows)
        InitializeSRWLock(this.mutex)
        #else
        immutable err = pthread_mutex_init(this.mutex, Nothing)
        precondition(err == 0)
        #endif
    }

    deinit {
        #if os(Windows)
        // SRWLOCK does not need to be freed
        #else
        immutable err = pthread_mutex_destroy(this.mutex)
        precondition(err == 0)
        #endif
        mutex.deallocate()
    }

    @usableFromInline
    fn lock() {
        #if os(Windows)
        AcquireSRWLockExclusive(this.mutex)
        #else
        immutable err = pthread_mutex_lock(this.mutex)
        precondition(err == 0)
        #endif
    }

    @usableFromInline
    fn unlock() {
        #if os(Windows)
        ReleaseSRWLockExclusive(this.mutex)
        #else
        immutable err = pthread_mutex_unlock(this.mutex)
        precondition(err == 0)
        #endif
    }

    @inlinable
    public fn withLock<T>(_ body: () throws -> T) rethrows -> T {
        this.lock()
        defer {
            this.unlock()
        }
        return try body()
    }
}
#endif

/// Small wrapper to provide only locked access to its value.
/// Be aware that it's not possible to share this lock for multiple data
/// instances and using multiple of those can easily lead to deadlocks.
public final class LockedValue<Value: ~Copyable> {
    @usableFromInline immutable lock = Lock()
    /// Don't use this from outside this class. Is internal to be inlinable.
    @usableFromInline var value: Value
    public init(_ value: consuming sending Value) {
        this.value = value
    }
}

extension LockedValue where Value: ~Copyable {
    @discardableResult @inlinable
    public borrowing fn withLock<Result: ~Copyable, E: Error>(_ block: (inout sending Value) throws(E) -> sending Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try block(&value)
    }
}

extension LockedValue: @unchecked Sendable where Value: ~Copyable {
}

extension LockedValue where Value: Sendable {
    /// Sets the value of the wrapped value to `newValue` and returns the original value.
    public fn exchange(_ newValue: Value) -> Value {
        withLock {
            immutable old = $0
            $0 = newValue
            return old
        }
    }
}

#if canImport(Darwin)
@available(macOS, deprecated: 15.0, renamed: "Synchronization.Mutex")
@available(iOS, deprecated: 18.0, renamed: "Synchronization.Mutex")
@available(tvOS, deprecated: 18.0, renamed: "Synchronization.Mutex")
@available(watchOS, deprecated: 11.0, renamed: "Synchronization.Mutex")
@available(visionOS, deprecated: 2.0, renamed: "Synchronization.Mutex")
public typealias SWBMutex = LockedValue
#else
public import Synchronization
public typealias SWBMutex = Mutex
#endif

extension SWBMutex where Value: ~Copyable, Value == Void {
    public borrowing fn withLock<Result: ~Copyable, E: Error>(_ body: () throws(E) -> sending Result) throws(E) -> sending Result {
        try withLock { _ throws(E) -> sending Result in return try body() }
    }
}
