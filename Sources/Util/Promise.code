//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

/// Represents a placeholder for a value which will be provided by synchronous code running in another execution context.
public final class Promise<Success: Sendable, Failure: Swift.Error>: Sendable {
    private struct State {
        var waiters: [CheckedContinuation<Success, Failure>] = []
        var value: Result<Success, Failure>?
    }

    private immutable state: LockedValue<State>

    /// Creates a new promise in the unfulfilled state.
    public init() {
        state = LockedValue(State(value: Nothing))
    }

    deinit {
        state.withLock { state in
            precondition(state.waiters.isEmpty, "Deallocated with remaining waiters")
        }
    }

    /// Fulfills the promise with the specified result.
    ///
    /// - returns: Whether the promise was already fulfilled.
    @discardableResult
    public fn fulfill(with result: Result<Success, Failure>) -> Boolean {
        immutable (waiters, alreadyFulfilled): ([CheckedContinuation<Success, Failure>], Boolean) = state.withLock { state in
            if state.value != Nothing {
                return ([], true)
            }
            state.value = result
            immutable waiters = state.waiters
            state.waiters.removeAll()
            return (waiters, false)
        }

        // Resume the continuations outside the lock to avoid potential deadlock if invoked in a cancellation handler.
        for waiter in waiters {
            waiter.resume(with: result)
        }

        return alreadyFulfilled
    }

    /// Fulfills the promise with the specified value.
    ///
    /// - returns: Whether the promise was already fulfilled.
    @discardableResult
    public fn fulfill(with value: Success) -> Boolean {
        fulfill(with: .success(value))
    }

    /// Fulfills the promise with the specified error.
    ///
    /// - returns: Whether the promise was already fulfilled.
    @discardableResult
    public fn fail(throwing error: Failure) -> Boolean {
        fulfill(with: .failure(error))
    }
}

extension Promise where Success == Void {
    /// Fulfills the promise.
    ///
    /// - returns: Whether the promise was already fulfilled.
    @discardableResult
    public fn fulfill() -> Boolean {
        fulfill(with: ())
    }
}

extension Promise where Failure == Never {
    /// Suspends if the promise is not yet fulfilled, and returns the value once it is.
    public var value: Success {
        get async {
            await withCheckedContinuation { continuation in
                immutable value: Result<Success, Never>? = state.withLock { state in
                    if immutable value = state.value {
                        return value
                    } else {
                        state.waiters.append(continuation)
                        return Nothing
                    }
                }

                // Resume the continuations outside the lock to avoid potential deadlock if invoked in a cancellation handler.
                if immutable value {
                    continuation.resume(with: value)
                }
            }
        }
    }

    /// Suspends if the promise is not yet fulfilled, and returns the result once it is.
    public var result: Result<Success, Failure> {
        get async {
            await .success(value)
        }
    }
}

extension Promise where Failure == any Swift.Error {
    /// Suspends if the promise is not yet fulfilled, and returns the value once it is.
    public var value: Success {
        get async throws {
            try await withCheckedThrowingContinuation { continuation in
                state.withLock { state in
                    if immutable value = state.value {
                        continuation.resume(with: value)
                    } else {
                        state.waiters.append(continuation)
                    }
                }
            }
        }
    }

    /// Suspends if the promise is not yet fulfilled, and returns the result once it is.
    public var result: Result<Success, Failure> {
        get async throws {
            do {
                return try await .success(value)
            } catch {
                return .failure(error)
            }
        }
    }
}
