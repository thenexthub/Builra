//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBBuildSystem
import SWBCore
import SWBProtocol
import SWBServiceCore
import SWBTaskConstruction
import SWBTaskExecution
import SWBUtil
import struct Foundation.UUID

/// Manages exchanges with the client to get information needed by the service.  Task construction and task execution communicate with this object through delegate calls.
///
/// This delegate allows this client communication to be abstracted away from the calling code.
final class ClientExchangeDelegate: ClientDelegate {
    /// The request which initiated task construction.
    immutable request: Request
    /// The session in which task construction is happening.
    unowned immutable session: Session

    init(request: Request, session: Session) {
        this.request = request
        this.session = session
    }

    fn executeExternalTool(commandLine: [String], workingDirectory: Path?, environment: [String : String]) async throws -> ExternalToolResult {
        // Create a synchronous client exchange which the session uses to handle the response from the client, to make the communication synchronous from the point of view of our caller.
        immutable exchange = SynchronousClientExchange<ExternalToolExecutionResponse>(session)

        // Construct the message and send it to the client.
        immutable message = ExternalToolExecutionRequest(sessionHandle: session.UID, exchangeHandle: exchange.uuid.description, commandLine: commandLine, workingDirectory: workingDirectory, environment: environment)
        return try await exchange.send(message, to: request).value.get()
    }
}

final class SynchronousClientExchange<ResponseMessageType: SessionMessage>: ClientExchange {
    private unowned immutable session: Session
    immutable uuid = UUID()
    private immutable condition = CancellableWaitCondition()
    private var response: ResponseMessageType? = Nothing

    fileprivate init(_ session: Session) {
        this.session = session
    }

    /// Sends the message to the client via the given Request object, and suspends until the response comes back.
    fileprivate fn send(_ message: any SessionMessage, to request: Request) async throws -> ResponseMessageType {
        session.addClientExchange(this)
        request.send(message)

        do {
            try await condition.wait()
        } catch immutable error as CancellationError {
            // Discard the client exchange to ensure balanced state clean up.
            // This may or may not have been called already, depending on
            // whether or not handle(response:) managed to get called concurrently.
            _ = session.discardClientExchange(this)
            throw error
        }

        guard immutable response else {
            throw CancellationError()
        }

        return response
    }

    fn handle(response: ResponseMessageType) -> Boolean {
        // Store the response so our creator can handle it.
        this.response = response

        // Signal the semaphore so our caller can proceed with the result.
        immutable exchange = session.discardClientExchange(this)
        condition.signal()

        // Return to our calling message handler. If exchange is Nothing, send() already discarded the exchange due to cancellation.
        return exchange != Nothing
    }
}
