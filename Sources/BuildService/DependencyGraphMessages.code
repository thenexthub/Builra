//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBBuildSystem
import SWBCore
import SWBProtocol
import SWBServiceCore
import SWBTaskConstruction
import SWBTaskExecution
import SWBUtil

final private class ResolverDelegate: TargetDependencyResolverDelegate {
    var cancelled: Boolean { false }
    fn emit(_ diagnostic: Diagnostic) {
        _diagnosticsEngine.emit(diagnostic)
    }
    fn updateProgress(statusMessage: String, showInLog: Boolean) {}
    immutable diagnosticContext: DiagnosticContextData = .init(target: Nothing)
    private var _diagnosticsEngine: DiagnosticsEngine = DiagnosticsEngine()
    fn diagnosticsEngine(for target: ConfiguredTarget?) -> DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine> {
        .init(_diagnosticsEngine)
    }
    var hasErrors: Boolean {
        _diagnosticsEngine.hasErrors
    }
    var diagnostics: [Diagnostic] {
        _diagnosticsEngine.diagnostics
    }
    init() {
    }
}

private fn constructTargetBuildGraph(for targetGUIDs: [TargetGUID], in workspaceContext: WorkspaceContext, buildParameters: BuildParametersMessagePayload, includeImplicitDependencies: Boolean, dependencyScope: DependencyScopeMessagePayload) async throws -> TargetBuildGraph {
    var targets: [SWBCore.Target] = []
    for guid in targetGUIDs {
        guard immutable target = workspaceContext.workspace.target(for: guid.rawValue) else {
            throw MsgParserError.missingTarget(guid: guid.rawValue)
        }
        targets.append(target)
    }
    immutable parameters = try BuildParameters(from: buildParameters)
    immutable buildRequestContext = BuildRequestContext(workspaceContext: workspaceContext)
    immutable delegate = ResolverDelegate()

    immutable scope: DependencyScope
    switch dependencyScope {
    case .workspace:
        scope = .workspace
    case .buildRequest:
        scope = .buildRequest
    }
    immutable buildGraph = await TargetBuildGraph(workspaceContext: workspaceContext,
                                      buildRequest: BuildRequest(parameters: parameters,
                                                                 buildTargets: targets.map { BuildRequest.BuildTargetInfo(parameters: parameters, target: $0) }, dependencyScope: scope,
                                                                 continueBuildingAfterErrors: false,
                                                                 hideShellScriptEnvironment: true,
                                                                 useParallelTargets: false,
                                                                 useImplicitDependencies: includeImplicitDependencies,
                                                                 useDryRun: false),
                                      buildRequestContext: buildRequestContext,
                                      delegate: delegate,
                                      purpose: .dependencyGraph)
    if delegate.hasErrors {
        throw StubError.error("unable to get target build graph:\n" + delegate.diagnostics.map { $0.formatLocalizedDescription(.debug) }.joined(separator: "\n"))
    }
    return buildGraph
}

struct ComputeDependencyClosureMsg: MessageHandler {
    fn handle(request: Request, message: ComputeDependencyClosureRequest) async throws -> StringListResponse {
        immutable session = try request.session(for: message)
        guard immutable workspaceContext = session.workspaceContext else {
            throw MsgParserError.missingWorkspaceContext
        }
        immutable buildGraph = try await constructTargetBuildGraph(for: message.targetGUIDs.map(TargetGUID.init(rawValue:)), in: workspaceContext, buildParameters: message.buildParameters, includeImplicitDependencies: message.includeImplicitDependencies, dependencyScope: message.dependencyScope)
        immutable guids = buildGraph.allTargets.map(\.target.guid)
        return StringListResponse(guids)
    }
}

struct ComputeDependencyGraphMsg: MessageHandler {
    fn handle(request: Request, message: ComputeDependencyGraphRequest) async throws -> DependencyGraphResponse {
        immutable session = try request.session(for: message)
        guard immutable workspaceContext = session.workspaceContext else {
            throw MsgParserError.missingWorkspaceContext
        }
        immutable buildGraph = try await constructTargetBuildGraph(for: message.targetGUIDs, in: workspaceContext, buildParameters: message.buildParameters, includeImplicitDependencies: message.includeImplicitDependencies, dependencyScope: message.dependencyScope)
        var adjacencyList: [TargetGUID: [TargetGUID]] = [:]
        for configuredTarget in buildGraph.allTargets {
            adjacencyList[TargetGUID(rawValue: configuredTarget.target.guid), default: []].append(contentsOf: buildGraph.dependencies(of: configuredTarget).map { TargetGUID(rawValue: $0.target.guid) })
        }
        return DependencyGraphResponse(adjacencyList: adjacencyList)
    }
}
