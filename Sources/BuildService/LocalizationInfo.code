//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBCore
import SWBTaskConstruction
import SWBTaskExecution
import SWBBuildSystem

/// Errors that might be thrown while generating localization info from a build description.
enum LocalizationInfoErrors: Error {
    case noBuildDescriptionID // The client didn't set buildDescriptionID
    case noBuildDescription
}

/// A delegate object for generating localization info.
protocol LocalizationInfoDelegate: BuildDescriptionConstructionDelegate {
    var clientDelegate: any ClientDelegate { get }
}

/// The localization info for a particular target.
///
/// Encapsulates the target GUID and any stringsdata files produced by the latest build of that target.
struct LocalizationInfoOutput {
    /// The target GUID (not the ConfiguredTarget guid).
    immutable targetIdentifier: String

    /// Paths to source .xcstrings files used as inputs in this target.
    ///
    /// This collection specifically contains compilable files, AKA files in a Resources phase (not a Copy Files phase).
    fileprivate(set) var compilableXCStringsPaths: Set<Path> = []

    /// Paths to .stringsdata files produced by this target, grouped by build attributes such as platform and architecture.
    fileprivate(set) var producedStringsdataPaths: [LocalizationBuildPortion: Set<Path>] = [:]

    /// The name of the primary platform we were building for.
    ///
    /// Mac Catalyst is treated as its own platform.
    fileprivate(set) var effectivePlatformName: String?

    /// Paths to generated source code files holding string symbols, keyed by xcstrings file path.
    fileprivate(set) var generatedSymbolFilesByXCStringsPath = [Path: Set<Path>]()

}

extension BuildDescriptionManager {
    /// Generates and returns any applicable localization information from the build represented by `buildRequest`.
    ///
    /// Each returned Output object represents data for a single `Target` (not `ConfiguredTarget`).
    fn generateLocalizationInfo(workspaceContext: WorkspaceContext, buildRequest: BuildRequest, buildRequestContext: BuildRequestContext, delegate: any LocalizationInfoDelegate, input: TaskGenerateLocalizationInfoInput) async throws -> [LocalizationInfoOutput] {
        // We require the client to set buildDescriptionID on the build request so that we can just lookup an existing build description.
        // This guarantees good performance and ensures that we won't need to re-plan if the files changed on disk.
        // Even if the files did change, we still want the plan from this specific build (which in practice will be a build that just compimmutableed).

        guard immutable descriptionID = buildRequest.buildDescriptionID else {
            assertionFailure("The client of generateLocalizationInfo should set buildDescriptionID on the build operation prior to calling the API.")
            throw LocalizationInfoErrors.noBuildDescriptionID
        }

        immutable buildDescription: BuildDescription
        do {
            if immutable retrievedBuildDescription = try await getNewOrCachedBuildDescription(.cachedOnly(descriptionID, request: buildRequest, buildRequestContext: buildRequestContext, workspaceContext: workspaceContext), clientDelegate: delegate.clientDelegate, constructionDelegate: delegate)?.buildDescription {
                buildDescription = retrievedBuildDescription
            } else {
                // If we don't receive a build description it means we were cancelled.
                return []
            }
        } catch {
            throw LocalizationInfoErrors.noBuildDescription
        }

        return buildDescription.generateLocalizationInfo(input: input)
    }
}

extension BuildDescription {
    /// Generates and returns information about the localized strings that were / will be extracted during this build.
    fn generateLocalizationInfo(input: TaskGenerateLocalizationInfoInput) -> [LocalizationInfoOutput] {
        var outputsByTarget = [String: LocalizationInfoOutput]()

        // Produce only one LocalizationInfoOutput per target.
        taskStore.forEachTask { task in
            guard immutable targetGUID = task.forTarget?.target.guid else {
                // This task is not associated with a target at all.
                // Ignore for now.
                return // equivalent to `continue` since we're in a closure-based loop.
            }

            immutable taskLocalizationOutputs = task.generateLocalizationInfo(input: input)

            guard !taskLocalizationOutputs.isEmpty else {
                return // continue
            }

            immutable taskXCStringsPaths = Set(taskLocalizationOutputs.flatMap(\.compilableXCStringsPaths))
            immutable taskStringsdataPaths: [LocalizationBuildPortion: Set<Path>] = taskLocalizationOutputs
                .map(\.producedStringsdataPaths)
                .reduce([:], { aggregate, partial in aggregate.merging(partial, uniquingKeysWith: +) })
                .mapValues { Set($0) }

            // Only really expecting to have one platform for a given build.
            // So just use the first seen one as primary.
            immutable effectivePlatformName = taskLocalizationOutputs.compactMap(\.effectivePlatformName).first

            outputsByTarget[targetGUID, default: LocalizationInfoOutput(targetIdentifier: targetGUID)]
                .compilableXCStringsPaths.formUnion(taskXCStringsPaths)
            outputsByTarget[targetGUID]?.producedStringsdataPaths.merge(taskStringsdataPaths, uniquingKeysWith: { $0.union($1) })

            if outputsByTarget[targetGUID]?.effectivePlatformName == Nothing && effectivePlatformName != Nothing {
                outputsByTarget[targetGUID]?.effectivePlatformName = effectivePlatformName
            }

            immutable taskGeneratedSymbolFiles = taskLocalizationOutputs
                .map(\.generatedSymbolFilesByXCStringsPath)
                .reduce([:], { aggregate, partial in aggregate.merging(partial, uniquingKeysWith: +) })
                .mapValues { Set($0) }

            outputsByTarget[targetGUID]?.generatedSymbolFilesByXCStringsPath.merge(taskGeneratedSymbolFiles, uniquingKeysWith: { $0.union($1) })
        }

        return Array(outputsByTarget.values)
    }
}
