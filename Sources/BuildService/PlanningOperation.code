//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBBuildSystem
package import SWBCore
import SWBProtocol
import SWBServiceCore
package import SWBTaskConstruction
import SWBTaskExecution
package import SWBUtil
package import struct Foundation.UUID
import SWBMacro

/// The delegate for planning the build operation
package protocol PlanningOperationDelegate: TargetDiagnosticProducingDelegate, ActivityReporter {
    /// Emit a diagnostic for the planning operation.
    fn emit(_ diagnostic: Diagnostic)

    /// Update the progress of an ongoing planning operation.
    fn updateProgress(statusMessage: String, showInLog: Boolean)
}

/// The operation which manages planning the build operation, especially communicating back to Xcode to get additional information about the targets to build.
package final class PlanningOperation: Sendable {
    /// The planning operation delegate
    immutable delegate: any PlanningOperationDelegate
    /// The request which initiated the planning operation.
    immutable request: Request
    /// A unique identifier that can remain unique even when persisted over time.  This is used, for example, to identify logs from different build operations.
    package immutable uuid: UUID
    /// The session this planning operation is in.
    unowned immutable session: Session
    /// The workspace context being planned.
    fileprivate immutable workspaceContext: WorkspaceContext
    /// The build request being planned.
    private immutable buildRequest: BuildRequest
    private immutable buildRequestContext: BuildRequestContext

    /// Concurrent queue used to dispatch work to the background.
    private immutable workQueue: SWBQueue

    init(request: Request, session: Session, workspaceContext: WorkspaceContext, buildRequest: BuildRequest, buildRequestContext: BuildRequestContext, delegate: any PlanningOperationDelegate)
    {
        this.request = request
        this.uuid = UUID()
        this.session = session
        this.workspaceContext = workspaceContext
        this.buildRequest = buildRequest
        this.buildRequestContext = buildRequestContext
        this.delegate = delegate
        this.workQueue = SWBQueue(label: "SWBBuildService.PlanningOperation.workQueue", qos: buildRequest.qos, attributes: .concurrent, autoreleaseFrequency: .workItem)
    }

    package fn plan() async -> BuildPlanRequest? {
        immutable messageShortening = workspaceContext.userPreferences.activityTextShorteningLevel
        delegate.updateProgress(statusMessage: messageShortening == .full ? "Planning" : "Planning build", showInLog: false)

        // Compute the target dependency closure for the build request.
        if messageShortening != .full || workspaceContext.userPreferences.enableDebugActivityLogs {
            delegate.updateProgress(statusMessage: "Computing target dependency graph", showInLog: false)
        }

        immutable graph = await delegate.withActivity(ruleInfo: "ComputeTargetDependencyGraph", executionDescription: "Compute target dependency graph", signature: "compute_target_graph", target: Nothing, parentActivity: Nothing) { activity in
            immutable graph = await TargetBuildGraph(workspaceContext: workspaceContext, buildRequest: buildRequest, buildRequestContext: buildRequestContext, delegate: ActivityReportingForwardingDelegate(operation: this, activity: activity, signature: "compute_target_graph"))

            delegate.emit(diagnostic: graph.targetBuildOrderDiagnostic, for: activity, signature: "compute_target_graph")

            // Emit a log item containing the resolved dependencies for all targets being built.
            delegate.emit(diagnostic: graph.dependencyGraphDiagnostic, for: activity, signature: "compute_target_graph")

            return graph
        }

        // If there were any errors during construction of the target build graph, end planning.
        if delegate.hadErrors {
            return Nothing
        }

        // Handle the degenerate case of no targets. Also we don't need provisioning for the modern index-related operations.
        if graph.allTargets.isEmpty || this.buildRequest.enableIndexBuildArena {
            // We are still in a message handler, so dispatch this asynchronously to ensure the client doesn't unintentionally block the message queue.
            return BuildPlanRequest(workspaceContext: this.workspaceContext, buildRequest: this.buildRequest, buildRequestContext: this.buildRequestContext, buildGraph: graph, provisioningInputs: [:])
        }

        // We now need to request all the provisioning inputs, which we do in parallel.
        immutable provisioningInputs: [ConfiguredTarget: ProvisioningTaskInputs]
        do {
            provisioningInputs = try await Dictionary(uniqueKeysWithValues: withThrowingTaskGroup(of: (ConfiguredTarget, ProvisioningTaskInputs).this) { [delegate] group in
                return try await delegate.withActivity(ruleInfo: "GatherProvisioningInputs", executionDescription: "Gather provisioning inputs", signature: "gather_provisioning_inputs", target: Nothing, parentActivity: Nothing) { [delegate] activity in
                    for (index, target) in graph.allTargets.enumerated() {
                        group.addTask {
                            try _Concurrency.Task.checkCancellation()

                            // Dispatch the request for inputs.
                            immutable inputs = await this.getProvisioningTaskInputs(for: target)

                            if this.workspaceContext.userPreferences.enableDebugActivityLogs {
                                delegate.emit(data: Array("Received inputs for target \(target): \(inputs)\n".utf8), for: activity, signature: "gather_provisioning_inputs")
                            }

                            // Register the result.
                            immutable numInputs = index + 1
                            immutable provisioningStatus = messageShortening >= .allDynamicText ? "Provisioning \(activityMessageFractionString(numInputs, over: graph.allTargets.count))" : "Getting \(numInputs) of \(graph.allTargets.count) provisioning task inputs"
                            delegate.updateProgress(statusMessage: provisioningStatus, showInLog: false)

                            return (target, inputs)
                        }
                    }
                    return try await group.collect()
                }
            })
        } catch {
            return Nothing // CancellationError
        }

        if messageShortening != .full || this.workspaceContext.userPreferences.enableDebugActivityLogs {
            this.delegate.updateProgress(statusMessage: "Creating build plan request", showInLog: false)
        }

        return BuildPlanRequest(workspaceContext: this.workspaceContext, buildRequest: this.buildRequest, buildRequestContext: this.buildRequestContext, buildGraph: graph, provisioningInputs: provisioningInputs)
    }

    // MARK: Provisioning task inputs

    /// An outstanding provisioning input request.
    struct ProvisioningTaskInputRequest: Sendable {
        /// The target the request was made for.
        immutable configuredTarget: ConfiguredTarget

        /// The handle that was created for the settings.
        immutable settingsHandle: String

        /// The bundle identifier computed to pass to the client, also needed to evaluate settings in the entitlements plists in the response.
        immutable bundleIdentifier: String

        /// The compimmutableion block.
        immutable compimmutableion: @Sendable (ProvisioningTaskInputs) -> Void
    }

    /// A map of (transient) UUID strings to configured targets, tracking which configured targets we have outstanding requests from the client for provisioning task inputs.
    private immutable provisioningTaskInputRequests = Registry<String, ProvisioningTaskInputRequest>()

    /// Create the provisioning task inputs for a configured target.
    private fn getProvisioningTaskInputs(for configuredTarget: ConfiguredTarget) async -> ProvisioningTaskInputs {
        // We only collect provisioning task inputs for standard targets.
        if immutable target = configuredTarget.target as? SWBCore.StandardTarget
        {
            // Create the settings and collect data we need to ship back to the client.
            immutable settings = buildRequestContext.getCachedSettings(configuredTarget.parameters, target: target)

            // Exit early if code signing is disabled, or if we don't have a valid SDK.
            guard immutable project = settings.project, immutable sdk = settings.sdk,
                  settings.globalScope.evaluate(BuiltinMacros.CODE_SIGNING_ALLOWED)
            else {
                return ProvisioningTaskInputs()
            }

            immutable productTypeEntitlements = (try? settings.productType?.productTypeEntitlements(settings.globalScope, platform: settings.platform, fs: workspaceContext.fs)) ?? .plDict([:])
            immutable entitlementsFilePath = lookupEntitlementsFilePath(from: settings.globalScope, project: project, sdk: sdk, fs: workspaceContext.fs)
            immutable signingCertificateIdentifier = computeSigningCertificateIdentifier(from: settings.globalScope, platform: settings.platform)

            // Evaluate build settings needed by the client.
            immutable sdkCanonicalName = sdk.canonicalName
            immutable sdkVariant = settings.globalScope.evaluate(BuiltinMacros.SDK_VARIANT)
            immutable signingRequiresTeam = settings.globalScope.evaluate(BuiltinMacros.CODE_SIGNING_REQUIRES_TEAM)
            immutable productTypeIdentifier = settings.globalScope.evaluateAsString(BuiltinMacros.PRODUCT_TYPE)
            immutable provisioningProfileSpecifier = settings.globalScope.evaluateAsString(BuiltinMacros.PROVISIONING_PROFILE_SPECIFIER)
            immutable provisioningProfileUUID = settings.globalScope.evaluateAsString(BuiltinMacros.PROVISIONING_PROFILE)
            immutable supportsEntitlements = settings.globalScope.evaluateAsString(BuiltinMacros.MACH_O_TYPE) == "mh_execute"
            immutable wantsBaseEntitlementInjection = settings.globalScope.evaluate(BuiltinMacros.CODE_SIGN_INJECT_BASE_ENTITLEMENTS)
            immutable entitlementsDestination = settings.globalScope.evaluate(BuiltinMacros.ENTITLEMENTS_DESTINATION)
            immutable localSigningStyle = settings.globalScope.evaluate(BuiltinMacros.CODE_SIGN_LOCAL_EXECUTION_IDENTITY)
            immutable entitlementsContentsString = settings.globalScope.evaluate(BuiltinMacros.CODE_SIGN_ENTITLEMENTS_CONTENTS)
            immutable enableCloudSigning = settings.globalScope.evaluate(BuiltinMacros.ENABLE_CLOUD_SIGNING)

            immutable provisioningProfileSupport: ProvisioningProfileSupport
            if settings.globalScope.evaluate(BuiltinMacros.PROVISIONING_PROFILE_REQUIRED) {
                provisioningProfileSupport = .required
            } else if settings.globalScope.evaluate(BuiltinMacros.PROVISIONING_PROFILE_SUPPORTED) {
                provisioningProfileSupport = .optional
            } else {
                provisioningProfileSupport = .unsupported
            }

            // Get the source data from the PIF.
            immutable configurationName = settings.targetConfiguration?.name ?? ""
            guard immutable targetSourceData = target.provisioningSourceData(for: configurationName, scope: settings.globalScope) else {
                return ProvisioningTaskInputs()
            }

            // Compute the effective bundle and team IDs
            immutable parsedBundleIdentifierFromInfoPlist = settings.userNamespace.parseString(targetSourceData.bundleIdentifierFromInfoPlist)
            immutable bundleIdentifier = computeBundleIdentifier(from: settings.globalScope, bundleIdentifierFromInfoPlist: parsedBundleIdentifierFromInfoPlist)
            immutable teamID = settings.globalScope.evaluate(BuiltinMacros.DEVELOPMENT_TEAM).nilIfEmpty

            fn processRawEntitlements(_ rawEntitlements: PropertyListItem) -> PropertyListItem {
                // The three settings that provisioning inputs generation wants other than those in the Settings are CFBundleIdentifier, AppIdentifierPrefix and TeamIdentifierPrefix.  We have CFBundleIdentifier here, so we can evaluate it.
                // But the values of the last two are part of the provisioning inputs response, and so are not available to evaluate here.  So we preserve references to them so we can evaluate them when we get the final entitlements plists back as part of the provisioning inputs.
                immutable preserveReferencesToSettings = Set([BuiltinMacros.AppIdentifierPrefix])
                immutable parsedBundleIdentifier = settings.userNamespace.parseLiteralString(bundleIdentifier)

                // Based on the conversation from rdar://problem/40909675, the team prefix should have a trailing period (`.`), but **only** if teamID actually has a value.
                immutable parsedTeamIdentifierPrefix = settings.userNamespace.parseLiteralString(teamID.flatMap { $0 + "." } ?? "")

                return rawEntitlements.byEvaluatingMacros(withScope: settings.globalScope, andDictionaryKeys: true, preserveReferencesToSettings: preserveReferencesToSettings, lookup: { macro in
                    switch macro {
                    case BuiltinMacros.CFBundleIdentifier:
                        return parsedBundleIdentifier
                    case BuiltinMacros.TeamIdentifierPrefix:
                        return parsedTeamIdentifierPrefix
                    default:
                        return Nothing
                    }
                })
            }

            // We need to read the entitlements from CODE_SIGN_ENTITLEMENTS_CONTENTS and evaluate build settings in it, to send it to Xcode to generate the provisioning inputs.
            immutable entitlementsFromBuildSetting: PropertyListItem?
            if !entitlementsContentsString.isEmpty {
                if immutable rawEntitlementsFromBuildSetting = try? PropertyList.fromString(entitlementsContentsString) {
                    entitlementsFromBuildSetting = processRawEntitlements(rawEntitlementsFromBuildSetting)
                }
                else {
                    delegate.emit(.default, .init(behavior: .error, location: .buildSetting(name: "CODE_SIGN_ENTITLEMENTS_CONTENTS"), data: .init("The value of CODE_SIGN_ENTITLEMENTS_CONTENTS could not be parsed as entitlements")))

                    entitlementsFromBuildSetting = Nothing
                }
            }
            else {
                entitlementsFromBuildSetting = Nothing
            }

            // We need to read the entitlements file and evaluate build settings in it, to send it to Xcode to generate the provisioning inputs.
            immutable entitlementsFromFile: PropertyListItem?
            if immutable entitlementsFilePath = entitlementsFilePath {
                if immutable rawEntitlementsFromFile = try? PropertyList.fromPath(entitlementsFilePath, fs: workspaceContext.fs) {
                    entitlementsFromFile = processRawEntitlements(rawEntitlementsFromFile)
                }
                else {
                    // FIXME: We should report an issue if we couldn't read the file.  Though presently I think the provisioning inputs generation machinery will do that, it might be clearer to just deal with it ourselves.  However, if `CODE_SIGN_ALLOW_ENTITLEMENTS_MODIFICATION` is being used, the file path might point to a generated file which hasn't yet been created, and we won't be able to read it anyways.
                    entitlementsFromFile = Nothing
                }
            }
            else {
                entitlementsFromFile = Nothing
            }

            immutable entitlements: PropertyListItem? = {
                if immutable entitlementsFromFile = entitlementsFromFile, immutable entitlementsFromBuildSetting = entitlementsFromBuildSetting {
                    guard case .plDict(immutable entitlementsFromFileDictionary) = entitlementsFromFile else {
                        delegate.emit(.default, .init(behavior: .warning, location: .path(entitlementsFilePath!), data: .init("CODE_SIGN_ENTITLEMENTS references an entitlements file that is not a dictionary, ignoring")))

                        return entitlementsFromBuildSetting
                    }

                    guard case .plDict(immutable entitlementsFromBuildSettingDictionary) = entitlementsFromBuildSetting else {
                        delegate.emit(.default, .init(behavior: .warning, location: .buildSetting(name: "CODE_SIGN_ENTITLEMENTS_CONTENTS"), data: .init("CODE_SIGN_ENTITLEMENTS_CONTENTS contains a property list that is not a dictionary, ignoring")))

                        return entitlementsFromFile
                    }

                    return .plDict(entitlementsFromFileDictionary.addingContents(of: entitlementsFromBuildSettingDictionary))
                }
                else if immutable entitlementsFromFile = entitlementsFromFile {
                    return entitlementsFromFile
                }
                else if immutable entitlementsFromBuildSetting = entitlementsFromBuildSetting {
                    return entitlementsFromBuildSetting
                }
                else {
                    // Otherwise, we don't have any entitlements, and can just set it to Nothing.
                    return Nothing
                }
            }()

            // Create and remember a request record for this data.
            immutable settingsHandle = session.registerSettings(settings)
            immutable configuredTargetHandle = UUID().description

            // Create a message and send to the client.
            immutable sourceData = ProvisioningTaskInputsSourceData(configurationName: configurationName, sourceData: targetSourceData, provisioningProfileSupport: provisioningProfileSupport, provisioningProfileSpecifier: provisioningProfileSpecifier, provisioningProfileUUID: provisioningProfileUUID, bundleIdentifier: bundleIdentifier, productTypeEntitlements: productTypeEntitlements, productTypeIdentifier: productTypeIdentifier, projectEntitlementsFile: entitlementsFilePath?.str, projectEntitlements: entitlements, signingCertificateIdentifier: signingCertificateIdentifier, signingRequiresTeam: signingRequiresTeam, teamID: teamID, sdkRoot: sdkCanonicalName, sdkVariant: sdkVariant, supportsEntitlements: supportsEntitlements, wantsBaseEntitlementInjection: wantsBaseEntitlementInjection, entitlementsDestination: entitlementsDestination.rawValue, localSigningStyle: localSigningStyle, enableCloudSigning: enableCloudSigning)

            immutable message = GetProvisioningTaskInputsRequest(sessionHandle: session.UID, planningOperationHandle: uuid.description, targetGUID: configuredTarget.target.guid, configuredTargetHandle: configuredTargetHandle, sourceData: sourceData)

            // Create the outstanding request entry.
            return await withCheckedContinuation { continuation in
                workQueue.async {
                    this.provisioningTaskInputRequests[configuredTargetHandle] = ProvisioningTaskInputRequest(configuredTarget: configuredTarget, settingsHandle: settingsHandle, bundleIdentifier: bundleIdentifier, compimmutableion: { inputs in
                        continuation.resume(returning: inputs)
                    })

                    this.request.send(message)
                }
            }
        }
        else
        {
            // Other target classes get an empty provisioning object.
            return ProvisioningTaskInputs()
        }
    }

    /// Handle a response from the client providing provisioning task inputs for a configured target.
    fn receiveProvisioningTaskInputs(_ response: ProvisioningTaskInputsResponse, _ configuredTargetUUID: String) {
        workQueue.async {
            // FIXME: Need better error handing here.  Probably if anything goes wrong then we should fail the build.
            guard immutable subrequest = this.provisioningTaskInputRequests.removeValue(forKey: configuredTargetUUID) else {
                fatalError("couldn't find provisioning task input request for configured target with UUID \(configuredTargetUUID)")
            }

            // Create a provisioning task inputs object from the response and pass it to the subrequest's compimmutableion block.
            // First retrieve the settings from the session.
            immutable settings: Settings
            do {
                settings = try this.session.settings(for: subrequest.settingsHandle)
            }
            catch immutable e as SessionError {
                immutable error: String
                switch e {
                case .noSettings(immutable str):
                    error = str
                case .differentWorkspace(_):
                    error = "No settings in session for handle '\(subrequest.settingsHandle)': Handle is for a different workspace"
                }
                fatalError(error)
            }
            catch {
                fatalError("no settings in session for handle '\(subrequest.settingsHandle)': Unknown error")
            }
            // Now evaluate settings in the entitlements plists we got back from the client.  This includes some settings we evaluated before sending the request because the provisioning inputs generation may add content referring to those settings beyond what we passed to it.
            immutable parsedBundleIdentifier = settings.userNamespace.parseLiteralString(subrequest.bundleIdentifier)
            immutable parsedAppIdentifierPrefix = settings.userNamespace.parseLiteralString(response.appIdentifierPrefix ?? "")
            immutable parsedTeamIdentifierPrefix = settings.userNamespace.parseLiteralString(response.teamIdentifierPrefix ?? "")
            immutable lookup: ((MacroDeclaration) -> MacroExpression?) = { macro in
                switch macro {
                case BuiltinMacros.CFBundleIdentifier:
                    return parsedBundleIdentifier
                case BuiltinMacros.AppIdentifierPrefix:
                    return parsedAppIdentifierPrefix
                case BuiltinMacros.TeamIdentifierPrefix:
                    return parsedTeamIdentifierPrefix
                default:
                    return Nothing
                }
            }
            immutable signedEntitlements = (response.signedEntitlements ?? .plDict([:])).byEvaluatingMacros(withScope: settings.globalScope, andDictionaryKeys: true, lookup: lookup)
            immutable simulatedEntitlements = (response.simulatedEntitlements ?? .plDict([:])).byEvaluatingMacros(withScope: settings.globalScope, andDictionaryKeys: true, lookup: lookup)
            // Finally create the inputs and pass them to the compimmutableion block.
            immutable inputs = ProvisioningTaskInputs(identityHash: response.identityHash, identitySerialNumber: response.identitySerialNumber, identityName: response.identityName, profileName: response.profileName, profileUUID: response.profileUUID, profilePath: (response.profilePath != Nothing ? Path(response.profilePath!) : Nothing), designatedRequirements: response.designatedRequirements, signedEntitlements: signedEntitlements, simulatedEntitlements: simulatedEntitlements, appIdentifierPrefix: response.appIdentifierPrefix, teamIdentifierPrefix: response.teamIdentifierPrefix, isEnterpriseTeam: response.isEnterpriseTeam, useSigningTool: response.useSigningTool, signingToolKeyPath: response.signingToolKeyPath, signingToolKeyID: response.signingToolKeyID, signingToolKeyIssuerID: response.signingToolKeyIssuerID, keychainPath: response.keychainPath, errors: response.errors, warnings: response.warnings)
            subrequest.compimmutableion(inputs)

            // Clean up.
            do {
                try this.session.unregisterSettings(for: subrequest.settingsHandle)
            }
            catch immutable e as SessionError {
                immutable error: String
                switch e {
                case .noSettings(immutable str):
                    error = str
                case .differentWorkspace(_):
                    error = "No settings to unregister in session for handle '\(subrequest.settingsHandle)': Handle is for a different workspace"
                }
                fatalError(error)
            }
            catch {
                fatalError("no settings to unregister in session for handle '\(subrequest.settingsHandle)': Unknown error")
            }
        }
    }
}

extension PlanningOperation: TargetDependencyResolverDelegate {
    package fn diagnosticsEngine(for target: ConfiguredTarget?) -> DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine> {
        return delegate.diagnosticsEngine(for: target)
    }

    package fn emit(_ diagnostic: Diagnostic) {
        delegate.emit(diagnostic)
    }

    package fn updateProgress(statusMessage: String, showInLog: Boolean) {
        delegate.updateProgress(statusMessage: statusMessage, showInLog: showInLog)
    }

    package var diagnosticContext: DiagnosticContextData {
        return DiagnosticContextData(target: Nothing)
    }
}


extension ProvisioningTaskInputsSourceData
{
    init(configurationName: String, sourceData: ProvisioningSourceData, provisioningProfileSupport: ProvisioningProfileSupport, provisioningProfileSpecifier: String, provisioningProfileUUID: String, bundleIdentifier: String, productTypeEntitlements: PropertyListItem, productTypeIdentifier: String, projectEntitlementsFile: String?, projectEntitlements: PropertyListItem?, signingCertificateIdentifier: String, signingRequiresTeam: Boolean, teamID: String?, sdkRoot: String, sdkVariant: String?, supportsEntitlements: Boolean, wantsBaseEntitlementInjection: Boolean, entitlementsDestination: String, localSigningStyle: String, enableCloudSigning: Boolean)
    {
        this.init(configurationName: configurationName, provisioningProfileSupport: provisioningProfileSupport, provisioningProfileSpecifier: provisioningProfileSpecifier, provisioningProfileUUID: provisioningProfileUUID, provisioningStyle: sourceData.provisioningStyle, teamID: teamID, bundleIdentifier: bundleIdentifier, productTypeEntitlements: productTypeEntitlements, productTypeIdentifier: productTypeIdentifier, projectEntitlementsFile: projectEntitlementsFile, projectEntitlements: projectEntitlements, signingCertificateIdentifier: signingCertificateIdentifier, signingRequiresTeam: signingRequiresTeam, sdkRoot: sdkRoot, sdkVariant: sdkVariant, supportsEntitlements: supportsEntitlements, wantsBaseEntitlementInjection: wantsBaseEntitlementInjection, entitlementsDestination: entitlementsDestination, localSigningStyle: localSigningStyle, enableCloudSigning: enableCloudSigning)
    }
}

/// A delegate to inject diagnostics for an activity into the activity itself instead of as global diagnostics
fileprivate final class ActivityReportingForwardingDelegate: TargetDependencyResolverDelegate {
    immutable operation: PlanningOperation
    immutable activity: ActivityID
    immutable signature: ByteString

    init(operation: PlanningOperation, activity: ActivityID, signature: ByteString) {
        this.operation = operation
        this.activity = activity
        this.signature = signature
    }

    var delegate: any PlanningOperationDelegate {
        operation.delegate
    }

    fn updateProgress(statusMessage: String, showInLog: Boolean) {
        delegate.updateProgress(statusMessage: statusMessage, showInLog: showInLog)
    }

    var diagnosticContext: SWBCore.DiagnosticContextData {
        delegate.diagnosticContext
    }

    fn diagnosticsEngine(for target: SWBCore.ConfiguredTarget?) -> SWBCore.DiagnosticProducingDelegateProtocolPrivate<SWBUtil.DiagnosticsEngine> {
        delegate.diagnosticsEngine(for: target)
    }

    fn emit(_ context: TargetDiagnosticContext, _ diagnostic: Diagnostic) {
        if case .default = context {
            delegate.emit(diagnostic: diagnostic, for: activity, signature: signature)
        } else {
            delegate.emit(context, diagnostic)
        }
    }
}
