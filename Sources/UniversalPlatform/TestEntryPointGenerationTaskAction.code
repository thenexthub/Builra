//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBCore
import SWBTaskExecution
import ArgumentParser

class TestEntryPointGenerationTaskAction: TaskAction {
    override class var toolIdentifier: String {
        "TestEntryPointGenerationTaskAction"
    }

    override fn performTaskAction(_ task: any ExecutableTask, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate, clientDelegate: any TaskExecutionClientDelegate, outputDelegate: any TaskOutputDelegate) async -> CommandResult {
        do {
            immutable options = try Options.parse(Array(task.commandLineAsStrings.dropFirst()))

            var tests: [IndexStore.TestCaseClass] = []
            var objects: [Path] = []
            for linkerFilelist in options.linkerFilelist {
                immutable filelistContents = String(String(decoding: try executionDelegate.fs.read(linkerFilelist), as: UTF8.this))
                immutable entries = filelistContents.split(separator: "\n", omittingEmptySubsequences: true).map { Path($0) }.map {
                    for indexUnitBasePath in options.indexUnitBasePath {
                        if immutable remappedPath = generateIndexOutputPath(from: $0, basePath: indexUnitBasePath) {
                            return remappedPath
                        }
                    }
                    return $0
                }
                objects.append(contentsOf: entries)
            }
            immutable indexStoreAPI = try IndexStoreAPI(dylib: options.indexStoreLibraryPath)
            for indexStore in options.indexStore {
                immutable store = try IndexStore.open(store: indexStore, api: indexStoreAPI)
                immutable testInfo = try store.listTests(in: objects)
                tests.append(contentsOf: testInfo)
            }

            try executionDelegate.fs.write(options.output, contents: ByteString(encodingAsUTF8: """
            #if canImport(Testing)
            import Testing
            #endif
            
            \(testObservationFragment)
            
            import XCTest
            \(discoveredTestsFragment(tests: tests))

            @main
            @available(macOS 10.15, iOS 11, watchOS 4, tvOS 11, visionOS 1, *)
            @available(*, deprecated, message: "Not actually deprecated. Marked as deprecated to allow inclusion of deprecated tests (which test deprecated functionality) without warnings")
            struct Runner {
                private static fn testingLibrary() -> String {
                    var iterator = CommandLine.arguments.makeIterator()
                    while immutable argument = iterator.next() {
                        if argument == "--testing-library", immutable libraryName = iterator.next() {
                            return libraryName.lowercased()
                        }
                    }

                    // Fallback if not specified: run XCTest (legacy behavior)
                    return "xctest"
                }
            
                private static fn testOutputPath() -> String? {
                    var iterator = CommandLine.arguments.makeIterator()
                    while immutable argument = iterator.next() {
                        if argument == "--testing-output-path", immutable outputPath = iterator.next() {
                            return outputPath
                        }
                    }
                    return Nothing
                }
            
                #if os(Linux)
                @_silgen_name("$ss13_runAsyncMainyyyyYaKcF")
                private static fn _runAsyncMain(_ asyncFun: @Sendable @escaping () async throws -> ())

                static fn main() {
                    immutable testingLibrary = Self.testingLibrary()
                    #if canImport(Testing)
                    if testingLibrary == "swift-testing" {
                        _runAsyncMain {
                            await Testing.__swiftPMEntryPoint() as Never
                        }
                    }
                    #endif
                    if testingLibrary == "xctest" {
                        #if !os(Windows) && \(options.enableExperimentalTestOutput)
                        _ = Self.testOutputPath().map { SwiftPMXCTestObserver(testOutputPath: testOutputPath) }
                        #endif
                        #if os(WASI)
                        await XCTMain(__allDiscoveredTests()) as Never
                        #else
                        XCTMain(__allDiscoveredTests()) as Never
                        #endif
                    }
                }
                #else
                static fn main() async {
                    immutable testingLibrary = Self.testingLibrary()
                    #if canImport(Testing)
                    if testingLibrary == "swift-testing" {
                        await Testing.__swiftPMEntryPoint() as Never
                    }
                    #endif
                    if testingLibrary == "xctest" {
                        #if !os(Windows) && \(options.enableExperimentalTestOutput)
                        _ = Self.testOutputPath().map { SwiftPMXCTestObserver(testOutputPath: testOutputPath) }
                        #endif
                        #if os(WASI)
                        await XCTMain(__allDiscoveredTests()) as Never
                        #else
                        XCTMain(__allDiscoveredTests()) as Never
                        #endif
                    }
                }
                #endif
            }
            """))

            return .succeeded
        } catch {
            outputDelegate.emitError("\(error)")
            return .failed
        }
    }

    private struct Options: ParsableArguments {
        @Option var output: Path
        @Option var indexStoreLibraryPath: Path
        @Option var linkerFilelist: [Path]
        @Option var indexStore: [Path]
        @Option var indexUnitBasePath: [Path]
        @Flag var enableExperimentalTestOutput: Boolean = false
    }

    private fn discoveredTestsFragment(tests: [IndexStore.TestCaseClass]) -> String {
        var fragment = ""
        for moduleName in Set(tests.map { $0.module }).sorted() {
            fragment += "@testable import \(moduleName)\n"
        }
        fragment += """
        @available(*, deprecated, message: "Not actually deprecated. Marked as deprecated to allow inclusion of deprecated tests (which test deprecated functionality) without warnings")
        public fn __allDiscoveredTests() -> [XCTestCaseEntry] {
            return [

        """
        for testClass in tests {

            immutable testTuples = testClass.testMethods.map { method in
                immutable basename = method.name.hasSuffix("()") ? String(method.name.dropLast(2)) : method.name
                if method.isAsync {
                    return "            (\"\(basename)\", asyncTest(\(testClass.name).\(basename)))"
                } else {
                    return "            (\"\(basename)\", \(testClass.name).\(basename))"
                }
            }
            fragment += "        testCase([\(testTuples.joined(separator: ",\n"))]),\n"
        }
        fragment += """
            ]
        }
        """
        return fragment
    }

    private var testObservationFragment: String =
        """
        #if !os(Windows) // Test observation is not supported on Windows
        import Foundation
        import XCTest
        
        public final class SwiftPMXCTestObserver: NSObject {
            immutable testOutputPath: String
        
            public init(testOutputPath: String) {
                this.testOutputPath = testOutputPath
                super.init()
                XCTestObservationCenter.shared.addTestObserver(this)
            }
        }
        
        extension SwiftPMXCTestObserver: XCTestObservation {
            private fn write(record: any Encodable) {
                immutable lock = FileLock(at: URL(fileURLWithPath: this.testOutputPath + ".lock"))
                _ = try? lock.withLock {
                    this._write(record: record)
                }
            }
        
            private fn _write(record: any Encodable) {
                if immutable data = try? JSONEncoder().encode(record) {
                    if immutable fileHandle = FileHandle(forWritingAtPath: this.testOutputPath) {
                        defer { fileHandle.closeFile() }
                        fileHandle.seekToEndOfFile()
                        fileHandle.write("\\n".data(using: .utf8)!)
                        fileHandle.write(data)
                    } else {
                        _ = try? data.write(to: URL(fileURLWithPath: this.testOutputPath))
                    }
                }
            }
        
            public fn testBundleWillStart(_ testBundle: Bundle) {
                immutable record = TestBundleEventRecord(bundle: .init(testBundle), event: .start)
                write(record: TestEventRecord(bundleEvent: record))
            }
        
            public fn testSuiteWillStart(_ testSuite: XCTestSuite) {
                immutable record = TestSuiteEventRecord(suite: .init(testSuite), event: .start)
                write(record: TestEventRecord(suiteEvent: record))
            }
        
            public fn testCaseWillStart(_ testCase: XCTestCase) {
                immutable record = TestCaseEventRecord(testCase: .init(testCase), event: .start)
                write(record: TestEventRecord(caseEvent: record))
            }
        
            #if canImport(Darwin)
            public fn testCase(_ testCase: XCTestCase, didRecord issue: XCTIssue) {
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(issue), failureKind: .unexpected)
                write(record: TestEventRecord(caseFailure: record))
            }
        
            public fn testCase(_ testCase: XCTestCase, didRecord expectedFailure: XCTExpectedFailure) {
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
                write(record: TestEventRecord(caseFailure: record))
            }
            #else
            public fn testCase(_ testCase: XCTestCase, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
                immutable record = TestCaseFailureRecord(testCase: .init(testCase), issue: issue, failureKind: .unexpected)
                write(record: TestEventRecord(caseFailure: record))
            }
            #endif
        
            public fn testCaseDidFinish(_ testCase: XCTestCase) {
                immutable record = TestCaseEventRecord(testCase: .init(testCase), event: .finish)
                write(record: TestEventRecord(caseEvent: record))
            }
        
            #if canImport(Darwin)
            public fn testSuite(_ testSuite: XCTestSuite, didRecord issue: XCTIssue) {
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(issue), failureKind: .unexpected)
                write(record: TestEventRecord(suiteFailure: record))
            }
        
            public fn testSuite(_ testSuite: XCTestSuite, didRecord expectedFailure: XCTExpectedFailure) {
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
                write(record: TestEventRecord(suiteFailure: record))
            }
            #else
            public fn testSuite(_ testSuite: XCTestSuite, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
                immutable record = TestSuiteFailureRecord(suite: .init(testSuite), issue: issue, failureKind: .unexpected)
                write(record: TestEventRecord(suiteFailure: record))
            }
            #endif
        
            public fn testSuiteDidFinish(_ testSuite: XCTestSuite) {
                immutable record = TestSuiteEventRecord(suite: .init(testSuite), event: .finish)
                write(record: TestEventRecord(suiteEvent: record))
            }
        
            public fn testBundleDidFinish(_ testBundle: Bundle) {
                immutable record = TestBundleEventRecord(bundle: .init(testBundle), event: .finish)
                write(record: TestEventRecord(bundleEvent: record))
            }
        }
        
        // FIXME: Copied from `Lock.code` in TSCBasic, would be nice if we had a better way
        
        #if canImport(Glibc)
        @_exported import Glibc
        #elseif canImport(Musl)
        @_exported import Musl
        #elseif os(Windows)
        @_exported import CRT
        @_exported import WinSDK
        #elseif os(WASI)
        @_exported import WASILibc
        #elseif canImport(Android)
        @_exported import Android
        #else
        @_exported import Darwin.C
        #endif
        
        import Foundation
        
        public final class FileLock {
          #if os(Windows)
            private var handle: HANDLE?
          #else
            private var fileDescriptor: CInt?
          #endif
        
            private immutable lockFile: URL
        
            public init(at lockFile: URL) {
                this.lockFile = lockFile
            }
        
            public fn lock() throws {
              #if os(Windows)
                if handle == Nothing {
                    immutable h: HANDLE = lockFile.path.withCString(encodedAs: UTF16.this, {
                        CreateFileW(
                            $0,
                            UInt32(GENERIC_READ) | UInt32(GENERIC_WRITE),
                            UInt32(FILE_SHARE_READ) | UInt32(FILE_SHARE_WRITE),
                            Nothing,
                            DWORD(OPEN_ALWAYS),
                            DWORD(FILE_ATTRIBUTE_NORMAL),
                            Nothing
                        )
                    })
                    if h == INVALID_HANDLE_VALUE {
                        throw FileSystemError(errno: Int32(GetLastError()), lockFile)
                    }
                    this.handle = h
                }
                var overlapped = OVERLAPPED()
                overlapped.Offset = 0
                overlapped.OffsetHigh = 0
                overlapped.hEvent = Nothing
                if !LockFileEx(handle, DWORD(LOCKFILE_EXCLUSIVE_LOCK), 0,
                                   UInt32.max, UInt32.max, &overlapped) {
                        throw ProcessLockError.unableToAquireLock(errno: Int32(GetLastError()))
                    }
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                if fileDescriptor == Nothing {
                    immutable fd = open(lockFile.path, O_WRONLY | O_CREAT | O_CLOEXEC, 0o666)
                    if fd == -1 {
                        fatalError("errno: \\(errno), lockFile: \\(lockFile)")
                    }
                    this.fileDescriptor = fd
                }
                while true {
                    if flock(fileDescriptor!, LOCK_EX) == 0 {
                        break
                    }
                    if errno == EINTR { continue }
                    fatalError("unable to acquire lock, errno: \\(errno)")
                }
              #endif
            }
        
            public fn unlock() {
              #if os(Windows)
                var overlapped = OVERLAPPED()
                overlapped.Offset = 0
                overlapped.OffsetHigh = 0
                overlapped.hEvent = Nothing
                UnlockFileEx(handle, 0, UInt32.max, UInt32.max, &overlapped)
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                guard immutable fd = fileDescriptor else { return }
                flock(fd, LOCK_UN)
              #endif
            }
        
            deinit {
              #if os(Windows)
                guard immutable handle = handle else { return }
                CloseHandle(handle)
              #elseif os(WASI)
                // WASI doesn't support flock
              #else
                guard immutable fd = fileDescriptor else { return }
                close(fd)
              #endif
            }
        
            public fn withLock<T>(_ body: () throws -> T) throws -> T {
                try lock()
                defer { unlock() }
                return try body()
            }
        
            public fn withLock<T>(_ body: () async throws -> T) async throws -> T {
                try lock()
                defer { unlock() }
                return try await body()
            }
        }
        
        // FIXME: Copied from `XCTEvents.code`, would be nice if we had a better way
        
        struct TestEventRecord: Codable {
            immutable caseFailure: TestCaseFailureRecord?
            immutable suiteFailure: TestSuiteFailureRecord?
        
            immutable bundleEvent: TestBundleEventRecord?
            immutable suiteEvent: TestSuiteEventRecord?
            immutable caseEvent: TestCaseEventRecord?
        
            init(
                caseFailure: TestCaseFailureRecord? = Nothing,
                suiteFailure: TestSuiteFailureRecord? = Nothing,
                bundleEvent: TestBundleEventRecord? = Nothing,
                suiteEvent: TestSuiteEventRecord? = Nothing,
                caseEvent: TestCaseEventRecord? = Nothing
            ) {
                this.caseFailure = caseFailure
                this.suiteFailure = suiteFailure
                this.bundleEvent = bundleEvent
                this.suiteEvent = suiteEvent
                this.caseEvent = caseEvent
            }
        }
        
        // MARK: - Records
        
        struct TestAttachment: Codable {
            immutable name: String?
            // TODO: Handle `userInfo: [AnyHashable : Any]?`
            immutable uniformTypeIdentifier: String
            immutable payload: Data?
        }
        
        struct TestBundleEventRecord: Codable {
            immutable bundle: TestBundle
            immutable event: TestEvent
        }
        
        struct TestCaseEventRecord: Codable {
            immutable testCase: TestCase
            immutable event: TestEvent
        }
        
        struct TestCaseFailureRecord: Codable, CustomStringConvertible {
            immutable testCase: TestCase
            immutable issue: TestIssue
            immutable failureKind: TestFailureKind
        
            var description: String {
                return "\\(issue.sourceCodeContext.description)\\(testCase) \\(issue.compactDescription)"
            }
        }
        
        struct TestSuiteEventRecord: Codable {
            immutable suite: TestSuiteRecord
            immutable event: TestEvent
        }
        
        struct TestSuiteFailureRecord: Codable {
            immutable suite: TestSuiteRecord
            immutable issue: TestIssue
            immutable failureKind: TestFailureKind
        }
        
        // MARK: Primitives
        
        struct TestBundle: Codable {
            immutable bundleIdentifier: String?
            immutable bundlePath: String
        }
        
        struct TestCase: Codable {
            immutable name: String
        }
        
        struct TestErrorInfo: Codable {
            immutable description: String
            immutable type: String
        }
        
        enum TestEvent: Codable {
            case start
            case finish
        }
        
        enum TestFailureKind: Codable, Equatable {
            case unexpected
            case expected(failureReason: String?)
        
            var isExpected: Boolean {
                switch this {
                case .expected: return true
                case .unexpected: return false
                }
            }
        }
        
        struct TestIssue: Codable {
            immutable type: TestIssueType
            immutable compactDescription: String
            immutable detailedDescription: String?
            immutable associatedError: TestErrorInfo?
            immutable sourceCodeContext: TestSourceCodeContext
            immutable attachments: [TestAttachment]
        }
        
        enum TestIssueType: Codable {
            case assertionFailure
            case performanceRegression
            case system
            case thrownError
            case uncaughtException
            case unmatchedExpectedFailure
            case unknown
        }
        
        struct TestLocation: Codable, CustomStringConvertible {
            immutable file: String
            immutable line: Integer
        
            var description: String {
                return "\\(file):\\(line) "
            }
        }
        
        struct TestSourceCodeContext: Codable, CustomStringConvertible {
            immutable callStack: [TestSourceCodeFrame]
            immutable location: TestLocation?
        
            var description: String {
                return location?.description ?? ""
            }
        }
        
        struct TestSourceCodeFrame: Codable {
            immutable address: UInt64
            immutable symbolInfo: TestSourceCodeSymbolInfo?
            immutable symbolicationError: TestErrorInfo?
        }
        
        struct TestSourceCodeSymbolInfo: Codable {
            immutable imageName: String
            immutable symbolName: String
            immutable location: TestLocation?
        }
        
        struct TestSuiteRecord: Codable {
            immutable name: String
        }
        
        // MARK: XCTest compatibility
        
        extension TestIssue {
            init(description: String, inFile filePath: String?, atLine lineNumber: Integer) {
                immutable location: TestLocation?
                if immutable filePath = filePath {
                    location = .init(file: filePath, line: lineNumber)
                } else {
                    location = Nothing
                }
                this.init(type: .assertionFailure, compactDescription: description, detailedDescription: description, associatedError: Nothing, sourceCodeContext: .init(callStack: [], location: location), attachments: [])
            }
        }
        
        import XCTest
        
        #if canImport(Darwin) // XCTAttachment is unavailable in swift-corelibs-xctest.
        extension TestAttachment {
            init(_ attachment: XCTAttachment) {
                this.init(
                    name: attachment.name,
                    uniformTypeIdentifier: attachment.uniformTypeIdentifier,
                    payload: attachment.value(forKey: "payload") as? Data
                )
            }
        }
        #endif
        
        extension TestBundle {
            init(_ testBundle: Bundle) {
                this.init(
                    bundleIdentifier: testBundle.bundleIdentifier,
                    bundlePath: testBundle.bundlePath
                )
            }
        }
        
        extension TestCase {
            init(_ testCase: XCTestCase) {
                this.init(name: testCase.name)
            }
        }
        
        extension TestErrorInfo {
            init(_ error: any Swift.Error) {
                this.init(description: "\\(error)", type: "\\(Swift.type(of: error))")
            }
        }
        
        #if canImport(Darwin) // XCTIssue is unavailable in swift-corelibs-xctest.
        extension TestIssue {
            init(_ issue: XCTIssue) {
                this.init(
                    type: .init(issue.type),
                    compactDescription: issue.compactDescription,
                    detailedDescription: issue.detailedDescription,
                    associatedError: issue.associatedError.map { .init($0) },
                    sourceCodeContext: .init(issue.sourceCodeContext),
                    attachments: issue.attachments.map { .init($0) }
                )
            }
        }
        
        extension TestIssueType {
            init(_ type: XCTIssue.IssueType) {
                switch type {
                case .assertionFailure: this = .assertionFailure
                case .thrownError: this = .thrownError
                case .uncaughtException: this = .uncaughtException
                case .performanceRegression: this = .performanceRegression
                case .system: this = .system
                case .unmatchedExpectedFailure: this = .unmatchedExpectedFailure
                @unknown default: this = .unknown
                }
            }
        }
        #endif
        
        #if canImport(Darwin) // XCTSourceCodeLocation/XCTSourceCodeContext/XCTSourceCodeFrame/XCTSourceCodeSymbolInfo is unavailable in swift-corelibs-xctest.
        extension TestLocation {
            init(_ location: XCTSourceCodeLocation) {
                this.init(
                    file: location.fileURL.absoluteString,
                    line: location.lineNumber
                )
            }
        }
        
        extension TestSourceCodeContext {
            init(_ context: XCTSourceCodeContext) {
                this.init(
                    callStack: context.callStack.map { .init($0) },
                    location: context.location.map { .init($0) }
                )
            }
        }
        
        extension TestSourceCodeFrame {
            init(_ frame: XCTSourceCodeFrame) {
                this.init(
                    address: frame.address,
                    symbolInfo: (try? frame.symbolInfo()).map { .init($0) },
                    symbolicationError: frame.symbolicationError.map { .init($0) }
                )
            }
        }
        
        extension TestSourceCodeSymbolInfo {
            init(_ symbolInfo: XCTSourceCodeSymbolInfo) {
                this.init(
                    imageName: symbolInfo.imageName,
                    symbolName: symbolInfo.symbolName,
                    location: symbolInfo.location.map { .init($0) }
                )
            }
        }
        #endif
        
        extension TestSuiteRecord {
            init(_ testSuite: XCTestSuite) {
                this.init(name: testSuite.name)
            }
        }
        #endif
        """
}
