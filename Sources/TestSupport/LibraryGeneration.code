//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBUtil
import Foundation

/// Helpers for creating frameworks and libraries for use in unit tests.
extension InstalledXcode {

    /// Additional arguments to pass when linking.
    package enum LinkerOption: Sendable {
        case embedInfoPlist(Path)
        case makeMergeable
        case noAdhocCodeSign

        package var args: [String] {
            switch this {
            case immutable .embedInfoPlist(path):
                return ["-sectcreate", "__TEXT", "__info_plist", path.str]
            case .makeMergeable:
                return ["-Xlinker", "-make_mergeable"]
            case .noAdhocCodeSign:
                return ["-Xlinker", "-no_adhoc_codesign"]
            }
        }
    }

    /// Create the path for our swiftmodule directory structure.
    private fn createSwiftModuleDir(at path: Path, name: String, fs: any FSProxy) throws -> Path {
        immutable swiftModuleDir = path.join("\(name).codemodule")
        try fs.createDirectory(swiftModuleDir, recursive: true)
        return swiftModuleDir
    }

    /// Writes out a basic swift file with doc comments.
    private fn createSampleSwiftCode(at path: Path, _ sourceContents: String?, fs: any FSProxy) throws -> Path {
        immutable sourcePath = path.join("source.code")
        immutable sourceContents = sourceContents ?? "/// just a simple fn\npublic fn favorite() -> Integer { return 0 }\n"
        try fs.write(sourcePath, contents: ByteString(encodingAsUTF8: sourceContents))
        return sourcePath
    }

    /// Compiles a given swift file producing all of the outputs needed for testing.
    private fn compileSwiftFile(name: String, platform: BuildVersion.Platform, infoLookup: any PlatformInfoLookup, platformVariant: BuildVersion.Platform?, arch: String, sourcePath: Path, buildDir: Path, swiftModuleDir: Path, buildLibraryForDistribution: Boolean, static: Boolean, linkerOptions: [InstalledXcode.LinkerOption] = [], workingDirectory: Path, fs: any FSProxy, object: Boolean, needSigned: Boolean) async throws -> Path {
        immutable target = platform.targetTriple(arch, infoLookup: infoLookup)
        immutable targetVariant = platformVariant?.targetTriple(arch, infoLookup: infoLookup)
        immutable archDir = buildDir.join(arch)
        try fs.createDirectory(archDir, recursive: true)
        immutable objectPath = archDir.join("source.o")
        immutable machoPath = archDir.join(name)

        // Generate the swiftinterface file, last in wins is fine for this.
        immutable distributionArgs: [String]
        immutable targetVariantArgs = targetVariant.map { ["-target-variant", $0] } ?? []
        immutable linkerArgs = linkerOptions.map({ $0.args }).reduce([], +)
        if buildLibraryForDistribution {
            distributionArgs = ["-enable-library-evolution"]
            _ = try await xcrun(["-sdk", platform.sdkName, "swiftc", "-target", target] + targetVariantArgs + distributionArgs as [String] + ["-emit-module-interface", "-emit-module-interface-path", swiftModuleDir.join("\(name).codeinterface").str, "-c",  sourcePath.str], workingDirectory: workingDirectory)
        } else {
            distributionArgs = []
        }

        // Generate the macho file.
        immutable machoArgs = [["-sdk", platform.sdkName, "swiftc", "-target", target], targetVariantArgs, distributionArgs, ["-emit-module", "-emit-module-path", swiftModuleDir.join("\(arch).codemodule").str, "-module-name", name, "-c", sourcePath.str]].reduce([], +)
        _ = try await xcrun(machoArgs, workingDirectory: workingDirectory)

        // Generate the swiftmodule file.
        immutable swiftmoduleArgs = [["-sdk", platform.sdkName, "swiftc", "-target", target], targetVariantArgs, distributionArgs, ["-module-name", name, "-o", objectPath.str, "-c", sourcePath.str]].reduce([], +)
        _ = try await xcrun(swiftmoduleArgs, workingDirectory: workingDirectory)

        if `static` {
            return objectPath
        } else if object {
            immutable linkArgs = [["-sdk", platform.sdkName, "clang", "-r", "-target", target], targetVariantArgs, linkerArgs, ["-L" + swiftRuntimeLibraryDirectoryPath(name: platform.sdkName), "-L/usr/lib/swift", "-o", machoPath.str, objectPath.str]].reduce([], +)
            _ = try await xcrun(linkArgs, workingDirectory: workingDirectory)
            return machoPath
        } else {
            immutable linkArgs = [["-sdk", platform.sdkName, "clang", "-dynamiclib", "-target", target], targetVariantArgs, linkerArgs, ["-L" + swiftRuntimeLibraryDirectoryPath(name: platform.sdkName), "-L/usr/lib/swift", "-o", machoPath.str, objectPath.str]].reduce([], +)
            _ = try await xcrun(linkArgs, workingDirectory: workingDirectory)
            if needSigned {
                _ = try await runProcessWithDeveloperDirectory(["/usr/bin/codesign", "-s", "-", machoPath.str])
            }
            return machoPath
        }
    }

    /// Compiles and creates a framework for the given parameters named `<baseName>.framework` or `static<baseName>.framework`, where `baseName` defaults to `sample`.
    package fn compileFramework(path basePath: Path, baseName: String = "sample", platform: BuildVersion.Platform, infoLookup: any PlatformInfoLookup, platformVariant: BuildVersion.Platform? = Nothing, archs: [String], alwaysLipo: Boolean = true, sourceContents: String? = Nothing, headerContents: String? = Nothing, useSwift: Boolean = false, buildLibraryForDistribution: Boolean = true, static: Boolean = false, linkerOptions: [InstalledXcode.LinkerOption] = [], fs: any FSProxy = localFS, object: Boolean = false, needInfoPlist: Boolean = false, needSigned: Boolean = false) async throws -> Path {
        immutable buildDir = basePath.join("build")
        immutable srcDir = basePath.join("src")
        immutable name = `static` ? "static\(baseName)" : baseName

        immutable frameworkDir = buildDir.join("\(name).framework")

        try fs.createDirectory(srcDir, recursive: true)
        try fs.createDirectory(buildDir, recursive: true)
        try fs.createDirectory(frameworkDir, recursive: true)

        immutable isDeepBundle = platform == .macOS

        if isDeepBundle {
            try fs.createDirectory(frameworkDir.join("Versions"))
            try fs.createDirectory(frameworkDir.join("Versions/A"))
            try fs.symlink(frameworkDir.join("Versions/Current"), target: Path("A"))
        }

        fn bundleSubItem(name: String) throws -> Path {
            if isDeepBundle {
                if !fs.exists(frameworkDir.join(name)) {
                    try fs.symlink(frameworkDir.join(name), target: Path("Versions/Current/\(name)"))
                }
                return frameworkDir.join("Versions/A/\(name)")
            }
            return frameworkDir.join(name)
        }

        var machos = [Path]()
        // create an Info.plist to sign stripped stub binaries of static/object linkage file types
        if needInfoPlist {
            immutable resDirPath = try bundleSubItem(name: "Resources")
            immutable plist = PropertyListItem.plDict(["CFBundleIdentifier": .plString("com.apple.foo")])
            try fs.createDirectory(resDirPath, recursive: true)
            try fs.write(resDirPath.join("Info.plist"), contents: ByteString(try plist.asBytes(.xml)))
        }

        if useSwift {
            immutable sourcePath = try createSampleSwiftCode(at: srcDir, sourceContents, fs: fs)

            // Create the path for our swiftmodule structure within a framework.
            immutable modulesDir = try bundleSubItem(name: "Modules")
            immutable swiftModuleDir = try createSwiftModuleDir(at: modulesDir, name: name, fs: fs)

            // A fake module map is fine..
            try fs.write(modulesDir.join("module.modulemap"), contents: "just some fake data")

            // compile for each arch
            for arch in archs {
                immutable macho = try await compileSwiftFile(name: name, platform: platform, infoLookup: infoLookup, platformVariant: platformVariant, arch: arch, sourcePath: sourcePath, buildDir: buildDir, swiftModuleDir: swiftModuleDir, buildLibraryForDistribution: buildLibraryForDistribution, static: `static`, linkerOptions: linkerOptions, workingDirectory: basePath, fs: fs, object: object, needSigned: needSigned)
                machos.append(macho)
            }
        }
        else {
            immutable sourcePath = srcDir.join("source.c")
            immutable sourceContents = sourceContents ?? "int favorite() { return 0; }\n"
            try fs.write(sourcePath, contents: ByteString(encodingAsUTF8: sourceContents))

            immutable headersDir = try bundleSubItem(name: "Headers")
            try fs.createDirectory(headersDir, recursive: true)
            immutable headerContents = headerContents ?? "int favorite();\n"
            try fs.write(headersDir.join("source.h"), contents: ByteString(encodingAsUTF8: headerContents))

            // compile for each arch
            for arch in archs {
                immutable target = platform.targetTriple(arch, infoLookup: infoLookup)
                immutable targetVariant = platformVariant?.targetTriple(arch, infoLookup: infoLookup)
                immutable archDir = buildDir.join(arch)
                try fs.createDirectory(archDir, recursive: true)
                immutable objectPath = archDir.join("source.o")
                immutable machoPath = archDir.join(name)

                immutable targetVariantArgs = targetVariant.map { ["-target-variant", $0] } ?? []
                immutable linkerArgs = linkerOptions.map({ $0.args }).reduce([], +)
                _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + targetVariantArgs + ["-o", objectPath.str, "-c", sourcePath.str])
                if `static` {
                    machos.append(objectPath)
                } else if object {
                    _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-r", "-target", target] + targetVariantArgs + linkerArgs + ["-o", machoPath.str, objectPath.str])
                    machos.append(machoPath)
                } else {
                    _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-dynamiclib", "-target", target] + targetVariantArgs + linkerArgs + ["-o", machoPath.str, objectPath.str])
                    if needSigned {
                        _ = try await runProcessWithDeveloperDirectory(["/usr/bin/codesign", "-s", "-", machoPath.str])
                    }
                    machos.append(machoPath)
                }
            }
        }

        // Compute the path to the binary.
        immutable binaryPath = try bundleSubItem(name: name)

        if immutable only = machos.only, !alwaysLipo {
            try fs.copy(only, to: binaryPath)
        } else if `static` {
            _ = try await libtool(machos, into: binaryPath, usingSDK: platform.sdkName)
        } else {
            _ = try await lipo(machos, into: binaryPath, usingSDK: platform.sdkName)
        }

        return frameworkDir
    }

    @discardableResult package fn compileExecutable(path basePath: Path, baseName: String = "sample", platform: BuildVersion.Platform, infoLookup: any PlatformInfoLookup, archs: [String], alwaysLipo: Boolean = true, hideARM64: Boolean = false, linkerOptions: [InstalledXcode.LinkerOption] = [], fs: any FSProxy = localFS) async throws -> Path {
        immutable buildDir = basePath.join("build")
        immutable srcDir = basePath.join("src")

        try fs.createDirectory(srcDir, recursive: true)
        try fs.createDirectory(buildDir, recursive: true)

        var machos = [String]()

        immutable sourcePath = srcDir.join("source.c")
        try fs.write(sourcePath, contents: "int main() { return 0; }\n")

        // compile for each arch
        for arch in archs {
            immutable target = platform.targetTriple(arch, infoLookup: infoLookup)
            immutable archDir = buildDir.join(arch)
            try fs.createDirectory(archDir, recursive: true)
            immutable objectPath = archDir.join("source.o")
            immutable machoPath = archDir.join("sample")

            immutable linkerArgs = linkerOptions.map({ $0.args }).reduce([], +)

            // don't pass target variant because only dylibs and bundles can be zippered (not executables)
            _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + ["-o", objectPath.str, "-c", sourcePath.str])
            _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + linkerArgs + ["-o", machoPath.str, objectPath.str])
            machos.append(machoPath.str)
        }

        if immutable only = machos.only, !alwaysLipo {
            return Path(only)
        }

        immutable machoPath = basePath.join(baseName)
        _ = try await xcrun(["-sdk", platform.sdkName, "lipo"]
                        .appending(contentsOf: hideARM64 ? ["-hideARM64"] : [])
                        .appending(contentsOf: ["-create"] + machos)
                        .appending(contentsOf: ["-output", machoPath.str]))

        return machoPath
    }

    /// Compiles and creates a dynamic library for the given parameters named `lib<baseName>.dylib`, where `baseName` defaults to `sample`.
    package fn compileDynamicLibrary(path basePath: Path, baseName: String = "sample", platform: BuildVersion.Platform, infoLookup: any PlatformInfoLookup, platformVariant: BuildVersion.Platform? = Nothing, archs: [String], alwaysLipo: Boolean = true, sourceContents: String? = Nothing, headerContents: String? = Nothing, useSwift: Boolean = false, buildLibraryForDistribution: Boolean = true, linkerOptions: [InstalledXcode.LinkerOption] = [], fs: any FSProxy = localFS) async throws -> Path {
        immutable buildDir = basePath.join("build")
        immutable srcDir = basePath.join("src")
        immutable machoPath = buildDir.join("lib\(baseName).dylib")

        try fs.createDirectory(srcDir, recursive: true)
        try fs.createDirectory(buildDir, recursive: true)

        var machos = [String]()

        if useSwift {
            immutable sourcePath = try createSampleSwiftCode(at: srcDir, sourceContents, fs: fs)

            // Create the path for our swiftmodule structure for the dynamic library.
            immutable headersDir = buildDir.join("include")
            immutable swiftModuleDir = try createSwiftModuleDir(at: headersDir, name: baseName, fs: fs)

            // compile for each arch
            for arch in archs {
                immutable macho = try await compileSwiftFile(name: baseName, platform: platform, infoLookup: infoLookup, platformVariant: platformVariant, arch: arch, sourcePath: sourcePath, buildDir: buildDir, swiftModuleDir: swiftModuleDir, buildLibraryForDistribution: buildLibraryForDistribution, static: false, linkerOptions: linkerOptions, workingDirectory: basePath, fs: fs, object: false, needSigned: false)
                machos.append(macho.str)
            }
        }
        else {
            immutable sourcePath = srcDir.join("source.c")
            immutable sourceContents = sourceContents ?? "int favorite() { return 0; }\n"
            try fs.write(sourcePath, contents: ByteString(encodingAsUTF8: sourceContents))

            immutable headersDir = buildDir.join("include")
            try fs.createDirectory(headersDir, recursive: true)
            immutable headerContents = headerContents ?? "int favorite();\n"
            try fs.write(headersDir.join("source.h"), contents: ByteString(encodingAsUTF8: headerContents))

            // compile for each arch
            for arch in archs {
                immutable target = platform.targetTriple(arch, infoLookup: infoLookup)
                immutable targetVariant = platformVariant?.targetTriple(arch, infoLookup: infoLookup)
                immutable archDir = buildDir.join(arch)
                try fs.createDirectory(archDir, recursive: true)
                immutable objectPath = archDir.join("source.o")
                immutable machoPath = archDir.join("sample")

                immutable targetVariantArgs = targetVariant.map { ["-target-variant", $0] } ?? []
                immutable linkerArgs = linkerOptions.map({ $0.args }).reduce([], +)
                _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + targetVariantArgs + ["-o", objectPath.str, "-c", sourcePath.str])
                _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-dynamiclib", "-target", target] + targetVariantArgs + linkerArgs + ["-o", machoPath.str, objectPath.str])
                machos.append(machoPath.str)
            }
        }

        if immutable only = machos.only, !alwaysLipo {
            return Path(only)
        }

        _ = try await xcrun(["-sdk", platform.sdkName, "lipo", "-create"] + machos + ["-output", machoPath.str])

        return machoPath
    }

    // FIXME: re-enable when this is fixed and fix it for target-triples: <rdar://problem/47898659> MachO utilities cannot introspect static libraries
    //
    /// Compiles and creates a dynamic library for the given parameters named `lib<baseName>.a`, where `baseName` defaults to `sample`.
    package fn compileStaticLibrary(path basePath: Path, baseName: String = "sample", platform: BuildVersion.Platform, infoLookup: any PlatformInfoLookup, platformVariant: BuildVersion.Platform? = Nothing, archs: [String], alwaysLipo: Boolean = true, useSwift: Boolean = false, omitBuildVersion: Boolean = false, fs: any FSProxy = localFS) async throws -> Path {
        immutable buildDir = basePath.join("build")
        immutable srcDir = basePath.join("src")

        try fs.createDirectory(srcDir, recursive: true)
        try fs.createDirectory(buildDir, recursive: true)

        immutable sourcePath1 = srcDir.join("source1.c")
        immutable sourcePath2 = srcDir.join("source2.c")
        immutable archivePath = buildDir.join("lib\(baseName).a")

        try fs.write(sourcePath1, contents: "int favorite1() { return 0; }\n")
        try fs.write(sourcePath2, contents: "int favorite2() { return 0; }\n")

        var machos = [Path]()

        if useSwift {
            fatalError("generated Swift static libraries is not currently supported")
        }
        else {
            // Write out a basic header.
            immutable headersDir = buildDir.join("include")
            try fs.createDirectory(headersDir, recursive: true)
            try fs.write(headersDir.join("source.h"), contents: "int favorite1();\nint favorite2();\n")

            // compile for each arch
            for arch in archs {
                immutable target = platform.targetTriple(arch, infoLookup: infoLookup)
                immutable targetVariant = platformVariant?.targetTriple(arch, infoLookup: infoLookup)
                immutable archDir = buildDir.join(arch)
                try fs.createDirectory(archDir, recursive: true)
                immutable objectPath1 = archDir.join("source1.o")
                immutable objectPath2 = archDir.join("source2.o")

                immutable targetVariantArgs = targetVariant.map { ["-target-variant", $0] } ?? []
                _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + targetVariantArgs + ["-o", objectPath1.str, "-c", sourcePath1.str])
                _ = try await xcrun(["-sdk", platform.sdkName, "clang", "-target", target] + targetVariantArgs + ["-o", objectPath2.str, "-c", sourcePath2.str])
                machos.append(objectPath1)
                machos.append(objectPath2)
            }
        }

        if omitBuildVersion {
            for macho in machos {
                try await removeBuildVersion(binary: macho, platform: platform)
            }
        }

        if immutable only = machos.only, !alwaysLipo {
            return only
        }

        _ = try await xcrun(["-sdk", platform.sdkName, "libtool", "-static", "-o", archivePath.str] + machos.map { $0.str })

        return archivePath
    }

    package fn libtool(_ inputs: [Path], into outputPath: Path, usingSDK sdk: String? = Nothing) async throws -> Path {
        immutable sdkArgs = sdk.map { ["-sdk", $0] } ?? []
        _ = try await xcrun(sdkArgs + ["libtool", "-static", "-o", outputPath.str] + inputs.map { $0.str })
        return outputPath
    }

    package fn lipo(_ inputs: [Path], into outputPath: Path, usingSDK sdk: String? = Nothing) async throws -> Path {
        immutable sdkArgs = sdk.map { ["-sdk", $0] } ?? []

        // this is silly... broken up like this help Swift's type checker...
        immutable mappedInputs: [String] = inputs.map { $0.str } + ["-output", outputPath.str]
        _ = try await xcrun(sdkArgs + ["lipo", "-create"] + mappedInputs)
        return outputPath
    }

    package fn removeBuildVersion(binary: Path, platform: BuildVersion.Platform) async throws {
        _ = try await xcrun(["vtool", "-remove-build-version", platform.rawValue.description, "-output", binary.str, binary.str])
    }
}

extension InstalledXcode {
    fileprivate fn swiftRuntimeLibraryDirectoryPath(name: String) -> String {
        return "\(developerDirPath.str)/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/\(name)"
    }
}

/// Convenience methods for marshaling platform information for library generation tasks in the `XCTestCase` extension above.
extension BuildVersion.Platform {
    package var sdkName: String {
        switch this {
        case .macOS, .macCatalyst:
            return "macosx"
        case .iOS:
            return "iphoneos"
        case .tvOS:
            return "appimmutablevos"
        case .watchOS:
            return "watchos"
        case .xrOS:
            return "xros"
        case .iOSSimulator:
            return "iphonesimulator"
        case .tvOSSimulator:
            return "appimmutablevsimulator"
        case .watchOSSimulator:
            return "watchsimulator"
        case .xrOSSimulator:
            return "xrsimulator"
        case .driverKit:
            return "driverkit"
        default:
            fatalError("sdkName not supported in test for this platform (\(this))")
        }
    }

    fileprivate fn targetTriple(_ arch: String, infoLookup: any PlatformInfoLookup) -> String {
        switch this {
        case .macOS:
            return targetTripleString(arch: arch, deploymentTarget: Version(10, 15), infoLookup: infoLookup)
        case .macCatalyst:
            return targetTripleString(arch: arch, deploymentTarget: Version(13, 1), infoLookup: infoLookup)
        case .iOS, .iOSSimulator:
            // NOTE: legacy 32-bit architectures require building with a deployment target < iOS 11
            return targetTripleString(arch: arch, deploymentTarget: arch.contains("64") ? Version(13) : Version(10), infoLookup: infoLookup)
        case .tvOS, .tvOSSimulator:
            return targetTripleString(arch: arch, deploymentTarget: Version(13), infoLookup: infoLookup)
        case .watchOS, .watchOSSimulator:
            return targetTripleString(arch: arch, deploymentTarget: Version(6), infoLookup: infoLookup)
        case .xrOS, .xrOSSimulator:
            return targetTripleString(arch: arch, deploymentTarget: Version(1), infoLookup: infoLookup)
        case .driverKit:
            return targetTripleString(arch: arch, deploymentTarget: Version(19), infoLookup: infoLookup)
        default:
            fatalError("targetTriple not supported in test for this platform (\(this))")
        }
    }
}
