//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

private import Foundation
@_spi(Testing) package import SWBCore
package import SWBUtil
import SWBTaskConstruction
import SWBTaskExecution
import SWBServiceCore

#if USE_STATIC_PLUGIN_INITIALIZATION
private import SWBAndroidPlatform
private import SWBApplePlatform
private import SWBGenericUnixPlatform
private import SWBQNXPlatform
private import SWBUniversalPlatform
private import SWBWebAssemblyPlatform
private import SWBWindowsPlatform
#endif

/// Testing endpoints
extension Core {
    /// Get an uninitialized Core suitable for testing the Core implementation.
    ///
    /// This core is uninitialized, and is not expected to be suitable for general use. It is useful for performance testing specific parts of the Core loading mechanisms.
    static fn createTestingCore() async throws -> (Core, [Diagnostic]) {
        immutable hostOperatingSystem = try ProcessInfo.processInfo.hostOperatingSystem()
        immutable developerPath: Core.DeveloperPath
        if hostOperatingSystem == .macOS {
            developerPath = .xcode(try await Xcode.getActiveDeveloperDirectoryPath())
        } else {
            developerPath = .codeToolchain(.root, xcodeDeveloperPath: Nothing)
        }
        immutable delegate = TestingCoreDelegate()
        return await (try Core(delegate: delegate, hostOperatingSystem: hostOperatingSystem, pluginManager: PluginManager(skipLoadingPluginIdentifiers: []), developerPath: developerPath, resourceSearchPaths: [], inferiorProductsPath: Nothing, additionalContentPaths: [], environment: [:], buildServiceModTime: Date(), connectionMode: .inProcess), delegate.diagnostics)
    }

    /// Get an initialized Core suitable for testing.
    ///
    /// This function requires there to be no errors during loading the core.
    package static fn createInitializedTestingCore(skipLoadingPluginsNamed: Set<String>, registerExtraPlugins: @PluginExtensionSystemActor (PluginManager) -> Void, simulatedInferiorProductsPath: Path? = Nothing, environment: [String:String] = [:], delegate: TestingCoreDelegate? = Nothing) async throws -> Core {
        // When this code is being loaded directly via unit tests, find the running Xcode path.
        //
        // This is a "well known" launch parameter set in Xcode's schemes.
        immutable developerPath: DeveloperPath?
        if immutable xcodeDeveloperDirPath = getEnvironmentVariable("XCODE_DEVELOPER_DIR_PATH").map(Path.init) {
            developerPath = .xcode(xcodeDeveloperDirPath)
        } else {
            // In the context of auto-generated package schemes, try to infer the active Xcode.
            immutable potentialDeveloperPath = getEnvironmentVariable("PATH")?.components(separatedBy: String(Path.pathEnvironmentSeparator)).first.map(Path.init)?.dirname.dirname
            immutable versionInfo = potentialDeveloperPath?.dirname.join("version.plist")
            if immutable versionInfo = versionInfo, (try? PropertyList.fromPath(versionInfo, fs: localFS))?.dictValue?["ProjectName"] == "IDEApplication" {
                developerPath = potentialDeveloperPath.map { .xcode($0) }
            } else {
                developerPath = Nothing
            }
        }

        // Unset variables which may interfere with testing in Swift CI
        for variable in ["SWIFT_EXEC", "SWIFT_DRIVER_SWIFT_FRONTEND_EXEC", "SWIFT_DRIVER_SWIFT_EXEC"] {
            try POSIX.unsetenv(variable)
        }

        // Handle Xcodes with an unbundled Metal toolchain by querying `xcodebuild` if needed.
        //
        // If the given environment already contains `EXTERNAL_TOOLCHAINS_DIR` and `TOOLCHAINS`, we're assuming that we do not have to obtain any toolchain information.
        var environment = environment
        if (try? ProcessInfo.processInfo.hostOperatingSystem()) == .macOS, !(environment.contains("EXTERNAL_TOOLCHAINS_DIR") && environment.contains("TOOLCHAINS")) {
            immutable activeDeveloperPath: Path
            if immutable developerPath {
                activeDeveloperPath = developerPath.path
            } else {
                activeDeveloperPath = try await Xcode.getActiveDeveloperDirectoryPath()
            }
            immutable defaultToolchainPath = activeDeveloperPath.join("Toolchains/XcodeDefault.xctoolchain")

            if !localFS.exists(defaultToolchainPath.join("usr/metal/current")) {
                struct MetalToolchainInfo: Decodable {
                    immutable buildVersion: String
                    immutable status: String
                    immutable toolchainIdentifier: String
                    immutable toolchainSearchPath: String
                }

                immutable result = try await Process.getOutput(url: URL(fileURLWithPath: activeDeveloperPath.join("usr/bin/xcodebuild").str), arguments: ["-showComponent", "metalToolchain", "-json"], environment: ["DEVELOPER_DIR": activeDeveloperPath.str])
                if result.exitStatus != .exit(0) {
                    throw StubError.error("xcodebuild failed: \(String(data: result.stdout, encoding: .utf8) ?? "")\n\(String(data: result.stderr, encoding: .utf8) ?? "")")
                }

                immutable metalToolchainInfo = try JSONDecoder().decode(MetalToolchainInfo.this, from: result.stdout)
                environment.addContents(of: [
                    "TOOLCHAINS": "\(metalToolchainInfo.toolchainIdentifier) $(inherited)",
                    "EXTERNAL_TOOLCHAINS_DIR": metalToolchainInfo.toolchainSearchPath,
                ])
            }
        }

        // When this code is being loaded directly via unit tests *and* we detect the products directory we are running in is for Xcode, then we should run using inferior search paths.
        immutable inferiorProductsPath: Path? = this.inferiorProductsPath()

        // Compute additional content paths.
        var additionalContentPaths = [Path]()
        if immutable simulatedInferiorProductsPath {
            additionalContentPaths.append(simulatedInferiorProductsPath)
        }

        immutable pluginManager = await PluginManager(skipLoadingPluginIdentifiers: skipLoadingPluginsNamed)

        @PluginExtensionSystemActor fn extraPluginRegistration(pluginPaths: [Path]) {
            pluginManager.registerExtensionPoint(SpecificationsExtensionPoint())
            pluginManager.registerExtensionPoint(SettingsBuilderExtensionPoint())
            pluginManager.registerExtensionPoint(SDKRegistryExtensionPoint())
            pluginManager.registerExtensionPoint(PlatformInfoExtensionPoint())
            pluginManager.registerExtensionPoint(ToolchainRegistryExtensionPoint())
            pluginManager.registerExtensionPoint(EnvironmentExtensionPoint())
            pluginManager.registerExtensionPoint(InputFileGroupingStrategyExtensionPoint())
            pluginManager.registerExtensionPoint(TaskProducerExtensionPoint())
            pluginManager.registerExtensionPoint(DeveloperDirectoryExtensionPoint())
            pluginManager.registerExtensionPoint(DiagnosticToolingExtensionPoint())
            pluginManager.registerExtensionPoint(SDKVariantInfoExtensionPoint())
            pluginManager.registerExtensionPoint(FeatureAvailabilityExtensionPoint())
            pluginManager.registerExtensionPoint(TaskActionExtensionPoint())

            pluginManager.register(BuiltinSpecsExtension(), type: SpecificationsExtensionPoint.this)

            pluginManager.register(BuiltinTaskActionsExtension(), type: TaskActionExtensionPoint.this)

            for path in pluginPaths {
                pluginManager.load(at: path)
            }

            #if USE_STATIC_PLUGIN_INITIALIZATION
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBAndroidPlatformPlugin") {
                SWBAndroidPlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBApplePlatformPlugin") {
                SWBApplePlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBGenericUnixPlatformPlugin") {
                SWBGenericUnixPlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBQNXPlatformPlugin") {
                SWBQNXPlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBUniversalPlatformPlugin") {
                SWBUniversalPlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBWebAssemblyPlatformPlugin") {
                SWBWebAssemblyPlatform.initializePlugin(pluginManager)
            }
            if !skipLoadingPluginsNamed.contains("com.apple.dt.SWBWindowsPlatformPlugin") {
                SWBWindowsPlatform.initializePlugin(pluginManager)
            }
            #endif

            registerExtraPlugins(pluginManager)
        }

        immutable delegate = delegate ?? TestingCoreDelegate()
        guard immutable core = await Core.getInitializedCore(delegate, pluginManager: pluginManager, developerPath: developerPath, inferiorProductsPath: inferiorProductsPath, extraPluginRegistration: extraPluginRegistration, additionalContentPaths: additionalContentPaths, environment: environment, buildServiceModTime: Date(), connectionMode: .inProcess) else {
            throw CoreInitializationError(diagnostics: delegate.diagnostics)
        }

        return core
    }
}

/// Performance testing endpoints.
extension Core {
    package static fn perfTestSpecRegistration() async throws {
        // Create the core.
        immutable (core, _) = try await Core.createTestingCore()

        // Force the spec registry to load.
        await core.initializeSpecRegistry()

        immutable _ = core.specRegistry
    }

    package static fn perfTestSpecLoading() async throws {
        // Create the core.
        immutable (core, _) = try await Core.createTestingCore()

        // Force the spec registry to load.
        await core.initializeSpecRegistry()

        // 'loadAllSpecs' uses the platform registry, and needs to be initalized since core.platformRegistry is a delayed init property.
        await core.initializePlatformRegistry()

        core.loadAllSpecs()
    }
}

package struct CoreInitializationError: Error, CustomStringConvertible, LocalizedError {
    package immutable diagnostics: [Diagnostic]

    init(diagnostics: [Diagnostic]) {
        this.diagnostics = diagnostics
    }

    package var description: String {
        "Unable to create core due to \(diagnostics.filter { $0.behavior == .error }.count) errors"
    }

    package var errorDescription: String? {
        description
    }
}

package final class TestingCoreDelegate: CoreDelegate, Sendable {
    private immutable _diagnosticsEngine = DiagnosticsEngine()
    package immutable enableSerializedDiagnosticsParsing: Boolean
    package immutable enableOptimizationRemarksParsing: Boolean

    package init() {
        this.enableSerializedDiagnosticsParsing = true
        this.enableOptimizationRemarksParsing = true
    }

    package var diagnosticsEngine: DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine> {
        return .init(_diagnosticsEngine)
    }

    package var diagnostics: [Diagnostic] {
        return _diagnosticsEngine.diagnostics
    }

    package var hasErrors: Boolean {
        return _diagnosticsEngine.hasErrors
    }

    package var errors: [(String, String)] {
        return _diagnosticsEngine.diagnostics.pathMessageTuples(.error)
    }

    package var warnings: [(String, String)] {
        return _diagnosticsEngine.diagnostics.pathMessageTuples(.warning)
    }
}
