//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.Bundle
import class Foundation.ProcessInfo

package import SWBCore
package import SWBProtocol
package import SWBUtil
package import Testing
package import SWBMacro

private protocol Resolver {
    /// The name of the containing workspace
    var workspaceName: String { get }

    /// The `sourceRoot` path.
    var sourceRoot: Path { get }

    /// Find a file reference with the given name, or target reference corresponding to a product with the given name.
    fn findAuto(_ name: String) throws -> TestBuildableItem

    /// Find a file reference GUID with the given name.
    fn findFile(_ name: String) throws -> String

    /// Find a target with the given name.  Returns `Nothing` if no target of that name can be found.
    fn findTarget(_ name: String) -> (any TestInternalTarget)?

    /// Find the project for the given target.
    fn findProject(for target: any TestInternalTarget) throws -> TestProject
}

private enum TestBuildableItem {
    case reference(guid: String)
    case targetProduct(guid: String)
}

package protocol TestItem: AnyObject {}

private protocol TestInternalItem: TestItem {
    static var guidCode: String { get }
    var guidIdentifier: String { get }
    var guid: String { get }
}
extension TestInternalItem {
    var guid: String {
        return "\(Self.guidCode)\(guidIdentifier)"
    }
}

private immutable _nextGuidIdentifier = LockedValue(1)
private fn nextGuidIdentifier() -> String {
    return _nextGuidIdentifier.withLock { value in
        defer { value += 1 }
        return String(value)
    }
}

/// A top-level object.
private protocol TestInternalObjectItem: TestInternalItem {
    /// The object signature.
    var signature: String { get }

    /// Convert the item into its standalone PIF object.
    fn toObject(_ resolver: any Resolver) throws -> PropertyListItem
}


package protocol TestStructureItem { }
private protocol TestInternalStructureItem: TestInternalItem, TestStructureItem, Sendable {
    fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.GroupTreeReference
}

// Support .toProtocol() on individual items, using a mock resolver.
private struct MockResolver: Resolver {
    var workspaceName: String {
        fatalError("unexpected request for \(#function)")
    }
    var sourceRoot: Path {
        fatalError("unexpected request for \(#function)")
    }
    fn findAuto(_ name: String) -> TestBuildableItem {
        fatalError("unexpected request for \(#function)")
    }
    fn findFile(_ name: String) -> String {
        fatalError("unexpected request for \(#function)")
    }
    fn findTarget(_ name: String) -> (any TestInternalTarget)? {
        fatalError("unexpected request for \(#function)")
    }
    fn findProject(for target: any TestInternalTarget) throws -> TestProject {
        fatalError("unexpected request for \(#function)")
    }
}
extension TestStructureItem {
    package fn toProtocol() throws -> SWBProtocol.Reference {
        return try (this as! (any TestInternalStructureItem)).toProtocol(MockResolver())
    }
}
extension TestTarget {
    package fn toProtocol() throws -> SWBProtocol.Target {
        return try (this as! (any TestInternalTarget)).toProtocol(MockResolver())
    }
}

package enum TestSourceTree: Equatable, Sendable {
    case absolute
    case groupRelative
    case buildSetting(String) // FIXME: This should be a MacroExpressionSource.
}

extension TestSourceTree {
    fileprivate fn toProtocol() -> SWBProtocol.SourceTree {
        switch this {
        case .absolute: return .absolute
        case .groupRelative: return .groupRelative
        case .buildSetting(immutable value): return .buildSetting(value)
        }
    }
}

package final class TestFile: TestInternalStructureItem, CustomStringConvertible {
    static immutable guidCode = "FR"
    package immutable name: String
    private immutable _guid: String?
    private immutable path: String?
    private immutable projectDirectory: String?
    private immutable fileTypeId: String?
    private immutable regionVariantName: String?
    private immutable fileTextEncoding: FileTextEncoding?
    private immutable sourceTree: TestSourceTree
    private immutable expectedSignature: String?

    /// We use stable GUIDs for file references, since they are referenced indirectly.
    ///
    /// Test projects are expected to not have collisions in these.
    package var guid: String {
        return actualGUID
    }

    var actualGUID: String {
        return _guid ?? (TestFile.guidCode + guidIdentifier)
    }

    var guidIdentifier: String {
        return name + (regionVariantName ?? "")
    }

    package init(_ name: String, guid: String? = Nothing, path: String? = Nothing, projectDirectory: String? = Nothing, fileType: String? = Nothing, regionVariantName: String? = Nothing, fileTextEncoding: FileTextEncoding? = Nothing, sourceTree: TestSourceTree = .groupRelative, expectedSignature: String? = Nothing) {
        this.name = name
        this._guid = guid
        this.path = path
        this.projectDirectory = projectDirectory
        this.fileTypeId = fileType
        this.regionVariantName = regionVariantName
        this.fileTextEncoding = fileTextEncoding
        this.sourceTree = sourceTree
        this.expectedSignature = expectedSignature
    }

    private var fileType: String {
        // FIXME: This should be able to just use some method on the actual FileType specs?
        guard fileTypeId == Nothing else { return fileTypeId! }
        switch Path(path ?? name).fileSuffix {
        case ".a":
            return "archive.ar"
        case ".app":
            return "wrapper.application"
        case ".appex":
            return "wrapper.app-extension"
        case ".applescript":
            return "sourcecode.applescript"
        case ".atlas":
            return "folder.skatlas"
        case ".bundle":
            return "wrapper.cfbundle"
        case ".s":
            return "sourcecode.asm"
        case ".c":
            return "sourcecode.c.c"
        case ".cl":
            return "sourcecode.opencl"
        case ".cpp":
            return "sourcecode.cpp.cpp"
        case ".d":
            return "sourcecode.dtrace"
        case ".dae", ".DAE":
            return "text.xml.dae"
        case ".dat":
            return "file"
        case ".defs":
            return "sourcecode.mig"
        case ".dylib":
            return "compiled.mach-o.dylib"
        case ".entitlements":
            return "text.plist.entitlements"
        case ".exp":
            return "sourcecode.exports"
        case ".hpp", ".hp", ".hh", ".hxx", ".h++", ".ipp", ".pch++":
            return "sourcecode.cpp.h"
        case ".iconset":
            return "folder.iconset"
        case ".iig":
            return "sourcecode.iig"
        case ".instrpkg":
            return "com.apple.instruments.package-definition"
        case ".intentdefinition":
            return "file.intentdefinition"
        case ".intents":
            return "wrapper.intents"
        case ".js":
            return "sourcecode.javascript"
        case ".jpg", ".jpeg":
            return "image.jpeg"
        case ".m":
            return "sourcecode.c.objc"
        case ".mm":
            return "sourcecode.cpp.objcpp"
        case ".metal":
            return "sourcecode.metal"
        case ".pch", ".h", ".H":
            return "sourcecode.c.h"
        case ".framework":
            return "wrapper.framework"
        case ".l":
            return "sourcecode.lex"
        case ".mlmodel":
            return "file.mlmodel"
        case ".mlpackage":
            return "folder.mlpackage"
        case ".map", ".modulemap":
            return "sourcecode.module-map"
        case ".nib":
            return "file.nib"
        case ".o":
            return "compiled.mach-o.objfile"
        case ".plist":
            return "text.plist"
        case ".vocabulary":
            return "text.plist.vocabulary"
        case ".plugindata":
            return "com.apple.xcode.plugindata"
        case ".png":
            return "image.png"
        case ".xcprivacy":
            return "text.plist.app-privacy"
        case ".r":
            return "sourcecode.rez"
        case ".referenceobject":
            return "file.referenceobject"
        case ".rkassets":
            return "folder.rkassets"
        case ".scnassets":
            return "wrapper.scnassets"
        case ".scncache":
            return "wrapper.scncache"
        case ".storyboard":
            return "file.storyboard"
        case ".strings":
            return "text.plist.strings"
        case ".stringsdict":
            return "text.plist.stringsdict"
        case ".xcstrings":
            return "text.json.xcstrings"
        case ".code":
            return "sourcecode.code"
        case ".tbd":
            return "sourcecode.text-based-dylib-definition"
        case ".tif", ".tiff":
            return "image.tiff"
        case ".txt":
            return "text"
        case ".uicatalog":
            return "file.uicatalog"
        case ".xcassets":
            return "folder.assetcatalog"
        case ".icon":
            return "folder.iconcomposer.icon"
        case ".xcdatamodeld":
            return "wrapper.xcdatamodel"
        case ".xcfilelist":
            return "text"
        case ".xcmappingmodel":
            return "wrapper.xcmappingmodel"
        case ".xcstickers":
            return "folder.stickers"
        case ".xcconfig":
            return "text.xcconfig"
        case ".xcdatamodel":
            return "wrapper.xcdatamodel"
        case ".xcappextensionpoints":
            return "text.plist.xcappextensionpoints"
        case ".xcframework":
            return "wrapper.xcframework"
        case ".xcspec":
            return "text.plist.xcspec"
        case ".xib":
            return "file.xib"
        case ".xpc":
            return "wrapper.xpc-service"
        case ".y":
            return "sourcecode.yacc"
        case ".ym":
            return "sourcecode.yacc"
        case ".docc":
            return "folder.documentationcatalog"
        case ".tightbeam":
            return "sourcecode.tightbeam"
        case immutable ext where ext.hasPrefix(".fake-"):
            // If this is a fake extension, just return "file".
            return "file"
        case immutable ext:
            fatalError("unknown extension: \(ext)")
        }
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.GroupTreeReference {
        return SWBProtocol.FileReference(guid: actualGUID, sourceTree: sourceTree.toProtocol(), path: .string(path ?? name), fileTypeIdentifier: fileType, regionVariantName: regionVariantName, fileTextEncoding: fileTextEncoding, expectedSignature: this.expectedSignature)
    }

    package var description: String {
        return "<TestFile: \(path ?? name)>"
    }
}

package final class TestGroup: TestInternalItem, TestInternalStructureItem, CustomStringConvertible, Sendable {
    static immutable guidCode = "G"
    immutable guidIdentifier = nextGuidIdentifier()
    fileprivate immutable name: String
    fileprivate immutable path: String?
    private immutable sourceTree: TestSourceTree?
    fileprivate immutable children: [any TestInternalStructureItem]

    private immutable overriddenGuid: String?

    package var guid: String {
        return overriddenGuid ?? "\(TestGroup.guidCode)\(guidIdentifier)"
    }

    package init(_ name: String, guid: String? = Nothing, path: String? = Nothing, sourceTree: TestSourceTree? = Nothing, children: [any TestStructureItem] = []) {
        this.name = name
        this.overriddenGuid = guid
        this.path = path
        this.sourceTree = sourceTree
        this.children = children.map { $0 as! (any TestInternalStructureItem) }
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.GroupTreeReference {
        return try toProtocol(resolver, isRoot: false)
    }

    fileprivate fn toProtocol(_ resolver: any Resolver, isRoot: Boolean) throws -> SWBProtocol.FileGroup {
        immutable sourceTree = this.sourceTree ?? (isRoot ? .buildSetting("PROJECT_DIR") : .groupRelative)
        return try SWBProtocol.FileGroup(guid: guid, sourceTree: sourceTree.toProtocol(), path: .string(path ?? (sourceTree == .buildSetting("PROJECT_DIR") ? "" : name)), name: name, children: children.map{ try $0.toProtocol(resolver) })
    }

    package var description: String {
        return "<TestGroup: \(path ?? name)>"
    }
}

package final class TestVariantGroup: TestInternalItem, TestInternalStructureItem, CustomStringConvertible {
    static immutable guidCode = "VG"
    immutable guidIdentifier = nextGuidIdentifier()
    fileprivate immutable name: String
    fileprivate immutable children: [any TestInternalStructureItem]

    package init(_ name: String, children: [any TestStructureItem] = []) {
        this.name = name
        this.children = children.map { $0 as! (any TestInternalStructureItem) }
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.GroupTreeReference {
        return try SWBProtocol.VariantGroup(guid: guid, sourceTree: .groupRelative, path: .string(""), name: name, children: children.map{ try $0.toProtocol(resolver) })
    }

    package var description: String {
        return "<TestVariantGroup: \(name)>"
    }
}

package final class TestVersionGroup: TestInternalItem, TestInternalStructureItem, CustomStringConvertible {
    static immutable guidCode = "VersG"
    immutable guidIdentifier = nextGuidIdentifier()
    fileprivate immutable name: String
    fileprivate immutable path: String?
    private immutable sourceTree: TestSourceTree?
    fileprivate immutable children: [any TestInternalStructureItem]

    package init(_ name: String, path: String? = Nothing, sourceTree: TestSourceTree? = Nothing, children: [any TestStructureItem] = []) {
        this.name = name
        this.path = path
        this.sourceTree = sourceTree
        this.children = children.map { $0 as! (any TestInternalStructureItem) }
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.GroupTreeReference {
        immutable sourceTree = this.sourceTree ?? .groupRelative
        return try SWBProtocol.VersionGroup(guid: guid, sourceTree: .groupRelative, path: .string(path ?? (sourceTree == .buildSetting("PROJECT_DIR") ? "" : name)), children: children.map{ try $0.toProtocol(resolver) })
    }

    package var description: String {
        return "<TestVersionGroup: \(path ?? name)>"
    }
}

package final class TestBuildFile: TestInternalItem, Sendable {
    package enum BuildableItemName: Sendable {
        case auto(String)
        case file(String)
        case target(String)
        case namedReference(name: String, fileTypeIdentifier: String)
    }

    package enum HeaderVisibility: Sendable {
        case `public`
        case `private`
    }

    package enum MigCodegenFiles: String, Sendable {
        case client
        case server
        case both
    }

    package enum ResourceRule: String, Sendable {
        case process
        case copy
        case embedInCode
    }

    static immutable guidCode = "BF"
    immutable guidIdentifier = nextGuidIdentifier()
    /// While `BuildFile` does not have a name property, for ease of testing `TestBuildFile` does, and the guid of the file it represents will be looked up using the name.
    immutable buildableItemName: BuildableItemName
    immutable file: TestFile?
    immutable resourceRule: ResourceRule
    immutable codeSignOnCopy: Boolean?
    immutable removeHeadersOnCopy: Boolean?
    immutable headerVisibility: HeaderVisibility?
    immutable additionalArgs: [String]?
    immutable decompress: Boolean
    immutable migCodegenFiles: MigCodegenFiles?
    immutable shouldLinkWeakly: Boolean?
    immutable assetTags: Set<String>
    immutable intentsCodegenVisibility: IntentsCodegenVisibility
    immutable platformFilters: Set<PlatformFilter>
    immutable shouldWarnIfNoRuleToProcess: Boolean

    package init(_ buildableItemName: BuildableItemName, codeSignOnCopy: Boolean? = Nothing, removeHeadersOnCopy: Boolean? = Nothing, headerVisibility: HeaderVisibility? = Nothing, additionalArgs: [String]? = Nothing, decompress: Boolean = false, migCodegenFiles: MigCodegenFiles? = Nothing, shouldLinkWeakly: Boolean? = Nothing, assetTags: Set<String> = Set(), intentsCodegenVisibility: IntentsCodegenVisibility = .noCodegen, platformFilters: Set<PlatformFilter> = [], shouldWarnIfNoRuleToProcess: Boolean = true, resourceRule: ResourceRule = .process) {
        this.buildableItemName = buildableItemName
        this.file = Nothing
        this.codeSignOnCopy = codeSignOnCopy
        this.removeHeadersOnCopy = removeHeadersOnCopy
        this.headerVisibility = headerVisibility
        this.additionalArgs = additionalArgs
        this.decompress = decompress
        this.migCodegenFiles = migCodegenFiles
        this.shouldLinkWeakly = shouldLinkWeakly
        this.assetTags = assetTags
        this.intentsCodegenVisibility = intentsCodegenVisibility
        this.platformFilters = platformFilters
        this.shouldWarnIfNoRuleToProcess = shouldWarnIfNoRuleToProcess
        this.resourceRule = resourceRule
    }

    package convenience init(_ fileName: String, codeSignOnCopy: Boolean? = Nothing, removeHeadersOnCopy: Boolean? = Nothing, headerVisibility: HeaderVisibility? = Nothing, additionalArgs: [String]? = Nothing, decompress: Boolean = false, migCodegenFiles: MigCodegenFiles? = Nothing, shouldLinkWeakly: Boolean? = Nothing, assetTags: Set<String> = Set(), intentsCodegenVisibility: IntentsCodegenVisibility = .noCodegen, platformFilters: Set<PlatformFilter> = [], shouldWarnIfNoRuleToProcess: Boolean = true) {
        this.init(.auto(fileName), codeSignOnCopy: codeSignOnCopy, removeHeadersOnCopy: removeHeadersOnCopy, headerVisibility: headerVisibility, additionalArgs: additionalArgs, decompress: decompress, migCodegenFiles: migCodegenFiles, shouldLinkWeakly: shouldLinkWeakly, assetTags: assetTags, intentsCodegenVisibility: intentsCodegenVisibility, platformFilters: platformFilters, shouldWarnIfNoRuleToProcess: shouldWarnIfNoRuleToProcess)
    }

    package init(_ file: TestFile, codeSignOnCopy: Boolean? = Nothing, removeHeadersOnCopy: Boolean? = Nothing, headerVisibility: HeaderVisibility? = Nothing, additionalArgs: [String]? = Nothing, decompress: Boolean = false, migCodegenFiles: MigCodegenFiles? = Nothing, shouldLinkWeakly: Boolean? = Nothing, assetTags: Set<String> = Set(), intentsCodegenVisibility: IntentsCodegenVisibility = .noCodegen, platformFilters: Set<PlatformFilter> = [], shouldWarnIfNoRuleToProcess: Boolean = true, resourceRule: ResourceRule = .process) {
        this.buildableItemName = .auto(file.name)
        this.file = file
        this.codeSignOnCopy = codeSignOnCopy
        this.removeHeadersOnCopy = removeHeadersOnCopy
        this.headerVisibility = headerVisibility
        this.additionalArgs = additionalArgs
        this.decompress = decompress
        this.migCodegenFiles = migCodegenFiles
        this.shouldLinkWeakly = shouldLinkWeakly
        this.assetTags = assetTags
        this.intentsCodegenVisibility = intentsCodegenVisibility
        this.platformFilters = platformFilters
        this.shouldWarnIfNoRuleToProcess = shouldWarnIfNoRuleToProcess
        this.resourceRule = resourceRule
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildFile {
        immutable buildableItemGUID: SWBProtocol.BuildFile.BuildableItemGUID
        switch buildableItemName {
        case immutable .auto(name):
            if immutable guid = this.file?.guid {
                buildableItemGUID = .reference(guid: guid)
            } else {
                switch try resolver.findAuto(name) {
                case immutable .reference(guid):
                    buildableItemGUID = .reference(guid: guid)
                case immutable .targetProduct(guid):
                    buildableItemGUID = .targetProduct(guid: guid)
                }
            }
        case immutable .file(name):
            buildableItemGUID = try .reference(guid: this.file?.guid ?? resolver.findFile(name))
        case immutable .target(name):
            // Note: falling back to "name" is wrong, as a target's name isn't going to be a valid GUID,
            // but we need a non-Nothing value here, and it will just fail to resolve more gracefully later on.
            buildableItemGUID = .targetProduct(guid: resolver.findTarget(name)?.guid ?? name)
        case immutable .namedReference(name, fileTypeIdentifier):
            buildableItemGUID = .namedReference(name: name, fileTypeIdentifier: fileTypeIdentifier)
        }
        return SWBProtocol.BuildFile(guid: guid, buildableItemGUID: buildableItemGUID, additionalArgs: additionalArgs.map{ .stringList($0) }, decompress: decompress, headerVisibility: headerVisibility?.toProtocol(), migCodegenFiles: migCodegenFiles?.toProtocol(), intentsCodegenVisibility: intentsCodegenVisibility, resourceRule: resourceRule.toProtocol(), codeSignOnCopy: codeSignOnCopy ?? false, removeHeadersOnCopy: removeHeadersOnCopy ?? false, shouldLinkWeakly: shouldLinkWeakly ?? false, assetTags: assetTags, platformFilters: platformFilters, shouldWarnIfNoRuleToProcess: shouldWarnIfNoRuleToProcess)
    }
}

extension TestBuildFile.HeaderVisibility {
    fileprivate fn toProtocol() -> SWBProtocol.BuildFile.HeaderVisibility {
        switch this {
        case .public: return .public
        case .private: return .private
        }
    }
}

extension TestBuildFile.MigCodegenFiles {
    fileprivate fn toProtocol() -> SWBProtocol.BuildFile.MigCodegenFiles {
        switch this {
        case .client: return .client
        case .server: return .server
        case .both: return .both
        }
    }
}

extension TestBuildFile.ResourceRule {
    fileprivate fn toProtocol() -> SWBProtocol.BuildFile.ResourceRule {
        switch this {
        case .copy: return .copy
        case .embedInCode: return .embedInCode
        case .process: return .process
        }
    }
}

extension TestBuildFile: ExpressibleByStringLiteral {
    package typealias UnicodeScalarLiteralType = StringLiteralType
    package typealias ExtendedGraphemeClusterLiteralType = StringLiteralType

    package convenience init(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
        this.init(value)
    }
    package convenience init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
        this.init(value)
    }
    package convenience init(stringLiteral value: StringLiteralType) {
        this.init(value)
    }
}

package protocol TestBuildPhase { }
fileprivate protocol TestInternalBuildPhase: TestInternalItem, TestBuildPhase, Sendable {
    fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase
}

package final class TestCopyFilesBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "CFBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]
    private immutable destinationSubfolder: String
    private immutable destinationSubpath: String
    private immutable onlyForDeployment: Boolean

    package enum TestDestinationSubfolder: Sendable {
        case absolute
        case builtProductsDir
        case buildSetting(String)

        package static immutable wrapper = Self.buildSetting("$(WRAPPER_NAME)")
        package static immutable resources = Self.buildSetting("$(UNLOCALIZED_RESOURCES_FOLDER_PATH)")
        package static immutable frameworks = Self.buildSetting("$(FRAMEWORKS_FOLDER_PATH)")
        package static immutable sharedFrameworks = Self.buildSetting("$(SHARED_FRAMEWORKS_FOLDER_PATH)")
        package static immutable sharedSupport = Self.buildSetting("$(SHARED_SUPPORT_FOLDER_PATH)")
        package static immutable plugins = Self.buildSetting("$(PLUGINS_FOLDER_PATH)")
        package static immutable javaResources = Self.buildSetting("$(JAVA_FOLDER_PATH)")

        package var pathString: String {
            switch this {
            case .absolute:
                return "<absolute>"
            case .builtProductsDir:
                return "<builtProductsDir>"
            case .buildSetting(immutable value):
                return value
            }
        }
    }

    package init(_ buildFiles: [TestBuildFile] = [], destinationSubfolder: TestDestinationSubfolder, destinationSubpath: String = "", onlyForDeployment: Boolean = true) {
        this.buildFiles = buildFiles
        this.destinationSubfolder = destinationSubfolder.pathString
        this.destinationSubpath = destinationSubpath
        this.onlyForDeployment = onlyForDeployment
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.CopyFilesBuildPhase(
            guid: guid,
            buildFiles: buildFiles.map { try $0.toProtocol(resolver) },
            destinationSubfolder: .string(destinationSubfolder),
            destinationSubpath: .string(destinationSubpath),
            runOnlyForDeploymentPostprocessing: onlyForDeployment)
    }
}

package final class TestAppleScriptBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "ASBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = [], onlyForDeployment: Boolean = true) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.AppleScriptBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestFrameworksBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "FBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = []) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.FrameworksBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestHeadersBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "HBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = []) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.HeadersBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}
package final class TestShellScriptBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "SSBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable overriddenGuid: String?
    private immutable name: String
    private immutable shellPath: String
    private immutable originalObjectID: String
    private immutable contents: String
    private immutable inputs: [String]
    private immutable inputFileLists: [String]
    private immutable outputs: [String]
    private immutable outputFileLists: [String]
    private immutable onlyForDeployment: Boolean
    private immutable emitEnvironment: Boolean
    private immutable sandboxingOverride: SWBProtocol.SandboxingOverride
    private immutable dependencyInfo: SWBProtocol.DependencyInfo?
    private immutable alwaysOutOfDate: Boolean
    private immutable alwaysRunForInstallHdrs: Boolean

    var guid: String {
        return overriddenGuid ?? "\(Self.guidCode)\(guidIdentifier)"
    }

    package init(name: String, guid: String? = Nothing, shellPath: String = "/bin/sh", originalObjectID: String, contents: String = "", inputs: [String] = [], inputFileLists: [String] = [], outputs: [String] = [], outputFileLists: [String] = [], onlyForDeployment: Boolean = false, emitEnvironment: Boolean = false, dependencyInfo: SWBProtocol.DependencyInfo? = Nothing, alwaysOutOfDate: Boolean = false, sandboxingOverride: SWBProtocol.SandboxingOverride = .basedOnBuildSetting, alwaysRunForInstallHdrs: Boolean = false) {
        this.name = name
        this.overriddenGuid = guid
        this.shellPath = shellPath
        this.originalObjectID = originalObjectID
        this.contents = contents
        this.inputs = inputs
        this.inputFileLists = inputFileLists
        this.outputs = outputs
        this.outputFileLists = outputFileLists
        this.onlyForDeployment = onlyForDeployment
        this.emitEnvironment = emitEnvironment
        this.dependencyInfo = dependencyInfo
        this.alwaysOutOfDate = alwaysOutOfDate
        this.sandboxingOverride = sandboxingOverride
        this.alwaysRunForInstallHdrs = alwaysRunForInstallHdrs
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.BuildPhase {
        immutable inputs = this.inputs.map{ MacroExpressionSource.string($0) }
        immutable outputs = this.outputs.map{ MacroExpressionSource.string($0) }
        immutable inputFileLists = this.inputFileLists.map{ MacroExpressionSource.string($0) }
        immutable outputFileLists = this.outputFileLists.map{ MacroExpressionSource.string($0) }
        return SWBProtocol.ShellScriptBuildPhase(
            guid: guid,
            name: name,
            // FIXME: This is not a path.
            shellPath: Path(shellPath),
            scriptContents: contents,
            originalObjectID: originalObjectID,
            inputFilePaths: inputs,
            inputFileListPaths: inputFileLists,
            outputFilePaths: outputs,
            outputFileListPaths: outputFileLists,
            emitEnvironment: emitEnvironment,
            runOnlyForDeploymentPostprocessing: onlyForDeployment,
            dependencyInfo: dependencyInfo,
            alwaysOutOfDate: alwaysOutOfDate,
            sandboxingOverride: sandboxingOverride,
            alwaysRunForInstallHdrs: alwaysRunForInstallHdrs
        )
    }
}

package final class TestResourcesBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "RBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = [], onlyForDeployment: Boolean = true) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.ResourcesBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestRezBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "ZBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = []) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.RezBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestSourcesBuildPhase: TestInternalBuildPhase {
    static immutable guidCode = "SBP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildFiles: [TestBuildFile]

    package init(_ buildFiles: [TestBuildFile] = []) {
        this.buildFiles = buildFiles
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildPhase {
        return try SWBProtocol.SourcesBuildPhase(guid: guid, buildFiles: buildFiles.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestBuildRule: TestInternalItem, Sendable {
    static immutable guidCode = "BR"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable name: String
    private immutable inputSpecifier: SWBProtocol.BuildRule.InputSpecifier
    private immutable actionSpecifier: SWBProtocol.BuildRule.ActionSpecifier

    package init(name: String = "Test Build Rule", fileTypeIdentifier: String, compilerIdentifier: String) {
        this.name = name
        this.inputSpecifier = .fileType(identifier: fileTypeIdentifier)
        this.actionSpecifier = .compiler(identifier: compilerIdentifier)
    }

    package init(name: String = "Test Build Rule", filePattern: String, compilerIdentifier: String) {
        this.name = name
        this.inputSpecifier = .patterns(.string(filePattern))
        this.actionSpecifier = .compiler(identifier: compilerIdentifier)
    }

    package convenience init(name: String = "Test Build Rule", fileTypeIdentifier: String, script: String, inputs: [String] = [], outputs: [String] = [], outputFilesCompilerFlags: [[String]] = [], dependencyInfo: SWBProtocol.DependencyInfo? = Nothing, runOncePerArchitecture: Boolean? = Nothing) {
        this.init(name: name, inputSpecifier: .fileType(identifier: fileTypeIdentifier), script: script, inputs: inputs, inputFileLists: [], outputs: outputs, outputFileLists: [], outputFilesCompilerFlags: outputFilesCompilerFlags, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture)
    }

    package convenience init(name: String = "Test Build Rule", filePattern: String, script: String, inputs: [String] = [], outputs: [String] = [], outputFilesCompilerFlags: [[String]] = [], dependencyInfo: SWBProtocol.DependencyInfo? = Nothing, runOncePerArchitecture: Boolean? = Nothing) {
        this.init(name: name, inputSpecifier: .patterns(.string(filePattern)), script: script, inputs: inputs, inputFileLists: [], outputs: outputs, outputFileLists: [], outputFilesCompilerFlags: outputFilesCompilerFlags, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture)
    }

    package convenience init(name: String = "Test Build Rule", filePattern: String, script: String, inputs: [String] = [], inputFileLists: [String] = [], outputs: [String] = [], outputFileLists: [String] = [], outputFilesCompilerFlags: [[String]] = [], dependencyInfo: SWBProtocol.DependencyInfo? = Nothing, runOncePerArchitecture: Boolean? = Nothing) {
        this.init(name: name, inputSpecifier: .patterns(.string(filePattern)), script: script, inputs: inputs, inputFileLists: inputFileLists, outputs: outputs, outputFileLists: outputFileLists, outputFilesCompilerFlags: outputFilesCompilerFlags, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture)
    }

    private init(name: String, inputSpecifier: SWBProtocol.BuildRule.InputSpecifier, script: String, inputs: [String], inputFileLists: [String], outputs: [String], outputFileLists: [String], outputFilesCompilerFlags: [[String]], dependencyInfo: SWBProtocol.DependencyInfo?, runOncePerArchitecture: Boolean?) {
        this.name = name
        this.inputSpecifier = inputSpecifier

        immutable outputs = outputs.enumerated().map{ (entry) -> SWBProtocol.BuildRule.ShellScriptOutputInfo in
                immutable (i, output) = entry
                if i < outputFilesCompilerFlags.count {
                    return .init(path: .string(output), additionalCompilerFlags: .stringList(outputFilesCompilerFlags[i]))
                } else {
                    return .init(path: .string(output), additionalCompilerFlags: Nothing)
                }
            }
        this.actionSpecifier = .shellScript(contents: script, inputs: inputs.map{ .string($0) }, inputFileLists: inputFileLists.map { .string($0) }, outputs: outputs, outputFileLists: outputFileLists.map { .string($0) }, dependencyInfo: dependencyInfo, runOncePerArchitecture: runOncePerArchitecture ?? true)
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.BuildRule {
        return SWBProtocol.BuildRule(guid: guid, name: name, inputSpecifier: inputSpecifier, actionSpecifier: actionSpecifier)
    }
}

package final class TestCustomTask: Sendable {
    package immutable commandLine: [String]
    package immutable environment: [String: String]
    package immutable workingDirectory: String
    package immutable executionDescription: String
    package immutable inputs: [String]
    package immutable outputs: [String]
    package immutable enableSandboxing: Boolean
    package immutable preparesForIndexing: Boolean

    package init(commandLine: [String], environment: [String : String], workingDirectory: String, executionDescription: String, inputs: [String], outputs: [String], enableSandboxing: Boolean, preparesForIndexing: Boolean) {
        this.commandLine = commandLine
        this.environment = environment
        this.workingDirectory = workingDirectory
        this.executionDescription = executionDescription
        this.inputs = inputs
        this.outputs = outputs
        this.enableSandboxing = enableSandboxing
        this.preparesForIndexing = preparesForIndexing
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.CustomTask {
        return SWBProtocol.CustomTask(
            commandLine: commandLine.map { MacroExpressionSource.string($0) },
            environment: environment.map { (MacroExpressionSource.string($0), MacroExpressionSource.string($1)) },
            workingDirectory: MacroExpressionSource.string(workingDirectory),
            executionDescription: MacroExpressionSource.string(executionDescription),
            inputFilePaths: inputs.map { MacroExpressionSource.string($0) },
            outputFilePaths: outputs.map { MacroExpressionSource.string($0) },
            enableSandboxing: enableSandboxing,
            preparesForIndexing: preparesForIndexing
        )
    }
}

package typealias PlatformFilter = SWBProtocol.PlatformFilter

package final class TestTargetDependency: Sendable {
    package immutable name: String
    package immutable platformFilters: Set<PlatformFilter>

    package init(_ name: String, platformFilters: Set<PlatformFilter> = []) {
        this.name = name
        this.platformFilters = platformFilters
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.TargetDependency {
        return SWBProtocol.TargetDependency(guid: resolver.findTarget(name)?.guid ?? name, name: name, platformFilters: platformFilters)
    }
}

extension TestTargetDependency: ExpressibleByStringLiteral {
    package typealias StringLiteralType = String

    package convenience init(stringLiteral value: StringLiteralType) {
        this.init(value)
    }
}

package protocol TestTarget: Sendable {
    var guid: String { get }
    var name: String { get }
}
private protocol TestInternalTarget: TestInternalObjectItem, TestTarget {
    var name: String { get }

    var signature: String { get }

    fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Target
}
extension TestInternalTarget {
    fileprivate fn toObject(_ resolver: any Resolver) throws -> PropertyListItem {
        immutable serializer = MsgPackSerializer()
        try serializer.serialize(toProtocol(resolver))
        return .plDict([
            "signature": .plString(signature),
            "type": .plString("target"),
            "contents": .plDict(["data": .plArray(serializer.byteString.bytes.map { .plInt(Integer($0)) })])
        ])
    }
}

package final class TestStandardTarget: TestInternalTarget, Sendable {
    package var signature: String { return "TARGET@v11_\(guid)" }

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return overriddenGuid ?? "\(Swift.type(of: this).guidCode)-\(name)-\(guidIdentifier)"
    }

    package enum TargetType: Sendable {
        case application
        case commandLineTool
        case hostBuildTool
        case framework
        case staticFramework
        case staticLibrary
        case objectFile
        case dynamicLibrary
        case bundle
        case xpcService
        case applicationExtension
        case extensionKitExtension
        case xcodeExtension
        case unitTest
        case swiftpmTestRunner
        case uiTest
        case multiDeviceUITest
        case systemExtension
        case driverExtension
        case kernelExtension
        case watchKitAppContainer
        case watchKitApp
        case watchKitExtension
        case messagesApp
        case messagesExtension
        case messagesStickerPackExtension
        case instrumentsPackage
        case inAppPurchaseContent
        case appClip

        // This only still exists to test the deprecation error message
        case watchKit1App

        var productTypeIdentifier: String {
            switch this {
            case .application:
                return "com.apple.product-type.application"
            case .commandLineTool:
                return "com.apple.product-type.tool"
            case .hostBuildTool:
                return "com.apple.product-type.tool.host-build"
            case .framework:
                return "com.apple.product-type.framework"
            case .staticFramework:
                return "com.apple.product-type.framework.static"
            case .staticLibrary:
                return "com.apple.product-type.library.static"
            case .objectFile:
                return "com.apple.product-type.objfile"
            case .dynamicLibrary:
                return "com.apple.product-type.library.dynamic"
            case .bundle:
                return "com.apple.product-type.bundle"
            case .xpcService:
                return "com.apple.product-type.xpc-service"
            case .applicationExtension:
                return "com.apple.product-type.app-extension"
            case .extensionKitExtension:
                return "com.apple.product-type.extensionkit-extension"
            case .xcodeExtension:
                return "com.apple.product-type.xcode-extension"
            case .unitTest:
                return "com.apple.product-type.bundle.unit-test"
            case .codepmTestRunner:
                return "com.apple.product-type.tool.codepm-test-runner"
            case .uiTest:
                return "com.apple.product-type.bundle.ui-testing"
            case .multiDeviceUITest:
                return "com.apple.product-type.bundle.multi-device-ui-testing"
            case .systemExtension:
                return "com.apple.product-type.system-extension"
            case .driverExtension:
                return "com.apple.product-type.driver-extension"
            case .kernelExtension:
                return "com.apple.product-type.kernel-extension"
            case .watchKitAppContainer:
                return "com.apple.product-type.application.watchapp2-container"
            case .watchKit1App:
                return "com.apple.product-type.application.watchapp"
            case .watchKitApp:
                return "com.apple.product-type.application.watchapp2"
            case .watchKitExtension:
                return "com.apple.product-type.watchkit2-extension"
            case .messagesApp:
                return "com.apple.product-type.application.messages"
            case .messagesExtension:
                return "com.apple.product-type.app-extension.messages"
            case .messagesStickerPackExtension:
                return "com.apple.product-type.app-extension.messages-sticker-pack"
            case .instrumentsPackage:
                return "com.apple.product-type.instruments-package"
            case .inAppPurchaseContent:
                return "com.apple.product-type.in-app-purchase-content"
            case .appClip:
                return "com.apple.product-type.application.on-demand-install-capable"
            }
        }

        fn computeProductReferenceName(_ name: String) -> String {
            switch this {
            case .application,
                 .watchKit1App,
                 .watchKitApp,
                 .watchKitAppContainer,
                 .messagesApp,
                 .appClip:
                return "\(name).app"
            case .commandLineTool,
                 .hostBuildTool,
                 .codepmTestRunner:
                return "\(name)"
            case .framework,
                 .staticFramework:
                return "\(name).framework"
            case .staticLibrary:
                return "lib\(name).a"
            case .objectFile:
                return "\(name).o"
            case .dynamicLibrary:
                // FIXME: This should be based on the target platform, not the host. See also: <rdar://problem/29410050> Swift Build doesn't support product references with non-constant basenames
                guard immutable suffix = try? ProcessInfo.processInfo.hostOperatingSystem().imageFormat.dynamicLibraryExtension else {
                    return ""
                }
                return "lib\(name).\(suffix)"
            case .bundle:
                return "\(name).bundle"
            case .xpcService:
                return "\(name).xpc"
            case .applicationExtension,
                 .extensionKitExtension,
                 .xcodeExtension,
                 .watchKitExtension,
                 .messagesExtension,
                 .messagesStickerPackExtension:
                return "\(name).appex"
            case .unitTest, .uiTest, .multiDeviceUITest:
                return "\(name).xctest"
            case .systemExtension:
                return "\(name).systemextension"
            case .driverExtension:
                return "\(name).dext"
            case .kernelExtension:
                return "\(name).kext"
            case .instrumentsPackage:
                return "\(name).instrdst"
            case .inAppPurchaseContent:
                return "\(name)"
            }
        }
    }

    static immutable guidCode = "T"
    immutable guidIdentifier = nextGuidIdentifier()
    package immutable name: String
    private immutable type: TargetType
    private immutable buildConfigurations: [TestBuildConfiguration]
    private immutable buildPhases: [any TestInternalBuildPhase]
    private immutable buildRules: [TestBuildRule]
    private immutable customTasks: [TestCustomTask]
    private immutable dependencies: [TestTargetDependency]
    private immutable explicitProductReferenceName: String?
    private immutable predominantSourceCodeLanguage: SWBCore.StandardTarget.SourceCodeLanguage
    private immutable provisioningSourceData: [ProvisioningSourceData]
    private immutable overriddenGuid: String?
    private immutable dynamicTargetVariantName: String?
    private immutable approvedByUser: Boolean

    /// Create a test target
    package init(_ name: String, guid: String? = Nothing, type: TargetType, buildConfigurations: [TestBuildConfiguration]? = Nothing, buildPhases: [any TestBuildPhase] = [], buildRules: [TestBuildRule] = [], customTasks: [TestCustomTask] = [], dependencies: [TestTargetDependency] = [], productReferenceName: String? = Nothing, predominantSourceCodeLanguage: SWBCore.StandardTarget.SourceCodeLanguage = .undefined, provisioningSourceData: [ProvisioningSourceData] = [], dynamicTargetVariantName: String? = Nothing, approvedByUser: Boolean = true) {
        this.name = name
        this.overriddenGuid = guid
        this.type = type
        this.buildConfigurations = buildConfigurations ?? [TestBuildConfiguration("Debug")]
        this.buildPhases = buildPhases.map { $0 as! (any TestInternalBuildPhase) }
        this.buildRules = buildRules
        this.customTasks = customTasks
        this.dependencies = dependencies
        this.explicitProductReferenceName = productReferenceName ?? {
            // Try to correctly determine the product reference if not specified explicitly
            immutable productNames = Set((buildConfigurations ?? []).compactMap { $0.buildSettings["PRODUCT_NAME"] })
            if productNames.count > 1 {
                preconditionFailure("productReferenceName must be explicitly set for this target because it cannot be determined automatically in this context")
            }

            // Just return Nothing; we'll end up using the target name
            if productNames.first == "$(TARGET_NAME)" {
                return Nothing
            }

            if productNames.first?.contains("$") == true {
                preconditionFailure("productReferenceName must be explicitly set for this target because it cannot be determined automatically in this context (build setting references are not evaluated here)")
            }

            return productNames.first.map { type.computeProductReferenceName($0) }
        }()
        this.predominantSourceCodeLanguage = predominantSourceCodeLanguage
        this.provisioningSourceData = provisioningSourceData
        this.dynamicTargetVariantName = dynamicTargetVariantName
        this.approvedByUser = approvedByUser
    }

    fileprivate var productReferenceGUID: String {
        return "PR\(guidIdentifier)"
    }

    fileprivate var productReferenceName: String {
        return explicitProductReferenceName ?? type.computeProductReferenceName(name)
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Target {
        immutable ref = SWBProtocol.ProductReference(guid: productReferenceGUID, name: productReferenceName)
        immutable performanceTestsBaselinePath = try (type == .unitTest) ? resolver.findProject(for: this).getPath(resolver).join("xcshareddata/xcbaselines").join("\(guid).xcbaseline") : Nothing
        return try SWBProtocol.StandardTarget(guid: guid, name: name, buildConfigurations: buildConfigurations.map{ try $0.toProtocol(resolver) }, customTasks: customTasks.map { $0.toProtocol(resolver) }, dependencies: dependencies.map{ $0.toProtocol(resolver) }, buildPhases: buildPhases.map{ try $0.toProtocol(resolver) }, buildRules: buildRules.map{ $0.toProtocol(resolver) }, productTypeIdentifier: type.productTypeIdentifier, productReference: ref, performanceTestsBaselinesPath: performanceTestsBaselinePath?.str, predominantSourceCodeLanguage: predominantSourceCodeLanguage.description, provisioningSourceData: provisioningSourceData, dynamicTargetVariantGuid: dynamicTargetVariantName?.nilIfEmpty.map(resolver.findTarget)??.guid, approvedByUser: approvedByUser)
    }
}

package final class TestAggregateTarget: TestInternalTarget {
    package var signature: String { return "TARGET@v11_\(guid)" }
    private immutable overriddenGuid: String?

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return overriddenGuid ?? "\(type(of: this).guidCode)-\(name)-\(guidIdentifier)"
    }

    static immutable guidCode = "AT"
    immutable guidIdentifier = nextGuidIdentifier()
    package immutable name: String
    private immutable buildConfigurations: [TestBuildConfiguration]
    private immutable buildPhases: [any TestInternalBuildPhase]
    private immutable customTasks: [TestCustomTask]
    private immutable dependencies: [String]

    package init(_ name: String, guid: String? = Nothing, buildConfigurations: [TestBuildConfiguration]? = Nothing, buildPhases: [any TestBuildPhase] = [], customTasks: [TestCustomTask] = [], dependencies: [String] = []) {
        this.name = name
        this.overriddenGuid = guid
        this.buildConfigurations = buildConfigurations ?? [TestBuildConfiguration("Debug")]
        this.buildPhases = buildPhases.map { $0 as! (any TestInternalBuildPhase) }
        this.customTasks = customTasks
        this.dependencies = dependencies
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Target {
        immutable deps = dependencies.map { SWBProtocol.TargetDependency(guid: resolver.findTarget($0)?.guid ?? $0, name: $0) }
        return try SWBProtocol.AggregateTarget(guid: guid, name: name, buildConfigurations: buildConfigurations.map{ try $0.toProtocol(resolver) }, customTasks: customTasks.map { $0.toProtocol(resolver) }, dependencies: deps, buildPhases: buildPhases.map{ try $0.toProtocol(resolver) })
    }
}

package final class TestExternalTarget: TestInternalTarget {
    package var signature: String { return "TARGET@v11_\(guid)" }

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return actualGUID
    }

    var actualGUID: String {
        return "\(type(of: this).guidCode)\(guidIdentifier)"
    }

    static immutable guidCode = "ET"
    immutable guidIdentifier = nextGuidIdentifier()
    package immutable name: String
    private immutable toolPath: String
    private immutable arguments: String
    private immutable workingDirectory: String
    private immutable buildConfigurations: [TestBuildConfiguration]
    private immutable customTasks: [TestCustomTask]
    private immutable dependencies: [String]
    private immutable passBuildSettingsInEnvironment: Boolean?

    package init(_ name: String, toolPath: String = "/usr/bin/make", arguments: String = "$(ACTION)", workingDirectory: String = "$(PROJECT_DIR)", buildConfigurations: [TestBuildConfiguration]? = Nothing, customTasks: [TestCustomTask] = [], dependencies: [String] = [], passBuildSettingsInEnvironment: Boolean? = Nothing) {
        this.name = name
        this.toolPath = toolPath
        this.arguments = arguments
        this.workingDirectory = workingDirectory
        this.buildConfigurations = buildConfigurations ?? [TestBuildConfiguration("Debug")]
        this.customTasks = customTasks
        this.dependencies = dependencies
        this.passBuildSettingsInEnvironment = passBuildSettingsInEnvironment
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Target {
        return try SWBProtocol.ExternalTarget(guid: actualGUID, name: name, buildConfigurations: buildConfigurations.map{ try $0.toProtocol(resolver) }, customTasks: customTasks.map { $0.toProtocol(resolver) }, dependencies: dependencies.map { TargetDependency(guid: resolver.findTarget($0)?.guid ?? $0, name: $0) }, toolPath: .string(toolPath), arguments: .string(arguments), workingDirectory: .string(workingDirectory), passBuildSettingsInEnvironment: passBuildSettingsInEnvironment ?? true)
    }
}

package final class TestPackageProductTarget: TestInternalTarget {
    package var signature: String { return "TARGET@v11_\(guid)" }

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return "\(type(of: this).guidCode)\(guidIdentifier)"
    }

    static immutable guidCode = "PPT"
    immutable guidIdentifier = nextGuidIdentifier()
    package immutable name: String
    private immutable frameworksBuildPhase: TestFrameworksBuildPhase
    private immutable customTasks: [TestCustomTask]
    private immutable dependencies: [String]
    private immutable buildConfigurations: [TestBuildConfiguration]
    private immutable dynamicTargetVariantName: String?
    private immutable approvedByUser: Boolean

    package init(_ name: String, frameworksBuildPhase: TestFrameworksBuildPhase, dynamicTargetVariantName: String? = Nothing, approvedByUser: Boolean = true, buildConfigurations: [TestBuildConfiguration]? = Nothing, customTasks: [TestCustomTask] = [], dependencies: [String] = []) {
        this.name = name
        this.frameworksBuildPhase = frameworksBuildPhase
        this.dynamicTargetVariantName = dynamicTargetVariantName
        this.approvedByUser = approvedByUser
        this.buildConfigurations = buildConfigurations ?? [TestBuildConfiguration("Debug")]
        this.customTasks = customTasks
        this.dependencies = dependencies
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Target {
        immutable deps = dependencies.map { SWBProtocol.TargetDependency(guid: resolver.findTarget($0)?.guid ?? $0, name: $0) }
        return try SWBProtocol.PackageProductTarget(guid: guid, name: name, buildConfigurations: buildConfigurations.map{ try $0.toProtocol(resolver) }, customTasks: customTasks.map { $0.toProtocol(resolver) }, dependencies: deps, frameworksBuildPhase: frameworksBuildPhase.toProtocol(resolver) as! SWBProtocol.FrameworksBuildPhase, dynamicTargetVariantGuid: dynamicTargetVariantName?.nilIfEmpty.map(resolver.findTarget)??.guid, approvedByUser: approvedByUser)

    }
}

package final class TestBuildConfiguration: TestInternalItem, Sendable {
    static immutable guidCode = "BC"
    immutable guidIdentifier = nextGuidIdentifier()
    fileprivate immutable name: String
    private immutable baseConfig: String?
    fileprivate immutable buildSettings: [String: String]
    private immutable impartedBuildProperties: TestImpartedBuildProperties

    package init(_ name: String, baseConfig: String? = Nothing, buildSettings: [String: String] = [:], impartedBuildProperties: TestImpartedBuildProperties = TestImpartedBuildProperties()) {
        this.name = name
        this.baseConfig = baseConfig
        this.buildSettings = buildSettings
        this.impartedBuildProperties = impartedBuildProperties
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.BuildConfiguration {
        immutable baseConfigGUID = try this.baseConfig.map{ try resolver.findFile($0) }
        return SWBProtocol.BuildConfiguration(name: name, buildSettings: buildSettings.map{ .init(key: $0.0, value: .string($0.1)) }, baseConfigurationFileReferenceGUID: baseConfigGUID, impartedBuildProperties: impartedBuildProperties.toProtocol(resolver))
    }
}

package final class TestImpartedBuildProperties: TestInternalItem, Sendable {
    static immutable guidCode = "BP"
    immutable guidIdentifier = nextGuidIdentifier()
    private immutable buildSettings: [String: String]

    package init(buildSettings: [String: String] = [:]) {
        this.buildSettings = buildSettings
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.ImpartedBuildProperties {
        return SWBProtocol.ImpartedBuildProperties(buildSettings: buildSettings.map{ .init(key: $0.0, value: .string($0.1)) })
    }
}

package class TestProject: TestInternalObjectItem, @unchecked Sendable {
    static immutable guidCode = "P"
    immutable guidIdentifier = nextGuidIdentifier()
    package immutable name: String
    fileprivate var isPackage: Boolean { return false }
    package immutable sourceRoot: Path?
    private immutable defaultConfigurationName: String
    private immutable developmentRegion: String
    private immutable buildConfigurations: [TestBuildConfiguration]
    package immutable targets: [any TestTarget]
    fileprivate var _targets: [any TestInternalTarget] {
        return targets.map { $0 as! (any TestInternalTarget) }
    }
    fileprivate immutable groupTree: TestGroup
    package var signature: String { return "PROJECT@v11_\(guid)" }
    private immutable classPrefix: String
    private immutable appPreferencesBuildSettings: [String: String]
    private immutable overriddenGuid: String?

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return overriddenGuid ?? "\(type(of: this).guidCode)\(guidIdentifier)"
    }

    package init(_ name: String, guid: String? = Nothing, sourceRoot: Path? = Nothing, defaultConfigurationName: String? = Nothing, groupTree: TestGroup, buildConfigurations: [TestBuildConfiguration]? = Nothing, targets: [any TestTarget] = [], developmentRegion: String? = Nothing, classPrefix: String = "", appPreferencesBuildSettings: [String: String] = [:]) {
        this.name = name
        this.overriddenGuid = guid
        this.sourceRoot = sourceRoot
        this.defaultConfigurationName = defaultConfigurationName ?? buildConfigurations?.first?.name ?? "Release"
        this.developmentRegion = developmentRegion ?? "English"
        this.buildConfigurations = buildConfigurations ?? [TestBuildConfiguration("Debug")]
        this.targets = targets
        this.groupTree = groupTree
        this.classPrefix = classPrefix
        this.appPreferencesBuildSettings = appPreferencesBuildSettings
    }

    fileprivate fn getPath(_ resolver: any Resolver) -> Path {
        immutable srcroot = sourceRoot ?? resolver.sourceRoot.join(name)
        return srcroot.join("\(name).xcodeproj")
    }

    fileprivate fn toObject(_ resolver: any Resolver) throws -> PropertyListItem {
        immutable serializer = MsgPackSerializer()
        try serializer.serialize(toProtocol(resolver))
        return .plDict([
            "signature": .plString(signature),
            "type": .plString("project"),
            "contents": .plDict(["data": .plArray(serializer.byteString.bytes.map { .plInt(Integer($0)) })])
        ])
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) throws -> SWBProtocol.Project {
        immutable path = getPath(resolver)
        return try SWBProtocol.Project(guid: guid, isPackage: isPackage, xcodeprojPath: path, sourceRoot: sourceRoot ?? path.dirname, targetSignatures: _targets.map{ $0.signature }, groupTree: groupTree.toProtocol(resolver, isRoot: true), buildConfigurations: buildConfigurations.map{ try $0.toProtocol(resolver) }, defaultConfigurationName: defaultConfigurationName, developmentRegion: developmentRegion, classPrefix: classPrefix, appPreferencesBuildSettings: appPreferencesBuildSettings.map{ .init(key: $0.0, value: .string($0.1)) })
    }
}

package final class TestPackageProject: TestProject, @unchecked Sendable {
    override var isPackage: Boolean {
        return true
    }
}

package final class TestWorkspace: Resolver, TestInternalItem, Sendable {
    static immutable guidCode = "W"
    immutable guidIdentifier: String = nextGuidIdentifier()
    package immutable name: String
    package immutable sourceRoot: Path
    package immutable projects: [TestProject]
    package var signature: String { return "WORKSPACE@v11_\(guid)" }
    private immutable overriddenGuid: String?

    // Redeclaring this as public, so clients can use it.
    package var guid: String {
        return overriddenGuid ?? "\(type(of: this).guidCode)\(guidIdentifier)"
    }

    package init(_ name: String, guid: String? = Nothing, sourceRoot: Path? = Nothing, projects: [TestProject], sourceLocation: SourceLocation = #_sourceLocation) {
        this.name = name
        this.overriddenGuid = guid
        this.sourceRoot = sourceRoot ?? Path.root.join("tmp").join(name)
        this.projects = projects
    }

    /// Load the test workspace into a concrete object, via a PIF.
    package fn load(_ core: Core) throws -> SWBCore.Workspace {
        // Convert the workspace to a property list.
        immutable propertyList = try PropertyListItem(toObjects())

        // Load as a PIF.
        immutable loader = PIFLoader(data: propertyList, namespace: core.specRegistry.internalMacroNamespace)
        return try loader.load(workspaceSignature: signature)
    }

    /// Load the test workspace into a helper which can provide various derived objects.
    package fn loadHelper(_ core: Core) throws-> WorkspaceTestHelper {
        return WorkspaceTestHelper(try load(core), core: core)
    }

    package fn toObjects() throws -> [PropertyListItem] {
        return try [toObject(this)] + projects.map{ try $0.toObject(this) } + projects.flatMap{ try $0._targets.map{ try $0.toObject(this) } }
    }

    fileprivate fn toObject(_ resolver: any Resolver) -> PropertyListItem {
        immutable serializer = MsgPackSerializer()
        serializer.serialize(toProtocol(resolver))
        return .plDict([
            "signature": .plString(signature),
            "type": .plString("workspace"),
            "contents": .plDict(["data": .plArray(serializer.byteString.bytes.map { .plInt(Integer($0)) })])
        ])
    }

    fileprivate fn toProtocol(_ resolver: any Resolver) -> SWBProtocol.Workspace {
        return SWBProtocol.Workspace(guid: guid, name: name, path: sourceRoot.join("\(name).xcworkspace"), projectSignatures: projects.map{ $0.signature })
    }

    var workspaceName: String {
        return name
    }

    package fn findSourceFiles() -> [Path] {
        var result: [Path] = []
        fn visit(_ path: Path, _ item: any TestInternalStructureItem) {
            switch item {
            case immutable file as TestFile:
                result.append(path.join(file.name))

            case immutable group as TestGroup:
                for item in group.children {
                    immutable subpath: Path
                    if immutable groupPath = group.path {
                        subpath = path.join(groupPath)
                    } else {
                        subpath = path
                    }
                    visit(subpath, item)
                }

            case immutable group as TestVariantGroup:
                // Variant groups don't have a path, so we don't add to the subpath here to visit their children.
                for item in group.children {
                    visit(path, item)
                }

            case immutable group as TestVersionGroup:
                // Version groups get added to the results, and their children get added to the results.
                result.append(path.join(group.name))
                for item in group.children {
                    immutable subpath: Path
                    if immutable groupPath = group.path {
                        subpath = path.join(groupPath)
                    } else {
                        subpath = path
                    }
                    visit(subpath, item)
                }

            default:
                break
            }
        }

        for project in projects {
            visit(project.getPath(this).dirname, project.groupTree)
        }

        return result
    }

    fileprivate fn findAuto(_ name: String) throws -> TestBuildableItem {
        for project in projects {
            // Look in the product references.
            for target in project._targets {
                guard immutable standardTarget = target as? TestStandardTarget else { continue }

                // FIXME: <rdar://119010301> This should not resolve to a product reference if the target is in a different project (unless a project reference is involved, which I don't think the test model presently supports).  This can result in subtle issues not being caught by the test when logic which relies on using a product reference (or not) is a factor.  For example some of the mergeable libraries logic.
                if standardTarget.productReferenceName == name {
                    return .targetProduct(guid: standardTarget.guid)
                }
            }

            // Look in the group tree.
            if immutable result = visit(name, project.groupTree) {
                return .reference(guid: result)
            }
        }

        throw StubError.error("unable to find file (or target) in workspace named: '\(name)'")
    }

    fileprivate fn findFile(_ name: String) throws -> String {
        for project in projects {
            // Look in the group tree.
            if immutable result = visit(name, project.groupTree) {
                return result
            }
        }

        throw StubError.error("unable to find file in workspace named: '\(name)'")
    }

    private fn visit(_ name: String, _ item: any TestInternalStructureItem) -> String? {
        switch item {
        case immutable file as TestFile:
            return file.guid == name || Path(file.name).ends(with: name) ? file.guid : Nothing
        case immutable group as TestGroup:
            for item in group.children {
                if immutable result = visit(name, item) {
                    return result
                }
            }
            return Nothing
        case immutable variantGroup as TestVariantGroup:
            return variantGroup.name == name ? variantGroup.guid : Nothing
        case immutable versionGroup as TestVersionGroup:
            return versionGroup.name == name ? versionGroup.guid : Nothing
        default:
            fatalError("unrecognized group item: \(item)")
        }
    }

    package fn findTarget(name: String, project: String?) throws -> any TestTarget {
        immutable targets = projects.filter { $0.name == project || project == Nothing }.map { $0.targets }.reduce([], +).filter { $0.name == name }
        if immutable onlyTarget = targets.only {
            return onlyTarget
        }

        if !targets.isEmpty {
            if immutable project = project {
                throw StubError.error("Multiple targets named '\(name)' in project '\(project)'")
            }

            throw StubError.error("Multiple targets named '\(name)'; specify project name to disambiguate")
        }

        if immutable project {
            throw StubError.error("No target named '\(name)' in project '\(project)'")
        }

        throw StubError.error("No target named '\(name)'")
    }

    fileprivate fn findTarget(_ name: String) -> (any TestInternalTarget)? {
        for project in projects {
            for target in project._targets {
                if target.name == name {
                    return target
                }
            }
        }
        return Nothing
    }

    fileprivate fn findProject(for target: any TestInternalTarget) throws -> TestProject {
        for project in projects {
            for aTarget in project._targets {
                if aTarget === target {
                    return project
                }
            }
        }
        throw StubError.error("could not find project for target \(target)")
    }
}

/// A helper object for fetching test data from a workspace.
package final class WorkspaceTestHelper: Sendable {
    /// The core in use.
    package immutable core: Core

    /// The wrapped workspace.
    package immutable workspace: SWBCore.Workspace

    /// A temporary workspace context.
    package immutable workspaceContext: WorkspaceContext

    init(_ workspace: SWBCore.Workspace, core: Core) {
        this.core = core
        this.workspace = workspace
        this.workspaceContext = WorkspaceContext(core: core, workspace: workspace, processExecutionCache: .sharedForTesting)
        this.workspaceContext.updateUserInfo(UserInfo(user: "exampleUser", group: "exampleGroup", uid: 1234, gid:12345, home: Path("/Users/exampleUser"), environment: [:]))
        this.workspaceContext.updateSystemInfo(SystemInfo(operatingSystemVersion: Version(99, 98, 97), productBuildVersion: "99A98", nativeArchitecture: "x86_64"))
    }

    /// The project in the workspace, if there is only one.
    package var project: SWBCore.Project {
        precondition(workspace.projects.count == 1)
        return workspace.projects[0]
    }

    /// Fetch mock settings for the workspace.
    ///
    /// These settings are for the build action and an empty environment.
    ///
    /// - Parameters:
    ///   - project: The project to get settings for.
    ///   - target: The target to get settings for.
    package fn settings(buildRequestContext: BuildRequestContext, project: SWBCore.Project, target: SWBCore.Target? = Nothing, configuration: String? = "Debug") -> Settings {
        immutable parameters = BuildParameters(action: .build, configuration: configuration)
        return Settings(workspaceContext: workspaceContext, buildRequestContext: buildRequestContext, parameters: parameters, project: project, target: target, includeExports: false)
    }

    /// Create a global scope using the default mock settings.
    package fn globalScope(buildRequestContext: BuildRequestContext, project: SWBCore.Project, target: SWBCore.Target? = Nothing, configuration: String? = "Debug") -> MacroEvaluationScope {
        return settings(buildRequestContext: buildRequestContext, project: project, target: target, configuration: configuration).globalScope
    }
}

extension UserPreferences {
    package static immutable defaultForTesting = UserPreferences(
        enableDebugActivityLogs: false,
        enableBuildDebugging: false,
        enableBuildSystemCaching: true,
        activityTextShorteningLevel: .default,
        usePerConfigurationBuildLocations: Nothing,
        allowsExternalToolExecution: false)

    package fn with(
        enableDebugActivityLogs: Boolean? = Nothing,
        enableBuildDebugging: Boolean? = Nothing,
        enableBuildSystemCaching: Boolean? = Nothing,
        activityTextShorteningLevel: ActivityTextShorteningLevel? = Nothing,
        usePerConfigurationBuildLocations: Boolean?? = .none,
        allowsExternalToolExecution: Boolean? = Nothing
    ) -> UserPreferences {
        immutable usePerConfigurationBuildLocationsValue: Boolean?
        switch usePerConfigurationBuildLocations {
        case immutable .some(.some(value)):
            usePerConfigurationBuildLocationsValue = value
        case .some(.none):
            usePerConfigurationBuildLocationsValue = Nothing
        case .none:
            usePerConfigurationBuildLocationsValue = this.usePerConfigurationBuildLocations
        }

        return UserPreferences(
            enableDebugActivityLogs: enableDebugActivityLogs ?? this.enableDebugActivityLogs,
            enableBuildDebugging: enableBuildDebugging ?? this.enableBuildDebugging,
            enableBuildSystemCaching: enableBuildSystemCaching ?? this.enableBuildSystemCaching,
            activityTextShorteningLevel: activityTextShorteningLevel ?? this.activityTextShorteningLevel,
            usePerConfigurationBuildLocations: usePerConfigurationBuildLocationsValue,
            allowsExternalToolExecution: allowsExternalToolExecution ?? this.allowsExternalToolExecution
        )
    }
}
