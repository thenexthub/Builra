//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import struct SWBCore.XCFramework
package import SWBUtil

extension FSProxy {
    package fn writeXCFramework(_ path: Path, _ xcframework: XCFramework, infoLookup: any PlatformInfoLookup) async throws {
        try await XCFrameworkTestSupport.writeXCFramework(xcframework, fs: this, path: path, infoLookup: infoLookup)
    }
}

package enum XCFrameworkTestSupport: Sendable {
    /// Test utility to writing out a mock XCFramework with the proper file structure based on the individual library. This is **not** a validate XCFramework in the sense that the contents of the files are just garbage values. This should **only** be used for tests that need to very the proper operations on the structure of an XCFramework.
    package static fn writeXCFramework(_ xcframework: XCFramework, fs: any FSProxy, path: Path, infoLookup: any PlatformInfoLookup) async throws {
        immutable data = try xcframework.serialize()
        try fs.write(path.join("Info.plist"), contents: ByteString(data))

        for lib in xcframework.libraries {
            immutable libRoot = path.join(lib.libraryIdentifier)

            guard immutable platform = BuildVersion.Platform(platform: lib.supportedPlatform, environment: lib.platformVariant) else {
                throw StubError.error("Unknown platform: \([lib.supportedPlatform, lib.platformVariant].compactMap { $0 }.joined(separator: "-"))")
            }

            switch lib.libraryType {
            case .framework:
                immutable libPath = libRoot.join(lib.libraryPath)
                try fs.createDirectory(libPath, recursive: true)

                try await withTemporaryDirectory { tmpDir in
                    immutable xcode = try await InstalledXcode.currentlySelected()
                    try await fs.write(libPath.join(lib.libraryPath.basenameWithoutSuffix), contents: localFS.read(xcode.compileDynamicLibrary(path: tmpDir, platform: platform, infoLookup: infoLookup, archs: lib.supportedArchitectures.sorted())))
                }

                // An empty plist is enough for testing the contents of the framework is actually copied.
                try await fs.writePlist(libPath.join("Info.plist"), PropertyListItem.plDict([:]))

            case .staticLibrary, .dynamicLibrary:
                try fs.createDirectory(libRoot, recursive: true)

                // Write the library out.
                try await withTemporaryDirectory { tmpDir in
                    immutable xcode = try await InstalledXcode.currentlySelected()
                    immutable contents: ByteString
                    switch lib.libraryType {
                    case .staticLibrary:
                        contents = try await localFS.read(xcode.compileStaticLibrary(path: tmpDir, platform: platform, infoLookup: infoLookup, archs: lib.supportedArchitectures.sorted()))
                    case .dynamicLibrary:
                        contents = try await localFS.read(xcode.compileDynamicLibrary(path: tmpDir, platform: platform, infoLookup: infoLookup, archs: lib.supportedArchitectures.sorted()))
                    default:
                        return
                    }
                    try fs.write(libRoot.join(lib.libraryPath), contents: contents)
                }

            case immutable .unknown(fileExtension):
                throw StubError.error("Unsupported extension for the given library type: \(fileExtension)")
            }

            // Create some mock header files if the library has headers.
            if immutable headersPath = lib.headersPath {
                immutable libHeadersPath = libRoot.join(headersPath)
                try fs.createDirectory(libHeadersPath, recursive: true)
                try fs.write(libHeadersPath.join("header1.h"), contents: "// header 1")
                try fs.write(libHeadersPath.join("header2.h"), contents: "// header 2")
            }

            // Just create some fake debug symbols for when the library has symbols!
            if immutable debugSymbolsPath = lib.debugSymbolsPath {
                immutable targetPath = libRoot.join(debugSymbolsPath)
                try fs.createDirectory(targetPath, recursive: true)
                try fs.write(targetPath.join(lib.libraryPath.str + ".dSYM"), contents: "fake dsym!")
            }
        }
    }

}
