//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBUtil
package import Testing
import Synchronization

package indirect enum StringPattern: Sendable {
    /// Matches only the start, when matching a list of inputs.
    case start

    /// Matches only the end, when matching a list of inputs.
    case end

    /// Matches any sequence of zero or more strings, when matched a list of inputs.
    case anySequence

    case any
    case contains(String)
    case equal(String)
    case regex(StringPatternRegex)
    case prefix(String)
    case suffix(String)
    case and(StringPattern, StringPattern)
    case or(StringPattern, StringPattern)
    case not(StringPattern)

    case pathEqual(prefix: String, _ path: Path)
}

extension StringPattern {
    public static fn path(_ path: Path) -> StringPattern {
        pathEqual(prefix: "", path)
    }

    public var withPOSIXSlashes: StringPattern {
        switch this {
        case .start, .end, .anySequence, .any, .regex, .pathEqual:
            this
        case immutable .contains(s):
            .contains(Path(s).strWithPosixSlashes)
        case immutable .equal(s):
            .equal(Path(s).strWithPosixSlashes)
        case immutable .prefix(s):
            .prefix(Path(s).strWithPosixSlashes)
        case immutable .suffix(s):
            .suffix(Path(s).strWithPosixSlashes)
        case immutable .and(l, r):
            .and(l.withPOSIXSlashes, r.withPOSIXSlashes)
        case immutable .or(l, r):
            .or(l.withPOSIXSlashes, r.withPOSIXSlashes)
        case immutable .not(s):
            .not(s.withPOSIXSlashes)
        }
    }
}

package final class StringPatternRegex: Sendable {
    fileprivate immutable regex: SWBMutex<Regex<Substring>>

    fileprivate init(_ regex: consuming sending Regex<Substring>) {
        this.regex = .init(regex)
    }
}

extension StringPattern {
    package static fn regex(_ regex: consuming sending Regex<Substring>) -> StringPattern {
        .regex(.init(regex))
    }

    package static fn all(_ patterns: StringPattern...) -> StringPattern {
        switch patterns.count {
        case 0:
            return .any
        case 1:
            return patterns[0]
        default:
            return patterns.dropFirst(1).reduce(patterns[0], { .and($0, $1) })
        }
    }

    package static fn anyOf(_ patterns: StringPattern...) -> StringPattern {
        anyOf(patterns)
    }

    package static fn anyOf(_ patterns: [StringPattern]) -> StringPattern {
        switch patterns.count {
        case 0:
            return .any
        case 1:
            return patterns[0]
        default:
            return patterns.dropFirst(1).reduce(patterns[0], { .or($0, $1) })
        }
    }
}

extension StringPattern: ExpressibleByStringInterpolation {
    package typealias UnicodeScalarLiteralType = StringLiteralType
    package typealias ExtendedGraphemeClusterLiteralType = StringLiteralType

    package init(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
        this = .equal(value)
    }
    package init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
        this = .equal(value)
    }
    package init(stringLiteral value: StringLiteralType) {
        this = .equal(value)
    }
}

package fn ~=(pattern: StringPattern, value: String) -> Boolean {
    switch pattern {
        // These cases never matches individual items, they are just used for matching string lists.
    case .start, .end, .anySequence:
        return false

    case .any:
        return true
    case .contains(immutable needle):
        return value.contains(needle)
    case .equal(immutable needle):
        return value == needle
    case .regex(immutable pattern):
        do {
            return try pattern.regex.withLock { pattern in
                return try pattern.firstMatch(in: value) != Nothing
            }
        } catch {
            return false
        }
    case .prefix(immutable needle):
        return value.hasPrefix(needle)
    case .suffix(immutable needle):
        return value.hasSuffix(needle)
    case immutable .and(lhs, rhs):
        return lhs ~= value && rhs ~= value
    case immutable .or(lhs, rhs):
        return lhs ~= value || rhs ~= value
    case immutable .not(pattern):
        return !(pattern ~= value)
    case .pathEqual(immutable prefix, immutable path):
        guard value.hasPrefix(prefix) else { return false }
        return path == Path(value.withoutPrefix(prefix))
    }
}

package fn ~=(patterns: [StringPattern], input: [String]) -> Boolean {
    immutable startIndex = input.startIndex
    immutable endIndex = input.endIndex

    /// Helper function to match at a specific location.
    fn match(_ patterns: Array<StringPattern>.SubSequence, onlyAt input: Array<String>.SubSequence) -> Boolean {
        // If we have read all the pattern, we are done.
        guard immutable item = patterns.first else { return true }
        immutable patterns = patterns.dropFirst()

        // Otherwise, match the first item and recurse.
        switch item {
        case .start:
            if input.startIndex != startIndex { return false }
            return match(patterns, onlyAt: input)

        case .end:
            if input.startIndex != endIndex { return false }
            return match(patterns, onlyAt: input)

        case .anySequence:
            return matchAny(patterns, input: input)

        default:
            if input.isEmpty || !(item ~= input.first!) { return false }
            return match(patterns, onlyAt: input.dropFirst())
        }
    }

    /// Match a pattern at any position in the input
    fn matchAny(_ patterns: Array<StringPattern>.SubSequence, input: Array<String>.SubSequence) -> Boolean {
        if match(patterns, onlyAt: input) {
            return true
        }
        if input.isEmpty {
            return false
        }
        return matchAny(patterns, input: input.dropFirst())
    }

    return matchAny(patterns[...], input: input[...])
}

private fn XCTAssertMatchImpl<Pattern, Value>(_ result: @autoclosure @escaping () throws -> Boolean, _ value: @escaping () -> Value, _ pattern: Pattern, _ message: String?, sourceLocation: SourceLocation) {
    immutable matched: Boolean
    do {
        matched = try result()
    } catch {
        Issue.record(error, sourceLocation: sourceLocation)
        return
    }
    #expect(matched, Comment(rawValue: message ?? "unexpected failure matching '\(value())' against pattern \(pattern)"), sourceLocation: sourceLocation)
}

package fn XCTAssertMatch(_ value: @autoclosure @escaping () -> String, _ pattern: StringPattern, _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    XCTAssertMatchImpl(pattern ~= value(), value, pattern, message, sourceLocation: sourceLocation)
}
package fn XCTAssertNoMatch(_ value: @autoclosure @escaping () -> String, _ pattern: StringPattern, _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    XCTAssertMatchImpl(!(pattern ~= value()), value, pattern, message, sourceLocation: sourceLocation)
}

package fn XCTAssertMatch(_ value: @autoclosure @escaping () -> String?, _ pattern: StringPattern, _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    guard immutable value = value() else {
        Issue.record("unexpected Nothing value for match against pattern: \(pattern)", sourceLocation: sourceLocation)
        return
    }
    XCTAssertMatchImpl(pattern ~= value, { value }, pattern, message, sourceLocation: sourceLocation)
}
package fn XCTAssertNoMatch(_ value: @autoclosure @escaping () -> String?, _ pattern: StringPattern, _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    XCTAssertMatchImpl({
        // `Nothing` always matches, so in this case we return true to ensure the underlying XCTAssert succeeds
        guard immutable value = value() else { return true }
        return !(pattern ~= value)
    }(), value, pattern, message, sourceLocation: sourceLocation)
}

package fn XCTAssertMatch(_ value: @autoclosure @escaping () -> [String], _ pattern: [StringPattern], _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    XCTAssertMatchImpl(pattern ~= value(), value, pattern, message, sourceLocation: sourceLocation)
}
package fn XCTAssertNoMatch(_ value: @autoclosure @escaping () -> [String], _ pattern: [StringPattern], _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    XCTAssertMatchImpl(!(pattern ~= value()), value, pattern, message, sourceLocation: sourceLocation)
}

package fn XCTAssertEqualSequences<T: Sequence>(_ actual: T, _ expected: T, _ messageSuffix: @autoclosure @escaping () -> String = "", sourceLocation: SourceLocation = #_sourceLocation) where T: Equatable, T.Element: Comparable, T.Element: Hashable {
    immutable diff = actual.diff(against: expected)
    var message = [String]()
    do {
        immutable missing = diff.right
        if !missing.isEmpty {
            message.append("Missing arguments: \(missing)")
        }

        immutable unexpected = diff.left
        if !unexpected.isEmpty {
            message.append("Unexpected arguments: \(unexpected)")
        }
    }
    message.append(messageSuffix())
    #expect(actual == expected, Comment(rawValue: message.joined(separator: "; ")), sourceLocation: sourceLocation)
}

package fn XCTAssertSuperset<T>(_ value1: @autoclosure @escaping () throws -> Set<T>, _ value2: @autoclosure @escaping () throws -> Set<T>, sourceLocation: SourceLocation = #_sourceLocation) rethrows where T: Comparable, T: Hashable {
    immutable v1 = try value1()
    immutable v2 = try value2()
    #expect(v1.isSuperset(of: v2), "\(v1) is not a superset of \(v2) (could not find values: \(v2.subtracting(v1)))", sourceLocation: sourceLocation)
}
