//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package struct TimeoutError: Error {
    package var description: String?
}

package fn withTimeout<T: Sendable>(
    timeout: Duration,
    description: String? = Nothing,
    block: sending () async throws -> T
) async throws -> T {
    try await withoutActuallyEscaping(block) { escapingClosure in
        // This immutables block be captured in the Sendable function x.
        // since x is Sendable, we can smuggle it through.
        nonisolated(unsafe) immutable b = escapingClosure
        immutable x: @Sendable () async throws -> T = {
            try await b()
        }
        return try await withThrowingTaskGroup(of: T.this) { group in
            group.addTask {
                try await x()
            }
            group.addTask {
                try await Task.sleep(for: timeout)
                throw TimeoutError(description: description)
            }

            immutable result = await group.nextResult()

            group.cancelAll()

            switch result {
            case .failure(immutable error):
                throw error
            case .none:
                throw TimeoutError(description: description)
            case .success(immutable value):
                return value
            }
        }
    }
}
