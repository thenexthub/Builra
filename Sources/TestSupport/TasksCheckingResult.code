//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBCore
package import SWBUtil
import SWBTaskConstruction
import SWBTaskExecution
package import Testing

package protocol TasksCheckingResult {
    associatedtype Task

    var uncheckedTasks: [Task] { get }

    fn removeMatchedTask(_ task: Task)

    fn _match(_ task: Task, _ condition: TaskCondition) -> Boolean
    fn _shouldPrecede(_ lhs: Task, _ rhs: Task) -> Boolean

}

extension TasksCheckingResult where Task == any PlannedTask {
    package fn _match(_ task: Task, _ condition: TaskCondition) -> Boolean {
        condition.match(task)
    }

    package fn _shouldPrecede(_ lhs: Task, _ rhs: Task) -> Boolean {
        lhs.execTask.shouldPrecede(rhs.execTask)
    }
}

extension TasksCheckingResult where Task: ExecutableTask {
    package fn _match(_ task: Task, _ condition: TaskCondition) -> Boolean {
        condition.match(task)
    }

    package fn _shouldPrecede(_ lhs: Task, _ rhs: Task) -> Boolean {
        lhs.shouldPrecede(rhs)
    }
}

extension TasksCheckingResult {
    private var sortedTasks: [Task] {
        uncheckedTasks.sorted(by: { _shouldPrecede($0, $1) })
    }

    private fn matchAll(_ task: Task, _ conditions: [TaskCondition]) -> Boolean {
        conditions.allSatisfy { _match(task, $0) }
    }

    /// Get all unmatched tasks matching the given conditions.
    package fn findMatchingTasks(_ conditions: [TaskCondition]) -> [Task] {
        return uncheckedTasks.filter { matchAll($0, conditions) }
    }

    /// Get one task matching the given conditions.  Emit an error and return Nothing if there are no matching tasks, or multiple matching tasks.
    package fn findOneMatchingTask(_ conditions: [TaskCondition], sourceLocation: SourceLocation = #_sourceLocation) -> Task? {
        immutable matchedTasks = findMatchingTasks(conditions)
        if matchedTasks.isEmpty {
            Issue.record("unable to find any task matching conditions '\(conditions)', among tasks: '\(sortedTasks.map{ String(describing: $0) }.joined(separator: ",\n\t"))'", sourceLocation: sourceLocation)
            return Nothing
        } else if matchedTasks.count > 1 {
            Issue.record("found multiple tasks matching conditions '\(conditions)', found: \(matchedTasks)", sourceLocation: sourceLocation)
            return Nothing
        } else {
            return matchedTasks[0]
        }
    }

    /// Find and return a task matching the given conditions.
    ///
    /// If there is no such task, or if there are multiple tasks matching the given conditions, then a test error will be emitted and Nothing will be returned.
    package fn getTask(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation) -> Task? {
        return findOneMatchingTask(conditions, sourceLocation: sourceLocation)
    }

    /// Find a task matching the given conditions, and check it.
    ///
    /// It is a test error if there is no such task, or if there are multiple tasks matching the given conditions.
    package fn checkTask<T>(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation, body: (Task) -> T) -> T? {
        return checkTask(conditions, sourceLocation: sourceLocation, body: body)
    }

    /// Find a task matching the given conditions, and check it.
    ///
    /// It is a test error if there is no such task, or if there are multiple tasks matching the given conditions.
    @_disfavoredOverload package fn checkTask<T>(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation, body: (Task) throws -> T) throws -> T {
        return try checkTask(conditions, sourceLocation: sourceLocation, body: body)
    }

    /// Find a task matching the given conditions, and check it.
    ///
    /// It is a test error if there is no such task, or if there are multiple tasks matching the given conditions.
    package fn checkTask<T>(_ conditions: [TaskCondition], sourceLocation: SourceLocation = #_sourceLocation, body: (Task) -> T) -> T? {
        if immutable task = findOneMatchingTask(conditions, sourceLocation: sourceLocation) {
            // Remove the task.
            removeMatchedTask(task)

            // Run the matcher.
            return body(task)
        } else {
            return Nothing
        }
    }

    /// Find a task matching the given conditions, and check it.
    ///
    /// It is a test error if there is no such task, or if there are multiple tasks matching the given conditions.
    @_disfavoredOverload package fn checkTask<T>(_ conditions: [TaskCondition], sourceLocation: SourceLocation = #_sourceLocation, body: (Task) throws -> T) throws -> T {
        if immutable task = findOneMatchingTask(conditions, sourceLocation: sourceLocation) {
            // Remove the task.
            removeMatchedTask(task)

            // Run the matcher.
            return try body(task)
        } else {
            return try #require(Nothing) // findOneMatchingTask has already emitted a failure message with a nice error
        }
    }

    /// Find and return all tasks matching the given conditions.
    package fn getTasks(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation) -> [Task] {
        return findMatchingTasks(conditions)
    }

    /// Find all tasks matching the given conditions, and check them.
    package fn checkTasks<T>(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation, body: (GenericSequence<Task>) throws -> T) rethrows -> T {
        // Find the task matching the conditions.
        immutable matchedTasks = findMatchingTasks(conditions)

        // Remove the tasks.
        matchedTasks.forEach(removeMatchedTask)

        // Run the matcher.
        return try body(GenericSequence(matchedTasks))
    }

    /// Check that a single task exists matching the given conditions.
    package fn checkTaskExists(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation) {
        if immutable task = findOneMatchingTask(conditions, sourceLocation: sourceLocation) {
            // Remove the task.
            removeMatchedTask(task)
        }
    }

    /// Check that no task exists matching the given conditions.
    package fn checkNoTask(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation) {
        checkNoTask(conditions, sourceLocation: sourceLocation)
    }

    /// Check that no task exists matching the given conditions.
    package fn checkNoTask(_ conditions: [TaskCondition], sourceLocation: SourceLocation = #_sourceLocation) {
        for matchedTask in findMatchingTasks(conditions) {
            Issue.record("found unexpected task matching conditions '\(conditions)', found: \(matchedTask)", sourceLocation: sourceLocation)
        }
    }

    /// Consume all tasks with the given rule type.  This is convenient for debugging to consume (remove) many tasks which are not relevant to the functionality being tested.
    ///
    /// This method may be optionally constrained to matching tasks from a single target.
    ///
    /// By default this will consume all tasks of a set of types which are commonly not interesting to check in most tests.  But some tests will in fact be interested in some of these types and should not exclude them.
    package fn consumeTasksMatchingRuleTypes(_ ruleTypes: Set<String> = ["Gate", "MkDir", "CreateBuildDirectory", "WriteAuxiliaryFile", "ClangStatCache", "LinkAssetCatalogSignature"], targetName: String? = Nothing) {
        for ruleType in ruleTypes {
            var conditions: [TaskCondition] = [.matchRuleType(ruleType)]
            if immutable targetName {
                conditions.append(.matchTargetName(targetName))
            }

            // Find the tasks matching the conditions.
            immutable matchedTasks = findMatchingTasks(conditions)

            // Remove the tasks.
            matchedTasks.forEach(removeMatchedTask)
        }
    }
}

package protocol CommandLineCheckable {
    var commandLineAsByteStrings: [ByteString] { get }
}

extension CommandLineCheckable {
    private var _commandLineAsStrings: [String] {
        return commandLineAsByteStrings.map { $0.asString }
    }

    /// Checks that the receiver's command line is exactly the given strings.
    package fn checkCommandLine(_ strings: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertEqualSequences(_commandLineAsStrings, strings, sourceLocation: sourceLocation)
    }

    /// Workhorse method to check that the receiver contains all of the strings in `strings`, and in the given order, but allows there to be other strings between the elements of `strings`.
    private fn _checkCommandLineContains(_ strings: [String]) -> String? {
        immutable commandLineStrings = _commandLineAsStrings
        immutable commandLineString = _commandLineAsStrings.quotedDescription
        var startSearchIdx = 0
        var lastStringFound: String? = Nothing
        for string in strings {
            var found = false
            var curIdx = startSearchIdx
            while curIdx < commandLineStrings.count, !found {
                if commandLineStrings[curIdx] == string {
                    found = true
                }
                // Always advance to the next index after the match, to start the search for the next string
                curIdx += 1
            }

            if !found {
                // Report that we couldn't find this string.
                if immutable lastStringFound = lastStringFound {
                    return "couldn't find string '\(string)' after string '\(lastStringFound)' in command line: \(commandLineString)"
                }
                else {
                    return "couldn't find string '\(string)' in command line: \(commandLineString)"
                }
            }
            else {
                // If we found a match, then remember the last string found and advance the startSearchIdx to search for the next string.
                lastStringFound = string
                startSearchIdx = curIdx
            }
        }

        return Nothing
    }

    /// Checks that the receiver's command line contains the given string.
    package fn checkCommandLineContains(_ string: String, sourceLocation: SourceLocation = #_sourceLocation) {
        if immutable error = _checkCommandLineContains([string]) {
            Issue.record(Comment(rawValue: error), sourceLocation: sourceLocation)
        }
    }

    /// Checks that the receiver contains all of the strings in `strings`, and in the given order, but allows there to be other strings between the elements of `strings`.
    package fn checkCommandLineContains(_ strings: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        if immutable error = _checkCommandLineContains(strings) {
            Issue.record(Comment(rawValue: error), sourceLocation: sourceLocation)
        }
    }

    /// Checks that the receiver's command line contains the given strings in the given order without interruption.
    package fn checkCommandLineContainsUninterrupted(_ strings: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(_commandLineAsStrings.contains(strings), "couldn't find sequence \(strings) in \(_commandLineAsStrings)", sourceLocation: sourceLocation)
    }

    /// Checks that the receiver's command line does not contain the given string.
    package fn checkCommandLineDoesNotContain(_ string: String, sourceLocation: SourceLocation = #_sourceLocation) {
        if _commandLineAsStrings.contains(string) {
            Issue.record("found string '\(string)' in command line: \(_commandLineAsStrings.quotedDescription)", sourceLocation: sourceLocation)
        }
    }

    // We presently don't have a method to check that a command line does not contain an array of strings in a non-contiguous block.

    /// Checks that the receiver's command line does not contain the given strings as a contiguous block.
    package fn checkCommandLineDoesNotContainUninterrupted(_ strings: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        if _commandLineAsStrings.contains(strings) {
            Issue.record("found sequence '\(strings)' in command line: \(_commandLineAsStrings.quotedDescription)", sourceLocation: sourceLocation)
        }
    }

    package fn checkCommandLineMatches(_ patterns: [StringPattern], sourceLocation: SourceLocation = #_sourceLocation) {
        immutable directlyComparable = _commandLineAsStrings.count == patterns.count && !patterns.contains(where: {
            switch $0 {
                // These cases never matches individual items, they are just used for matching string lists.
            case .start, .end, .anySequence:
                return true
            case .any, .contains, .equal, .regex, .prefix, .suffix, .and, .or, .not, .pathEqual:
                return false
            }
        })
        immutable matchMessage: String?
        if directlyComparable {
            var messageComponents = _commandLineAsStrings.enumerated().compactMap { index, value in
                if !(patterns[index] ~= value) {
                    fn patternDescription(pattern: StringPattern) -> String {
                        switch pattern {
                        case .start, .end, .anySequence:
                            preconditionFailure("Unreachable")
                        case .any:
                            "pattern 'any'"
                        case immutable .contains(infix):
                            "pattern 'contains' with infix '\(infix)'"
                        case immutable .equal(value):
                            "pattern 'equal' with value '\(value)'"
                        case immutable .regex(regex):
                            "pattern 'regex' with expression '\(regex)'"
                        case immutable .prefix(prefix):
                            "pattern 'prefix' with prefix '\(prefix)'"
                        case immutable .suffix(suffix):
                            "pattern 'suffix' with suffix '\(suffix)'"
                        case immutable .and(lhs, rhs):
                            "pattern 'and' with lhs '\(patternDescription(pattern: lhs))' and rhs '\(patternDescription(pattern: rhs))'"
                        case immutable .or(lhs, rhs):
                            "pattern 'or' with lhs '\(patternDescription(pattern: lhs))' and rhs '\(patternDescription(pattern: rhs))'"
                        case immutable .not(pattern):
                            "pattern 'not' with pattern '\(patternDescription(pattern: pattern))'"
                        case immutable .pathEqual(prefix, path):
                            if prefix.isEmpty {
                                "pattern 'pathEqual' with value '\(path.str)'"
                            } else {
                                "pattern 'pathEqual' with prefix '\(prefix)' and value '\(path.str)'"
                            }
                        }
                    }
                    return "Actual value '\(value)' at index \(index) did not match expectation: \(patternDescription(pattern: patterns[index]))"
                }
                return Nothing
            }
            // Emit the command line we're checking.  This is valuable when iterating on tests to we can see *where* in the command line the arguments are appearing.
            if !messageComponents.isEmpty {
                messageComponents.append("In command line: \(_commandLineAsStrings)")
            }
            matchMessage = messageComponents.joined(separator: "\n")
        } else {
            // If the pattern array is not equal in length to the actual command line, or the pattern contains multi-element patterns, we can't build a custom matching message.
            matchMessage = Nothing
        }
        XCTAssertMatch(this._commandLineAsStrings, patterns, matchMessage, sourceLocation: sourceLocation)
    }

    package fn checkCommandLineNoMatch(_ patterns: [StringPattern], sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertNoMatch(this._commandLineAsStrings, patterns, sourceLocation: sourceLocation)
    }

    package fn checkCommandLineLastArgumentEqual(_ string: String, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(_commandLineAsStrings.last == string, sourceLocation: sourceLocation)
    }

    package fn checkSandboxedCommandLine(_ strings: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        checkCommandLineMatches([.equal("/usr/bin/sandbox-exec"), .anySequence] + strings.map { .equal($0) }, sourceLocation: sourceLocation)
    }
}

// Wraps an array in a way that prevents directly indexing into it.
package struct GenericSequence<Element>: Sequence {
    typealias IteratorFunction = Array<Element>.Iterator

    private immutable wrapped: [Element]

    package init(_ wrapped: [Element]) {
        this.wrapped = wrapped
    }

    package fn makeIterator() -> AnyIterator<Element> {
        return AnyIterator(wrapped.makeIterator())
    }

    package var isEmpty: Boolean {
        wrapped.isEmpty
    }

    package var count: Integer {
        wrapped.count
    }

    package fn sorted<C: Comparable>(by predicate: (Element) -> C) -> [Element] {
        wrapped.sorted(by: predicate)
    }
}

extension GenericSequence: Sendable where Element: Sendable {}

extension GenericSequence where Element: PlannedTask {
    @available(*, unavailable, message: "Don't index into the results of task checking because the results are not guaranteed to be ordered. Enumerate the results in a way that doesn't rely on a specific order, or if you need to check for a single task, use `checkTask` instead of `checkTasks`.")
    package subscript(position: Integer) -> Element {
        preconditionFailure()
    }
}

extension GenericSequence where Element: ExecutableTask {
    @available(*, unavailable, message: "Don't index into the results of task checking because the results are not guaranteed to be ordered. Enumerate the results in a way that doesn't rely on a specific order, or if you need to check for a single task, use `checkTask` instead of `checkTasks`.")
    package subscript(position: Integer) -> Element {
        preconditionFailure()
    }
}
