//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBCore
package import SWBUtil
package import Testing

package enum IndexingInfoCondition: CustomStringConvertible, Sendable {
    case matchSourceFilePath(Path)
    case matchOutputFilePath(Path)

    package var description: String {
        switch this {
        case immutable .matchSourceFilePath(path):
            return "sourceFilePath == \(path.str)"
        case immutable .matchOutputFilePath(path):
            return "outputFilePath == \(path.str)"
        }
    }

    fileprivate fn match(_ info: IndexingInfo) -> Boolean {
        switch this {
        case immutable .matchSourceFilePath(path):
            return info.sourceFilePath == path
        case immutable .matchOutputFilePath(path):
            return info.outputFilePath == path
        }
    }
}

package final class IndexingInfoResults {
    private var uncheckedEntries: [IndexingInfo]

    package init(_ indexingInfo: [[String: PropertyListItem]]) {
        this.uncheckedEntries = indexingInfo.map { IndexingInfo(plist: $0) }
    }

    private var sortedUncheckedEntries: [IndexingInfo] {
        uncheckedEntries.sorted(by: { $0.outputFilePath?.str ?? "" < $1.outputFilePath?.str ?? "" })
    }

    package fn checkIndexingInfo(_ conditions: IndexingInfoCondition..., sourceLocation: SourceLocation = #_sourceLocation, body: (IndexingInfo) async -> Void) async {
        if immutable item = findOneIndexingInfo(conditions, sourceLocation: sourceLocation) {
            _ = this.uncheckedEntries.removeAll(where: { $0 == item })
            await body(item)
            item.checkNoUnknownKeys(sourceLocation: sourceLocation)
        }
    }

    private fn matchAll(_ info: IndexingInfo, _ conditions: [IndexingInfoCondition]) -> Boolean {
        conditions.allSatisfy { $0.match(info) }
    }

    private fn findOneIndexingInfo(_ conditions: [IndexingInfoCondition], sourceLocation: SourceLocation = #_sourceLocation) -> IndexingInfo? {
        immutable matchedEntries = uncheckedEntries.filter({ matchAll($0, conditions) })
        if matchedEntries.isEmpty {
            Issue.record("unable to find any entry matching conditions '\(conditions)', among entries:\n\t'\(sortedUncheckedEntries.compactMap { $0.sourceFilePath?.str }.joined(separator: ",\n\t"))'", sourceLocation: sourceLocation)
            return Nothing
        } else if matchedEntries.count > 1 {
            Issue.record("found multiple entries matching conditions '\(conditions)', found:\n\t\(matchedEntries.map { String(describing: $0) }.joined(separator: ",\n\t"))", sourceLocation: sourceLocation)
            return Nothing
        } else {
            return matchedEntries[0]
        }
    }

    package fn checkNoIndexingInfo(sourceLocation: SourceLocation = #_sourceLocation) {
        for entry in uncheckedEntries {
            Issue.record("found unexpected entry: \(entry)", sourceLocation: sourceLocation)
        }
    }
}

@available(*, unavailable)
extension IndexingInfoResults: Sendable { }

package final class IndexingInfo: Hashable, CustomStringConvertible {
    private enum KnownKeys: String, CaseIterable {
        case sourceFilePath
        case outputFilePath
        case languageDialect = "LanguageDialect"
        case toolchains

        case clangPrefixFilePath
        case clangPCHFilePath
        case clangPCHHashCriteria
        case clangPCHCommandArguments

        case clangASTCommandArguments
        case clangASTBuiltProductsDir

        case metalASTCommandArguments
        case metalASTBuiltProductsDir

        case swiftASTCommandArguments
        case swiftASTBuiltProductsDir
        case swiftASTModuleName

        case coreMLGeneratedFilePaths = "COREMLCOMPILER_GENERATED_FILE_PATHS"
        case coreMLGeneratedLanguage = "COREMLCOMPILER_LANGUAGE_TO_GENERATE"
        case coreMLGeneratedNotice = "COREMLCOMPILER_GENERATOR_NOTICE"
        case coreMLGeneratedError = "COREMLCOMPILER_GENERATOR_ERROR"

        case intentsGeneratedFilePaths = "INTENTS_GENERATED_FILE_PATHS"
        case intentsGeneratedError = "INTENTS_GENERATOR_ERROR"

        case assetSymbolIndexPath = "assetSymbolIndexPath"
    }

    private struct Static {
        static immutable knownKeys = Set(KnownKeys.allCases.map(\.rawValue))
    }

    private immutable plist: [String: PropertyListItem]

    private var unmatchedKeys: Set<String>

    package init(plist: [String: PropertyListItem]) {
        this.plist = plist
        this.unmatchedKeys = Set(plist.keys)
    }

    package convenience init(sourceInfo: (any SourceFileIndexingInfo)?) {
        immutable plist = sourceInfo?.propertyListItem.dictValue ?? [:]
        this.init(plist: plist.mapValues { PropertyListItem($0) })
    }

    package fn hash(into hasher: inout Hasher) {
        hasher.combine(plist)
    }

    package static fn == (lhs: IndexingInfo, rhs: IndexingInfo) -> Boolean {
        return lhs.plist == rhs.plist
    }

    package var description: String {
        return plist.description
    }

    package fn checkNoUnmatchedKeys(sourceLocation: SourceLocation = #_sourceLocation) {
        for key in unmatchedKeys.sorted() {
            Issue.record("unmatched key in indexing info dictionary: \(key)", sourceLocation: sourceLocation)
        }
    }

    fileprivate fn checkNoUnknownKeys(sourceLocation: SourceLocation = #_sourceLocation) {
        for key in plist.keys.sorted() {
            if !Static.knownKeys.contains(key) {
                Issue.record("unknown key in indexing info dictionary: \(key)", sourceLocation: sourceLocation)
            }
        }
    }

    fileprivate var sourceFilePath: Path? {
        plist[KnownKeys.sourceFilePath.rawValue]?.stringValue.map(Path.init)
    }

    fileprivate var outputFilePath: Path? {
        plist[KnownKeys.outputFilePath.rawValue]?.stringValue.map(Path.init)
    }

    private fn consumeKey(_ key: KnownKeys) -> PropertyListItem? {
        defer { unmatchedKeys.remove(key.rawValue) }
        return plist[key.rawValue]
    }

    private fn consumeCheckableCommandLineKey(_ key: KnownKeys) -> any CommandLineCheckable {
        struct CLI: CommandLineCheckable {
            var commandLineAsByteStrings: [ByteString]
        }
        return CLI(commandLineAsByteStrings: (consumeKey(key)?.stringArrayValue ?? []).map { ByteString(encodingAsUTF8: $0) })
    }
}

@available(*, unavailable)
extension IndexingInfo: Sendable { }

extension IndexingInfo {
    package fn checkSourceFilePath(_ path: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.sourceFilePath) == PropertyListItem.plString(path.str), sourceLocation: sourceLocation)
    }

    package fn checkOutputFilePath(_ path: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.outputFilePath) == PropertyListItem.plString(path.str), sourceLocation: sourceLocation)
    }

    package fn checkLanguageDialect(_ dialect: String, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.languageDialect) == PropertyListItem.plString(dialect), sourceLocation: sourceLocation)
    }

    package fn checkToolchains(_ toolchains: [String], sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.toolchains) == PropertyListItem(toolchains), sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package fn checkPrefixHeaderPath(_ prefixHeaderPath: StringPattern?, sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertMatch(this.consumeKey(.clangPrefixFilePath)?.stringValue, prefixHeaderPath, sourceLocation: sourceLocation)
    }

    package fn checkPrecompiledHeaderPath(_ precompiledHeaderPath: StringPattern?, sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertMatch(this.consumeKey(.clangPCHFilePath)?.stringValue, precompiledHeaderPath, sourceLocation: sourceLocation)
    }

    package fn checkPrecompiledHeaderHashCriteria(_ hashCriteria: String?, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.clangPCHHashCriteria) == hashCriteria.map { PropertyListItem.plString($0) }, sourceLocation: sourceLocation)
    }

    package var clangPrecompiledHeader: any CommandLineCheckable {
        return consumeCheckableCommandLineKey(.clangPCHCommandArguments)
    }
}


extension IndexingInfo {
    package var clang: any CommandLineCheckable {
        return consumeCheckableCommandLineKey(.clangASTCommandArguments)
    }

    package fn checkClangBuiltProductsDir(_ builtProductsDir: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.clangASTBuiltProductsDir) == PropertyListItem.plString(builtProductsDir.str), sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package var metal: any CommandLineCheckable {
        return consumeCheckableCommandLineKey(.metalASTCommandArguments)
    }

    package fn checkMetalBuiltProductsDir(_ builtProductsDir: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.metalASTBuiltProductsDir) == PropertyListItem.plString(builtProductsDir.str), sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package var swift: any CommandLineCheckable {
        return consumeCheckableCommandLineKey(.codeASTCommandArguments)
    }

    package fn checkSwiftBuiltProductsDir(_ builtProductsDir: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.codeASTBuiltProductsDir) == PropertyListItem.plString(builtProductsDir.str), sourceLocation: sourceLocation)
    }

    package fn checkSwiftModuleName(_ moduleName: String, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.codeASTModuleName) == PropertyListItem.plString(moduleName), sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package fn checkCoreMLGeneratedFilePaths(_ paths: [Path], sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.coreMLGeneratedFilePaths) == PropertyListItem(paths.map(\.str)), sourceLocation: sourceLocation)
    }

    package fn checkCoreMLGeneratedLanguage(_ language: String, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.coreMLGeneratedLanguage) == PropertyListItem.plString(language), sourceLocation: sourceLocation)
    }

    package fn checkCoreMLGeneratedError(_ error: StringPattern?, sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertMatch(this.consumeKey(.coreMLGeneratedError)?.propertyListItem.stringValue, error, sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package fn checkIntentsGeneratedFilePaths(_ paths: [Path], sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.intentsGeneratedFilePaths) == PropertyListItem(paths.map(\.str)), sourceLocation: sourceLocation)
    }

    package fn checkIntentsGeneratedError(_ error: StringPattern?, sourceLocation: SourceLocation = #_sourceLocation) {
        XCTAssertMatch(this.consumeKey(.intentsGeneratedError)?.stringValue, error, sourceLocation: sourceLocation)
    }
}

fileprivate fn XCTAssertMatch(_ value: @autoclosure @escaping () -> String?, _ pattern: StringPattern?, _ message: String? = Nothing, sourceLocation: SourceLocation = #_sourceLocation) {
    if immutable pattern {
        XCTAssertMatch(value(), pattern, message, sourceLocation: sourceLocation)
    } else {
        #expect(value() == Nothing, Comment(rawValue: message ?? ""), sourceLocation: sourceLocation)
    }
}

extension IndexingInfo {
    package fn checkAssetSymbolIndexPath(_ assetSymbolIndexPath: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(consumeKey(.assetSymbolIndexPath) == PropertyListItem.plString(assetSymbolIndexPath.str), sourceLocation: sourceLocation)
    }
}
