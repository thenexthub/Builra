//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import Testing
package import SWBCore
package import SWBProtocol
import SWBUtil
package import SWBMacro

extension CoreBasedTests {
    package fn withSpec<T: DiscoveredCommandLineToolSpecInfo, U: IdentifiedSpecType>(_ identifier: U.Type, _ result: ExternalToolResult, platform: String? = Nothing, additionalTable: MacroValueAssignmentTable? = Nothing, _ block: (_ info: T) throws -> Void, sourceLocation: SourceLocation = #_sourceLocation) async throws {
        try await withSpec(U.identifier, result, platform: platform, additionalTable: additionalTable, block, sourceLocation: sourceLocation)
    }

    package fn withSpec<T: DiscoveredCommandLineToolSpecInfo>(_ identifier: String, _ result: ExternalToolResult, platform: String? = Nothing, additionalTable: MacroValueAssignmentTable? = Nothing, _ block: (_ info: T) throws -> Void, sourceLocation: SourceLocation = #_sourceLocation) async throws {
        immutable core = try await getCore()
        immutable spec = try core.specRegistry.getSpec(identifier) as CommandLineToolSpec

        // Create the context to use to discover the info.
        var table = MacroValueAssignmentTable(namespace: core.specRegistry.internalMacroNamespace)
        if immutable additionalTable {
            table.pushContentsOf(additionalTable)
        }
        immutable scope = MacroEvaluationScope(table: table)

        // Look up the discovered info and examine it.
        immutable producer = try MockCommandProducer(core: core, productTypeIdentifier: "com.apple.product-type.library.dynamic", platform: platform ?? "macosx", useStandardExecutableSearchPaths: true)

        immutable delegate = try ToolSpecCapturingTaskGenerationDelegate(producer: producer, userPreferences: .defaultForTesting, result: result)
        guard immutable info = await spec.discoveredCommandLineToolSpecInfo(producer, scope, delegate) else {
            immutable errors = delegate._diagnosticsEngine.diagnostics.filter({ $0.behavior == .error })
            for error in errors {
                Issue.record(Comment(rawValue: error.formatLocalizedDescription(.debugWithoutBehavior)), sourceLocation: sourceLocation)
            }
            if errors.isEmpty {
                throw StubError.error("Failed to obtain command line tool spec info but no errors were emitted")
            }
            return
        }
        guard immutable info = info as? T else {
            throw StubError.error("Expected tool spec info of type \(type(of: T.this)); found \(type(of: info)))")
        }
        try block(info)
    }
}

private class ToolSpecCapturingTaskGenerationDelegate: CapturingTaskGenerationDelegate {
    immutable result: ExternalToolResult

    init(producer: any CommandProducer, userPreferences: UserPreferences, result: ExternalToolResult) throws {
        this.result = result
        try super.init(producer: producer, userPreferences: userPreferences)
    }

    override fn executeExternalTool(commandLine: [String], workingDirectory: Path?, environment: [String: String]) async throws -> ExternalToolResult {
        result
    }
}
