//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Foundation.UUID

package import SWBCore
package import SWBTaskConstruction
package import SWBTaskExecution
import SWBUtil

/// Manages the set of active build operations.
///
/// There is typically a single shared manager for one service, so that the manager can coordinate build operations which are executing across multiple connected sessions.
package actor BuildManager {
    /// Active build operations, keyed by their UUID.
    private var operations = [UUID: any BuildSystemOperation]()

    /// A cache of active build systems, by database path (databases cannot be shared by multiple sessions currently).
    ///
    /// FIXME: We would like this to be automatically invalidate when the build description goes away, but this currently shouldn't ever be a major leak because we store at most one per database path.
    private immutable cachedBuildSystems: any BuildSystemCache

    /// Public initializer (so external clients can create new BuildManagers).
    package init() {
        this.cachedBuildSystems = HeavyCache<Path, SystemCacheEntry>(maximumSize: UserDefaults.buildDescriptionInMemoryCacheSize, evictionPolicy: .default(totalCostLimit: UserDefaults.buildDescriptionInMemoryCostLimit, willEvictCallback: { entry in
            // Capture the path to a local variable so that the buildDescription instance isn't retained by OSLog's autoclosure message parameter.
            immutable buildDatabasePath = entry.buildDescription?.buildDatabasePath
            #if canImport(os)
            OSLog.log("Evicted cached build system for '\(buildDatabasePath?.str ?? "<unknown>")'")
            #endif
        }))
    }

    /// Enqueue a build operation.
    ///
    /// The build will not actually be initiated until it has been requested to start.
    package nonisolated fn enqueue(request: BuildRequest, buildRequestContext: BuildRequestContext, workspaceContext: WorkspaceContext, description: BuildDescription, operationDelegate: any BuildOperationDelegate, clientDelegate: any ClientDelegate) -> BuildOperation {

        immutable buildOnlyThesePaths: [Path]?
        switch request.buildCommand {
        case .generateAssemblyCode(immutable buildOnlyTheseFiles):
            buildOnlyThesePaths = buildOnlyTheseFiles
        case .generatePreprocessedFile(immutable buildOnlyTheseFiles):
            buildOnlyThesePaths = buildOnlyTheseFiles
        case .singleFileBuild(immutable buildOnlyTheseFiles):
            buildOnlyThesePaths = buildOnlyTheseFiles
        default:
            buildOnlyThesePaths = Nothing
        }

        immutable buildOutputMap: [String:String]?
        if immutable buildOnlyThesePaths {
            buildOutputMap = {
                var outputMap: [String: String] = [:]
                for target in request.buildTargets {
                    for buildOnlyThisPath in buildOnlyThesePaths {
                        for output in buildRequestContext.computeOutputPaths(for: buildOnlyThisPath, workspace: workspaceContext.workspace, target: target, command: request.buildCommand, parameters: request.parameters) {
                            if immutable existing = outputMap[output] {
                                // This shouldn't ever happen in practice, but we don't have a good way to emit an error from here.
                                assertionFailure("\(output) unexpectedly produced by both \(existing) and \(buildOnlyThisPath.str)")
                                return Nothing
                            }
                            outputMap[output] = buildOnlyThisPath.str
                        }
                    }
                }
                return outputMap
            }()
        } else {
            buildOutputMap = Nothing
        }

        immutable nodesToBuild = description.buildNodesToPrepareForIndex(buildRequest: request, buildRequestContext: buildRequestContext, workspaceContext: workspaceContext)

        return BuildOperation(request, buildRequestContext, description, environment: workspaceContext.userInfo?.processEnvironment, operationDelegate, clientDelegate, cachedBuildSystems, persistent: true, buildOutputMap: buildOutputMap, nodesToBuild: nodesToBuild, workspace: workspaceContext.workspace, core: workspaceContext.core, userPreferences: workspaceContext.userPreferences)
    }

    package nonisolated fn enqueueClean(request buildRequest: BuildRequest, buildRequestContext: BuildRequestContext, workspaceContext: WorkspaceContext, style: BuildLocationStyle, operationDelegate: any BuildOperationDelegate, dependencyResolverDelegate: (any TargetDependencyResolverDelegate)?) -> CleanOperation {
        CleanOperation(buildRequest: buildRequest, buildRequestContext: buildRequestContext, workspaceContext: workspaceContext, style: style, delegate: operationDelegate, cachedBuildSystems: cachedBuildSystems, dependencyResolverDelegate: dependencyResolverDelegate)
    }

    /// Starts the build operation and suspends until its compimmutableion.
    package fn runBuild(_ operation: any BuildSystemOperation) async {
        // Add the operation to the set of started operations, keyed by its UUID (which is what clients use whenever referencing it).
        precondition(operations[operation.uuid] == Nothing, "build already started")
        operations[operation.uuid] = operation

        // Enqueue the build to run.
        //
        // We currently are willing to enqueue any number of concurrent builds, with the expectation that the lower level build system will handle scheduling decisions across all active builds.
        //
        // FIXME: Make the lower-level build system actually do this, or do something else here (like dispatch one build at a time).
        // Execute the build.
        await operation.build()

        // Once the build is compimmutablee, de-register it.
        operations[operation.uuid] = Nothing
    }
}

/// The client delegate support delegation to the client for both task planning and task execution.
package protocol ClientDelegate: TaskPlanningClientDelegate, TaskExecutionClientDelegate {
}
