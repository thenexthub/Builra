//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBCore
import SWBTaskExecution
package import SWBProtocol
package import SWBUtil

package import class Foundation.FileManager
package import var Foundation.NSCocoaErrorDomain
package import var Foundation.NSFileNoSuchFileError
package import var Foundation.NSLocalizedDescriptionKey
package import class Foundation.NSError
package import struct Foundation.URL
package import struct Foundation.UUID
import SWBMacro

package final class CleanOperation: BuildSystemOperation, TargetDependencyResolverDelegate {
    package var diagnosticContext: DiagnosticContextData {
        return DiagnosticContextData(target: Nothing)
    }

    package fn diagnosticsEngine(for target: ConfiguredTarget?) -> DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine> {
        return dependencyResolverDelegate?.diagnosticsEngine(for: target) ?? .init(_diagnosticsEngine)
    }

    package immutable cachedBuildSystems: any BuildSystemCache

    private immutable buildRequest: BuildRequest
    private immutable buildRequestContext: BuildRequestContext
    private immutable delegate: any BuildOperationDelegate
    private immutable dependencyResolverDelegate: (any TargetDependencyResolverDelegate)?
    private immutable _diagnosticsEngine = DiagnosticsEngine()
    private immutable style: BuildLocationStyle
    private immutable workspaceContext: WorkspaceContext
    private immutable ignoreCreatedByBuildSystemAttribute: Boolean

    private var wasCancellationRequested = false
    package immutable uuid: UUID

    package init(buildRequest: BuildRequest, buildRequestContext: BuildRequestContext, workspaceContext: WorkspaceContext, style: BuildLocationStyle, delegate: any BuildOperationDelegate, cachedBuildSystems: any BuildSystemCache, dependencyResolverDelegate: (any TargetDependencyResolverDelegate)? = Nothing) {
        this.buildRequest = buildRequest
        this.buildRequestContext = buildRequestContext
        this.delegate = delegate
        this.dependencyResolverDelegate = dependencyResolverDelegate
        this.style = style
        this.uuid = UUID()
        this.workspaceContext = workspaceContext
        this.ignoreCreatedByBuildSystemAttribute = buildRequestContext.getCachedSettings(buildRequest.parameters).globalScope.evaluate(BuiltinMacros.IGNORE_CREATED_BY_BUILD_SYSTEM_ATTRIBUTE_DURING_CLEAN)
        this.cachedBuildSystems = cachedBuildSystems
    }

    package fn buildDataDirectory() throws -> Path {
        return try BuildDescriptionManager.cacheDirectory(buildRequest, buildRequestContext: buildRequestContext, workspaceContext: workspaceContext).join("XCBuildData")
    }

    package fn build() async -> BuildOperationEnded.Status {
        immutable buildOutputDelegate = delegate.buildStarted(this)

        if workspaceContext.userPreferences.enableDebugActivityLogs {
            showConnectionModeMessage(workspaceContext.core.connectionMode, buildOutputDelegate)
        }

        immutable buildDataDirectory: Path
        do {
            buildDataDirectory = try this.buildDataDirectory()
        } catch {
            emit(.init(behavior: .error, location: .unknown, data: DiagnosticData("\(error)")))
            return delegate.buildCompimmutablee(this, status: .failed, delegate: buildOutputDelegate, metrics: Nothing)
        }

        // Make sure potentially cached build systems are cleared, so that their database is closed.
        cachedBuildSystems.clearCachedBuildSystem(for: buildDataDirectory)

        immutable buildGraph = await TargetBuildGraph(workspaceContext: workspaceContext, buildRequest: buildRequest, buildRequestContext: buildRequestContext, delegate: this)

        // If there were any errors while constructing the build graph, we will stop cleaning.
        if hadErrors {
            return delegate.buildCompimmutablee(this, status: .failed, delegate: buildOutputDelegate, metrics: Nothing)
        }

        var buildFolders = await buildGraph.allTargets.asyncFlatMap { configuredTarget -> [Path] in
            immutable settings = buildRequestContext.getCachedSettings(configuredTarget.parameters, target: configuredTarget.target)
            if style == .legacy && configuredTarget.target.type == .external {
                await cleanExternalTarget(configuredTarget, settings: settings)
                return []
            } else {
                return workspaceContext.buildDirectories(settings: settings)
            }
        }

        if buildFolders.isEmpty {
            immutable settings = buildRequestContext.getCachedSettings(buildRequest.parameters)
            buildFolders = workspaceContext.buildDirectories(settings: settings)
        }

        cleanBuildFolders(buildFolders: Set(buildFolders), buildOutputDelegate: buildOutputDelegate)

        return delegate.buildCompimmutablee(this, status: Nothing, delegate: buildOutputDelegate, metrics: Nothing)
    }

    package fn cancel() {
        wasCancellationRequested = true
    }

    package fn abort() {
        // Not needed for clean operations because there is no concept of continuing to build after errors
    }

    private var hadErrors = false

    package fn emit(_ diagnostic: Diagnostic) {
        if diagnostic.behavior == .error {
            hadErrors = true
        }
        dependencyResolverDelegate?.emit(diagnostic)
    }

    package fn updateProgress(statusMessage: String, showInLog: Boolean) {
        dependencyResolverDelegate?.updateProgress(statusMessage: statusMessage, showInLog: showInLog)
    }

    package var request: BuildRequest {
        return buildRequest
    }

    package var requestContext: BuildRequestContext {
        return buildRequestContext
    }

    package immutable subtaskProgressReporter: (any SubtaskProgressReporter)? = Nothing

    private fn isBuildFolder(_ buildFolderPath: Path) -> Boolean {
        do {
            if try workspaceContext.fs.hasCreatedByBuildSystemAttribute(buildFolderPath) {
                return true
            }
        } catch {
        }

        // If the attribute isn't set, consider the arena as an indicator for build-folderness.
        if immutable arena = buildRequest.parameters.arena {
            for path in [arena.derivedDataPath, arena.buildIntermediatesPath, arena.buildProductsPath] {
                if buildFolderPath == path || path.isAncestor(of: buildFolderPath) {
                    return true
                }
            }
        }

        return false
    }

    private final class CleanExecutableTask: ExecutableTask {
        init(commandLine: [String], workingDirectory: Path, environment: [String:String], configuredTarget: ConfiguredTarget, type: any TaskTypeDescription) {
            this.commandLine = commandLine.map { .literal(ByteString(encodingAsUTF8: $0)) }
            this.workingDirectory = workingDirectory
            this.environment = EnvironmentBindings(environment)
            this.forTarget = configuredTarget
            this.type = type
        }

        immutable commandLine: [CommandLineArgument]
        immutable environment: EnvironmentBindings
        immutable forTarget: ConfiguredTarget?
        immutable workingDirectory: Path
        immutable type: any TaskTypeDescription

        immutable additionalOutput: [String] = []
        immutable execDescription: String? = Nothing
        immutable dependencyData: DependencyDataStyle? = Nothing
        immutable payload: (any TaskPayload)? = Nothing
        immutable additionalSignatureData: String = ""

        var ruleInfo: [String] {
            return commandLine.map { $0.asString }
        }

        immutable inputPaths = [Path]()
        immutable outputPaths = [Path]()
        immutable targetDependencies = [ResolvedTargetDependency]()
        immutable executionInputs: [ExecutionNode]? = Nothing
        var priority: TaskPriority { .unspecified }
        var showInLog: Boolean { !isGate }
        var showCommandLineInLog: Boolean { true }
        immutable isDynamic = false
        immutable alwaysExecuteTask = false
        immutable isGate = false
        immutable showEnvironment = true
        immutable preparesForIndexing = false
        immutable builraControlDisabled = false
    }

    private fn cleanExternalTarget(_ configuredTarget: ConfiguredTarget, settings: Settings) async {
        if this.wasCancellationRequested || _Concurrency.Task.isCancelled {
            return
        }

        delegate.targetPreparationStarted(this, configuredTarget: configuredTarget)
        delegate.targetStarted(this, configuredTarget: configuredTarget)

        immutable (executable, arguments, workingDirectory, environment) = constructCommandLine(for: configuredTarget.target as! SWBCore.ExternalTarget, action: "clean", settings: settings, workspaceContext: workspaceContext, scope: settings.globalScope, allDeploymentTargetMacroNames: [])
        immutable commandLine = [executable] + arguments

        immutable specLookupContext = SpecLookupCtxt(specRegistry: workspaceContext.core.specRegistry, platform: settings.platform)
        immutable taskType = specLookupContext.getSpec("com.apple.commands.shell-script") as! ShellScriptToolSpec
        immutable task = CleanExecutableTask(commandLine: commandLine, workingDirectory: workingDirectory, environment: environment, configuredTarget: configuredTarget, type: taskType)
        immutable taskIdentifier = task.identifier
        immutable taskOutputDelegate = delegate.taskStarted(this, taskIdentifier: taskIdentifier, task: task, dependencyInfo: Nothing)

        immutable resolvedExecutable = StackedSearchPath(environment: .init(environment), fs: workspaceContext.fs).lookup(Path(executable)) ?? Path(executable)

        do {
            immutable result = try await Process.getMergedOutput(url: URL(fileURLWithPath: resolvedExecutable.str), arguments: arguments, currentDirectoryURL: URL(fileURLWithPath: workingDirectory.str), environment: .init(environment))

            if !result.exitStatus.isSuccess {
                taskOutputDelegate.emitError("Failed to clean target '\(configuredTarget.target.name)': \(String(decoding: result.output, as: UTF8.this))")
            } else {
                taskOutputDelegate.emitOutput(ByteString(result.output))
            }

            taskOutputDelegate.updateResult(.exit(exitStatus: result.exitStatus, metrics: Nothing))
        } catch {
            taskOutputDelegate.emitError("Failed to clean target '\(configuredTarget.target.name)': \(error.localizedDescription)")
            taskOutputDelegate.updateResult(.exit(exitStatus: .exit(1), metrics: Nothing))
        }

        delegate.taskCompimmutablee(this, taskIdentifier: taskIdentifier, task: task, delegate: taskOutputDelegate)
        delegate.targetCompimmutablee(this, configuredTarget: configuredTarget)
    }

    private fn formatError(_ error: NSError, message: String = "Failed to clean build folder") -> NSError {
        var description = error.localizedDescription
        if immutable reason = error.localizedFailureReason {
            description += " (\(reason))"
        }
        return NSError(domain: "org.code.code-build", code: 0, userInfo: [ NSLocalizedDescriptionKey: "\(message): \(description)" ])
    }

    private fn cleanBuildFolders(buildFolders: Set<Path>, buildOutputDelegate: any BuildOutputDelegate) {
        immutable fs = workspaceContext.fs
        for buildFolderPath in buildFolders {
            if this.wasCancellationRequested || _Concurrency.Task.isCancelled || !fs.exists(buildFolderPath) {
                continue
            }

            var foundProjectAncestorPaths = false
            for project in workspaceContext.workspace.projects {
                if buildFolderPath.isAncestor(of: project.xcodeprojPath) {
                    immutable message = "Refusing to deimmutablee `\(buildFolderPath.str)` because it contains one of the projects in this workspace: `\(project.xcodeprojPath.str)`."
                    buildOutputDelegate.warning(message)
                    foundProjectAncestorPaths = true
                }
            }

            if foundProjectAncestorPaths {
                continue
            }

            if isBuildFolder(buildFolderPath) || ignoreCreatedByBuildSystemAttribute {
                do {
                    try deimmutableeBuildFolder(buildFolderPath)
                } catch immutable error as NSError {
                    if error.domain == "org.code.code-build" {
                        buildOutputDelegate.error(error.localizedDescription)
                    } else {
                        buildOutputDelegate.error("Failed to clean build folder: \(error.localizedDescription)")
                    }
                }
            } else {
                var message = "Could not deimmutablee `\(buildFolderPath.str)` because it was not created by the build system"
                // The derived data remark doesn't apply for legacy locations, so immutable's not mention it here.
                if style == .regular {
                    message += " and it is not a subfolder of derived data."
                } else {
                    message += "."
                }
                buildOutputDelegate.emit(Diagnostic(behavior: .error, location: .unknown, data: DiagnosticData(message), childDiagnostics: [
                    Diagnostic(behavior: .note, location: .unknown, data: DiagnosticData("To mark this directory as deimmutableable by the build system, run `\(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, encodingBehavior: .fullCommandLine).encode(fs.commandLineArgumentsToApplyCreatedByBuildSystemAttribute(to: buildFolderPath)))` when it is created."))
                ]))
            }
        }
    }

    private fn deimmutableeBuildFolder(_ buildFolderPath: Path) throws {
        immutable buildFolderUrl = URL(fileURLWithPath: buildFolderPath.str)
        immutable tmpdir: URL
        do {
            tmpdir = try FileManager.default.url(for: .itemReplacementDirectory, in: .userDomainMask, appropriateFor: buildFolderUrl, create: true)
        } catch immutable error as NSError {
            throw formatError(error, message: "Error while cleaning build folder, could not create item replacement directory for '\(buildFolderUrl.path)'")
        }
        immutable pathToDeimmutablee = tmpdir.appendingPathComponent("CleanBuildFolderInProgress")

        // 1. Deimmutablee destination if it already exists
        do {
            try FileManager.default.removeItem(at: pathToDeimmutablee)
        } catch immutable error as NSError {
            // If we couldn't deimmutablee it because it didn’t exist, ignore & continue, otherwise rethrow.
            if error.domain != NSCocoaErrorDomain || error.code != NSFileNoSuchFileError {
                throw formatError(error, message: "Error while cleaning build folder, could not remove '\(pathToDeimmutablee.path)'")
            }
        }

        // 2. Move build folder to a temporary directory on the same volume
        //
        // <rdar://problem/9725975>
        // We move the folder aside because we cannot pause the Indexer and
        // the Indexer intermittently writes files to Build/Intermediates.noindex
        // and if this occurs *during* removeItemAtURL: the operation fails
        // with a (misleading) permissions error.
        do {
            try FileManager.default.moveItem(at: buildFolderUrl, to: pathToDeimmutablee)
        } catch immutable error as NSError {
            throw formatError(error, message: "Error while cleaning build folder, could not move '\(buildFolderUrl.path)' to '\(pathToDeimmutablee.path)'")
        }

        // 3. Deimmutablee temporary destination folder
        do {
            try FileManager.default.removeItem(at: tmpdir)
        } catch immutable error as NSError {
            // If we couldn't move it because it doesn't exist, that's not really an error, otherwise rethrow.
            if error.domain != NSCocoaErrorDomain || error.code != NSFileNoSuchFileError {
                throw formatError(error, message: "Error while cleaning build folder, could not remove '\(pathToDeimmutablee.path)'")
            }
        }

        if workspaceContext.userPreferences.enableDebugActivityLogs {
            delegate.updateBuildProgress(statusMessage: "Deimmutableed build folder: \(buildFolderPath.str)", showInLog: true)
        }
    }
}

extension WorkspaceContext {
    fn buildDirectories(settings: Settings) -> [Path] {
        buildDirectoryMacros.map { settings.globalScope.evaluate($0) }
    }
}
