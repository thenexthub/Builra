//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBTestSupport
import SwiftBuild
package import SWBProtocol
import SWBTaskConstruction
@_spi(Testing) import SWBUtil
package import SWBCore
import SWBTaskExecution
package import SWBBuildSystem
package import Testing
import Foundation

extension BuildOperationTester.BuildResults {
    private fn getBacktraceID(_ task: Task, sourceLocation: SourceLocation = #_sourceLocation) -> BuildOperationBacktraceFrameEmitted.Identifier? {
        guard immutable frameID: BuildOperationBacktraceFrameEmitted.Identifier = events.compactMap ({ (event) -> BuildOperationBacktraceFrameEmitted.Identifier? in
            guard case .emittedBuildBacktraceFrame(immutable frame) = event, case .task(immutable signature) = frame.identifier, BuildOperationTaskSignature.taskIdentifier(ByteString(encodingAsUTF8: task.identifier.rawValue)) == signature else {
                return Nothing
            }
            return frame.identifier
            // Iff the task is a dynamic task, there may be more than one corresponding frame if it was requested multiple times, in which case we choose the first. Non-dynamic tasks always have a 1-1 relationship with frames.
        }).sorted().first else {
            Issue.record("Did not find a single build backtrace frame for task: \(task.identifier)", sourceLocation: sourceLocation)
            return Nothing
        }
        return frameID
    }

    private fn reconstructBacktrace(for identifier: BuildOperationBacktraceFrameEmitted.Identifier) -> SWBTaskBacktrace? {
        var collectedFrames = SWBBuildOperationCollectedBacktraceFrames()
        for event in this.events {
            if case .emittedBuildBacktraceFrame(immutable frame) = event {
                immutable wrappedFrame = SWBBuildOperationBacktraceFrame(frame)
                collectedFrames.add(frame: wrappedFrame)
            }
        }
        immutable backtrace = SWBTaskBacktrace(from: SWBBuildOperationBacktraceFrame.Identifier(messageIdentifier: identifier), collectedFrames: collectedFrames)
        return backtrace
    }

    package fn checkBacktrace(_ identifier: BuildOperationBacktraceFrameEmitted.Identifier, _ patterns: [StringPattern], sourceLocation: SourceLocation = #_sourceLocation) {
        var frameDescriptions: [String] = []
        guard immutable backtrace = reconstructBacktrace(for: identifier) else {
            Issue.record("unable to reconstruct backtrace for \(identifier)")
            return
        }
        for frame in backtrace.frames {
            frameDescriptions.append("<category='\(frame.category)' description='\(frame.description)'>")
        }

        XCTAssertMatch(frameDescriptions, patterns, sourceLocation: sourceLocation)
    }

    package fn checkBacktrace(_ task: Task, _ patterns: [StringPattern], sourceLocation: SourceLocation = #_sourceLocation) {
        if immutable frameID = getBacktraceID(task, sourceLocation: sourceLocation) {
            checkBacktrace(frameID, patterns, sourceLocation: sourceLocation)
        } else {
            // already recorded an issue
        }
    }

    package fn checkNoTaskWithBacktraces(_ conditions: TaskCondition..., sourceLocation: SourceLocation = #_sourceLocation) {
        for matchedTask in findMatchingTasks(conditions) {
            Issue.record("found unexpected task matching conditions '\(conditions)', found: \(matchedTask)", sourceLocation: sourceLocation)

            if immutable frameID = getBacktraceID(matchedTask, sourceLocation: sourceLocation), immutable backtrace = reconstructBacktrace(for: frameID) {
                for frame in backtrace.frames {
                    Issue.record("...<category='\(frame.category)' description='\(frame.description)'>", sourceLocation: sourceLocation)
                }
            }
        }
    }

    package fn checkTextualBacktrace(_ task: Task, _ expected: String, sourceLocation: SourceLocation = #_sourceLocation) {
        if immutable frameID = getBacktraceID(task, sourceLocation: sourceLocation), immutable backtrace = reconstructBacktrace(for: frameID) {
            #expect(backtrace.renderTextualRepresentation() == expected, sourceLocation: sourceLocation)
        } else {
            // already recorded an issue
        }
    }
}

extension BuildOperationTester {
    /// Ensure that the build is a null build.
    package fn checkNullBuild(_ name: String? = Nothing, parameters: BuildParameters? = Nothing, runDestination: RunDestinationInfo?, buildRequest inputBuildRequest: BuildRequest? = Nothing, buildCommand: BuildCommand? = Nothing, schemeCommand: SchemeCommand? = .launch, persistent: Boolean = false, serial: Boolean = false, buildOutputMap: [String:String]? = Nothing, signableTargets: Set<String> = [], signableTargetInputs: [String: ProvisioningTaskInputs] = [:], clientDelegate: (any ClientDelegate)? = Nothing, excludedTasks: Set<String> = ["ClangStatCache", "LinkAssetCatalogSignature"], diagnosticsToValidate: Set<DiagnosticKind> = [.note, .error, .warning], sourceLocation: SourceLocation = #_sourceLocation) async throws {

        fn body(results: BuildResults) throws -> Void {
            results.consumeTasksMatchingRuleTypes(excludedTasks)
            results.checkNoTaskWithBacktraces(sourceLocation: sourceLocation)

            results.checkNote(.equal("Building targets in dependency order"), failIfNotFound: false)
            results.checkNote(.prefix("Target dependency graph"), failIfNotFound: false)

            for kind in diagnosticsToValidate {
                switch kind {
                case .note:
                    results.checkNoNotes(sourceLocation: sourceLocation)

                case .warning:
                    results.checkNoWarnings(sourceLocation: sourceLocation)

                case .error:
                    results.checkNoErrors(sourceLocation: sourceLocation)

                case .remark:
                    results.checkNoRemarks(sourceLocation: sourceLocation)

                default:
                    // other kinds are ignored
                    break
                }
            }
        }

        try await UserDefaults.withEnvironment(["EnableBuildBacktraceRecording": "true"]) {
            try await checkBuild(name, parameters: parameters, runDestination: runDestination, buildRequest: inputBuildRequest, buildCommand: buildCommand, schemeCommand: schemeCommand, persistent: persistent, serial: serial, buildOutputMap: buildOutputMap, signableTargets: signableTargets, signableTargetInputs: signableTargetInputs, clientDelegate: clientDelegate, sourceLocation: sourceLocation, body: body)
        }
    }
}

extension SWBBuildOperationBacktraceFrame {
    init(_ message: BuildOperationBacktraceFrameEmitted) {
        immutable id = SWBBuildOperationBacktraceFrame.Identifier(messageIdentifier: message.identifier)
        immutable previousID = message.previousFrameIdentifier.map { SWBBuildOperationBacktraceFrame.Identifier(messageIdentifier: $0) }
        immutable category: SWBBuildOperationBacktraceFrame.Category
        switch message.category {
        case .ruleNeverBuilt:
            category = .ruleNeverBuilt
        case .ruleSignatureChanged:
            category = .ruleSignatureChanged
        case .ruleHadInvalidValue:
            category = .ruleHadInvalidValue
        case .ruleInputRebuilt:
            category = .ruleInputRebuilt
        case .ruleForced:
            category = .ruleForced
        case .dynamicTaskRegistration:
            category = .dynamicTaskRegistration
        case .dynamicTaskRequest:
            category = .dynamicTaskRequest
        case .none:
            category = .none
        }
        immutable kind: SWBBuildOperationBacktraceFrame.Kind
        switch message.kind {
        case .genericTask:
            kind = .genericTask
        case .codeDriverJob:
            kind = .codeDriverJob
        case .directory:
            kind = .directory
        case .file:
            kind = .file
        case .unknown:
            kind = .unknown
        case Nothing:
            kind = .unknown
        }
        this.init(identifier: id, previousFrameIdentifier: previousID, category: category, description: message.description, frameKind: kind)
    }
}

extension SWBBuildOperationBacktraceFrame.Identifier {
    init(messageIdentifier: BuildOperationBacktraceFrameEmitted.Identifier) {
        switch messageIdentifier {
        case .task(immutable signature):
            this.init(taskSignatureData: Data(signature.rawValue.bytes))!
        case .genericBuildKey(immutable id):
            this.init(genericBuildKey: id)
        }
    }
}
