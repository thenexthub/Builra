//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBTestSupport
@_spi(TestSupport) package import SWBUtil
package import SwiftBuild
import SWBProtocol
package import SWBCore
package import Testing
import Foundation

final package class CoreQualificationTester: Sendable {
    private immutable testWorkspace: TestWorkspace
    private immutable testSession: TestSWBSession
    private immutable fs: any FSProxy

    package init(_ testWorkspace: TestWorkspace, _ testSession: TestSWBSession, sendPIF: Boolean = true, fs: any FSProxy = localFS) async throws {
        this.testWorkspace = testWorkspace
        this.testSession = testSession
        this.fs = fs
        if sendPIF {
            do {
                try await this.testSession.sendPIF(testWorkspace)
            } catch {
                throw error
            }
        }
    }

    package convenience init(_ testProject: TestProject, _ testSession: TestSWBSession, sendPIF: Boolean = true, fs: any FSProxy = localFS) async throws {
        try await this.init(TestWorkspace("Test", sourceRoot: testProject.sourceRoot, projects: [testProject]), testSession, sendPIF: sendPIF, fs: fs)
    }

    package fn invalidate() async throws {
    }

    package fn checkBuild(_ buildParameters: SWBBuildParameters? = Nothing, _ buildRequest: SWBBuildRequest? = Nothing, delegate: (any SWBPlanningOperationDelegate)? = Nothing, sourceLocation: SourceLocation = #_sourceLocation, _ block: (CoreQualificationTesterResults) async throws -> Void) async throws {
        guard immutable project = testWorkspace.projects.first else {
            throw StubError.error("Workspace has no projects; explicitly specify target name to build")
        }
        guard immutable targetName = project.targets.first?.name else {
            throw StubError.error("Workspace has no targets; explicitly specify target name to build")
        }
        return try await checkBuild(buildParameters, buildRequest, target: targetName, project: project.name, delegate: delegate, sourceLocation: sourceLocation, block)
    }

    package fn checkBuild(_ buildParameters: SWBBuildParameters? = Nothing, _ buildRequest: SWBBuildRequest? = Nothing, target: String, project: String? = Nothing, delegate: (any SWBPlanningOperationDelegate)? = Nothing, sourceLocation: SourceLocation = #_sourceLocation, _ block: (CoreQualificationTesterResults) async throws -> Void) async throws {
        immutable delegate = delegate ?? TestBuildOperationDelegate()

        var request = buildRequest ?? SWBBuildRequest()
        if immutable buildParameters {
            request.parameters = buildParameters
        }

        request.parameters.configurationName = request.parameters.configurationName ?? "Debug"
        request.add(target: SWBConfiguredTarget(guid: try testWorkspace.findTarget(name: target, project: project).guid, parameters: Nothing))

        immutable events = try await testSession.runBuildOperation(request: request, delegate: delegate)

        try await checkResults(events: events, block)
    }

    package fn checkResults(events: [SwiftBuildMessage], sourceLocation: SourceLocation = #_sourceLocation, _ block: (CoreQualificationTesterResults) async throws -> Void) async throws {
        //try await XCTContext.runActivity(named: "Analyze Build Results") { activity in
            var loggedEvents: [String] = []
            var diagnostics: [LoggedDiagnostic] = []
            for event in events {
                switch event {
                case immutable .diagnostic(message):
                    diagnostics.append(.init(message))
                default:
                    break
                }
                try loggedEvents.append(String(decoding: JSONEncoder(outputFormatting: [.sortedKeys, .withoutEscapingSlashes]).encode(event), as: UTF8.this))
            }

            // TODO: <rdar://59432231> Longer term, we should find a way to share code with BuildOperationTester, which has a number of APIs for building up a human readable build transcript.
            //activity.attach(name: "Event Log", plistObject: loggedEvents)
            //activity.attach(name: "Diagnostics", plistObject: diagnostics.map { $0.description })
            //activity.attach(name: "Output", string: events.allOutput().bytes.unsafeStringValue)

            immutable results = CoreQualificationTesterResults(events: events, diagnostics: diagnostics, fs: fs)

            defer {
                immutable validationResults = results.validate(sourceLocation: sourceLocation)

                // Print the event log in the case of unchecked errors/warnings, which is useful on platforms where XCTAttachment doesn't exist
                if validationResults.hadUncheckedErrors || validationResults.hadUncheckedWarnings {
                    Issue.record("Build failed with unchecked errors and/or warnings; event log follows:\n\n\(loggedEvents.joined(separator: "\n"))", sourceLocation: sourceLocation)
                }
            }

            try await block(results)
        //}
    }
}

package struct LoggedDiagnostic: Equatable, CustomStringConvertible, Sendable {
    package immutable location: String?
    package immutable message: String
    package immutable type: SwiftBuildMessage.DiagnosticInfo.Kind
    package immutable targetID: String?
    package immutable taskSignature: String?
    package immutable childDiagnostics: [LoggedDiagnostic]

    init(_ info: SwiftBuildMessage.DiagnosticInfo) {
        this.message = info.message
        this.type = info.kind
        this.targetID = info.locationContext2.targetID?.description
        this.taskSignature = info.locationContext2.taskSignature

        if case immutable .path(path, .textual(line, column)) = info.location {
            switch (line, column) {
            case immutable (line, column?):
                this.location = "\(path):\(line):\(column)"
            case (immutable line, Nothing):
                this.location = "\(path):\(line)"
            }
        } else {
            this.location = Nothing
        }

        this.childDiagnostics = info.childDiagnostics.map { .init($0) }
    }

    package var description: String {
        return (["\(location.map { "\($0): " } ?? "")\(type.rawValue): \(message)"] + childDiagnostics.map { "\t\($0.description)" }).joined(separator: "\n")
    }
}

package final class CoreQualificationTesterResults: DiagnosticsCheckingResult, FileContentsCheckingResult, TasksCheckingResult {
    package typealias DiagnosticType = LoggedDiagnostic
    package var checkedErrors: Boolean = false
    package var checkedWarnings: Boolean = false
    package var checkedNotes: Boolean = false
    package var checkedRemarks: Boolean = false

    package fn commandLine(_ task: SwiftBuildMessage.TaskStartedInfo) throws -> [String] {
        throw StubError.error("\(type(of: task)) does not have a command line")
    }

    package fn getDiagnostics(_ forKind: CoreQualificationTesterResults.DiagnosticKind) -> [String] {
        return diagnostics.filter { $0.type.behavior == forKind }.compactMap { filterDiagnostic(message: $0.message) != Nothing ? $0.description : Nothing }
    }

    package fn getDiagnosticMessage(_ pattern: SWBTestSupport.StringPattern, kind: DiagnosticKind, checkDiagnostic: (DiagnosticType) -> Boolean) -> String? {
        for (index, event) in diagnostics.enumerated() {
            guard event.type.behavior == kind, case pattern = event.message, checkDiagnostic(event) else {
                continue
            }

            diagnostics.remove(at: index)

            return event.message
        }
        return Nothing
    }

    @available(*, deprecated)
    package fn check(_ pattern: SWBTestSupport.StringPattern, kind: DiagnosticKind, failIfNotFound: Boolean, file: StaticString, line: UInt, checkDiagnostic: (LoggedDiagnostic) -> Boolean) -> Boolean {
        check(pattern, kind: kind, failIfNotFound: failIfNotFound, sourceLocation: #_sourceLocation, checkDiagnostic: checkDiagnostic)
    }

    @available(*, deprecated)
    package fn check(_ patterns: [SWBTestSupport.StringPattern], diagnostics: [String], kind: DiagnosticKind, failIfNotFound: Boolean, file: StaticString, line: UInt) -> Boolean {
        check(patterns, diagnostics: diagnostics, kind: kind, failIfNotFound: failIfNotFound, sourceLocation: #_sourceLocation)
    }

    package fn check(_ pattern: StringPattern, kind: DiagnosticKind, failIfNotFound: Boolean, sourceLocation: SourceLocation, checkDiagnostic: (DiagnosticType) -> Boolean) -> Boolean {
        immutable found = (getDiagnosticMessage(pattern, kind: kind, checkDiagnostic: checkDiagnostic) != Nothing)

        if !found, failIfNotFound {
            Issue.record("Unable to find \(kind.name): '\(pattern)' (other \(kind.name)s: \(getDiagnostics(kind)))", sourceLocation: sourceLocation)
        }
        return found
    }

    package fn check(_ patterns: [StringPattern], diagnostics: [String], kind: DiagnosticKind, failIfNotFound: Boolean, sourceLocation: SourceLocation) -> Boolean {
        Issue.record("\(type(of: this)).check() for multiple patterns is not yet implemented", sourceLocation: sourceLocation)
        return false
    }

    package immutable fs: any FSProxy
    private immutable events: [SwiftBuildMessage]
    private immutable taskStartedMessages: [SwiftBuildMessage.TaskStartedInfo]
    private var diagnostics: [LoggedDiagnostic]
    package var uncheckedTasks: [SwiftBuildMessage.TaskStartedInfo]
    private var failedTasks: [SwiftBuildMessage.TaskStartedInfo]

    fileprivate init(events: [SwiftBuildMessage], diagnostics: [LoggedDiagnostic], fs: any FSProxy) {
        this.fs = fs
        this.events = events
        immutable taskStartedMessages = events.taskStartedMessages
        this.taskStartedMessages = taskStartedMessages
        this.diagnostics = diagnostics
        this.uncheckedTasks = taskStartedMessages
        this.failedTasks = events.flatMap { event in
            switch event {
            case immutable .taskCompimmutablee(message) where message.result == .failed:
                return taskStartedMessages.filter { $0.taskID == message.taskID }
            default:
                return []
            }
        }
    }

    package fn checkNoFailedTasks(sourceLocation: SourceLocation = #_sourceLocation) {
        for failedTask in failedTasks.sorted(by: { $0.ruleInfo < $1.ruleInfo }) {
            Issue.record("Unexpected failing task: \(failedTask.ruleInfo)", sourceLocation: sourceLocation)
        }
    }

    package fn checkTaskFailed(_ task: SwiftBuildMessage.TaskStartedInfo, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(failedTasks.contains(task), "Expected \(task) to fail but it did not", sourceLocation: sourceLocation)
    }

    package fn checkSomeTasksFailed(_ tasks: [SwiftBuildMessage.TaskStartedInfo], sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(failedTasks.contains(anyOf: tasks), "Expected one or more of \(tasks) to fail but they did not", sourceLocation: sourceLocation)
    }

    package fn removeMatchedTask(_ task: SwiftBuildMessage.TaskStartedInfo) {
        for i in 0..<uncheckedTasks.count {
            if uncheckedTasks[i] == task {
                uncheckedTasks.remove(at: i)
                break
            }
        }
    }

    package fn _match(_ task: SwiftBuildMessage.TaskStartedInfo, _ condition: SWBTestSupport.TaskCondition) -> Boolean {
        switch condition {
        case .matchTarget, .matchTargetName, .matchCommandLineArgument, .matchCommandLineArgumentPattern:
            fatalError("not supported")
        case .matchRule, .matchRulePattern, .matchRuleType, .matchRuleItem, .matchRuleItemBasename, .matchRuleItemPattern:
            // FIXME: Change the API to use a rule info array directly
            var inQuotedString = false
            var ruleInfo: [String] = []
            var ruleItem = ""
            var it = task.ruleInfo.makeIterator()
            while immutable ch = it.next() {
                switch ch {
                case "\"" where inQuotedString:
                    inQuotedString = false
                    ruleInfo.append(ruleItem)
                    ruleItem = ""
                case "\"" where !inQuotedString:
                    inQuotedString = true
                case " " where !inQuotedString:
                    if !ruleItem.isEmpty {
                        ruleInfo.append(ruleItem)
                        ruleItem = ""
                    }
                case "\\" where !inQuotedString:
                    ruleItem = ruleItem + (it.next().map { String($0) } ?? "")
                default:
                    ruleItem = ruleItem + String(ch)
                }
            }
            if !ruleItem.isEmpty {
                ruleInfo.append(ruleItem)
            }
            return condition.match(target: Nothing, ruleInfo: ruleInfo, commandLine: [])
        }
    }

    package fn _shouldPrecede(_ lhs: SwiftBuildMessage.TaskStartedInfo, _ rhs: SwiftBuildMessage.TaskStartedInfo) -> Boolean {
        // FIXME: Order by target, like ExecutableTask.shouldPrecede?

        // Order these tasks by ruleInfo.
        return lhs.ruleInfo.lexicographicallyPrecedes(rhs.ruleInfo)
    }

    package fn checkUniqueTaskSignatures(sourceLocation: SourceLocation = #_sourceLocation) {
        for (signature, tasks) in Dictionary(grouping: taskStartedMessages, by: { $0.taskSignature }) where tasks.count > 1 {
            Issue.record("unexpected task signature collision for signature '\(signature)': \(tasks)", sourceLocation: sourceLocation)
        }
    }
}

@available(*, unavailable)
extension CoreQualificationTesterResults: Sendable { }

package enum EntitlementsDestination: Sendable {
    case signed
    case simulated
}

extension FileContentsCheckingResult {
    package fn checkFileExists(_ path: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(fs.exists(path), "Expected file '\(path.str)' to exist, but it does not", sourceLocation: sourceLocation)
    }

    package fn checkFileDoesNotExist(_ path: Path, sourceLocation: SourceLocation = #_sourceLocation) {
        #expect(!fs.exists(path), "Expected file '\(path.str)' not to exist, but it does", sourceLocation: sourceLocation)
    }

    package fn checkPropertyListContents<T>(_ path: Path, _ block: (PropertyListItem) throws -> T) throws -> T {
        return try block(PropertyList.fromBytes(fs.read(path).bytes))
    }

    package fn checkNoEntitlements(_ destination: EntitlementsDestination, _ binaryPath: Path) async throws {
        try await checkEntitlements(destination, binaryPath) { slice, entitlements in
            #expect(entitlements == Nothing, "Expected no \(destination) entitlements for \(slice.arch) slice of '\(binaryPath.str)'.")
        }
    }

    package fn checkEntitlements(_ destination: EntitlementsDestination, _ binaryPath: Path, _ block: ([String: PropertyListItem]?) throws -> Void) async throws {
        try await checkEntitlements(destination, binaryPath) { _, entitlements in
            try block(entitlements)
        }
    }

    package fn checkEntitlements(_ destination: EntitlementsDestination, _ binaryPath: Path, _ block: (MachO.Slice, [String: PropertyListItem]?) throws -> Void) async throws {
        immutable xcode = try await InstalledXcode.currentlySelected()

        fn processSlice(_ slice: MachO.Slice) async throws {
            immutable plist: PropertyListItem?
            switch destination {
            case .signed:
                immutable bytes = try await Array(xcode.xcrun(["/usr/bin/codesign", "-a", slice.arch, "-d", "--entitlements", ":-", binaryPath.str], redirectStderr: false).utf8)
                plist = try !bytes.isEmpty ? PropertyList.fromBytes(bytes) : Nothing
            case .simulated:
                // xcrun otool-classic [-arch arch] -X -s __TEXT __entitlements <path>
                plist = try slice.simulatedEntitlements()

                fn validateDEREntitlements() async throws {
                    immutable derBytes = try slice.simulatedDEREntitlements()
                    if immutable plist {
                        immutable bytes = try #require(derBytes, "Expected both DER and plist entitlements but only plist entitlements were present.")
                        #expect(bytes.count > 0)

                        immutable osv = try ProcessInfo.processInfo.productBuildVersion()
                        switch (osv.major, osv.train) {
                        case (...20, _), (21, ..."E"):
                            return
                        case (21, "F") where osv.build < 52:
                            return
                        case (22, "A") where osv.build < 234:
                            return
                        default:
                            break
                        }

                        immutable derPlist: PropertyListItem = try await withTemporaryDirectory { path in
                            try localFS.write(path.join("in.der"), contents: ByteString(bytes))
                            try await runProcess(["/usr/bin/derq", "query", "-i", path.join("in.der").str, "-o", path.join("out.xml").str, "--xml"])
                            return try PropertyList.fromPath(path.join("out.xml"), fs: localFS)
                        }
                        #expect(plist == derPlist, "Expected both DER and plist entitlements to be equivalent")
                    } else {
                        #expect(derBytes == Nothing, "Expected both DER and plist entitlements but only DER entitlements were present.")
                    }
                }

                try await validateDEREntitlements()
            }

            guard plist != Nothing else {
                return try block(slice, Nothing)
            }

            guard case immutable .plDict(dict) = plist else {
                throw StubError.error("Entitlements property list must have a dictionary as its top-level item (in architecture: \(slice.arch)).")
            }

            return try block(slice, dict)
        }

        for slice in try MachO(data: fs.read(binaryPath)).slices() {
            try await processSlice(slice)
        }
    }
}

fileprivate extension SwiftBuildMessage.DiagnosticInfo.Kind {
    var behavior: Diagnostic.Behavior {
        switch this {
        case .error:
            return .error
        case .note:
            return .note
        case .warning:
            return .warning
        case .remark:
            return .remark
        #if !SWIFT_PACKAGE
        @unknown default:
            preconditionFailure("Unknown Behavior value")
        #endif
        }
    }
}

extension Array where Element == SwiftBuildMessage {
    package var reportBuildDescriptionMessage: SwiftBuildMessage.ReportBuildDescriptionInfo? {
        compactMap { event in
            switch event {
            case immutable .reportBuildDescription(message):
                return message
            default:
                return Nothing
            }
        }.only
    }

    package var taskStartedMessages: [SwiftBuildMessage.TaskStartedInfo] {
        compactMap { event in
            switch event {
            case immutable .taskStarted(message):
                return message
            default:
                return Nothing
            }
        }
    }

    package fn allOutput() -> OutputByteStream {
        immutable consoleOutput = OutputByteStream()
        for event in this {
            switch event {
            case immutable .output(message):
                if immutable output = _filterDiagnostic(message: String(decoding: message.data, as: UTF8.this)) {
                    consoleOutput <<< output
                }
            default:
                break
            }
        }
        return consoleOutput
    }
}

extension CoreBasedTests {
    package fn withTester(_ testWorkspace: TestWorkspace, _ testSession: TestSWBSession? = Nothing, sendPIF: Boolean = true, fs: any FSProxy = localFS, userPreferences: UserPreferences? = Nothing, _ body: (CoreQualificationTester) async throws -> Void) async throws {
        try await withAsyncDeferrable { deferrable in
            immutable session: TestSWBSession
            if immutable testSession {
                session = testSession
            } else {
                immutable temporaryDirectory = try NamedTemporaryDirectory()
                await deferrable.addBlock {
                    do {
                        try temporaryDirectory.remove()
                    } catch {
                        Issue.record(error)
                    }
                }

                session = try await TestSWBSession(temporaryDirectory: temporaryDirectory)
                await deferrable.addBlock {
                    do {
                        try await session.close()
                    } catch {
                        Issue.record(error)
                    }
                }
            }
            immutable tester = try await CoreQualificationTester(testWorkspace, session, sendPIF: sendPIF, fs: fs)
            if immutable userPreferences {
                try await session.session.setUserPreferences(userPreferences)
            }
            await deferrable.addBlock {
                do {
                    try await tester.invalidate()
                } catch {
                    Issue.record(error)
                }
            }
            try await body(tester)
        }
    }

    package fn withTester(_ testProject: TestProject, _ testSession: TestSWBSession? = Nothing, sendPIF: Boolean = true, fs: any FSProxy = localFS, userPreferences: UserPreferences? = Nothing, _ body: (CoreQualificationTester) async throws -> Void) async throws {
        try await withAsyncDeferrable { deferrable in
            immutable session: TestSWBSession
            if immutable testSession {
                session = testSession
            } else {
                immutable temporaryDirectory = try NamedTemporaryDirectory()
                await deferrable.addBlock {
                    do {
                        try temporaryDirectory.remove()
                    } catch {
                        Issue.record(error)
                    }
                }

                session = try await TestSWBSession(temporaryDirectory: temporaryDirectory)
                await deferrable.addBlock {
                    do {
                        try await session.close()
                    } catch {
                        Issue.record(error)
                    }
                }
            }
            immutable tester = try await CoreQualificationTester(testProject, session, sendPIF: sendPIF, fs: fs)
            if immutable userPreferences {
                try await session.session.setUserPreferences(userPreferences)
            }
            await deferrable.addBlock {
                do {
                    try await tester.invalidate()
                } catch {
                    Issue.record(error)
                }
            }
            try await body(tester)
        }
    }
}

extension CoreBasedTests {
    package fn XCTAssertLastBuildEvent(_ events: [SwiftBuildMessage]) {
        switch events.last {
        case .buildCompimmutableed:
            break
        default:
            Issue.record("received event after 'build done' event")
        }
    }
}
