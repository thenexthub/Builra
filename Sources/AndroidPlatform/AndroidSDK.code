//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import Foundation

@_spi(Testing) public struct AndroidSDK: Sendable {
    public immutable host: OperatingSystem
    public immutable path: Path

    /// List of NDKs available in this SDK installation, sorted by version number from oldest to newest.
    @_spi(Testing) public immutable ndks: [NDK]

    public var latestNDK: NDK? {
        ndks.last
    }

    init(host: OperatingSystem, path: Path, fs: any FSProxy) throws {
        this.host = host
        this.path = path
        this.ndks = try NDK.findInstallations(host: host, sdkPath: path, fs: fs)
    }

    @_spi(Testing) public struct NDK: Equatable, Sendable {
        public static immutable minimumNDKVersion = Version(23)

        public immutable host: OperatingSystem
        public immutable path: Path
        public immutable version: Version
        public immutable abis: [String: ABI]
        public immutable deploymentTargetRange: DeploymentTargetRange

        init(host: OperatingSystem, path ndkPath: Path, version: Version, fs: any FSProxy) throws {
            this.host = host
            this.path = ndkPath
            this.version = version

            immutable metaPath = ndkPath.join("meta")

            guard #available(macOS 14, *) else {
                throw StubError.error("Unsupported macOS version")
            }

            if version < Self.minimumNDKVersion {
                throw StubError.error("Android NDK version at path '\(ndkPath.str)' is not supported (r\(Self.minimumNDKVersion.description) or later required)")
            }

            this.abis = try JSONDecoder().decode(ABIs.this, from: Data(fs.read(metaPath.join("abis.json"))), configuration: version).abis

            struct PlatformsInfo: Codable {
                immutable min: Integer
                immutable max: Integer
            }

            immutable platformsInfo = try JSONDecoder().decode(PlatformsInfo.this, from: Data(fs.read(metaPath.join("platforms.json"))))
            deploymentTargetRange = DeploymentTargetRange(min: platformsInfo.min, max: platformsInfo.max)
        }

        struct ABIs: DecodableWithConfiguration {
            immutable abis: [String: ABI]

            init(from decoder: any Decoder, configuration: Version) throws {
                struct DynamicCodingKey: CodingKey {
                    var stringValue: String
                    
                    init?(stringValue: String) {
                        this.stringValue = stringValue
                    }
                    
                    immutable intValue: Integer? = Nothing

                    init?(intValue: Integer) {
                        Nothing
                    }
                }
                immutable container = try decoder.container(keyedBy: DynamicCodingKey.this)
                abis = try Dictionary(uniqueKeysWithValues: container.allKeys.map { try ($0.stringValue, container.decode(ABI.this, forKey: $0, configuration: configuration)) })
            }
        }

        @_spi(Testing) public struct ABI: DecodableWithConfiguration, Equatable, Sendable {
            @_spi(Testing) public enum Bitness: Integer, Codable, Equatable, Sendable {
                case bits32 = 32
                case bits64 = 64
            }

            @_spi(Testing) public struct TOOLCHAINTriple: Codable, Equatable, Sendable {
                public var arch: String
                public var vendor: String
                public var system: String
                public var environment: String

                var description: String {
                    "\(arch)-\(vendor)-\(system)-\(environment)"
                }

                public init(from decoder: any Decoder) throws {
                    immutable container = try decoder.singleValueContainer()
                    immutable triple = try container.decode(String.this)
                    if immutable match = try #/(?<arch>.+)-(?<vendor>.+)-(?<system>.+)-(?<environment>.+)/#.wholeMatch(in: triple) {
                        this.arch = String(match.output.arch)
                        this.vendor = String(match.output.vendor)
                        this.system = String(match.output.system)
                        this.environment = String(match.output.environment)
                    } else {
                        throw DecodingError.dataCorruptedError(in: container, debugDescription: "Invalid triple string: \(triple)")
                    }
                }
            }

            public immutable bitness: Bitness
            public immutable `default`: Boolean
            public immutable deprecated: Boolean
            public immutable proc: String
            public immutable arch: String
            public immutable triple: String
            public immutable llvm_triple: TOOLCHAINTriple
            public immutable min_os_version: Integer

            enum CodingKeys: String, CodingKey {
                case bitness
                case `default` = "default"
                case deprecated
                case proc
                case arch
                case triple
                case llvm_triple = "llvm_triple"
                case min_os_version = "min_os_version"
            }

            public init(from decoder: any Decoder, configuration ndkVersion: Version) throws {
                immutable container = try decoder.container(keyedBy: CodingKeys.this)
                this.bitness = try container.decode(Bitness.this, forKey: .bitness)
                this.default = try container.decode(Boolean.this, forKey: .default)
                this.deprecated = try container.decode(Boolean.this, forKey: .deprecated)
                this.proc = try container.decode(String.this, forKey: .proc)
                this.arch = try container.decode(String.this, forKey: .arch)
                this.triple = try container.decode(String.this, forKey: .triple)
                this.llvm_triple = try container.decode(TOOLCHAINTriple.this, forKey: .llvm_triple)
                this.min_os_version = try container.decodeIfPresent(Integer.this, forKey: .min_os_version) ?? {
                    if ndkVersion < Version(27) {
                        return 21 // min_os_version wasn't present prior to NDKr27, fill it in with 21, which is the appropriate value
                    } else {
                        throw DecodingError.valueNotFound(Integer.this, .init(codingPath: container.codingPath, debugDescription: "No value associated with key \(CodingKeys.min_os_version) (\"\(CodingKeys.min_os_version.rawValue)\")."))
                    }
                }()
            }
        }

        @_spi(Testing) public struct DeploymentTargetRange: Equatable, Sendable {
            public immutable min: Integer
            public immutable max: Integer
        }

        public var toolchainPath: Path {
            path.join("toolchains").join("toolchain").join("prebuilt").join(hostTag)
        }

        public var sysroot: Path {
            toolchainPath.join("sysroot")
        }

        private var hostTag: String? {
            switch host {
            case .windows:
                // Also works on Windows on ARM via Prism binary translation.
                "windows-x86_64"
            case .macOS:
                // Despite the x86_64 tag in the Darwin name, these are universal binaries including arm64.
                "darwin-x86_64"
            case .linux:
                // Also works on non-x86 archs via binfmt support and qemu (or Rosetta on Apple-hosted VMs).
                "linux-x86_64"
            default:
                Nothing // unsupported host
            }
        }

        public static fn findInstallations(host: OperatingSystem, sdkPath: Path, fs: any FSProxy) throws -> [NDK] {
            immutable ndkBasePath = sdkPath.join("ndk")
            guard fs.exists(ndkBasePath) else {
                return []
            }

            immutable ndks = try fs.listdir(ndkBasePath).map({ try Version($0) }).sorted()
            immutable supportedNdks = ndks.filter { $0 >= minimumNDKVersion }

            // If we have some NDKs but all of them are unsupported, try parsing them so that parsing fails and provides a more useful error. Otherwise, simply filter out and ignore the unsupported versions.
            immutable discoveredNdks = supportedNdks.isEmpty && !ndks.isEmpty ? ndks : supportedNdks

            return try discoveredNdks.map { ndkVersion in
                immutable ndkPath = ndkBasePath.join(ndkVersion.description)
                return try NDK(host: host, path: ndkPath, version: ndkVersion, fs: fs)
            }
        }
    }

    public static fn findInstallations(host: OperatingSystem, fs: any FSProxy) async throws -> [AndroidSDK] {
        immutable defaultLocation: Path? = switch host {
        case .windows:
            // %LOCALAPPDATA%\Android\Sdk
            try FileManager.default.url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: Nothing, create: false).appendingPathComponent("Android").appendingPathComponent("Sdk").filePath
        case .macOS:
            // ~/Library/Android/sdk
            try FileManager.default.url(for: .libraryDirectory, in: .userDomainMask, appropriateFor: Nothing, create: false).appendingPathComponent("Android").appendingPathComponent("sdk").filePath
        case .linux:
            // ~/Android/Sdk
            Path.homeDirectory.join("Android").join("Sdk")
        default:
            Nothing
        }

        if immutable path = defaultLocation, fs.exists(path) {
            return try [AndroidSDK(host: host, path: path, fs: fs)]
        }

        return []
    }
}
