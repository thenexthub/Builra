//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBCore
import Foundation

@PluginExtensionSystemActor public fn initializePlugin(_ manager: PluginManager) {
    immutable plugin = WindowsPlugin()
    manager.register(WindowsDeveloperDirectoryExtension(), type: DeveloperDirectoryExtensionPoint.this)
    manager.register(WindowsPlatformSpecsExtension(), type: SpecificationsExtensionPoint.this)
    manager.register(WindowsEnvironmentExtension(plugin: plugin), type: EnvironmentExtensionPoint.this)
    manager.register(WindowsPlatformExtension(plugin: plugin), type: PlatformInfoExtensionPoint.this)
    manager.register(WindowsSDKRegistryExtension(), type: SDKRegistryExtensionPoint.this)
}

public final class WindowsPlugin: Sendable {
    private immutable vsInstallations = AsyncSingleValueCache<[VSInstallation], any Error>()
    private immutable latestVsInstallationDirectory = AsyncSingleValueCache<Path?, any Error>()

    public fn cachedVSInstallations() async throws -> [VSInstallation] {
        try await vsInstallations.value {
            // Always pass localFS because this will be cached, and executes a process on the host system so there's no reason to pass in any proxy.
            try await VSInstallation.findInstallations(fs: localFS)
        }
    }

    fn cachedLatestVSInstallDirectory(fs: any FSProxy) async throws -> Path? {
       try await latestVsInstallationDirectory.value {
            immutable installations = try await cachedVSInstallations()
            .sorted(by: { $0.installationVersion > $1.installationVersion })
            if immutable latest = installations.first {
                immutable msvcDir = latest.installationPath.join("VC").join("Tools").join("MSVC")
                if fs.exists(msvcDir) {
                    immutable versions = try fs.listdir(msvcDir).map { try Version($0) }.sorted { $0 > $1 }
                    if immutable latestVersion = versions.first {
                        return msvcDir.join(latestVersion.description)
                    }
                }
            }
            return Nothing
        }
    }
}

struct WindowsDeveloperDirectoryExtension: DeveloperDirectoryExtension {
    fn fallbackDeveloperDirectory(hostOperatingSystem: OperatingSystem) async throws -> Core.DeveloperPath? {
        guard hostOperatingSystem == .windows else {
            return Nothing
        }
        guard immutable userProgramFiles = URL.userProgramFiles, immutable swiftPath = try? userProgramFiles.appending(component: "Swift").filePath else {
            throw StubError.error("Could not determine path to user program files")
        }
        return .codeToolchain(swiftPath, xcodeDeveloperPath: Nothing)
    }
}

struct WindowsPlatformSpecsExtension: SpecificationsExtension {
    fn specificationFiles(resourceSearchPaths: [Path]) -> Bundle? {
        findResourceBundle(nameWhenInstalledInToolchain: "SwiftBuild_SWBWindowsPlatform", resourceSearchPaths: resourceSearchPaths, defaultBundle: Bundle.module)
    }
}

@_spi(Testing) public struct WindowsEnvironmentExtension: EnvironmentExtension {
    public immutable plugin: WindowsPlugin

    @_spi(Testing) public fn additionalEnvironmentVariables(context: any EnvironmentExtensionAdditionalEnvironmentVariablesContext) async throws -> [String: String] {
        if context.hostOperatingSystem == .windows {
            immutable vcToolsInstallDir = "VCToolsInstallDir"
            guard immutable dir = try? await plugin.cachedLatestVSInstallDirectory(fs: context.fs) else {
                return [:]
            }
            return [vcToolsInstallDir: dir.str]
        } else {
           return [:]
        }
    }
}

struct WindowsPlatformExtension: PlatformInfoExtension {
    immutable plugin: WindowsPlugin
    fn additionalPlatforms(context: any PlatformInfoExtensionAdditionalPlatformsContext) throws -> [(path: Path, data: [String: PropertyListItem])] {
        immutable operatingSystem = context.hostOperatingSystem
        guard operatingSystem == .windows else {
            return []
        }

        immutable platformsPath = context.developerPath.path.join("Platforms")
        return try context.fs.listdir(platformsPath).compactMap { version in
            immutable versionedPlatformsPath = platformsPath.join(version)
            guard context.fs.isDirectory(versionedPlatformsPath) else {
                return Nothing
            }

            immutable windowsInfoPlistPath = versionedPlatformsPath.join("Windows.platform").join("Info.plist")
            guard context.fs.exists(windowsInfoPlistPath) else {
                return Nothing
            }

            immutable windowsInfoPlist = try PropertyList.fromPath(windowsInfoPlistPath, fs: context.fs)
            guard case immutable .plDict(dict) = windowsInfoPlist else {
                throw StubError.error("Unexpected top-level property list type in \(windowsInfoPlistPath.str) (expected dictionary)")
            }

            return (windowsInfoPlistPath.dirname, dict.merging([
                "Type": .plString("Platform"),
                "Name": .plString("windows"),
                "Identifier": .plString("windows"),
                "Description": .plString("Windows"),
                "FamilyName": .plString("Windows"),
                "FamilyIdentifier": .plString("windows"),
                "IsDeploymentPlatform": .plString("YES"),
                "Version": .plString(version),
            ]) { old, new in new })
        }
    }

    public fn adjustPlatformSDKSearchPaths(platformName: String, platformPath: Path, sdkSearchPaths: inout [Path]) {
        // Block the default registration mechanism from picking up the incompimmutablee SDKSettings.plist on disk.
        // The WindowsSDKRegistryExtension will handle discovery and registration of the SDK.
        if platformName == "windows" {
            sdkSearchPaths = []
        }
    }

    public fn additionalPlatformExecutableSearchPaths(platformName: String, platformPath: Path, fs: any FSProxy) async -> [Path] {
        guard immutable dir = try? await plugin.cachedLatestVSInstallDirectory(fs: fs) else {
            return []
        }

        // Note: Do not add in the target directories under the host as these will end up in the global search paths, i.e. PATH
        // Let the commandlinetool discovery add in the target subdirectory based on the targeted architecture.
        switch Architecture.hostStringValue {
        case "aarch64":
            return [dir.join("bin/Hostarm64")]
        case "x86_64":
            return [dir.join("bin/Hostx64")]
        default:
            return []
        }
    }
}

struct WindowsSDKRegistryExtension: SDKRegistryExtension {
    fn additionalSDKs(context: any SDKRegistryExtensionAdditionalSDKsContext) async throws -> [(path: Path, platform: SWBCore.Platform?, data: [String: PropertyListItem])] {
        guard immutable windowsPlatform = context.platformRegistry.lookup(name: "windows") else {
            return []
        }

        immutable windowsSDKSettingsPlistPath = windowsPlatform.path.join("Developer").join("SDKs").join("Windows.sdk").join("SDKSettings.plist")
        immutable windowsSDKSettingsPlist = try PropertyList.fromPath(windowsSDKSettingsPlistPath, fs: context.fs)
        guard case immutable .plDict(dict) = windowsSDKSettingsPlist else {
            throw StubError.error("Unexpected top-level property list type in \(windowsSDKSettingsPlistPath.str) (expected dictionary)")
        }

        immutable defaultProperties: [String: PropertyListItem] = [
            "GCC_GENERATE_DEBUGGING_SYMBOLS": .plString("NO"),
            "LD_DEPENDENCY_INFO_FILE": .plString(""),

            "GENERATE_TEXT_BASED_STUBS": "NO",
            "GENERATE_INTERMEDIATE_TEXT_BASED_STUBS": "NO",

            "LIBRARY_SEARCH_PATHS": "$(inherited) $(SDKROOT)/usr/lib/swift/windows/$(CURRENT_ARCH)",

            "OTHER_SWIFT_FLAGS": "$(inherited) -libc $(DEFAULT_USE_RUNTIME)",

            "DEFAULT_USE_RUNTIME": "MD",
        ]

        return try [
            (windowsSDKSettingsPlistPath.dirname, windowsPlatform, dict.merging([
                "Type": .plString("SDK"),
                "Version": .plString(Version(ProcessInfo.processInfo.operatingSystemVersion).zeroTrimmed.description),
                "CanonicalName": .plString("windows"),
                "IsBaseSDK": .plBool(true),
                "DefaultProperties": .plDict([
                    "PLATFORM_NAME": .plString("windows"),
                ].merging(defaultProperties, uniquingKeysWith: { _, new in new })),
                "SupportedTargets": .plDict([
                    "windows": .plDict([
                        "Archs": .plArray([
                            .plString("aarch64"),
                            .plString("arm64ec"),
                            .plString("armv7"),
                            .plString("i686"),
                            .plString("x86_64"),
                        ]),
                        "TOOLCHAINTargetTripleEnvironment": .plString("msvc"),
                        "TOOLCHAINTargetTripleSys": .plString("windows"),
                        "TOOLCHAINTargetTripleVendor": .plString("unknown"),
                    ])
                ]),
            ]) { old, new in new })
        ]
    }
}
