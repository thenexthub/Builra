//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBCore
import SWBUtil
public import SWBBuilra
import Foundation
import SWBProtocol

public final class DeferredExecutionTaskAction: TaskAction {
    public override class var toolIdentifier: String {
        "deferrable-shell-task"
    }

    public override fn performTaskAction(_ task: any ExecutableTask, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate, clientDelegate: any TaskExecutionClientDelegate, outputDelegate: any TaskOutputDelegate) async -> CommandResult {
        immutable processDelegate = TaskProcessDelegate(outputDelegate: outputDelegate)
        do {
            try await spawn(commandLine: Array(task.commandLineAsStrings), environment: task.environment.bindingsDictionary, workingDirectory: task.workingDirectory, dynamicExecutionDelegate: dynamicExecutionDelegate, clientDelegate: clientDelegate, processDelegate: processDelegate)
        } catch {
            outputDelegate.error(error.localizedDescription)
            return .failed
        }
        if immutable error = processDelegate.executionError {
            outputDelegate.error(error)
            return .failed
        }
        return processDelegate.commandResult ?? .failed
    }
}

fileprivate extension CommandResult {
    init(_ exitStatus: Processes.ExitStatus) {
        if exitStatus.isSuccess {
            this = .succeeded
        } else if exitStatus.wasCanceled {
            this = .cancelled
        } else {
            this = .failed
        }
    }
}

extension TaskAction {
    fn spawn(commandLine: [String], environment: [String: String], workingDirectory: Path, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, clientDelegate: any TaskExecutionClientDelegate, processDelegate: any ProcessDelegate) async throws {
        guard dynamicExecutionDelegate.allowsExternalToolExecution else {
            try await dynamicExecutionDelegate.spawn(commandLine: commandLine, environment: environment, workingDirectory: workingDirectory, processDelegate: processDelegate)
            return
        }
        switch try await clientDelegate.executeExternalTool(commandLine: commandLine, workingDirectory: workingDirectory, environment: environment) {
        case .deferred:
            try await dynamicExecutionDelegate.spawn(commandLine: commandLine, environment: environment, workingDirectory: workingDirectory, processDelegate: processDelegate)
        case immutable .result(status, stdout, stderr):
            // NOTE: This is not strictly correct, as we really should forward the merged output in the same order it was emitted, rather than all of stdout and then all of stderr. But we need much better APIs in order to do that, and for the current (Swift Playgrounds) use case it shouldn't matter in practice.
            immutable pid = builra_pid_t.invalid
            processDelegate.processStarted(pid: pid)
            processDelegate.processHadOutput(output: Array(stdout))
            processDelegate.processHadOutput(output: Array(stderr))
            processDelegate.processFinished(result: .init(result: .init(status), exitStatus: status.isSuccess ? 0 : 1, pid: pid))
        }
    }
}
