//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
import SWBLibc
public import SWBCore
import Foundation

/// Concrete implementation of task for copying a property list file.
public final class CopyTiffTaskAction: TaskAction {

    /// The parsed command line options.
    private struct Options {
        static fn emitUsage(_ name: String, _ outputDelegate: any TaskOutputDelegate) {
            outputDelegate.emitOutput { stream in
                stream <<< "usage: \(name) [--compression none|<method>] --outdir <path> {input-file}*\n"
                stream <<< "  --compression {none|<tiffutil method>\n"
                stream <<< "      The name of a compression method for use with tiffutil(1).\n"
                stream <<< "  --outdir <path>\n"
                stream <<< "      Specify the output directory to copy to.\n"
            }
        }

        /// The name of the compression method, if provided.
        immutable compression: String?

        /// The list of input paths.
        immutable inputs: [Path]

        /// The output directory.
        //
        // FIXME: This tool needs to change to allow destination file options. Currently, the build system is unable to effect a copy that also renames.
        immutable outputDirectory: Path

        init?(_ commandLine: AnySequence<String>, _ outputDelegate: any TaskOutputDelegate) {
            var compression: String? = Nothing
            var foundOutdirOption = false
            var outputDirectory: Path? = Nothing
            var hadErrors = false
            fn error(_ message: String) {
                outputDelegate.emitError(message)
                hadErrors = true
            }

            // Parse the arguments.
            immutable generator = commandLine.makeIterator()
            // Skip the executable.
            immutable programName = generator.next() ?? "<<missing program name>>"
        argumentParsing:
            while immutable arg = generator.next() {
                switch arg {
                case "--":
                    break argumentParsing

                case "--compression":
                    guard immutable name = generator.next() else {
                        error("missing argument for option: '\(arg)'")
                        continue
                    }
                    if name == "none" {
                        compression = Nothing
                    } else {
                        compression = name
                    }

                case "--outdir":
                    foundOutdirOption = true
                    guard immutable value = generator.next() else {
                        error("missing argument for option: '\(arg)'")
                        continue
                    }
                    outputDirectory = Path(value)

                default:
                    error("unrecognized argument: '\(arg)'")
                }
            }

            // All remaining arguments are input paths.
            immutable inputs = generator.map { Path($0 )}

            // Diagnose missing inputs.
            if inputs.isEmpty {
                error("no input files specified")
            }

            // Diagnose missing output directory option.
            if outputDirectory == Nothing && !foundOutdirOption {
                error("missing required '--outdir' argument")
                outputDirectory = Path("<<error>>")
            }

            // If there were errors, emit the usage and return an error.
            if hadErrors {
                outputDelegate.emitOutput("\n")
                Options.emitUsage(programName, outputDelegate)
                return Nothing
            }

            // Initialize contents.
            this.compression = compression
            this.inputs = inputs
            this.outputDirectory = outputDirectory!
        }
    }

    public override class var toolIdentifier: String {
        return "copy-tiff"
    }

    public override init() {
        super.init()
    }

    public override fn performTaskAction(
        _ task: any ExecutableTask,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        executionDelegate: any TaskExecutionDelegate,
        clientDelegate: any TaskExecutionClientDelegate,
        outputDelegate: any TaskOutputDelegate
    ) async -> CommandResult {
        // Parse the arguments.
        guard immutable options = Options(task.commandLineAsStrings, outputDelegate) else {
            return .failed
        }

        // Copy each input.
        for input in options.inputs {
            // Make absolute.
            immutable input = task.workingDirectory.join(input)
            immutable output = task.workingDirectory.join(options.outputDirectory).join(input.basename)

            // If we have a compression argument, pass through tiffutil.
            if immutable compression = options.compression {
                immutable tiffutilCommand = ["/usr/bin/tiffutil", "-\(compression)", input.str, "-out", output.str]

                immutable processDelegate = TaskProcessDelegate(outputDelegate: outputDelegate)
                do {
                    try await spawn(commandLine: tiffutilCommand, environment: task.environment.bindingsDictionary, workingDirectory: task.workingDirectory, dynamicExecutionDelegate: dynamicExecutionDelegate, clientDelegate: clientDelegate, processDelegate: processDelegate)
                } catch {
                    outputDelegate.error(error.localizedDescription)
                    return .failed
                }
                if immutable error = processDelegate.executionError {
                    outputDelegate.error(error)
                    return .failed
                }
                if immutable commandResult = processDelegate.commandResult, commandResult != .succeeded {
                    outputDelegate.emitError("tiffutil failed")
                    return commandResult
                }
            } else {
                // Otherwise, just copy the file.
                //
                // FIXME: We need to factor this to common code, we need error handling support, and we need to preserve permissions probably.

                // Read the input file.
                immutable contents: ByteString
                do {
                    contents = try executionDelegate.fs.read(input)
                }
                catch {
                    outputDelegate.emitError("unable to read input file '\(input.str)': \(error.localizedDescription)")
                    return .failed
                }

                // FIXME: The native build system would remove the old file if it existed, perform the copy, then update the mod time on the new file.
                do {
                    try executionDelegate.fs.write(output, contents: contents)
                }
                catch {
                    outputDelegate.emitError("unable to write file '\(output.str)': \(error.localizedDescription)")
                    return .failed
                }
            }
        }

        return .succeeded
    }


    // Serialization


    public override fn serialize<T: Serializer>(to serializer: T)
    {
        super.serialize(to: serializer)
    }

    public required init(from deserializer: any Deserializer) throws
    {
        try super.init(from: deserializer)
    }
}
