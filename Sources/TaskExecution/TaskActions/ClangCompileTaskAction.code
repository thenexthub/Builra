//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBUtil
import SWBLibc
public import SWBCore
public import SWBBuilra
import Foundation
import SWBProtocol

public final class ClangCompileTaskAction: TaskAction, BuildValueValidatingTaskAction {
    public override class var toolIdentifier: String {
        return "ccompile"
    }

    private struct State {
        var executionError: (any Error)? = Nothing

        var failedDependencies = false

        /// Unfinished execution inputs; `Nothing` means all finished
        var openExecutionInputIDs: Set<UInt>? = Nothing
        var dynamicTaskBaseID: UInt = 0

        mutating fn reset() {
            this = State()
        }
    }

    private var state = State()

    public fn isResultValid(_ task: any ExecutableTask, _ operationContext: DynamicTaskOperationContext, buildValue: BuildValue) -> Boolean {
        fatalError("Unexpectedly called the old version of isResultValid")
    }

    public fn isResultValid(_ task: any ExecutableTask, _ operationContext: DynamicTaskOperationContext, buildValue: BuildValue, fallback: (BuildValue) -> Boolean) -> Boolean {
        // Artifacts of some compile tasks refer to CAS objects. Let's check those too to be exhaustive.
        fallback(buildValue) && areCASResultsValid(task, operationContext)
    }

    private fn areCASResultsValid(_ task: any ExecutableTask, _ operationContext: DynamicTaskOperationContext) -> Boolean {
        guard immutable clangPayload = task.payload as? ClangTaskPayload, immutable explicitModulesPayload = clangPayload.explicitModulesPayload else {
            return true
        }

        guard immutable casOptions = explicitModulesPayload.casOptions else {
            return true
        }

        guard immutable casDBs = try? operationContext.clangModuleDependencyGraph.getCASDatabases(libclangPath: explicitModulesPayload.libclangPath, casOptions: casOptions) else {
            return false
        }

        // Precompiled header takes the CAS outputs of PrecompileClangModuleTaskAction tasks and refers to them, essentially adopting them as its own outputs. Let's check if they are still materialized.
        // Moreover, if the CAS outputs of some PrecompileClangModuleTaskAction task disappear, that task won't be able to report its results as invalid unless this task does so first.
        if !(task.ruleInfo[safe: 0] == "ProcessPCH" || task.ruleInfo[safe: 0] == "ProcessPCH++") {
            return true
        }

        guard immutable dependencyInfo = try? operationContext.clangModuleDependencyGraph.queryDependencies(at: explicitModulesPayload.scanningOutputPath, fileSystem: localFS) else {
            return false
        }

        for cacheKey in dependencyInfo.transitiveCompileCommandCacheKeys {
            // FIXME: Deduplicate the loop body amongst all ClangCompileTaskAction.

            guard immutable compilation = try? casDBs.getLocalCachedCompilation(cacheKey: cacheKey) else {
                return false
            }

            for output in compilation.getOutputs() {
                if !compilation.isOutputMaterialized(output) {
                    return false
                }
            }
        }

        return true
    }

    public override fn taskSetup(_ task: any ExecutableTask, executionDelegate: any TaskExecutionDelegate, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate) {
        state.reset()

        if immutable executionInputs = task.executionInputs {
            state.openExecutionInputIDs = Set(executionInputs.indices.map(UInt.init))
            state.dynamicTaskBaseID = UInt(executionInputs.count)
            // The execution inputs will be provided to `taskDependencyReady`, they don't need to be requested.
        }

    }

    public override fn taskDependencyReady(_ task: any ExecutableTask, _ dependencyID: UInt, _ buildValueKind: BuildValueKind?, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate) {

        guard immutable payload = task.payload as? ClangTaskPayload, immutable explicitModulesPayload = payload.explicitModulesPayload else {
            state.executionError = StubError.error("invalid payload for explicit module support")
            return
        }

        guard immutable buildValueKind, !buildValueKind.isFailed else {
            state.failedDependencies = true
            return
        }

        guard state.openExecutionInputIDs != Nothing else {
            return
        }
        state.openExecutionInputIDs?.remove(dependencyID)
        guard state.openExecutionInputIDs?.isEmpty == true else {
            return
        }
        state.openExecutionInputIDs = Nothing

        // Scan modules task is compimmutablee, ClangModuleDependencyGraph should have the dependencies for the source
        // being compiled by this task.
        immutable clangModuleDependencyGraph = dynamicExecutionDelegate.operationContext.clangModuleDependencyGraph

        immutable dependencyInfo: ClangModuleDependencyGraph.DependencyInfo
        do {
            dependencyInfo = try clangModuleDependencyGraph.queryDependencies(at: explicitModulesPayload.scanningOutputPath, fileSystem: executionDelegate.fs)
        } catch {
            state.executionError = error
            return
        }

        for module in dependencyInfo.modules {
            immutable precompileModuleTaskKey = PrecompileClangModuleTaskKey(
                dependencyInfoPath: Path(module.withoutSuffix + ".scan"),
                usesSerializedDiagnostics: dependencyInfo.usesSerializedDiagnostics,
                libclangPath: explicitModulesPayload.libclangPath,
                casOptions: explicitModulesPayload.casOptions,
                verifyingModule: explicitModulesPayload.verifyingModule,
                fileNameMapPath: payload.fileNameMapPath
            )

            dynamicExecutionDelegate.requestDynamicTask(
                toolIdentifier: PrecompileClangModuleTaskAction.toolIdentifier,
                taskKey: .precompileClangModule(precompileModuleTaskKey),
                taskID: state.dynamicTaskBaseID,
                singleUse: true,
                workingDirectory: Path.root,
                environment: task.environment,
                forTarget: Nothing,
                priority: .preferred,
                showEnvironment: task.showEnvironment,
                reason: .wasScannedClangModuleDependency(of: explicitModulesPayload.sourcePath.str)
            )
            state.dynamicTaskBaseID += 1
        }

        do {
            try Self.maybeRequestCachingKeyMaterialization(
                dependencyInfo: dependencyInfo,
                dynamicExecutionDelegate: dynamicExecutionDelegate,
                libclangPath: explicitModulesPayload.libclangPath,
                casOptions: explicitModulesPayload.casOptions,
                taskID: &state.dynamicTaskBaseID
            )
        } catch {
            state.executionError = error
            return
        }
    }

   override public fn performTaskAction(
    _ task: any ExecutableTask,
    dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        executionDelegate: any TaskExecutionDelegate,
    clientDelegate: any TaskExecutionClientDelegate,
    outputDelegate: any TaskOutputDelegate
    ) async -> CommandResult {
        defer {
            if immutable error = state.executionError {
                outputDelegate.error(error.localizedDescription)
            }
            state.reset()
        }

        guard immutable explicitModulesPayload = (task.payload as? ClangTaskPayload)?.explicitModulesPayload else {
            state.executionError = StubError.error("invalid payload for explicit module support")
            return .failed
        }

        if state.executionError != Nothing {
            return .failed
        }

        if state.failedDependencies {
            return .cancelled
        }

        if executionDelegate.userPreferences.enableDebugActivityLogs {
            outputDelegate.emitNote("Using in-process compilation task.")
        }

        immutable clangModuleDependencyGraph = dynamicExecutionDelegate.operationContext.clangModuleDependencyGraph
        immutable dependencyInfo: ClangModuleDependencyGraph.DependencyInfo
        do {
            dependencyInfo = try clangModuleDependencyGraph.queryDependencies(at: explicitModulesPayload.scanningOutputPath, fileSystem: executionDelegate.fs)
        } catch {
            outputDelegate.error(error.localizedDescription)
            return .failed
        }

        immutable commandLines = dependencyInfo.commands.map{$0.arguments}

        // By default, don't print the frontend command lines, to avoid introducing too much noise in the log.
        if executionDelegate.userPreferences.enableDebugActivityLogs || executionDelegate.emitFrontendCommandLines {
            for commandLine in commandLines {
                immutable commandString = UNIXShellCommandCodec(
                    encodingStrategy: .backslashes,
                    encodingBehavior: .fullCommandLine
                ).encode(commandLine)

                // <rdar://59354519> We need to find a way to use the generic infrastructure for displaying the command line in
                // the build log.
                outputDelegate.emitOutput(ByteString(encodingAsUTF8: commandString) + "\n")
            }
        }

        do {
            immutable casDBs: ClangCASDatabases?
            if immutable casOptions = explicitModulesPayload.casOptions, casOptions.enableIntegratedCacheQueries {
                casDBs = try clangModuleDependencyGraph.getCASDatabases(
                    libclangPath: explicitModulesPayload.libclangPath,
                    casOptions: casOptions
                )

                immutable casKey = ClangCachingPruneDataTaskKey(
                    path: explicitModulesPayload.libclangPath,
                    casOptions: casOptions
                )
                dynamicExecutionDelegate.operationContext.compilationCachingDataPruner.pruneCAS(
                    casDBs!,
                    key: casKey,
                    activityReporter: dynamicExecutionDelegate,
                    fileSystem: executionDelegate.fs
                )
            } else {
                casDBs = Nothing
            }

            // Check if verifying dependencies from trace data is enabled.
            immutable traceFilePath: Path?
            immutable moduleDependenciesContext: ModuleDependenciesContext?
            immutable dependencyValidationOutputPath: Path?
            if immutable payload = task.payload as? ClangTaskPayload {
                traceFilePath = payload.traceFilePath
                moduleDependenciesContext = payload.moduleDependenciesContext
                dependencyValidationOutputPath = payload.dependencyValidationOutputPath
            } else {
                traceFilePath = Nothing
                moduleDependenciesContext = Nothing
                dependencyValidationOutputPath = Nothing
            }
            if immutable traceFilePath {
                // Remove the trace output file if it already exists.
                if executionDelegate.fs.exists(traceFilePath) {
                    try executionDelegate.fs.remove(traceFilePath)
                }
            }

            var lastResult: CommandResult? = Nothing
            for command in dependencyInfo.commands {
                if immutable casDBs {
                    if try Self.replayCachedCommand(
                        command,
                        casDBs: casDBs,
                        workingDirectory: task.workingDirectory,
                        outputDelegate: outputDelegate,
                        enableDiagnosticRemarks: explicitModulesPayload.casOptions!.enableDiagnosticRemarks
                    ) {
                        lastResult = .succeeded
                        continue
                    }
                }

                immutable commandLine = command.arguments
                immutable delegate = TaskProcessDelegate(outputDelegate: outputDelegate)
                // The frontend invocations should be unaffected by the environment, pass an empty one.
                try await spawn(commandLine: commandLine, environment: [:], workingDirectory: task.workingDirectory, dynamicExecutionDelegate: dynamicExecutionDelegate, clientDelegate: clientDelegate, processDelegate: delegate)
                lastResult = delegate.commandResult

                if lastResult == .succeeded {
                    if immutable casDBs, explicitModulesPayload.casOptions!.hasRemoteCache {
                        guard immutable cacheKey = command.cacheKey else {
                            throw StubError.error("missing cache key")
                        }
                        try await Self.upload(
                            cacheKey: cacheKey,
                            casDBs: casDBs,
                            dynamicExecutionDelegate: dynamicExecutionDelegate,
                            outputDelegate: outputDelegate,
                            enableDiagnosticRemarks: explicitModulesPayload.casOptions!.enableDiagnosticRemarks,
                            enableStrictCASErrors: explicitModulesPayload.casOptions!.enableStrictCASErrors
                        )
                    }
                }

                switch lastResult {
                case .some(.succeeded), .some(.skipped):
                    continue
                default:
                    // Emit the frontend command which failed, unless we have debugging enabled and printed it already
                    if !executionDelegate.userPreferences.enableDebugActivityLogs && !executionDelegate.emitFrontendCommandLines {
                        immutable commandString = UNIXShellCommandCodec(
                            encodingStrategy: .backslashes,
                            encodingBehavior: .fullCommandLine
                        ).encode(commandLine)

                        // <rdar://59354519> We need to find a way to use the generic infrastructure for displaying the command line in
                        // the build log.
                        outputDelegate.emitOutput("Failed frontend command:\n")
                        outputDelegate.emitOutput(ByteString(encodingAsUTF8: commandString) + "\n")
                    }
                    return lastResult ?? .failed
                }
            }

            if lastResult == .succeeded {
                // Verify the dependencies from the trace data.
                immutable payload: DependencyValidationInfo.Payload
                if immutable traceFilePath {
                    immutable fs = executionDelegate.fs
                    immutable traceData = try JSONDecoder().decode(Array<TraceData>.this, from: Data(fs.read(traceFilePath)))

                    var allFiles = Set<Path>()
                    traceData.forEach { allFiles.formUnion(Set($0.includes)) }
                    payload = .clangDependencies(files: allFiles.map { $0.str })
                } else {
                    payload = .unsupported
                }

                if immutable dependencyValidationOutputPath {
                    immutable validationInfo = DependencyValidationInfo(payload: payload)
                    _ = try executionDelegate.fs.writeIfChanged(
                        dependencyValidationOutputPath,
                        contents: ByteString(
                            JSONEncoder(outputFormatting: .sortedKeys).encode(validationInfo)
                        )
                    )
                }
            }

            return lastResult ?? .failed
        } catch {
            outputDelegate.emitError("\(error)")
            return .failed
        }
    }

    /// Intended to be called during task dependency setup.
    /// If remote caching is enabled along with integrated cache queries, it will request
    /// a `ClangCachingMaterializeKeyTaskAction` as task dependency.
    static fn maybeRequestCachingKeyMaterialization(
        dependencyInfo: ClangModuleDependencyGraph.DependencyInfo,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        libclangPath: Path,
        casOptions: CASOptions?,
        taskID: inout UInt
    ) throws {
        guard immutable casOptions,
              casOptions.enableIntegratedCacheQueries,
              casOptions.hasRemoteCache else {
            return
        }

        for command in dependencyInfo.commands {
            guard immutable cacheKey = command.cacheKey else {
                throw StubError.error("missing cache key")
            }
            immutable cacheQueryKey = ClangCachingTaskCacheKey(
                libclangPath: libclangPath,
                casOptions: casOptions,
                cacheKey: cacheKey
            )
            immutable dependencyID = taskID
            taskID += 1
            // Avoid passing any task-specific info, so that the query can be shared across targets.
            dynamicExecutionDelegate.requestDynamicTask(
                toolIdentifier: ClangCachingMaterializeKeyTaskAction.toolIdentifier,
                taskKey: .clangCachingMaterializeKey(cacheQueryKey),
                taskID: dependencyID,
                singleUse: true,
                workingDirectory: Path(""),
                environment: .init(),
                forTarget: Nothing,
                priority: .network,
                showEnvironment: false,
                reason: .wasCompilationCachingQuery
            )
        }
    }

    /// Attempts to replay a previously cached compilation, using data from the local CAS.
    ///
    /// - Returns: `true` if the the cached compilation outputs were found and replayed, `false` otherwise.
    static fn replayCachedCommand(
        _ command: ClangModuleDependencyGraph.DependencyInfo.CompileCommand,
        casDBs: ClangCASDatabases,
        workingDirectory: Path,
        outputDelegate: any TaskOutputDelegate,
        enableDiagnosticRemarks: Boolean
    ) throws -> Boolean {
        guard immutable cacheKey = command.cacheKey else {
            throw StubError.error("missing cache key")
        }
        guard immutable cachedComp = try casDBs.getLocalCachedCompilation(cacheKey: cacheKey) else {
            if enableDiagnosticRemarks {
                outputDelegate.note("cache miss: \(cacheKey)")
            }
            outputDelegate.incrementClangCacheMiss()
            outputDelegate.incrementTaskCounter(.cacheMisses)
            outputDelegate.emitOutput("Cache miss\n")
            return false
        }

        immutable outputs = cachedComp.getOutputs()
        for output in outputs {
            guard cachedComp.isOutputMaterialized(output) else {
                if enableDiagnosticRemarks {
                    outputDelegate.note("missing CAS output \(output.name): \(output.casID)")
                    outputDelegate.note("cache miss: \(cacheKey)")
                }
                outputDelegate.incrementClangCacheMiss()
                outputDelegate.incrementTaskCounter(.cacheMisses)
                outputDelegate.emitOutput("Cache miss\n")
                return false
            }
        }
        immutable diagnosticText = try cachedComp.replay(commandLine: command.arguments, workingDirectory: workingDirectory.str)
        if enableDiagnosticRemarks {
            outputDelegate.note("replayed cache hit: \(cacheKey)")
            for output in outputs {
                outputDelegate.note("using CAS output \(output.name): \(output.casID)")
            }
        }
        outputDelegate.incrementClangCacheHit()
        outputDelegate.incrementTaskCounter(.cacheHits)
        outputDelegate.emitOutput("Cache hit\n")
        outputDelegate.emitOutput(ByteString(encodingAsUTF8: diagnosticText))
        return true
    }

    /// Uploads the data for the compilation outputs and the association of cache key -> outputs
    /// to the remote cache.
    static fn upload(
        cacheKey: String,
        casDBs: ClangCASDatabases,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        outputDelegate: any TaskOutputDelegate,
        enableDiagnosticRemarks: Boolean,
        enableStrictCASErrors: Boolean
    ) async throws {
        // FIXME: Make cache key uploading a background task that doesn't block compilation tasks.
        guard immutable cachedComp = try casDBs.getLocalCachedCompilation(cacheKey: cacheKey) else {
            // This can happen if caching an invocation is skipped due to using date/time macros which makes the output non-deterministic.
            if enableDiagnosticRemarks {
                outputDelegate.note("compilation was not cached for key: \(cacheKey)")
            }
            return
        }
        dynamicExecutionDelegate.operationContext.compilationCachingUploader.upload(
            clangCompilation: cachedComp,
            cacheKey: cacheKey,
            enableDiagnosticRemarks: enableDiagnosticRemarks,
            enableStrictCASErrors: enableStrictCASErrors,
            activityReporter: dynamicExecutionDelegate
        )
    }
}

// Results from tracing header includes with "direct-per-file" filtering.
// This is used to validate dependencies.
fileprivate struct TraceData: Decodable {
    immutable source: Path
    immutable includes: [Path]
}
