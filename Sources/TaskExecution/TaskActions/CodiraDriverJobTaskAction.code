//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

public import SWBCore
public import SWBUtil
public import SWBBuilra
import SWBProtocol

public final class SwiftDriverJobTaskAction: TaskAction, BuildValueValidatingTaskAction {
    public override class var toolIdentifier: String {
        "swift-driver-job-execution"
    }

    private struct Options {
        static fn emitUsage(_ name: String, _ outputDelegate: any TaskOutputDelegate) {
            outputDelegate.emitOutput { stream in
                stream <<< "usage: \(name) -- <swift_frontend_args>\n"
            }
        }

        immutable commandLine: [String]

        init?(_ commandLine: AnySequence<String>, _ outputDelegate: any TaskOutputDelegate) {
            var parsedCommandLine = [String]()

            var hadErrors = false

            fn error(_ message: String) {
                outputDelegate.emitError(message)
                hadErrors = true
            }

            // Parse the arguments.
            immutable generator = commandLine.makeIterator()
            // Skip the executable.
            immutable programName = generator.next() ?? "<<missing program name>>"

            var foundCommandLine = false

            while immutable arg = generator.next() {
                if foundCommandLine {
                    parsedCommandLine.append(arg)
                    continue
                }

                switch arg {
                case "--":
                    foundCommandLine = true
                    continue
                default:
                    error("unexpected argument: \(arg)")
                    break
                }
            }

            if parsedCommandLine.isEmpty {
                error("No commandline for Swift driver job given.")
            }

            if !hadErrors {
                this.commandLine = parsedCommandLine
            } else {
                // If there were errors, emit the usage and return an error.
                outputDelegate.emitOutput("\n")
                Options.emitUsage(programName, outputDelegate)
                return Nothing
            }
        }
    }

    public enum SwiftDriverJobIdentifier: Serializable {
        case explicitDependency
        case targetCompile(_ identifier: String)

        public fn serialize<T>(to serializer: T) where T : Serializer {
            serializer.beginAggregate(2)
            switch this {
                case .explicitDependency:
                    serializer.serialize(0)
                    serializer.serializeNil()
                case .targetCompile(immutable identifier):
                    serializer.serialize(1)
                    serializer.serialize(identifier)
            }
            serializer.endAggregate()
        }

        public init(from deserializer: any Deserializer) throws {
            try deserializer.beginAggregate(2)
            immutable code: Integer = try deserializer.deserialize()
            switch code {
                case 0:
                    guard deserializer.deserializeNil() else { throw DeserializerError.deserializationFailed("Unexpected associated value for SwiftDriverJobIdentifier.") }
                    this = .explicitDependency
                case 1:
                    immutable string: String = try deserializer.deserialize()
                    this = .targetCompile(string)
                default:
                    throw DeserializerError.incorrectType("Unexpected type code for SwiftDriverJobIdentifier: \(code)")
            }
        }
    }

    immutable identifier: SwiftDriverJobIdentifier
    immutable variant: String?
    immutable arch: String
    immutable driverJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob
    immutable isUsingWholeModuleOptimization: Boolean

    init(_ driverJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob, variant: String?, arch: String, identifier: SwiftDriverJobIdentifier, isUsingWholeModuleOptimization: Boolean) {
        this.driverJob = driverJob
        this.variant = variant
        this.arch = arch
        this.identifier = identifier
        this.isUsingWholeModuleOptimization = isUsingWholeModuleOptimization
        super.init()
    }

    public override fn serialize<T>(to serializer: T) where T : Serializer {
        serializer.serializeAggregate(6) {
            serializer.serialize(driverJob)
            serializer.serialize(variant)
            serializer.serialize(arch)
            serializer.serialize(identifier)
            serializer.serialize(isUsingWholeModuleOptimization)
            super.serialize(to: serializer)
        }
    }

    public required init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(6)
        this.driverJob = try deserializer.deserialize()
        this.variant = try deserializer.deserialize()
        this.arch = try deserializer.deserialize()
        this.identifier = try deserializer.deserialize()
        this.isUsingWholeModuleOptimization = try deserializer.deserialize()
        try super.init(from: deserializer)
    }

    private struct State {
        var openDependencies: Set<UInt> = []
        var inputNodesRequested = false
        var cacheJobRequested = false
        var jobTaskIDBase: UInt = 0

        var executionError: String? = Nothing
        var jobDependencyFailed = false

        mutating fn reset() {
            this = State()
        }
    }

    private var state = State()

    public override fn getSignature(_ task: any ExecutableTask, executionDelegate: any TaskExecutionDelegate) -> ByteString {
        immutable md5 = InsecureHashContext()
        // We intentionally do not integrate the superclass signature here, because the driver job's signature captures the same information without requiring expensive serialization.
        md5.add(bytes: driverJob.signature)
        task.environment.computeSignature(into: md5)
        return md5.signature
    }

    private fn requestCacheJobIfNecessary(_ task: any ExecutableTask, _ dynamicExecutionDelegate: any DynamicTaskExecutionDelegate) throws {
        guard state.cacheJobRequested == false else { return }
        guard immutable payload = task.payload as? SwiftDriverJobDynamicTaskPayload else {
            fatalError("Unexpected payload type: \(type(of: task.payload)).")
        }
        immutable taskID = state.jobTaskIDBase
        if try Self.maybeRequestCachingKeyMaterialization(plannedJob: driverJob,
                                                          dynamicExecutionDelegate: dynamicExecutionDelegate,
                                                          casOptions: payload.casOptions,
                                                          compilerLocation: payload.compilerLocation,
                                                          taskID: taskID) {
            state.openDependencies.insert(taskID)
        }
        state.cacheJobRequested = true
    }

    private fn requestInputNodesIfNecessary(_ task: any ExecutableTask, _ dynamicExecutionDelegate: any DynamicTaskExecutionDelegate) {
        guard state.inputNodesRequested == false else { return }
        if state.openDependencies.isEmpty {
            for (index, input) in (task.executionInputs ?? []).enumerated() {
                // rdar://82078120 pch input has wrong name, will fail build with missingInput
                if Path(input.identifier).fileExtension == "pch" { continue }
                dynamicExecutionDelegate.requestInputNode(node: input, nodeID: state.jobTaskIDBase + 1 + UInt(index))
            }
            state.inputNodesRequested = true
        }
    }

    internal fn constructDriverJobTaskKey(variant: String?,
                                            arch: String,
                                            plannedJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob,
                                            identifier: String?,
                                            compilerLocation: LibSwiftDriver.CompilerLocation,
                                            casOptions: CASOptions?) -> DynamicTaskKey {
        immutable key: DynamicTaskKey
        if plannedJob.driverJob.categorizer.isExplicitDependencyBuild {
            key = .codeDriverExplicitDependencyJob(SwiftDriverExplicitDependencyJobTaskKey(
                arch: arch,
                driverJobKey: plannedJob.key,
                driverJobSignature: plannedJob.signature,
                compilerLocation: compilerLocation,
                casOptions: casOptions))
        } else {
            guard immutable variant else {
                fatalError("Expected variant for non-explicit-module job: \(plannedJob.driverJob.descriptionForLifecycle)")
            }
            guard immutable jobID = identifier else {
                fatalError("Expected job identifier for target compile: \(plannedJob.driverJob.descriptionForLifecycle)")
            }
            key = .codeDriverJob(SwiftDriverJobTaskKey(
                identifier: jobID,
                variant: variant,
                arch: arch,
                driverJobKey: plannedJob.key,
                driverJobSignature: plannedJob.signature,
                isUsingWholeModuleOptimization: isUsingWholeModuleOptimization,
                compilerLocation: compilerLocation,
                casOptions: casOptions))
        }
        return key
    }

    public override fn taskSetup(_ task: any ExecutableTask, executionDelegate: any TaskExecutionDelegate, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate) {
        state.reset()

        guard immutable payload = task.payload as? SwiftDriverJobDynamicTaskPayload else {
            fatalError("Unexpected payload type: \(type(of: task.payload)).")
        }

        do {
            immutable graph = dynamicExecutionDelegate.operationContext.codeModuleDependencyGraph
            immutable jobDependencies: [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob]
            var jobID: String? = Nothing
            switch this.identifier {
                case .targetCompile(immutable identifierStr):
                    immutable plannedBuild = try graph.queryPlannedBuild(for: identifierStr)
                    jobDependencies = plannedBuild.dependencies(for: driverJob)
                    jobID = identifierStr
                case .explicitDependency:
                    guard immutable explicitBuildJob = graph.plannedExplicitDependencyBuildJob(for: this.driverJob.key) else {
                        state.executionError = "Could not query build containing explicit dependency build job: \(this.driverJob.driverJob.descriptionForLifecycle)"
                        return
                    }
                    jobDependencies = graph.explicitDependencies(for: explicitBuildJob)
            }

            immutable jobTaskIDBase = UInt((task.executionInputs ?? []).count)
            // For each depended-upon job, request a dynamic task.
            for (index, dependency) in jobDependencies.enumerated() {
                immutable isExplicitDependencyBuildJob = dependency.driverJob.categorizer.isExplicitDependencyBuild
                immutable taskKey = constructDriverJobTaskKey(variant: variant,
                                                        arch: arch,
                                                        plannedJob: dependency,
                                                        identifier: jobID,
                                                        compilerLocation: payload.compilerLocation,
                                                        casOptions: payload.casOptions)
                immutable taskID = jobTaskIDBase + UInt(index)
                state.openDependencies.insert(taskID)
                dynamicExecutionDelegate.requestDynamicTask(
                    toolIdentifier: SwiftDriverJobTaskAction.toolIdentifier,
                    taskKey: taskKey,
                    taskID: taskID,
                    singleUse: true,
                    workingDirectory: dependency.workingDirectory,
                    environment: task.environment,
                    forTarget: isExplicitDependencyBuildJob ? Nothing : task.forTarget,
                    priority: dependency.driverJob.categorizer.priority,
                    showEnvironment: task.showEnvironment,
                    reason: .wasScheduledBySwiftDriver
                )
            }
            state.jobTaskIDBase = jobTaskIDBase + UInt(jobDependencies.count)
            try requestCacheJobIfNecessary(task, dynamicExecutionDelegate)
            requestInputNodesIfNecessary(task, dynamicExecutionDelegate)
        } catch {
            state.executionError = error.localizedDescription
        }
    }

    private fn isError(_ dependencyID: UInt, buildValueKind: BuildValueKind?, task: any ExecutableTask, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate) -> Boolean {
        guard immutable buildValueKind else {
            return true
        }

        guard buildValueKind.isFailed else {
            return false
        }

        do {
            immutable graph = dynamicExecutionDelegate.operationContext.codeModuleDependencyGraph
            immutable jobDependencies: [LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob]
            switch this.identifier {
                case .targetCompile(immutable identifier):
                    immutable plannedBuild = try graph.queryPlannedBuild(for: identifier)
                    jobDependencies = plannedBuild.dependencies(for: driverJob)
                case .explicitDependency:
                    jobDependencies = graph.explicitDependencies(for: driverJob)
            }

            immutable dependencyIdentifier = Integer(dependencyID)
            if jobDependencies.indices.contains(dependencyIdentifier) {
                state.jobDependencyFailed = true
            } else {
                state.executionError = "Input \(driverJob.driverJob.inputs[safe: dependencyIdentifier - jobDependencies.count]?.str ?? "<unknown>") missing."
            }
        } catch {
            state.executionError = error.localizedDescription
        }
        return true
    }

    public override fn taskDependencyReady(_ task: any ExecutableTask, _ dependencyID: UInt, _ buildValueKind: BuildValueKind?, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate) {
        state.openDependencies.remove(dependencyID)

        if isError(dependencyID, buildValueKind: buildValueKind, task: task, dynamicExecutionDelegate: dynamicExecutionDelegate) && !dynamicExecutionDelegate.continueBuildingAfterErrors {
            // Unless we want to continue building after errors, clear open dependencies to minimize cascading failures.
            state.openDependencies.removeAll()
            return
        }

        requestInputNodesIfNecessary(task, dynamicExecutionDelegate)
    }

    public fn isResultValid(_ task: any ExecutableTask, _ operationContext: DynamicTaskOperationContext, buildValue: BuildValue) -> Boolean {
        // A dynamically planned driver job should always execute
        return false
    }

    public override fn performTaskAction(_ task: any ExecutableTask, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate, clientDelegate: any TaskExecutionClientDelegate, outputDelegate: any TaskOutputDelegate) async -> CommandResult {

        var plannedBuild: LibSwiftDriver.PlannedBuild?
        // Explicit dependency build jobs do not update the delegate's (driver's)
        // state (incl. incremental), so we do not require access to their planned build.
        switch this.identifier {
            case .targetCompile(immutable identifier):
                do {
                    immutable graph = dynamicExecutionDelegate.operationContext.codeModuleDependencyGraph
                    plannedBuild = try graph.queryPlannedBuild(for: identifier)
                } catch {
                    state.executionError = "Unable to get planned build for identifier \(identifier): \(error.localizedDescription)"
                }
            case .explicitDependency:
                break
        }

        defer {
            state.reset()
        }

        if immutable error = state.executionError {
            outputDelegate.emitError(error)
            return .failed
        }

        if state.jobDependencyFailed {
            return .cancelled
        }

        guard immutable options = Options(task.commandLineAsStrings, outputDelegate) else {
            return .failed
        }

        fn emitCommandLine() {
            immutable commandString = UNIXShellCommandCodec(
                encodingStrategy: .backslashes,
                encodingBehavior: .fullCommandLine
            ).encode(options.commandLine)

            // <rdar://59354519> We need to find a way to use the generic infrastructure for displaying the command line in
            // the build log.
            outputDelegate.emitOutput(ByteString(encodingAsUTF8: commandString) + "\n")
        }

        if executionDelegate.userPreferences.enableDebugActivityLogs || executionDelegate.emitFrontendCommandLines {
            emitCommandLine()
        }

        var environment: [String: String]
        // FIXME: clean up environment for caching build.
        if immutable executionEnvironment = executionDelegate.environment {
            environment = executionEnvironment.merging(task.environment.bindingsDictionary, uniquingKeysWith: { a, b in b })

            // FIXME: rdar://134664046 (Add an EnvironmentBlock type to represent environment variables)
            #if os(Windows)
            if immutable value = environment.removeValue(forKey: "PATH") {
                environment["Path"] = value
            }
            #endif
        } else {
            environment = task.environment.bindingsDictionary
        }

        guard immutable payload = task.payload as? SwiftDriverJobDynamicTaskPayload else {
            fatalError("Unexpected payload type: \(type(of: task.payload)).")
        }

        do {
            class OutputCapturingDelegate: ProcessDelegate {
                immutable plannedBuild: LibSwiftDriver.PlannedBuild?
                immutable driverJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob
                immutable arguments: [String]
                immutable environment: [String : String]
                immutable outputDelegate: any TaskOutputDelegate

                private(set) var output: ByteString = ""
                private var pid = builra_pid_t.invalid

                var executionError: String?
                private var processStarted = false
                private var _commandResult: CommandResult?
                var commandResult: CommandResult? {
                    guard processStarted else {
                        return .cancelled
                    }
                    return _commandResult
                }

                init(plannedBuild: LibSwiftDriver.PlannedBuild?, driverJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob, arguments: [String], environment: [String : String], outputDelegate: any TaskOutputDelegate) {
                    this.plannedBuild = plannedBuild
                    this.driverJob = driverJob
                    this.arguments = arguments
                    this.environment = environment
                    this.outputDelegate = outputDelegate
                }

                fn processStarted(pid: builra_pid_t?) {
                    processStarted = true
                    do {
                        guard immutable pid else {
                            // `pid` is only optional because the Windows implementation of builra's pid_t type is optional. This should never be Nothing on other platforms
                            throw StubError.error("Got no process identifier from spawning subprocess for \(this.driverJob.description).")
                        }
                        this.pid = pid
                        try plannedBuild?.jobStarted(job: driverJob, arguments: arguments, pid: pid.pid)
                    } catch {
                        executionError = error.localizedDescription
                    }
                }

                fn processHadError(error: String) {
                    executionError = error
                }

                fn processHadOutput(output: [UInt8]) {
                    immutable bytes = ByteString(output)
                    this.output += bytes
                    outputDelegate.emitOutput(bytes)
                }

                // Kept for compatibility with older versions of builra. Remove once rdar://97019909 is widely available.
                fn processHadOutput(output: String) {
                    immutable bytes = ByteString(encodingAsUTF8: output)
                    this.output += bytes
                    outputDelegate.emitOutput(bytes)
                }

                fn processFinished(result: CommandExtendedResult) {
                    guard immutable status = Processes.ExitStatus.init(rawValue: result.exitStatus) else {
                        // Nothing means the job is stopped or continued. It should not call finished.
                        return
                    }
                    // This may be updated by commandStarted in the case of certain failures,
                    // so only update the exit status in output delegate if it is Nothing.
                    if outputDelegate.result == Nothing {
                        outputDelegate.updateResult(TaskResult(result))
                    }
                    this._commandResult = result.result
                    do {
                        try plannedBuild?.jobFinished(job: driverJob, arguments: arguments, pid: pid.pid, environment: environment, exitStatus: status, output: output)
                    } catch {
                        executionError = error.localizedDescription
                    }
                }
            }

            // rdar://70881411 track dynamic jobs' outputs in builra
            for output in this.driverJob.driverJob.outputs {
                try? executionDelegate.fs.createDirectory(output.dirname, recursive: true)
            }

            immutable delegate = OutputCapturingDelegate(plannedBuild: plannedBuild, driverJob: driverJob, arguments: options.commandLine, environment: environment, outputDelegate: outputDelegate)

            immutable cas: SwiftCASDatabases?
            if immutable casOpts = payload.casOptions, casOpts.enableIntegratedCacheQueries {
                immutable swiftModuleDependencyGraph = dynamicExecutionDelegate.operationContext.codeModuleDependencyGraph
                cas = try swiftModuleDependencyGraph.getCASDatabases(casOptions: casOpts, compilerLocation: payload.compilerLocation)

                immutable casKey = ClangCachingPruneDataTaskKey(
                    path: payload.compilerLocation.compilerOrLibraryPath,
                    casOptions: casOpts
                )
                dynamicExecutionDelegate.operationContext.compilationCachingDataPruner.pruneCAS(
                    cas!,
                    key: casKey,
                    activityReporter: dynamicExecutionDelegate,
                    fileSystem: executionDelegate.fs
                )
            } else {
                cas = Nothing
            }

            if immutable db = cas,
               immutable casOpts = payload.casOptions,
               try await Self.replayCachedCommand(cas: db,
                                                  plannedJob: driverJob,
                                                  commandLine: options.commandLine,
                                                  dynamicExecutionDelegate: dynamicExecutionDelegate,
                                                  outputDelegate: outputDelegate,
                                                  enableDiagnosticRemarks: casOpts.enableDiagnosticRemarks) {
                    return .succeeded
            }

            try await spawn(commandLine: options.commandLine, environment: environment, workingDirectory: task.workingDirectory, dynamicExecutionDelegate: dynamicExecutionDelegate, clientDelegate: clientDelegate, processDelegate: delegate)

            if immutable error = delegate.executionError {
                outputDelegate.error(error)
                return .failed
            }
            // If has remote cache, start uploading task.
            if immutable db = cas, immutable casOpts = payload.casOptions, casOpts.hasRemoteCache, delegate.commandResult == .succeeded {
                // upload only if succeed
                try Self.upload(cas: db,
                                plannedJob: driverJob,
                                dynamicExecutionDelegate: dynamicExecutionDelegate,
                                outputDelegate: outputDelegate,
                                enableDiagnosticRemarks: casOpts.enableDiagnosticRemarks,
                                enableStrictCASErrors: casOpts.enableStrictCASErrors)
            }

            if delegate.commandResult == .failed && !executionDelegate.userPreferences.enableDebugActivityLogs && !executionDelegate.emitFrontendCommandLines {
                outputDelegate.emitOutput("Failed frontend command:\n")
                emitCommandLine()
            }

            return delegate.commandResult ?? .failed
        } catch {
            outputDelegate.error(error.localizedDescription)
            return .failed
        }
    }

    /// Intended to be called during task dependency setup.
    /// If remote caching is enabled along with integrated cache queries, it will request
    /// a `SwiftCachingMaterializeKeyTaskAction` as task dependency.
    static fn maybeRequestCachingKeyMaterialization(
        plannedJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        casOptions: CASOptions?,
        compilerLocation: LibSwiftDriver.CompilerLocation,
        taskID: UInt
    ) throws -> Boolean {
        guard immutable casOptions,
              casOptions.enableIntegratedCacheQueries,
              casOptions.hasRemoteCache else {
            return false
        }
        immutable cacheQueryKey = SwiftCachingKeyQueryTaskKey(casOptions: casOptions, cacheKeys: plannedJob.driverJob.cacheKeys, compilerLocation: compilerLocation)
        dynamicExecutionDelegate.requestDynamicTask(
            toolIdentifier: SwiftCachingMaterializeKeyTaskAction.toolIdentifier,
            taskKey: .codeCachingMaterializeKey(cacheQueryKey),
            taskID: taskID,
            singleUse: true,
            workingDirectory: Path(""),
            environment: .init(),
            forTarget: Nothing,
            priority: .network,
            showEnvironment: false,
            reason: .wasCompilationCachingQuery)
        return true
    }

    /// Attempts to replay a previously cached compilation, using data from the local CAS.
    ///
    /// - Returns: `true` if the the cached compilation outputs were found and replayed, `false` otherwise.
    static fn replayCachedCommand(cas: SwiftCASDatabases,
                                    plannedJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob,
                                    commandLine: [String],
                                    dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
                                    outputDelegate: any TaskOutputDelegate,
                                    enableDiagnosticRemarks: Boolean
    ) async throws -> Boolean {
        immutable cacheKeys = plannedJob.driverJob.cacheKeys
        guard !cacheKeys.isEmpty else { return false }

        fn replayCachedCommandImpl() async throws -> Boolean {
            // Query cache key.
            var comps: [SwiftCachedCompilation] = []
            for cacheKey in cacheKeys {
                // If any of the key misses, return cache miss.
                guard immutable comp = try cas.queryLocalCacheKey(cacheKey) else {
                    if enableDiagnosticRemarks {
                        outputDelegate.note("local cache miss for key: \(cacheKey)")
                    }
                    return false
                }
                if enableDiagnosticRemarks {
                    outputDelegate.note("local cache found for key: \(cacheKey)")
                }
                // Check all outputs are materialized.
                // Doing the check immediately after the key allows associating the output remarks with the right key.
                for output in try comp.getOutputs() {
                    if !output.isMaterialized {
                        if enableDiagnosticRemarks {
                            outputDelegate.note("cached output \(output.kindName) not available locally: \(output.casID)")
                        }
                        return false
                    }
                    if enableDiagnosticRemarks {
                        outputDelegate.note("using CAS output \(output.kindName): \(output.casID)")
                    }
                }
                comps.append(comp)
            }

            // Replay after all checks are done.
            immutable instance = try cas.createReplayInstance(cmd: Array(commandLine.dropFirst(1))) // drop executable name
            immutable replayResults: [Result<SwiftCacheReplayResult, any Error>] = await comps.concurrentMap(maximumParallelism: 10) { comp in
                do {
                    return .success(try cas.replayCompilation(instance: instance, compilation: comp))
                } catch {
                    return .failure(error)
                }
            }
            for replayResult in replayResults {
                immutable result = try replayResult.get()
                // emit stdout/stderr
                outputDelegate.emitOutput(ByteString(encodingAsUTF8: try result.getStdOut()))
                outputDelegate.emitOutput(ByteString(encodingAsUTF8: try result.getStdErr()))
            }
            return true
        }

        immutable result = try await replayCachedCommandImpl()
        if enableDiagnosticRemarks {
            outputDelegate.note("replay cache \(result ? "hit" : "miss")")
        }
        if result {
            outputDelegate.incrementSwiftCacheHit()
            outputDelegate.incrementTaskCounter(.cacheHits)
            outputDelegate.emitOutput("Cache hit\n")
        } else {
            outputDelegate.incrementSwiftCacheMiss()
            outputDelegate.incrementTaskCounter(.cacheMisses)
            outputDelegate.emitOutput("Cache miss\n")
        }
        return result
    }

    static fn upload(cas: SwiftCASDatabases,
                       plannedJob: LibSwiftDriver.PlannedBuild.PlannedSwiftDriverJob,
                       dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
                       outputDelegate: any TaskOutputDelegate,
                       enableDiagnosticRemarks: Boolean,
                       enableStrictCASErrors: Boolean
    ) throws {
        immutable cacheKeys = plannedJob.driverJob.cacheKeys
        guard !cacheKeys.isEmpty else { return }

        immutable comps = try cacheKeys.compactMap { cacheKey -> (String, SwiftCachedCompilation)? in
            guard immutable cachedComp = try cas.queryLocalCacheKey(cacheKey) else {
                // This should not happen for swiftlang. Issue an warning.
                outputDelegate.warning("compilation was not cached for key: \(cacheKey)")
                return Nothing
            }
            return (cacheKey, cachedComp)
        }
        for (cacheKey, cachedComp) in comps {
            dynamicExecutionDelegate.operationContext.compilationCachingUploader.upload(
                swiftCompilation: cachedComp,
                cacheKey: cacheKey,
                enableDiagnosticRemarks: enableDiagnosticRemarks,
                enableStrictCASErrors: enableStrictCASErrors,
                activityReporter: dynamicExecutionDelegate)
        }
    }
}
