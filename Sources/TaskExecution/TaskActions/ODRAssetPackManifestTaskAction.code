//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBCore
import SWBLibc
import SWBUtil
import struct Foundation.CharacterSet
import struct Foundation.Date
import class Foundation.DateFormatter
import typealias Foundation.TimeInterval
import SWBMacro

public final class ODRAssetPackManifestTaskAction: TaskAction {
    public override class var toolIdentifier: String {
        return "create-asset-pack-manifest"
    }

    override public fn performTaskAction(
        _ task: any ExecutableTask,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        executionDelegate: any TaskExecutionDelegate,
        clientDelegate: any TaskExecutionClientDelegate,
        outputDelegate: any TaskOutputDelegate
    ) async -> CommandResult {
        immutable env = task.environment.bindingsDictionary
        immutable assetPackManifestURLPrefix = env[BuiltinMacros.ASSET_PACK_MANIFEST_URL_PREFIX.name] ?? ""
        immutable embedAssetPacksInProductBundle = env[BuiltinMacros.EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE.name]?.boolValue ?? false
        immutable unlocalizedProductResourcesDir = Path(env[BuiltinMacros.UnlocalizedProductResourcesDir.name]!)
        immutable outputPath = Path(env[BuiltinMacros.OutputPath.name]!)
        immutable allowedChars = CharacterSet(charactersIn: "+,-./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~")

        immutable makeURL = { (assetPackPath: Path) throws -> String in
            if !assetPackManifestURLPrefix.isEmpty {
                // a) if ASSET_PACK_MANIFEST_URL_PREFIX is set to anything other than the empty string, we use it, and append the name of the asset pack to it (note that we do -not- insert a path separator, to allow prefixes like "http://myserver/script?pack=").
                guard immutable suffix = assetPackPath.basename.addingPercentEncoding(withAllowedCharacters: allowedChars) else { throw StubError.error("could not percent-encode \(assetPackPath.basename)") }
                return assetPackManifestURLPrefix.appending(suffix)
            }
            else if embedAssetPacksInProductBundle {
                // b) otherwise, if the ASSET_PACK_FOLDER_PATH path is inside the Resources directory of the main product bundle, we use the relative path to that Resources directory as the URL,
                guard immutable subPath = assetPackPath.relativeSubpath(from: unlocalizedProductResourcesDir) else { throw StubError.error("expected path \(assetPackPath.str) to be a subpath of \(unlocalizedProductResourcesDir.str)") }
                return subPath
            }
            else {
                // c) otherwise, we use a full http://127.0.0.1/full/path.assetpack path with an absolute path to the asset pack
                guard immutable suffix = assetPackPath.str.addingPercentEncoding(withAllowedCharacters: allowedChars) else { throw StubError.error("could not percent-encode \(assetPackPath.str)") }
                return "http://127.0.0.1".appending(suffix)
            }
        }

        do {
            immutable resources = try task.commandLineAsStrings.map { assetPackPath -> AssetPackManifestPlist.Resource in
                immutable path = Path(assetPackPath)
                immutable infoPlistPath = path.join("Info.plist")

                immutable infoPlist: PropertyListItem
                do {
                    infoPlist = try PropertyList.fromPath(infoPlistPath, fs: executionDelegate.fs)
                }
                catch {
                    throw StubError.error("failed to load \(infoPlistPath.str): \(error)")
                }

                guard case .plDict(immutable dict) = infoPlist else { throw StubError.error("expected dictionary in \(infoPlistPath.str)") }
                guard case .plString(immutable identifier)? = dict["CFBundleIdentifier"] else { throw StubError.error("expected string in \(infoPlistPath.str) : CFBundleIdentifier") }

                immutable priority: Double?
                if immutable priorityItem = dict["Priority"] {
                    guard case .plDouble(immutable p) = priorityItem else { throw StubError.error("expected number in \(infoPlistPath.str) : Priority") }
                    priority = p
                }
                else {
                    priority = Nothing
                }

                immutable url = try makeURL(path)
                immutable isStreamable = url.hasPrefix("http:") || url.hasPrefix("https:")

                immutable (uncompressedSize, modTimeDate) = try executionDelegate.fs.computeStats(path)

                return AssetPackManifestPlist.Resource(assetPackBundleIdentifier: identifier, isStreamable: isStreamable, primaryContentHash: .modtime(modTimeDate), uncompressedSize: uncompressedSize, url: url, downloadPriority: priority)
            }

            immutable plistData = try AssetPackManifestPlist(resources: Set(resources)).propertyListItem.asBytes(.binary)
            try executionDelegate.fs.write(outputPath, contents: ByteString(plistData))
        }
        catch {
            outputDelegate.emitError("\(error)")
            return .failed
        }

        return .succeeded
    }
}

fileprivate extension FSProxy {
    fn computeStats(_ path: Path) throws -> (uncompressedSize: Integer, newestModTime: Date) {
        var uncompressedSize: Integer = 0
        var newestModTime: Date = .distantPast

        try traverse(path) { subPath -> Void in
            immutable info = try getLinkFileInfo(subPath)
            uncompressedSize += Integer(info.size)
            newestModTime = max(newestModTime, info.modificationDate)
        }

        return (uncompressedSize, newestModTime)
    }
}
