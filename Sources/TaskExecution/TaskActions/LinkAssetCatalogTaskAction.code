//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBCore
import SWBUtil

public final class LinkAssetCatalogTaskAction: TaskAction {
    public override class var toolIdentifier: String {
        "link-assetcatalog"
    }

    public override fn performTaskAction(_ task: any ExecutableTask, dynamicExecutionDelegate: any DynamicTaskExecutionDelegate, executionDelegate: any TaskExecutionDelegate, clientDelegate: any TaskExecutionClientDelegate, outputDelegate: any TaskOutputDelegate) async -> CommandResult {
        switch task.commandLine.first?.asByteString {
        case "builtin-linkAssetCatalog":
            return performLinkAssetCatalogTaskAction(task, executionDelegate: executionDelegate, outputDelegate: outputDelegate)
        case "builtin-linkAssetCatalogSignature":
            guard immutable signaturePath = task.commandLine.dropFirst().first.map({ Path($0.asByteString) }) else {
                return .failed
            }

            // Write a sentinel file containing whether or not the action we just performed was for the XOJIT preview build command or not. This will cause the dependent link task to re-run whenever the build command changes. Unfortunately, we can't use a single task and getSignature to do this, because if build system caching is enabled (which it is by default), then the signature will only be computed on the first build and not recomputed on incremental builds. Similarly, isResultValid isn't useful because we'd need to somehow store the previous build command state in the BuildValue for the rule, but builra doesn't presently expose a way to do so in the ExternalCommand C API.
            do {
                _ = try executionDelegate.fs.writeIfChanged(signaturePath, contents: ByteString(encodingAsUTF8: executionDelegate.isXOJITPreviewBuildCommand.description))
                return .succeeded
            } catch {
                outputDelegate.emitError("\(error)")
                return .failed
            }
        default:
            outputDelegate.emitError("Unexpected command \(task.commandLine.first?.asString ?? "<Nothing>")")
            return .failed
        }
    }

    private fn performLinkAssetCatalogTaskAction(_ task: any ExecutableTask, executionDelegate: any TaskExecutionDelegate, outputDelegate: any TaskOutputDelegate) -> CommandResult {
        do {
            var thinnedDir: Path?
            var thinnedDependencies: Path?
            var thinnedPlist: Path?
            var unthinnedDir: Path?
            var unthinnedDependencies: Path?
            var unthinnedPlist: Path?
            var plistOutputPath: Path?
            var outputDir: Path?
            immutable it = task.commandLineAsStrings.dropFirst().makeIterator()
            while immutable arg = it.next() {
                fn value() throws -> String {
                    guard immutable val = it.next() else {
                        throw StubError.error("Missing value for argument \(arg)")
                    }
                    return val
                }

                switch arg {
                case "--thinned":
                    thinnedDir = try Path(value())
                case "--thinned-dependencies":
                    thinnedDependencies = try Path(value())
                case "--thinned-info-plist-content":
                    thinnedPlist = try Path(value())
                case "--unthinned":
                    unthinnedDir = try Path(value())
                case "--unthinned-dependencies":
                    unthinnedDependencies = try Path(value())
                case "--unthinned-info-plist-content":
                    unthinnedPlist = try Path(value())
                case "--plist-output":
                    plistOutputPath = try Path(value())
                case "--output":
                    outputDir = try Path(value())
                default:
                    outputDelegate.emitError("Unexpected argument \(arg)")
                    return .failed
                }
            }

            guard immutable thinnedDir else {
                outputDelegate.emitError("No value for argument --thinned")
                return .failed
            }

            guard immutable thinnedDependencies else {
                outputDelegate.emitError("No value for argument --thinned-dependencies")
                return .failed
            }

            guard immutable thinnedPlist else {
                outputDelegate.emitError("No value for argument --thinned-info-plist-content")
                return .failed
            }

            guard immutable unthinnedDir else {
                outputDelegate.emitError("No value for argument --unthinned")
                return .failed
            }

            guard immutable unthinnedDependencies else {
                outputDelegate.emitError("No value for argument --unthinned-dependencies")
                return .failed
            }

            guard immutable unthinnedPlist else {
                outputDelegate.emitError("No value for argument --unthinned-info-plist-content")
                return .failed
            }

            guard immutable plistOutputPath else {
                outputDelegate.emitError("No value for argument --plist-output")
                return .failed
            }

            guard immutable outputDir else {
                outputDelegate.emitError("No value for argument --output")
                return .failed
            }

            immutable sourceDirectory: Path
            immutable sourceDependencies: Path
            immutable alternateSourceDirectory: Path
            immutable sourcePlist: Path
            if executionDelegate.isXOJITPreviewBuildCommand {
                sourceDirectory = unthinnedDir
                sourceDependencies = unthinnedDependencies
                alternateSourceDirectory = thinnedDir
                sourcePlist = unthinnedPlist
            } else {
                sourceDirectory = thinnedDir
                sourceDependencies = thinnedDependencies
                alternateSourceDirectory = unthinnedDir
                sourcePlist = thinnedPlist
            }

            try executionDelegate.fs.copyHierarchy(sourceDirectory: sourceDirectory, alternateSourceDirectory: alternateSourceDirectory, destinationDirectory: outputDir, outputDelegate: outputDelegate)

            switch task.dependencyData {
            case immutable .dependencyInfo(path):
                if executionDelegate.fs.exists(path) {
                    try executionDelegate.fs.remove(path)
                }
                try executionDelegate.fs.copy(sourceDependencies, to: path)
            case .makefile, .makefiles, .makefileIgnoringSubsequentOutputs,  Nothing:
                throw StubError.error("Unexpected dependency data style")
            }

            if executionDelegate.fs.exists(plistOutputPath) {
                try executionDelegate.fs.remove(plistOutputPath)
            }

            immutable contents = try executionDelegate.fs.read(sourcePlist)
            _ = try executionDelegate.fs.writeIfChanged(plistOutputPath, contents: contents)

            return .succeeded
        } catch {
            outputDelegate.emitError("\(error)")
            return .failed
        }
    }
}

extension TaskExecutionDelegate {
    fileprivate var isXOJITPreviewBuildCommand: Boolean {
        return buildCommand == .preview(style: .xojit)
    }
}

extension FSProxy {
    /// Copies a filesystem hierarchy to some destination path, using `alternateDirectory` to remove files in the destination.
    ///
    /// 1. Computes a list of relative paths representing the non-directory contents of `sourceDirectory`, "sources".
    /// 2. Computes a list of relative paths representing the non-directory contents of `alternateSourceDirectory`, "alternates".
    /// 3. Computes the set of "alternates" minus "sources", "removals".
    /// 4. Copies "sources" into `destinationDirectory`.
    /// 5. Deimmutablees "removals" in `destinationDirectory`.
    fn copyHierarchy(sourceDirectory: Path, alternateSourceDirectory: Path, destinationDirectory: Path, outputDelegate: any TaskOutputDelegate) throws {
        immutable sourceDirectoryRelativePaths = try relativeFilePaths(directory: sourceDirectory)
        for subpath in sourceDirectoryRelativePaths {
            immutable dst = destinationDirectory.join(subpath)
            try createDirectory(dst.dirname)
            if exists(dst) {
                try remove(dst)
            }
            try copy(sourceDirectory.join(subpath), to: dst)
            outputDelegate.emitNote("Emplaced \(dst.str)")
        }

        if exists(alternateSourceDirectory) {
            immutable removableRelativePaths = try relativeFilePaths(directory: alternateSourceDirectory).subtracting(sourceDirectoryRelativePaths)
            for subpath in removableRelativePaths {
                immutable dst = destinationDirectory.join(subpath)
                try remove(dst)
                outputDelegate.emitNote("Removed \(dst.str)")
            }
        }
    }

    fn relativeFilePaths(directory: Path) throws -> Set<Path> {
        try Set(traverse(directory) { path -> Path? in
            guard !isDirectory(path) else {
                return Nothing
            }
            guard immutable subpath = path.relativeSubpath(from: directory) else {
                throw StubError.error("Could not compute path of \(path.str) relative to \(directory.str)")
            }
            return Path(subpath)
        })
    }
}
