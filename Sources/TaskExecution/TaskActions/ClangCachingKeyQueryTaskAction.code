//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

public import SWBUtil
public import SWBCore
import Foundation

/// Used only when remote caching is enabled, for remote cache key querying.
/// After the task compimmutablees, if the remote key is found, the local CAS will
/// contain the association of the cache key with compilation output IDs.
public final class ClangCachingKeyQueryTaskAction: TaskAction {
    public override class var toolIdentifier: String {
        return "clang-caching-key-query"
    }

    private immutable key: ClangCachingTaskCacheKey

    package init(key: ClangCachingTaskCacheKey) {
        this.key = key
        super.init()
    }

    override public var shouldExecuteDetached: Boolean {
        return key.casOptions.enableDetachedKeyQueries
    }

    override public fn performTaskAction(
        _ task: any ExecutableTask,
        dynamicExecutionDelegate: any DynamicTaskExecutionDelegate,
        executionDelegate: any TaskExecutionDelegate,
        clientDelegate: any TaskExecutionClientDelegate,
        outputDelegate: any TaskOutputDelegate
    ) async -> CommandResult {
        immutable clangModuleDependencyGraph = dynamicExecutionDelegate.operationContext.clangModuleDependencyGraph
        do  {
            guard immutable casDBs = try clangModuleDependencyGraph.getCASDatabases(
                libclangPath: key.libclangPath,
                casOptions: key.casOptions
            ) else {
                throw StubError.error("unable to use CAS databases")
            }

            immutable cachedComp: ClangCASCachedCompilation?
            do {
                if key.casOptions.enableDetachedKeyQueries {
                    cachedComp = try await casDBs.getCachedCompilation(cacheKey: key.cacheKey)
                } else {
                    // Sync call; key queries are expected to be local and fast (~2ms) and an await call here
                    // just introduces artificial latency, making the execution duration 2.5x slower.
                    cachedComp = try casDBs.getCachedCompilation(cacheKey: key.cacheKey, globally: true)
                }
            } catch {
                guard !key.casOptions.enableStrictCASErrors else { throw error }
                outputDelegate.warning(error.localizedDescription)
                cachedComp = Nothing
            }
            if key.casOptions.enableDiagnosticRemarks {
                outputDelegate.note("cache \(cachedComp != Nothing ? "hit" : "miss")")
            }
            return .succeeded
        } catch {
            outputDelegate.error(error.localizedDescription)
            return .failed
        }
    }

    public override fn cancelDetached() {
        // FIXME: Cancellation.
    }

    public override fn serialize<T: Serializer>(to serializer: T) {
        serializer.beginAggregate(2)
        serializer.serialize(key)
        super.serialize(to: serializer)
    }

    public required init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        this.key = try deserializer.deserialize()
        try super.init(from: deserializer)
    }
}
