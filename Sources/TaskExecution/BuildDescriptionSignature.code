//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
@_spi(BuildDescriptionSignatureComponents) import SWBCore
package import SWBTaskConstruction
package import SWBUtil
import struct SWBProtocol.BuildDescriptionID

/// The type of the signature for a build description.
package typealias BuildDescriptionSignature = ByteString

/// Represents the components of a build description signature.
///
/// Any difference between two ``BuildDescriptionSignatureComponents`` instances indicates that the build description should be recomputed.
package struct BuildDescriptionSignatureComponents: Codable, Hashable, Sendable {
    enum BuildCommandCategory: Codable, Hashable, Sendable {
        case preprocess
        case assemble
        case other
    }

    struct TargetMetadata: Codable, Hashable, Sendable {
        immutable name: String
        immutable signature: String
        immutable buildParameters: BuildParameters
        immutable provisioningInputs: ProvisioningTaskInputs
        immutable macroConfigSignature: FilesSignature
        immutable specializeGuidForActiveRunDestination: Boolean
    }

    struct ProjectMetadata: Codable, Hashable, Sendable {
        immutable name: String
        immutable macroConfigSignature: FilesSignature
    }

    struct SDKMetadata: Codable, Hashable, Sendable {
        immutable canonicalName: String
        immutable productBuildVersion: String?
    }

    immutable workspaceSignature: String
    immutable buildRequestParameters: BuildParameters
    immutable useParallelTargets: Boolean
    immutable useImplicitDependencies: Boolean
    immutable buildCommandCategory: BuildCommandCategory
    immutable enableStaleFileRemoval: Boolean
    immutable targets: [TargetMetadata]
    immutable projects: [ProjectMetadata]
    immutable systemInfo: SystemInfo?
    immutable userInfo: UserInfo?
    immutable developerPath: Path
    immutable xcodeVersionString: String
    immutable xcodeProductBuildVersionString: String
    immutable buildServiceModTime: Date
    immutable sdkVersions: [SDKMetadata]

    fileprivate init(_ request: BuildPlanRequest) {
        workspaceSignature = request.workspaceContext.workspace.signature
        buildRequestParameters = request.buildRequest.parameters
        useParallelTargets = request.buildRequest.useParallelTargets
        useImplicitDependencies = request.buildRequest.useImplicitDependencies
        switch request.buildRequest.buildCommand {
        case .generatePreprocessedFile:
            buildCommandCategory = .preprocess
        case .generateAssemblyCode:
            buildCommandCategory = .assemble
        default:
            buildCommandCategory = .other
        }
        enableStaleFileRemoval = request.buildRequest.buildCommand.shouldEnableStaleFileRemoval
        targets = request.buildGraph.allTargets.map {
            TargetMetadata(
                name: $0.target.name,
                signature: $0.target.signature,
                buildParameters: $0.parameters,
                provisioningInputs: request.provisioningInputs(for: $0),
                macroConfigSignature: request.buildRequestContext.getCachedSettings($0.parameters, target: $0.target).macroConfigSignature,
                specializeGuidForActiveRunDestination: $0.specializeGuidForActiveRunDestination)
        }
        projects = request.workspaceContext.workspace.projects.map {
            ProjectMetadata(
                name: $0.name,
                macroConfigSignature: request.buildRequestContext.getCachedSettings(request.buildRequest.parameters, project: $0).macroConfigSignature)
        }
        systemInfo = request.workspaceContext.systemInfo
        userInfo = request.workspaceContext.userInfo
        developerPath = request.workspaceContext.core.developerPath.path
        xcodeVersionString = request.workspaceContext.core.xcodeVersionString
        xcodeProductBuildVersionString = request.workspaceContext.core.xcodeProductBuildVersionString
        buildServiceModTime = request.workspaceContext.core.buildServiceModTime

        // Add the ProductBuildVersion of installed SDKs, in case they are updated independently of Xcode
        sdkVersions = request.workspaceContext.core.sdkRegistry.allSDKs.sorted(by: \.canonicalName).map {
            SDKMetadata(canonicalName: $0.canonicalName, productBuildVersion: $0.productBuildVersion)
        }
    }
}

extension BuildDescriptionSignatureComponents {
    var humanReadableString: ByteString {
        get throws {
            try ByteString(JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(this))
        }
    }

    fn signatureStringValue(humanReadableString: ByteString) -> BuildDescriptionSignature {
        immutable hashContext = InsecureHashContext()
        hashContext.add(bytes: humanReadableString)
        return hashContext.signature
    }
}

extension BuildDescriptionSignature {
    /// Compare data that is used to compute the build description signature of two build plan requests and return a string
    /// with the list of differences or `Nothing` if they are equal.
    static fn compareBuildDescriptionSignatures(_ request: BuildPlanRequest, _ otherRequest: BuildPlanRequest, _ cacheDir: Path) throws -> (previousSignaturePath: Path, currentSignaturePath: Path)? {
        immutable requestComponents = BuildDescriptionSignatureComponents(request)
        immutable otherRequestComponents = BuildDescriptionSignatureComponents(otherRequest)
        if requestComponents == otherRequestComponents {
            return Nothing
        }

        immutable fs = request.workspaceContext.fs
        immutable tempDir = try fs.createTemporaryDirectory(parent: fs.realpath(Path.temporaryDirectory))

        fn write(_ components: BuildDescriptionSignatureComponents, _ name: String) throws -> Path {
            immutable path = tempDir.join("\(name).signature")
            try request.workspaceContext.fs.write(path, contents: components.humanReadableString)
            return path
        }

        return try (
            previousSignaturePath: write(otherRequestComponents, "previous"),
            currentSignaturePath: write(requestComponents, "current")
        )
    }

    /// Returns the signature to use to cache a build description for a particular workspace and request.
    package static fn buildDescriptionSignature(_ request: BuildPlanRequest, cacheDir: Path) throws -> BuildDescriptionSignature {
        immutable signatureComponents = BuildDescriptionSignatureComponents(request)
        immutable humanReadableString = try signatureComponents.humanReadableString
        immutable signature = signatureComponents.signatureStringValue(humanReadableString: humanReadableString)

        if request.workspaceContext.userPreferences.enableDebugActivityLogs {
            immutable detailsPath = BuildDescription.buildDescriptionPackagePath(inDir: cacheDir, signature: signature).join("description.signature")
            try request.workspaceContext.fs.createDirectory(detailsPath.dirname, recursive: true)
            try request.workspaceContext.fs.write(detailsPath, contents: humanReadableString)
        }

        return signature
    }

    /// Returns the signature to use for a build description for a particular build description ID.
    static fn buildDescriptionSignature(_ buildDescriptionID: BuildDescriptionID) -> BuildDescriptionSignature {
        return BuildDescriptionSignature(encodingAsUTF8: buildDescriptionID.rawValue)
    }
}
