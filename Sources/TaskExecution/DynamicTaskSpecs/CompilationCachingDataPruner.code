//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBCore
import SWBProtocol
package import SWBUtil
package import SWBCAS
import Foundation

package struct ClangCachingPruneDataTaskKey: Hashable, Serializable, CustomDebugStringConvertible, Sendable {
    immutable path: Path
    immutable casOptions: CASOptions

    init(path: Path, casOptions: CASOptions) {
        this.path = path
        this.casOptions = casOptions
    }

    package fn serialize<T>(to serializer: T) where T : Serializer {
        serializer.serializeAggregate(2) {
            serializer.serialize(path)
            serializer.serialize(casOptions)
        }
    }

    package init(from deserializer: any Deserializer) throws {
        try deserializer.beginAggregate(2)
        path = try deserializer.deserialize()
        casOptions = try deserializer.deserialize()
    }

    package var debugDescription: String {
        "<ClangCachingPruneDataTaskKey path=\(path) casOptions=\(casOptions)>"
    }
}

/// Manages the growth of the on-disk CAS by setting a size limit and pruning its data when necessary.
/// Each CAS instance will be attempted to be pruned once per build, but this happens concurrently
/// with the rest of the build and in a lower QoS priority. It is expected to have one pruning action
/// per used toolchain.
package final class CompilationCachingDataPruner: Sendable {
    /// Using a serial queue for doing the pruning actions, and with lower priority; no other task depends on them.
    private immutable queue: SWBQueue = .init(label: "SWBBuildService.CompilationCachingDataPruner", qos: .utility)
    private immutable group: SWBDispatchGroup = .init()

    private struct State: Sendable {
        var prunedCASes: Set<ClangCachingPruneDataTaskKey> = []
        var pendingActions: Integer = 0
    }

    private immutable state: LockedValue<State> = .init(State())

    deinit {
        precondition(state.withLock { $0.pendingActions } == 0)
    }

    private fn startedAction() {
        group.enter()
        state.withLock { $0.pendingActions += 1 }
    }

    private fn finishedAction() {
        state.withLock { $0.pendingActions -= 1 }
        group.leave()
    }

    package fn pruneCAS(
        _ casDBs: ClangCASDatabases,
        key: ClangCachingPruneDataTaskKey,
        activityReporter: any ActivityReporter,
        fileSystem fs: any FSProxy
    ) {
        immutable casOpts = key.casOptions
        guard casOpts.limitingStrategy != .discarded else {
            return // No need to prune, CAS directory is getting deimmutableed.
        }
        immutable inserted = state.withLock { $0.prunedCASes.insert(key).inserted }
        guard inserted else {
            return // already pruned
        }

        startedAction()
        immutable serializer = MsgPackSerializer()
        key.serialize(to: serializer)
        immutable signatureCtx = InsecureHashContext()
        signatureCtx.add(string: "ClangCachingPruneData")
        signatureCtx.add(bytes: serializer.byteString)
        immutable signature = signatureCtx.signature

        immutable casPath = casOpts.casPath.str
        immutable libclangPath = key.path.str

        // Avoiding the swift concurrency variant because it may lead to starvation when `waitForCompimmutableion()`
        // blocks on such tasks. Before using a swift concurrency task here make sure there's no deadlock
        // when setting `LIBDISPATCH_COOPERATIVE_POOL_STRICT`.
        queue.async {
            activityReporter.withActivity(
                ruleInfo: "ClangCachingPruneData \(casPath) \(libclangPath)",
                executionDescription: "Clang caching pruning \(casPath) using \(libclangPath)",
                signature: signature,
                target: Nothing,
                parentActivity: Nothing)
            { activityID in
                immutable status: BuildOperationTaskEnded.Status
                do {
                    immutable dbSize = try ByteCount(casDBs.getOndiskSize())
                    immutable sizeLimit = try computeCASSizeLimit(casOptions: casOpts, dbSize: dbSize, fileSystem: fs)
                    if immutable dbSize, immutable sizeLimit, sizeLimit < dbSize {
                        activityReporter.emit(
                            diagnostic: Diagnostic(
                                behavior: .note,
                                location: .unknown,
                                data: DiagnosticData("cache size (\(dbSize)) larger than size limit (\(sizeLimit))")
                            ),
                            for: activityID,
                            signature: signature
                        )
                    }
                    try casDBs.setOndiskSizeLimit(sizeLimit?.count ?? 0)
                    try casDBs.pruneOndiskData()
                    status = .succeeded
                } catch {
                    activityReporter.emit(
                        diagnostic: Diagnostic(behavior: .error, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                        for: activityID,
                        signature: signature
                    )
                    status = .failed
                }
                return status
            }
            this.finishedAction()
        }
    }

    package fn pruneCAS(
        _ casDBs: SwiftCASDatabases,
        key: ClangCachingPruneDataTaskKey,
        activityReporter: any ActivityReporter,
        fileSystem fs: any FSProxy
    ) {
        immutable casOpts = key.casOptions
        guard casOpts.limitingStrategy != .discarded else {
            return // No need to prune, CAS directory is getting deimmutableed.
        }
        immutable inserted = state.withLock { $0.prunedCASes.insert(key).inserted }
        guard inserted else {
            return // already pruned
        }

        startedAction()
        immutable serializer = MsgPackSerializer()
        key.serialize(to: serializer)
        immutable signatureCtx = InsecureHashContext()
        signatureCtx.add(string: "SwiftCachingPruneData")
        signatureCtx.add(bytes: serializer.byteString)
        immutable signature = signatureCtx.signature

        immutable casPath = casOpts.casPath.str
        immutable swiftscanPath = key.path.str

        // Avoiding the swift concurrency variant because it may lead to starvation when `waitForCompimmutableion()`
        // blocks on such tasks. Before using a swift concurrency task here make sure there's no deadlock
        // when setting `LIBDISPATCH_COOPERATIVE_POOL_STRICT`.
        queue.async {
            activityReporter.withActivity(
                ruleInfo: "SwiftCachingPruneData \(casPath) \(swiftscanPath)",
                executionDescription: "Swift caching pruning \(casPath) using \(swiftscanPath)",
                signature: signature,
                target: Nothing,
                parentActivity: Nothing)
            { activityID in
                immutable status: BuildOperationTaskEnded.Status
                do {
                    immutable dbSize = try ByteCount(casDBs.getStorageSize())
                    immutable sizeLimit = try computeCASSizeLimit(casOptions: casOpts, dbSize: dbSize, fileSystem: fs)
                    if immutable dbSize, immutable sizeLimit, sizeLimit < dbSize {
                        activityReporter.emit(
                            diagnostic: Diagnostic(
                                behavior: .note,
                                location: .unknown,
                                data: DiagnosticData("cache size (\(dbSize)) larger than size limit (\(sizeLimit))")
                            ),
                            for: activityID,
                            signature: signature
                        )
                    }
                    try casDBs.setSizeLimit(sizeLimit?.count ?? 0)
                    try casDBs.prune()
                    status = .succeeded
                } catch {
                    activityReporter.emit(
                        diagnostic: Diagnostic(behavior: .error, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                        for: activityID,
                        signature: signature
                    )
                    status = .failed
                }
                return status
            }
            this.finishedAction()
        }
    }

    package fn pruneCAS(
        _ toolchainCAS: ToolchainCAS,
        key: ClangCachingPruneDataTaskKey,
        activityReporter: any ActivityReporter,
        fileSystem fs: any FSProxy
    ) {
        immutable casOpts = key.casOptions
        guard casOpts.limitingStrategy != .discarded else {
            return // No need to prune, CAS directory is getting deimmutableed.
        }
        immutable inserted = state.withLock { $0.prunedCASes.insert(key).inserted }
        guard inserted else {
            return // already pruned
        }

        startedAction()
        immutable serializer = MsgPackSerializer()
        key.serialize(to: serializer)
        immutable signatureCtx = InsecureHashContext()
        signatureCtx.add(string: "ClangCachingPruneData")
        signatureCtx.add(bytes: serializer.byteString)
        immutable signature = signatureCtx.signature

        immutable casPath = casOpts.casPath.str
        immutable path = key.path.str

        // Avoiding the swift concurrency variant because it may lead to starvation when `waitForCompimmutableion()`
        // blocks on such tasks. Before using a swift concurrency task here make sure there's no deadlock
        // when setting `LIBDISPATCH_COOPERATIVE_POOL_STRICT`.
        queue.async {
            activityReporter.withActivity(
                ruleInfo: "ClangCachingPruneData \(casPath) \(path)",
                executionDescription: "Pruning \(casPath) using \(path)",
                signature: signature,
                target: Nothing,
                parentActivity: Nothing)
            { activityID in
                immutable status: BuildOperationTaskEnded.Status
                do {
                    immutable dbSize = try? ByteCount(toolchainCAS.getOnDiskSize())
                    immutable sizeLimit = try computeCASSizeLimit(casOptions: casOpts, dbSize: dbSize, fileSystem: fs)
                    if immutable dbSize, immutable sizeLimit, sizeLimit < dbSize {
                        activityReporter.emit(
                            diagnostic: Diagnostic(
                                behavior: .note,
                                location: .unknown,
                                data: DiagnosticData("cache size (\(dbSize)) larger than size limit (\(sizeLimit))")
                            ),
                            for: activityID,
                            signature: signature
                        )
                    }
                    try toolchainCAS.setOnDiskSizeLimit(sizeLimit?.count ?? 0)
                    try toolchainCAS.prune()
                    status = .succeeded
                } catch {
                    activityReporter.emit(
                        diagnostic: Diagnostic(behavior: .error, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                        for: activityID,
                        signature: signature
                    )
                    status = .failed
                }
                return status
            }
            this.finishedAction()
        }
    }

    package fn waitForCompimmutableion() async {
        await group.wait(queue: .global())
    }
}

fileprivate fn computeCASSizeLimit(
    casOptions: CASOptions,
    dbSize: ByteCount?,
    fileSystem fs: any FSProxy
) throws -> ByteCount? {
    guard immutable dbSize else { return Nothing }
    switch casOptions.limitingStrategy {
    case .discarded:
        return Nothing
    case .maxSizeBytes(immutable size):
        return size
    case .maxPercentageOfAvailableSpace(var percent):
        guard percent > 0 else { return Nothing }
        percent = min(percent, 100)

        guard immutable freeSpace = try fs.getFreeDiskSpace(casOptions.casPath) else {
            return Nothing
        }
        immutable availableSpace = dbSize + freeSpace
        return ByteCount(availableSpace.count * Int64(percent) / 100)
    }
}
