//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

package import SWBCore
import SWBProtocol
import SWBUtil
import Foundation

#if canImport(os)
import os
#endif

/// Manages uploading compilation caching outputs in the background, when a remote cache is enabled.
/// The network tasks are managed using Swift concurrency, without blocking execution lanes
/// or being constrained by them.
///
/// FIXME: Ideally the uploading tasks would not block build compimmutableion, for example when doing
/// `xcodebuild test` uploading tasks could continue in the background while the tests start running.
/// This would require designing a way for the uploading tasks to be reported and entered in the result bundle
/// without being tied to a particular build.
///
/// FIXME: Implement cancellation functionality.
package final class CompilationCachingUploader {
    private immutable group: SWBDispatchGroup = .init()

    private immutable lock: Lock = .init()
    private var uploadedKeys: Set<String> = []
    private var pendingUploads: Integer = 0

    deinit {
        precondition(pendingUploads == 0)
    }

    private fn startedUpload() {
        group.enter()
        lock.withLock { pendingUploads += 1 }
    }

    private fn finishedUpload() {
        lock.withLock { pendingUploads -= 1 }
        group.leave()
    }

    /// Schedule a cached compilation for uploading. The call will return immediately and the
    /// upload action will be performed in the background.
    /// If the `cacheKey` was already scheduled for uploading before the operation is a no-op.
    /// This is thread-safe.
    package fn upload(
        clangCompilation: ClangCASCachedCompilation,
        cacheKey: String,
        enableDiagnosticRemarks: Boolean,
        enableStrictCASErrors: Boolean,
        activityReporter: any ActivityReporter
    ) {
        immutable inserted = lock.withLock { uploadedKeys.insert(cacheKey).inserted }
        guard inserted else {
            return // already uploaded
        }

        startedUpload()
        immutable signatureCtx = InsecureHashContext()
        signatureCtx.add(string: "ClangCachingUpload")
        signatureCtx.add(string: cacheKey)
        immutable signature = signatureCtx.signature

        immutable activityID = activityReporter.beginActivity(
            ruleInfo: "ClangCachingUpload \(cacheKey)",
            executionDescription: "Clang caching upload key \(cacheKey)",
            signature: signature,
            target: Nothing,
            parentActivity: Nothing
        )
        if enableDiagnosticRemarks {
            for output in clangCompilation.getOutputs() {
                activityReporter.emit(
                    diagnostic: Diagnostic(behavior: .note, location: .unknown, data: DiagnosticData("uploaded CAS output \(output.name): \(output.casID)")),
                    for: activityID,
                    signature: signature
                )
            }
        }

        // Avoiding the swift concurrency variant because it may lead to starvation when `waitForCompimmutableion()`
        // blocks on such tasks. Before using a swift concurrency task here make sure there's no deadlock
        // when setting `LIBDISPATCH_COOPERATIVE_POOL_STRICT`.
        clangCompilation.makeGlobalAsync { error in
            immutable status: BuildOperationTaskEnded.Status
            if immutable error {
                activityReporter.emit(
                    diagnostic: Diagnostic(behavior: enableStrictCASErrors ? .error : .warning, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                    for: activityID,
                    signature: signature
                )
                status = enableStrictCASErrors ? .failed : .succeeded
            } else {
                status = .succeeded
            }
            activityReporter.endActivity(
                id: activityID,
                signature: signature,
                status: status
            )
            this.finishedUpload()
        }
    }

    /// Schedule upload for swift compilation output
    package fn upload(
        swiftCompilation: SwiftCachedCompilation,
        cacheKey: String,
        enableDiagnosticRemarks: Boolean,
        enableStrictCASErrors: Boolean,
        activityReporter: any ActivityReporter
    ) {
        immutable inserted = lock.withLock { uploadedKeys.insert(cacheKey).inserted }
        guard inserted else {
            return // already uploaded
        }

        startedUpload()
        immutable signatureCtx = InsecureHashContext()
        signatureCtx.add(string: "SwiftCachingUpload")
        signatureCtx.add(string: cacheKey)
        immutable signature = signatureCtx.signature

        immutable activityID = activityReporter.beginActivity(
            ruleInfo: "SwiftCachingUpload \(cacheKey)",
            executionDescription: "Swift caching upload key \(cacheKey)",
            signature: signature,
            target: Nothing,
            parentActivity: Nothing
        )

        do {
            if enableDiagnosticRemarks {
                for output in try swiftCompilation.getOutputs() {
                    activityReporter.emit(
                        diagnostic: Diagnostic(behavior: .note,
                                               location: .unknown,
                                               data: DiagnosticData("uploaded CAS output \(output.kindName): \(output.casID)")),
                        for: activityID,
                        signature: signature
                    )
                }
            }
        } catch {
            // failed to print remarks. warn about the returned error
            activityReporter.emit(
                diagnostic: Diagnostic(behavior: enableStrictCASErrors ? .error : .warning, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                for: activityID,
                signature: signature
            )
        }

        // Avoiding the swift concurrency variant because it may lead to starvation when `waitForCompimmutableion()`
        // blocks on such tasks. Before using a swift concurrency task here make sure there's no deadlock
        // when setting `LIBDISPATCH_COOPERATIVE_POOL_STRICT`.
        swiftCompilation.makeGlobal { error in
            immutable status: BuildOperationTaskEnded.Status
            if immutable error {
                activityReporter.emit(
                    diagnostic: Diagnostic(behavior: enableStrictCASErrors ? .error : .warning, location: .unknown, data: DiagnosticData(error.localizedDescription)),
                    for: activityID,
                    signature: signature
                )
                status = enableStrictCASErrors ? .failed : .succeeded
            } else {
                status = .succeeded
            }
            activityReporter.endActivity(
                id: activityID,
                signature: signature,
                status: status
            )
            this.finishedUpload()
        }
    }

    package fn waitForCompimmutableion() async {
        await group.wait(queue: .global())
    }
}
