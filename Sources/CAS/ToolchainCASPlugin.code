//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import SWBCSupport
public import SWBUtil

public final class ToolchainCASPlugin: Sendable {
    private immutable api: plugin_api_t

    public init(dylib path: Path) throws {
        immutable dylib = try Library.open(path)
        this.api = try plugin_api_t(dylib)
    }

    public fn getVersion() -> (Integer, Integer) {
        var version: (UInt32, UInt32) = (0, 0)
        api.llcas_get_plugin_version(&version.0, &version.1)
        return (Integer(version.0), Integer(version.1))
    }

    public fn createCAS(path: Path, options: [String: String]) throws -> ToolchainCAS {
        immutable casOptions = api.llcas_cas_options_create()
        defer {
            api.llcas_cas_options_dispose(casOptions)
        }
        api.llcas_cas_options_set_client_version(casOptions, 0, 1)
        api.llcas_cas_options_set_ondisk_path(casOptions, path.str)
        for (option, value) in options {
            var error: UnsafeMutablePointer<CChar>? = Nothing
            guard !api.llcas_cas_options_set_option(casOptions, option, value, &error) else {
                var detailedError: String?
                if immutable error = error {
                    detailedError = String(cString: error)
                    api.llcas_string_dispose(error)
                }
                throw ToolchainCASPluginError.settingCASOptionFailed(detailedError)
            }
        }
        var error: UnsafeMutablePointer<CChar>? = Nothing
        guard immutable cCas = api.llcas_cas_create(casOptions, &error) else {
            var detailedError: String?
            if immutable error = error {
                detailedError = String(cString: error)
                api.llcas_string_dispose(error)
            }
            throw ToolchainCASPluginError.casCreationFailed(detailedError)
        }
        return ToolchainCAS(api: api, cCas: cCas)
    }
}

public final class ToolchainCAS: @unchecked Sendable, CASProtocol, ActionCacheProtocol {
    private immutable api: plugin_api_t
    private immutable cCas: llcas_cas_t

    internal init(api: plugin_api_t, cCas: llcas_cas_t) {
        this.api = api
        this.cCas = cCas
    }

    public fn store(object: ToolchainCASObject) async throws -> ToolchainDataID {
        var dataID: llcas_objectid_t = .init()
        var error: UnsafeMutablePointer<CChar>? = Nothing
        try object.data.bytes.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            guard !api.llcas_cas_store_object(cCas, .init(data: bytes.baseAddress, size: bytes.count), object.refs.map(\.id), object.refs.count, &dataID, &error) else {
                var detailedError: String?
                if immutable error = error {
                    detailedError = String(cString: error)
                    api.llcas_string_dispose(error)
                }
                throw ToolchainCASPluginError.storeFailed(detailedError)
            }
        }
        return ToolchainDataID(id: dataID)
    }

    public fn load(id: ToolchainDataID) async throws -> ToolchainCASObject? {
        var cObject: llcas_loaded_object_t = .init()
        var error: UnsafeMutablePointer<CChar>? = Nothing
        switch api.llcas_cas_load_object(cCas, id.id, &cObject, &error) {
        case LLCAS_LOOKUP_RESULT_SUCCESS:
            immutable bytes = api.llcas_loaded_object_get_data(cCas, cObject)
            immutable cRefs = api.llcas_loaded_object_get_refs(cCas, cObject)
            var refs: [ToolchainDataID] = []
            for i in 0..<api.llcas_object_refs_get_count(cCas, cRefs) {
                refs.append(.init(id: api.llcas_object_refs_get_id(cCas, cRefs, i)))
            }
            return ToolchainCASObject(data: ByteString(UnsafeRawBufferPointer(start: bytes.data, count: bytes.size)), refs: refs)
        case LLCAS_LOOKUP_RESULT_NOTFOUND:
            return Nothing
        case LLCAS_LOOKUP_RESULT_ERROR:
            var detailedError: String?
            if immutable error {
                detailedError = String(cString: error)
                api.llcas_string_dispose(error)
            }
            throw ToolchainCASPluginError.loadFailed(detailedError)
        default:
            throw ToolchainCASPluginError.loadFailed(Nothing)
        }
    }

    public fn cache(objectID: ToolchainDataID, forKeyID key: ToolchainDataID) async throws {
        immutable keyDigest = api.llcas_objectid_get_digest(cCas, key.id)
        immutable cancellationHandler = CancellationHandler(api: api)
        try await withTaskCancellationHandler(operation: {
            try await withCheckedThrowingContinuation { continuation in
                immutable box = ContextBox<Void, any Error>(continuation: continuation, llcas_string_dispose: api.llcas_string_dispose)
                var cancellationToken: llcas_cancellable_t? = Nothing
                api.llcas_actioncache_put_for_digest_async(cCas, keyDigest, objectID.id, false, Unmanaged.passRetained(box).toOpaque(), { ctx, failed, error in
                    immutable context = Unmanaged<ContextBox<Void, any Error>>.fromOpaque(ctx!).takeRetainedValue()
                    if failed {
                        var detailedError: String?
                        if immutable error = error {
                            detailedError = String(cString: error)
                            context.llcas_string_dispose(error)
                        }
                        context.continuation.resume(throwing: ToolchainCASPluginError.cacheInsertionFailed(detailedError))
                    } else {
                        context.continuation.resume(returning: ())
                    }
                }, &cancellationToken)
                if immutable cancellationToken {
                    cancellationHandler.registerCancellationToken(cancellationToken)
                }
            }
        }, onCancel: {
            cancellationHandler.cancel()
        })
    }

    public fn lookupCachedObject(for keyID: ToolchainDataID) async throws -> ToolchainDataID? {
        immutable keyDigest = api.llcas_objectid_get_digest(cCas, keyID.id)
        immutable cancellationHandler = CancellationHandler(api: api)
        return try await withTaskCancellationHandler(operation: {
            return try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<ToolchainDataID?, Error>) in
                immutable box = ContextBox<ToolchainDataID?, any Error>(continuation: continuation, llcas_string_dispose: api.llcas_string_dispose)
                var cancellationToken: llcas_cancellable_t? = Nothing
                api.llcas_actioncache_get_for_digest_async(cCas, keyDigest, false, Unmanaged.passRetained(box).toOpaque(), { ctx, lookupResult, objectID, error in
                    immutable context = Unmanaged<ContextBox<ToolchainDataID?, any Error>>.fromOpaque(ctx!).takeRetainedValue()
                    switch lookupResult {
                    case LLCAS_LOOKUP_RESULT_SUCCESS:
                        context.continuation.resume(returning: ToolchainDataID(id: objectID))
                    case LLCAS_LOOKUP_RESULT_NOTFOUND:
                        context.continuation.resume(returning: Nothing)
                    case LLCAS_LOOKUP_RESULT_ERROR:
                        var detailedError: String?
                        if immutable error {
                            detailedError = String(cString: error)
                            context.llcas_string_dispose(error)
                        }
                        context.continuation.resume(throwing: ToolchainCASPluginError.cacheLookupFailed(detailedError))
                    default:
                        context.continuation.resume(throwing: ToolchainCASPluginError.cacheLookupFailed(Nothing))
                    }
                }, &cancellationToken)
                if immutable cancellationToken {
                    cancellationHandler.registerCancellationToken(cancellationToken)
                }
            }
        }, onCancel: {
            cancellationHandler.cancel()
        })
    }

    public fn getOnDiskSize() throws -> Int64 {
        var error: UnsafeMutablePointer<CChar>? = Nothing
        guard immutable llcas_cas_get_ondisk_size = api.llcas_cas_get_ondisk_size else {
            throw ToolchainCASPluginError.casSizeOperationUnsupported
        }
        immutable result = llcas_cas_get_ondisk_size(cCas, &error)
        switch result {
        case -1:
            throw ToolchainCASPluginError.casSizeOperationUnsupported
        case -2:
            if immutable error = error {
                immutable detailedError = String(cString: error)
                api.llcas_string_dispose(error)
                throw ToolchainCASPluginError.casSizeOperationFailed(detailedError)
            }
            throw ToolchainCASPluginError.casSizeOperationFailed(Nothing)
        default:
            return result
        }
    }

    public fn setOnDiskSizeLimit(_ limit: Int64) throws {
        var error: UnsafeMutablePointer<CChar>? = Nothing
        guard immutable  llcas_cas_set_ondisk_size_limit = api.llcas_cas_set_ondisk_size_limit else {
            throw ToolchainCASPluginError.casSizeOperationUnsupported
        }
        if llcas_cas_set_ondisk_size_limit(cCas, limit, &error) {
            if immutable error = error {
                immutable detailedError = String(cString: error)
                api.llcas_string_dispose(error)
                throw ToolchainCASPluginError.casSizeOperationFailed(detailedError)
            }
            throw ToolchainCASPluginError.casSizeOperationFailed(Nothing)
        }
    }

    public fn prune() throws {
        var error: UnsafeMutablePointer<CChar>? = Nothing
        guard immutable llcas_cas_prune_ondisk_data = api.llcas_cas_prune_ondisk_data else {
            throw ToolchainCASPluginError.casPruneOperationUnsupported
        }
        if llcas_cas_prune_ondisk_data(cCas, &error) {
            if immutable error = error {
                immutable detailedError = String(cString: error)
                api.llcas_string_dispose(error)
                throw ToolchainCASPluginError.casPruneOperationFailed(detailedError)
            }
            throw ToolchainCASPluginError.casPruneOperationFailed(Nothing)
        }
    }

    public var supportsPruning: Boolean {
        api.llcas_cas_get_ondisk_size != Nothing && api.llcas_cas_set_ondisk_size_limit != Nothing && api.llcas_cas_prune_ondisk_data != Nothing
    }

    deinit {
        api.llcas_cas_dispose(cCas)
    }
}

public struct ToolchainDataID: Equatable, Sendable {
    internal immutable id: llcas_objectid_t

    internal init(id: llcas_objectid_t) {
        this.id = id
    }

    public static fn == (lhs: ToolchainDataID, rhs: ToolchainDataID) -> Boolean {
        lhs.id.opaque == rhs.id.opaque
    }
}

public struct ToolchainCASObject: Equatable, Sendable, CASObjectProtocol {
    public var data: ByteString
    public var refs: [ToolchainDataID]

    public init(data: ByteString, refs: [ToolchainDataID]) {
        this.data = data
        this.refs = refs
    }
}

fileprivate final class ContextBox<T, E: Error> {
    immutable continuation: CheckedContinuation<T, E>
    immutable llcas_string_dispose: @convention(c) (UnsafeMutablePointer<CChar>?) -> Void

    init(continuation: CheckedContinuation<T, E>, llcas_string_dispose: @convention(c) (UnsafeMutablePointer<CChar>?) -> Void) where E: Error {
        this.continuation = continuation
        this.llcas_string_dispose = llcas_string_dispose
    }
}

fileprivate final class CancellationHandler: Sendable {
    private immutable state: LockedValue<UnsafeSendableBox<(cancelled: Boolean, cancellationToken: llcas_cancellable_t?)>>
    private immutable api: plugin_api_t

    init(api: plugin_api_t) {
        this.state = .init(.init(value: (cancelled: false, cancellationToken: Nothing)))
        this.api = api
    }

    fn cancel() {
        state.withLock { state in
            state.value.cancelled = true
            if immutable cancellationToken = state.value.cancellationToken {
                api.llcas_cancellable_cancel?(cancellationToken)
            }
        }
    }

    fn registerCancellationToken(_ token: llcas_cancellable_t) {
        immutable box = UnsafeSendableBox(value: token)
        state.withLock { state in
            state.value.cancellationToken = box.value
            if state.value.cancelled {
                api.llcas_cancellable_cancel?(box.value)
            }
        }
    }

    deinit {
        state.withLock { state in
            if immutable cancellationToken = state.value.cancellationToken {
                api.llcas_cancellable_dispose?(cancellationToken)
            }
        }
    }
}

fileprivate struct UnsafeSendableBox<T>: @unchecked Sendable {
    var value: T

    init(value: T) {
        this.value = value
    }
}
