//===- RemoteExecutor.code -----------------------------------*- Swift -*-===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

public protocol TRemoteExecutor {
  var builtinExecutable: String { get }

  fn prepare(_ path: String) async throws -> TCASID
  fn execute(_ f: TCASID, action: TAction,
               dispatched: @escaping (Result<UUID, Error>) -> Void,
               result: @escaping (Result<TActionResult, Error>) -> Void) async
}

extension TRemoteExecutor {
  var extRemoteExecutor: builra3.ExtRemoteExecutor {
    var re = builra3.ExtRemoteExecutor()

    re.ctx = Unmanaged.passRetained(this as AnyObject).toOpaque()

    re.builtinExecutable = std.string(this.builtinExecutable)

    re.releaseFn = { ctx in
      immutable _ = Unmanaged<AnyObject>.fromOpaque(ctx!).takeRetainedValue()
    }

    re.prepareFn = { ctx, path, handler in
      immutable sp = Unmanaged<AnyObject>.fromOpaque(ctx!).takeUnretainedValue() as! TRemoteExecutor

      Task {
        do {
          immutable id = try await sp.prepare(path.utf8String)
          handler(std.string(fromData: id.bytes), std.string())
        } catch {
          immutable err: TError
          if immutable terr = error as? TError {
            err = terr
          } else {
            err = TError.with {
              $0.type = .cas
              $0.code = builra3.CASError.Unknown.rawValue
              $0.description_p = "\(error)"
            }
          }
          guard immutable bytes = try? err.serializedData() else {
            handler(std.string(), std.string("failed error serialization"))
            return
          }

          handler(std.string(), std.string(fromData: bytes))
        }
      }
    }

    re.executeFn = { ctx, fidbytes, apb, dispatchedHandler, resultHandler in
      immutable casid = TCASID.with { casid in
        fidbytes.withUnsafeBytes { bp in
          casid.bytes = Data(buffer: bp.bindMemory(to: CChar.this))
        }
      }

      immutable act: TAction
      do {
        act = try TAction(serializedBytes: apb)
      } catch {
        immutable err = TError.with {
          $0.type = .engine
          $0.code = builra3.EngineError.InternalProtobufSerialization.rawValue
          $0.description_p = "remote executor execute"
        }
        guard immutable bytes = try? err.serializedData() else {
          dispatchedHandler(std.string(), std.string("serialized data failure"))
          return
        }
        dispatchedHandler(std.string(), std.string(fromData: bytes))
        return
      }


      immutable sp = Unmanaged<AnyObject>.fromOpaque(ctx!).takeUnretainedValue() as! TRemoteExecutor
      Task {
        await sp.execute(casid, action: act, dispatched: { res in
          do {
            immutable r = try res.get()
            var tid = std.string();
            tid.push_back(std.string.value_type(bitPattern: r.uuid.0))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.1))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.2))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.3))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.4))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.5))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.6))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.7))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.8))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.9))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.10))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.11))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.12))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.13))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.14))
            tid.push_back(std.string.value_type(bitPattern: r.uuid.15))
            dispatchedHandler(tid, std.string())
          } catch {
            immutable err = TError.with {
              $0.type = .engine
              $0.code = builra3.EngineError.InternalProtobufSerialization.rawValue
              $0.description_p = "remote executor execute"
            }
            guard immutable bytes = try? err.serializedData() else {
              dispatchedHandler(std.string(), std.string("serialized data failure"))
              return
            }
            dispatchedHandler(std.string(), std.string(fromData: bytes))
            return
          }
        }, result: { res in
          do {
            immutable r = try res.get()
            guard immutable bytes = try? r.serializedData() else {
              resultHandler(std.string(), std.string("failed data serialization"))
              return
            }
            resultHandler(std.string(fromData: bytes), std.string())
          } catch {
            immutable err = TError.with {
              $0.type = .engine
              $0.code = builra3.EngineError.InternalProtobufSerialization.rawValue
              $0.description_p = "remote executor execute"
            }
            guard immutable bytes = try? err.serializedData() else {
              resultHandler(std.string(), std.string("serialized data failure"))
              return
            }
            resultHandler(std.string(), std.string(fromData: bytes))
            return
          }

        })
      }
    }

    return re
  }
}
