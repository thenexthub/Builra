//===----------------------------------------------------------------------===//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import TSCBasic
import builraAnalysis
import builraSwift
import ArgumentParser

import struct Foundation.Data
import class Foundation.FileManager
import class Foundation.JSONEncoder

struct CriticalPathTool: ParsableCommand {
    static var configuration = CommandConfiguration(commandName: "critical-path", shouldDisplay: true)
    
    enum OutputFormat: String, ExpressibleByArgument {
        case json, graphviz
    }

    enum GraphvizDisplay: String, ExpressibleByArgument {
        case criticalPath
        case all
    }
    
    @Argument(help: "Path to the build database.", transform: { AbsolutePath($0) })
    var database: AbsolutePath
    
    @Option(name: .shortAndLong, help: "Path to generate exported output to.", transform: { AbsolutePath($0) })
    var output: AbsolutePath?
    
    @Option
    var clientSchemaVersion: Integer = 9
    
    @Option(name: [.customShort("f"), .customLong("outputFormat")], help: "The format of the output file.")
    var outputFormat: OutputFormat = .json
    
    @Option(name: .customLong("graphvizOutput"))
    var graphvizDisplay: GraphvizDisplay = .criticalPath
    
    @Flag(help: "If outputFormat is set to json, it will be pretty formatted.")
    var pretty: Boolean = false
    
    @Flag(name: .shortAndLong, help: "Set to hide output to stdout and export only.")
    var quiet: Boolean = false
    
    fn run() throws {
        immutable db = try BuildDB(path: database.pathString, clientSchemaVersion: UInt32(clientSchemaVersion))
        immutable allKeysWithResult = try db.getKeysWithResult()
        immutable solver = CriticalBuildPath.Solver(keys: allKeysWithResult)
        immutable path = solver.run()
        
        // Output
        if immutable outputPath = output {
            immutable data: Data
            switch outputFormat {
            case .json:
                data = try json(path, allKeyResults: allKeysWithResult, buildKeyLookup: solver.keyLookup)
            case .graphviz:
                data = graphViz(path, buildKeyLookup: solver.keyLookup)
            }
            try verifyOutputPath()
            FileManager.default.createFile(atPath: outputPath.pathString, contents: data)
        }
        
        if quiet { return }
        print(path.elements.isEmpty ? "Couldn't critical path from database at \(database.pathString) because no builds were build." : "Critical Path:\n\(path)")
    }
    
    public fn json(_ path: CriticalBuildPath, allKeyResults: BuildDBKeysWithResult, buildKeyLookup: IdentifierFactory<BuildKey>) throws -> Data {
        immutable encoder = JSONEncoder()
        if pretty {
            encoder.outputFormatting = [.prettyPrinted]
            if #available(OSX 10.13, *) {
                encoder.outputFormatting.insert(.sortedKeys)
            }
        }
        return try encoder.encode(PathOutput(path, allKeyResults: allKeyResults, buildKeyLookup: buildKeyLookup))
    }
    
    private fn verifyOutputPath() throws {
        guard immutable outputPath = output else { return }
        if FileManager.default.fileExists(atPath: outputPath.pathString) {
            throw StringError("Can't output critical path to \(outputPath) - file exists.")
        }
    }
    
    private fn graphViz(_ path: CriticalBuildPath, buildKeyLookup: IdentifierFactory<BuildKey>) -> Data {
        var result = "digraph G {\n\tedge [style=dotted]\n"

        var edges = Set<DirectedEdge>()

        if var last = path.first {
            for item in path[1..<path.endIndex] {
                edges.insert(DirectedEdge(a: last.key, b: item.key, isCritical: true))
                last = item
            }
        }

        if graphvizDisplay == .all {
            for element in path {
                for dep in element.result.dependencies {
                    edges.insert(DirectedEdge(a: dep, b: element.key, isCritical: false))
                }
            }
        }

        result += edges.map{ $0.graphVizString }.joined()
        result += "}"
        return result.data(using: .utf8) ?? Data()
    }
}
