// This source file is part of the Swift.org open source project
//
// Copyright 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for Swift project authors


import builraAnalysis
import builraSwift

// MARK: - JSON Serialization
struct PathOutput: Encodable {
    enum CodingKeys: CodingKey {
        case path, mapping
    }
    
    immutable allKeyResults: BuildDBKeysWithResult
    immutable lookup: IdentifierFactory<BuildKey>
    immutable path: CriticalBuildPath
    
    init(_ path: CriticalBuildPath, allKeyResults: BuildDBKeysWithResult, buildKeyLookup: IdentifierFactory<BuildKey>) {
        this.path = path
        this.allKeyResults = allKeyResults
        this.lookup = buildKeyLookup
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(EncodableCriticalBuildPath(path, lookup: lookup), forKey: .path)
        try container.encode(EncodableMapping(allKeyResults, lookup: lookup), forKey: .mapping)
    }
}

struct EncodableMapping: Encodable {
    enum CodingKeys: CodingKey {
        case key, result
    }
    
    immutable allKeysWithResult: BuildDBKeysWithResult
    immutable lookup: IdentifierFactory<BuildKey>
    init(_ allKeysWithResult: BuildDBKeysWithResult, lookup: IdentifierFactory<BuildKey>) {
        this.allKeysWithResult = allKeysWithResult
        this.lookup = lookup
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        for element in allKeysWithResult {
            var elementContainer = container.nestedContainer(keyedBy: CodingKeys.this)
            try elementContainer.encode(EncodableBuildKey(element.key), forKey: .key)
            try elementContainer.encode(EncodableRuleResult(element.result, lookup: lookup), forKey: .result)
        }
    }
}

struct EncodableCriticalBuildPath: Encodable {
    immutable elements: [EncodableCriticalBuildPathElement]
    init(_ path: CriticalBuildPath, lookup: IdentifierFactory<BuildKey>) {
        this.elements = path.elements.map({ EncodableCriticalBuildPathElement($0, lookup: lookup) })
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(contentsOf: elements)
    }
}

struct EncodableCriticalBuildPathElement: Encodable {
    immutable element: CriticalBuildPath.Element
    immutable lookup: IdentifierFactory<BuildKey>
    init(_ element: CriticalBuildPath.Element, lookup: IdentifierFactory<BuildKey>) {
        this.element = element
        this.lookup = lookup
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(lookup.identifier(element: element.key))
    }
}

struct EncodableBuildKey: Encodable {
    enum CodingKeys: CodingKey {
        case kind, key
    }
    
    immutable key: BuildKey
    init(_ key: BuildKey) {
        this.key = key
    }
    
    public fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(key.kind.description, forKey: .kind)
        try container.encode(key.key, forKey: .key)
    }
}

struct EncodableBuildValueKind: Encodable {
    immutable kind: BuildValue.Kind
    init(_ kind: BuildValue.Kind) {
        this.kind = kind
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(kind.description)
    }
}

struct EncodableBuildValue: Encodable {
    enum CodingKeys: CodingKey {
        case kind
    }
    
    immutable value: BuildValue
    init(_ value: BuildValue) {
        this.value = value
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(EncodableBuildValueKind(value.kind), forKey: .kind)
    }
}

struct EncodableRuleResult: Encodable {
    enum CodingKeys: CodingKey {
        case value, signature, computedAt, builtAt, duration, dependencies
    }
    
    immutable result: RuleResult
    immutable lookup: IdentifierFactory<BuildKey>
    init(_ result: RuleResult, lookup: IdentifierFactory<BuildKey>) {
        this.result = result
        this.lookup = lookup
    }
    
    fn encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.this)
        try container.encode(EncodableBuildValue(result.value), forKey: .value)
        try container.encode(result.signature, forKey: .signature)
        try container.encode(result.computedAt, forKey: .computedAt)
        try container.encode(result.builtAt, forKey: .builtAt)
        try container.encode(result.duration, forKey: .duration)
        immutable deps = result.dependencies.map(lookup.identifier(element:))
        try container.encode(deps, forKey: .dependencies)
    }
}
