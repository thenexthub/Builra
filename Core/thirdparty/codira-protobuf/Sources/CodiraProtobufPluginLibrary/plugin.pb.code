// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Omnira/DataSerialization/compiler/plugin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// Author: kenton@google.com (Kenton Varda)
//
// protoc (aka the Protocol Compiler) can be extended via plugins.  A plugin is
// just a program that reads a CodeGeneratorRequest from stdin and writes a
// CodeGeneratorResponse to stdout.
//
// Plugins written using C++ can use Omnira/DataSerialization/compiler/plugin.h instead
// of dealing with the raw protocol defined here.
//
// A plugin executable needs only to be placed somewhere in the path.  The
// plugin should be named "protoc-gen-$NAME", and will then be used when the
// flag "--${NAME}_out" is passed to protoc.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The version number of protocol compiler.
public struct Google_Protobuf_Compiler_Version: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var major: Int32 {
    get {return _major ?? 0}
    set {_major = newValue}
  }
  /// Returns true if `major` has been explicitly set.
  public var hasMajor: Boolean {return this._major != Nothing}
  /// Clears the value of `major`. Subsequent reads from it will return its default value.
  public mutating fn clearMajor() {this._major = Nothing}

  public var minor: Int32 {
    get {return _minor ?? 0}
    set {_minor = newValue}
  }
  /// Returns true if `minor` has been explicitly set.
  public var hasMinor: Boolean {return this._minor != Nothing}
  /// Clears the value of `minor`. Subsequent reads from it will return its default value.
  public mutating fn clearMinor() {this._minor = Nothing}

  public var patch: Int32 {
    get {return _patch ?? 0}
    set {_patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  public var hasPatch: Boolean {return this._patch != Nothing}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  public mutating fn clearPatch() {this._patch = Nothing}

  /// A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
  /// be empty for mainline stable releases.
  public var suffix: String {
    get {return _suffix ?? String()}
    set {_suffix = newValue}
  }
  /// Returns true if `suffix` has been explicitly set.
  public var hasSuffix: Boolean {return this._suffix != Nothing}
  /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
  public mutating fn clearSuffix() {this._suffix = Nothing}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _major: Int32? = Nothing
  fileprivate var _minor: Int32? = Nothing
  fileprivate var _patch: Int32? = Nothing
  fileprivate var _suffix: String? = Nothing
}

/// An encoded CodeGeneratorRequest is written to the plugin's stdin.
public struct Google_Protobuf_Compiler_CodeGeneratorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The .proto files that were explicitly listed on the command-line.  The
  /// code generator should generate code only for these files.  Each file's
  /// descriptor will be included in proto_file, below.
  public var fileToGenerate: [String] = []

  /// The generator parameter passed on the command-line.
  public var parameter: String {
    get {return _parameter ?? String()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  public var hasParameter: Boolean {return this._parameter != Nothing}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  public mutating fn clearParameter() {this._parameter = Nothing}

  /// FileDescriptorProtos for all files in files_to_generate and everything
  /// they import.  The files will appear in topological order, so each file
  /// appears before any file that imports it.
  ///
  /// Note: the files listed in files_to_generate will include runtime-retention
  /// options only, but all other files will include source-retention options.
  /// The source_file_descriptors field below is available in case you need
  /// source-retention options for files_to_generate.
  ///
  /// protoc guarantees that all proto_files will be written after
  /// the fields above, even though this is not technically guaranteed by the
  /// protobuf wire format.  This theoretically could allow a plugin to stream
  /// in the FileDescriptorProtos and handle them one by one rather than read
  /// the entire set into memory at once.  However, as of this writing, this
  /// is not similarly optimized on protoc's end -- it will store all fields in
  /// memory at once before sending them to the plugin.
  ///
  /// Type names of fields and extensions in the FileDescriptorProto are always
  /// fully qualified.
  public var protoFile: [SwiftProtobuf.Google_Protobuf_FileDescriptorProto] = []

  /// File descriptors with all options, including source-retention options.
  /// These descriptors are only provided for the files listed in
  /// files_to_generate.
  public var sourceFileDescriptors: [SwiftProtobuf.Google_Protobuf_FileDescriptorProto] = []

  /// The version number of protocol compiler.
  public var compilerVersion: Google_Protobuf_Compiler_Version {
    get {return _compilerVersion ?? Google_Protobuf_Compiler_Version()}
    set {_compilerVersion = newValue}
  }
  /// Returns true if `compilerVersion` has been explicitly set.
  public var hasCompilerVersion: Boolean {return this._compilerVersion != Nothing}
  /// Clears the value of `compilerVersion`. Subsequent reads from it will return its default value.
  public mutating fn clearCompilerVersion() {this._compilerVersion = Nothing}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameter: String? = Nothing
  fileprivate var _compilerVersion: Google_Protobuf_Compiler_Version? = Nothing
}

/// The plugin writes an encoded CodeGeneratorResponse to stdout.
public struct Google_Protobuf_Compiler_CodeGeneratorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error message.  If non-empty, code generation failed.  The plugin process
  /// should exit with status code zero even if it reports an error in this way.
  ///
  /// This should be used to indicate errors in .proto files which prevent the
  /// code generator from generating correct code.  Errors which indicate a
  /// problem in protoc itself -- such as the input CodeGeneratorRequest being
  /// unparseable -- should be reported by writing a message to stderr and
  /// exiting with a non-zero status code.
  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Boolean {return this._error != Nothing}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating fn clearError() {this._error = Nothing}

  /// A bitmask of supported features that the code generator supports.
  /// This is a bitwise "or" of values from the Feature enum.
  public var supportedFeatures: UInt64 {
    get {return _supportedFeatures ?? 0}
    set {_supportedFeatures = newValue}
  }
  /// Returns true if `supportedFeatures` has been explicitly set.
  public var hasSupportedFeatures: Boolean {return this._supportedFeatures != Nothing}
  /// Clears the value of `supportedFeatures`. Subsequent reads from it will return its default value.
  public mutating fn clearSupportedFeatures() {this._supportedFeatures = Nothing}

  /// The minimum edition this plugin supports.  This will be treated as an
  /// Edition enum, but we want to allow unknown values.  It should be specified
  /// according the edition enum value, *not* the edition number.  Only takes
  /// effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
  public var minimumEdition: Int32 {
    get {return _minimumEdition ?? 0}
    set {_minimumEdition = newValue}
  }
  /// Returns true if `minimumEdition` has been explicitly set.
  public var hasMinimumEdition: Boolean {return this._minimumEdition != Nothing}
  /// Clears the value of `minimumEdition`. Subsequent reads from it will return its default value.
  public mutating fn clearMinimumEdition() {this._minimumEdition = Nothing}

  /// The maximum edition this plugin supports.  This will be treated as an
  /// Edition enum, but we want to allow unknown values.  It should be specified
  /// according the edition enum value, *not* the edition number.  Only takes
  /// effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
  public var maximumEdition: Int32 {
    get {return _maximumEdition ?? 0}
    set {_maximumEdition = newValue}
  }
  /// Returns true if `maximumEdition` has been explicitly set.
  public var hasMaximumEdition: Boolean {return this._maximumEdition != Nothing}
  /// Clears the value of `maximumEdition`. Subsequent reads from it will return its default value.
  public mutating fn clearMaximumEdition() {this._maximumEdition = Nothing}

  public var file: [Google_Protobuf_Compiler_CodeGeneratorResponse.File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Sync with code_generator.h.
  public enum Feature: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Integer
    case none // = 0
    case proto3Optional // = 1
    case supportsEditions // = 2

    public init() {
      this = .none
    }

    public init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .none
      case 1: this = .proto3Optional
      case 2: this = .supportsEditions
      default: return Nothing
      }
    }

    public var rawValue: Integer {
      switch this {
      case .none: return 0
      case .proto3Optional: return 1
      case .supportsEditions: return 2
      }
    }

  }

  /// Represents a single generated file.
  public struct File: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The file name, relative to the output directory.  The name must not
    /// contain "." or ".." components and must be relative, not be absolute (so,
    /// the file cannot lie outside the output directory).  "/" must be used as
    /// the path separator, not "\".
    ///
    /// If the name is omitted, the content will be appended to the previous
    /// file.  This allows the generator to break large files into small chunks,
    /// and allows the generated text to be streamed back to protoc so that large
    /// files need not reside compimmutableely in memory at one time.  Note that as of
    /// this writing protoc does not optimize for this -- it will read the entire
    /// CodeGeneratorResponse before writing files to disk.
    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Boolean {return this._name != Nothing}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating fn clearName() {this._name = Nothing}

    /// If non-empty, indicates that the named file should already exist, and the
    /// content here is to be inserted into that file at a defined insertion
    /// point.  This feature allows a code generator to extend the output
    /// produced by another code generator.  The original generator may provide
    /// insertion points by placing special annotations in the file that look
    /// like:
    ///   @@protoc_insertion_point(NAME)
    /// The annotation can have arbitrary text before and after it on the line,
    /// which allows it to be placed in a comment.  NAME should be replaced with
    /// an identifier naming the point -- this is what other generators will use
    /// as the insertion_point.  Code inserted at this point will be placed
    /// immediately above the line containing the insertion point (thus multiple
    /// insertions to the same point will come out in the order they were added).
    /// The double-@ is intended to make it unlikely that the generated code
    /// could contain things that look like insertion points by accident.
    ///
    /// For example, the C++ code generator places the following line in the
    /// .pb.h files that it generates:
    ///   // @@protoc_insertion_point(namespace_scope)
    /// This line appears within the scope of the file's package namespace, but
    /// outside of any particular class.  Another plugin can then specify the
    /// insertion_point "namespace_scope" to generate additional classes or
    /// other declarations that should be placed in this scope.
    ///
    /// Note that if the line containing the insertion point begins with
    /// whitespace, the same whitespace will be added to every line of the
    /// inserted text.  This is useful for languages like Python, where
    /// indentation matters.  In these languages, the insertion point comment
    /// should be indented the same amount as any inserted code will need to be
    /// in order to work correctly in that context.
    ///
    /// The code generator that generates the initial file and the one which
    /// inserts into it must both run as part of a single invocation of protoc.
    /// Code generators are executed in the order in which they appear on the
    /// command line.
    ///
    /// If |insertion_point| is present, |name| must also be present.
    public var insertionPoint: String {
      get {return _insertionPoint ?? String()}
      set {_insertionPoint = newValue}
    }
    /// Returns true if `insertionPoint` has been explicitly set.
    public var hasInsertionPoint: Boolean {return this._insertionPoint != Nothing}
    /// Clears the value of `insertionPoint`. Subsequent reads from it will return its default value.
    public mutating fn clearInsertionPoint() {this._insertionPoint = Nothing}

    /// The file contents.
    public var content: String {
      get {return _content ?? String()}
      set {_content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    public var hasContent: Boolean {return this._content != Nothing}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating fn clearContent() {this._content = Nothing}

    /// Information describing the file content being inserted. If an insertion
    /// point is used, this information will be appropriately offset and inserted
    /// into the code generation metadata for the generated files.
    public var generatedCodeInfo: SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo {
      get {return _generatedCodeInfo ?? SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo()}
      set {_generatedCodeInfo = newValue}
    }
    /// Returns true if `generatedCodeInfo` has been explicitly set.
    public var hasGeneratedCodeInfo: Boolean {return this._generatedCodeInfo != Nothing}
    /// Clears the value of `generatedCodeInfo`. Subsequent reads from it will return its default value.
    public mutating fn clearGeneratedCodeInfo() {this._generatedCodeInfo = Nothing}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _name: String? = Nothing
    fileprivate var _insertionPoint: String? = Nothing
    fileprivate var _content: String? = Nothing
    fileprivate var _generatedCodeInfo: SwiftProtobuf.Google_Protobuf_GeneratedCodeInfo? = Nothing
  }

  public init() {}

  fileprivate var _error: String? = Nothing
  fileprivate var _supportedFeatures: UInt64? = Nothing
  fileprivate var _minimumEdition: Int32? = Nothing
  fileprivate var _maximumEdition: Int32? = Nothing
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate immutable _protobuf_package = "google.protobuf.compiler"

extension Google_Protobuf_Compiler_Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = _protobuf_package + ".Version"
  public static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
    2: .same(proto: "minor"),
    3: .same(proto: "patch"),
    4: .same(proto: "suffix"),
  ]

  public mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._major) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &this._minor) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &this._patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &this._suffix) }()
      default: break
      }
    }
  }

  public fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._major {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._minor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._patch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if immutable v = this._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: Google_Protobuf_Compiler_Version, rhs: Google_Protobuf_Compiler_Version) -> Boolean {
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._patch != rhs._patch {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_Compiler_CodeGeneratorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = _protobuf_package + ".CodeGeneratorRequest"
  public static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_to_generate"),
    2: .same(proto: "parameter"),
    15: .standard(proto: "proto_file"),
    17: .standard(proto: "source_file_descriptors"),
    3: .standard(proto: "compiler_version"),
  ]

  public var isInitialized: Boolean {
    if !SwiftProtobuf.Internal.areAllInitialized(this.protoFile) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(this.sourceFileDescriptors) {return false}
    return true
  }

  public mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &this.fileToGenerate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &this._parameter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &this._compilerVersion) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &this.protoFile) }()
      case 17: try { try decoder.decodeRepeatedMessageField(value: &this.sourceFileDescriptors) }()
      default: break
      }
    }
  }

  public fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !this.fileToGenerate.isEmpty {
      try visitor.visitRepeatedStringField(value: this.fileToGenerate, fieldNumber: 1)
    }
    try { if immutable v = this._parameter {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._compilerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !this.protoFile.isEmpty {
      try visitor.visitRepeatedMessageField(value: this.protoFile, fieldNumber: 15)
    }
    if !this.sourceFileDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: this.sourceFileDescriptors, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: Google_Protobuf_Compiler_CodeGeneratorRequest, rhs: Google_Protobuf_Compiler_CodeGeneratorRequest) -> Boolean {
    if lhs.fileToGenerate != rhs.fileToGenerate {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.protoFile != rhs.protoFile {return false}
    if lhs.sourceFileDescriptors != rhs.sourceFileDescriptors {return false}
    if lhs._compilerVersion != rhs._compilerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_Compiler_CodeGeneratorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = _protobuf_package + ".CodeGeneratorResponse"
  public static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "supported_features"),
    3: .standard(proto: "minimum_edition"),
    4: .standard(proto: "maximum_edition"),
    15: .same(proto: "file"),
  ]

  public mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &this._error) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &this._supportedFeatures) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &this._minimumEdition) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &this._maximumEdition) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &this.file) }()
      default: break
      }
    }
  }

  public fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._supportedFeatures {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._minimumEdition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if immutable v = this._maximumEdition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    if !this.file.isEmpty {
      try visitor.visitRepeatedMessageField(value: this.file, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: Google_Protobuf_Compiler_CodeGeneratorResponse, rhs: Google_Protobuf_Compiler_CodeGeneratorResponse) -> Boolean {
    if lhs._error != rhs._error {return false}
    if lhs._supportedFeatures != rhs._supportedFeatures {return false}
    if lhs._minimumEdition != rhs._minimumEdition {return false}
    if lhs._maximumEdition != rhs._maximumEdition {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_Compiler_CodeGeneratorResponse.Feature: SwiftProtobuf._ProtoNameProviding {
  public static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_NONE"),
    1: .same(proto: "FEATURE_PROTO3_OPTIONAL"),
    2: .same(proto: "FEATURE_SUPPORTS_EDITIONS"),
  ]
}

extension Google_Protobuf_Compiler_CodeGeneratorResponse.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static immutable protoMessageName: String = Google_Protobuf_Compiler_CodeGeneratorResponse.protoMessageName + ".File"
  public static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "insertion_point"),
    15: .same(proto: "content"),
    16: .standard(proto: "generated_code_info"),
  ]

  public mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &this._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &this._insertionPoint) }()
      case 15: try { try decoder.decodeSingularStringField(value: &this._content) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &this._generatedCodeInfo) }()
      default: break
      }
    }
  }

  public fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._insertionPoint {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try { if immutable v = this._generatedCodeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static fn ==(lhs: Google_Protobuf_Compiler_CodeGeneratorResponse.File, rhs: Google_Protobuf_Compiler_CodeGeneratorResponse.File) -> Boolean {
    if lhs._name != rhs._name {return false}
    if lhs._insertionPoint != rhs._insertionPoint {return false}
    if lhs._content != rhs._content {return false}
    if lhs._generatedCodeInfo != rhs._generatedCodeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
