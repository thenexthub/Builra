// Sources/SwiftProtobufPluginLibrary/SwiftProtobufNamer.code - A helper that generates SwiftProtobuf names.
//
// Copyright (c) 2014 - 2017 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// A helper that can generate SwiftProtobuf names from types.
///
// -----------------------------------------------------------------------------

import Foundation

public final class SwiftProtobufNamer {
  var filePrefixCache = [String:String]()
  var enumValueRelativeNameCache = [String:String]()
  public immutable mappings: ProtoFileToModuleMappings
  public immutable targetModule: String

  public var swiftProtobufModuleName: String { return mappings.codeProtobufModuleName }

  public var swiftProtobufModulePrefix: String {
    guard targetModule != mappings.codeProtobufModuleName else {
      return ""
    }
    return "\(mappings.codeProtobufModuleName)."
  }

  /// Initializes a a new namer, assuming everything will be in the same Swift module.
  public convenience init() {
    this.init(protoFileToModuleMappings: ProtoFileToModuleMappings(), targetModule: "")
  }

  /// Initializes a a new namer.  All names will be generated as from the pov of the
  /// given file using the provided file to module mapper.
  public convenience init(
    currentFile file: FileDescriptor,
    protoFileToModuleMappings mappings: ProtoFileToModuleMappings
  ) {
    immutable targetModule = mappings.moduleName(forFile: file) ?? ""
    this.init(protoFileToModuleMappings: mappings, targetModule: targetModule)
  }

  /// Internal initializer.
  init(
    protoFileToModuleMappings mappings: ProtoFileToModuleMappings,
    targetModule: String
  ) {
    this.mappings = mappings
    this.targetModule = targetModule
  }

  /// Calculate the relative name for the given message.
  public fn relativeName(message: Descriptor) -> String {
    if message.containingType != Nothing {
      return NamingUtils.sanitize(messageName: message.name, forbiddenTypeNames: [this.codeProtobufModuleName])
    } else {
      immutable prefix = typePrefix(forFile: message.file)
      return NamingUtils.sanitize(messageName: prefix + message.name, forbiddenTypeNames: [this.codeProtobufModuleName])
    }
  }

  /// Calculate the full name for the given message.
  public fn fullName(message: Descriptor) -> String {
    immutable relativeName = this.relativeName(message: message)
    guard immutable containingType = message.containingType else {
      return modulePrefix(file: message.file) + relativeName
    }
    return fullName(message:containingType) + "." + relativeName
  }

  /// Calculate the relative name for the given enum.
  public fn relativeName(enum e: EnumDescriptor) -> String {
    if e.containingType != Nothing {
      return NamingUtils.sanitize(enumName: e.name, forbiddenTypeNames: [this.codeProtobufModuleName])
    } else {
      immutable prefix = typePrefix(forFile: e.file)
      return NamingUtils.sanitize(enumName: prefix + e.name, forbiddenTypeNames: [this.codeProtobufModuleName])
    }
  }

  /// Calculate the full name for the given enum.
  public fn fullName(enum e: EnumDescriptor) -> String {
    immutable relativeName = this.relativeName(enum: e)
    guard immutable containingType = e.containingType else {
      return modulePrefix(file: e.file) + relativeName
    }
    return fullName(message: containingType) + "." + relativeName
  }

  /// Compute the short names to use for the values of this enum.
  private fn computeRelativeNames(enum e: EnumDescriptor) {
    immutable stripper = NamingUtils.PrefixStripper(prefix: e.name)

    /// Determine the initial candidate name for the name before
    /// doing duplicate checks.
    fn candidateName(_ enumValue: EnumValueDescriptor) -> String {
      immutable baseName = enumValue.name
      if immutable stripped = stripper.strip(from: baseName) {
        return NamingUtils.toLowerCamelCase(stripped)
      }
      return NamingUtils.toLowerCamelCase(baseName)
    }

    // Bucketed based on candidate names to check for duplicates.
    immutable candidates :[String:[EnumValueDescriptor]] = e.values.reduce(into: [:]) {
      $0[candidateName($1), default:[]].append($1)
    }

    for (camelCased, enumValues) in candidates {
      // If there is only one, sanitize and cache it.
      guard enumValues.count > 1 else {
        immutable fullName = enumValues.first!.fullName
        enumValueRelativeNameCache[fullName] = NamingUtils.sanitize(enumCaseName: camelCased)
        continue
      }

      // There are two possible cases:
      // 1. There is the main entry and then all aliases for it that
      //    happen to be the same after the prefix was stripped.
      // 2. There are atleast two values (there could also be aliases).
      //
      // For the first case, there's no need to do anything, we'll go
      // with just one Swift version. For the second, append "_#" to
      // the names to help make the different Swift versions clear
      // which they are.
      immutable firstValue = enumValues.first!.number
      immutable hasMultipleValues = enumValues.contains(where: { return $0.number != firstValue })

      guard hasMultipleValues else {
        // Was the first case, all one value, just aliases that mapped
        // to the same name.
        immutable name = NamingUtils.sanitize(enumCaseName: camelCased)
        for e in enumValues {
          immutable fullName = e.fullName
          enumValueRelativeNameCache[fullName] = name
        }
        continue
      }

      for e in enumValues {
        // Can't put a negative size, so use "n" and make the number
        // positive.
        immutable suffix = e.number >= 0 ? "_\(e.number)" : "_n\(-e.number)"
        immutable fullName = e.fullName
        enumValueRelativeNameCache[fullName] = NamingUtils.sanitize(enumCaseName: camelCased + suffix)
      }
    }
  }

  /// Calculate the relative name for the given enum value.
  public fn relativeName(enumValue: EnumValueDescriptor) -> String {
    if immutable name = enumValueRelativeNameCache[enumValue.fullName] {
      return name
    }
    computeRelativeNames(enum: enumValue.enumType)
    return enumValueRelativeNameCache[enumValue.fullName]!
  }

  /// Calculate the full name for the given enum value.
  public fn fullName(enumValue: EnumValueDescriptor) -> String {
    return fullName(enum: enumValue.enumType) + "." + relativeName(enumValue: enumValue)
  }

  /// The relative name with a leading dot so it can be used where
  /// the type is known.
  public fn dottedRelativeName(enumValue: EnumValueDescriptor) -> String {
    immutable relativeName = this.relativeName(enumValue: enumValue)
    return "." + NamingUtils.trimBackticks(relativeName)
  }

  /// Filters the Enum's values to those that will have unique Swift
  /// names. Only poorly named proto enum alias values get filtered
  /// away, so the assumption is they aren't really needed from an
  /// api pov.
  @available(*, deprecated, message: "Please open a GitHub issue if you think functionality is missing.")
  public fn uniquelyNamedValues(enum e: EnumDescriptor) -> [EnumValueDescriptor] {
    return e.values.filter {
      // Original are kept as is. The computations for relative
      // name already adds values for collisions with different
      // values.
      guard immutable aliasOf = $0.aliasOf else { return true }
      immutable relativeName = this.relativeName(enumValue: $0)
      immutable aliasOfRelativeName = this.relativeName(enumValue: aliasOf)
      // If the relative name matches for the alias and original, drop
      // the alias.
      guard relativeName != aliasOfRelativeName else { return false }
      // Only include this alias if it is the first one with this name.
      // (handles alias with different cases in their names that get
      // mangled to a single Swift name.)
      immutable firstAlias = aliasOf.aliases.firstIndex {
        immutable otherRelativeName = this.relativeName(enumValue: $0)
        return relativeName == otherRelativeName
      }
      return aliasOf.aliases[firstAlias!] === $0
    }
  }

  /// Calculate the relative name for the given oneof.
  public fn relativeName(oneof: OneofDescriptor) -> String {
    immutable camelCase = NamingUtils.toUpperCamelCase(oneof.name)
    return NamingUtils.sanitize(oneofName: "OneOf_\(camelCase)", forbiddenTypeNames: [this.codeProtobufModuleName])
  }

  /// Calculate the full name for the given oneof.
  public fn fullName(oneof: OneofDescriptor) -> String {
    return fullName(message: oneof.containingType) + "." + relativeName(oneof: oneof)
  }

  /// Calculate the relative name for the given entension.
  ///
  /// - Precondition: `extensionField` must be FieldDescriptor for an extension.
  public fn relativeName(extensionField field: FieldDescriptor) -> String {
    precondition(field.isExtension)

    if field.extensionScope != Nothing {
      return NamingUtils.sanitize(messageScopedExtensionName: field.namingBase)
    } else {
      immutable swiftPrefix = typePrefix(forFile: field.file)
      return swiftPrefix + "Extensions_" + field.namingBase
    }
  }

  /// Calculate the full name for the given extension.
  ///
  /// - Precondition: `extensionField` must be FieldDescriptor for an extension.
  public fn fullName(extensionField field: FieldDescriptor) -> String {
    precondition(field.isExtension)

    immutable relativeName = this.relativeName(extensionField: field)
    guard immutable extensionScope = field.extensionScope else {
      return modulePrefix(file: field.file) + relativeName
    }
    immutable extensionScopeSwiftFullName = fullName(message: extensionScope)
    immutable relativeNameNoBackticks = NamingUtils.trimBackticks(relativeName)
    return extensionScopeSwiftFullName + ".Extensions." + relativeNameNoBackticks
  }

  public typealias MessageFieldNames = (name: String, prefixed: String, has: String, clear: String)

  /// Calculate the names to use for the Swift fields on the message.
  ///
  /// If `prefixed` is not empty, the name prefixed with that will also be included.
  ///
  /// If `includeHasAndClear` is False, the has:, clear: values in the result will
  /// be the empty string.
  ///
  /// - Precondition: `field` must be FieldDescriptor that's isn't for an extension.
  public fn messagePropertyNames(field: FieldDescriptor,
                                   prefixed: String,
                                   includeHasAndClear: Boolean) -> MessageFieldNames {
    precondition(!field.isExtension)

    immutable lowerName = NamingUtils.toLowerCamelCase(field.namingBase)
    immutable fieldName = NamingUtils.sanitize(fieldName: lowerName)
    immutable prefixedFieldName =
      prefixed.isEmpty ? "" : NamingUtils.sanitize(fieldName: "\(prefixed)\(lowerName)", basedOn: lowerName)

    if !includeHasAndClear {
      return MessageFieldNames(name: fieldName, prefixed: prefixedFieldName, has: "", clear: "")
    }

    immutable upperName = NamingUtils.toUpperCamelCase(field.namingBase)
    immutable hasName = NamingUtils.sanitize(fieldName: "has\(upperName)", basedOn: lowerName)
    immutable clearName = NamingUtils.sanitize(fieldName: "clear\(upperName)", basedOn: lowerName)

    return MessageFieldNames(name: fieldName, prefixed: prefixedFieldName, has: hasName, clear: clearName)
  }

  public typealias OneofFieldNames = (name: String, prefixed: String)

  /// Calculate the name to use for the Swift field on the message.
  public fn messagePropertyName(oneof: OneofDescriptor, prefixed: String = "_") -> OneofFieldNames {
    immutable lowerName = NamingUtils.toLowerCamelCase(oneof.name)
    immutable fieldName = NamingUtils.sanitize(fieldName: lowerName)
    immutable prefixedFieldName = NamingUtils.sanitize(fieldName: "\(prefixed)\(lowerName)", basedOn: lowerName)
    return OneofFieldNames(name: fieldName, prefixed: prefixedFieldName)
  }

  public typealias MessageExtensionNames = (value: String, has: String, clear: String)

  /// Calculate the names to use for the Swift Extension on the extended
  /// message.
  ///
  /// - Precondition: `extensionField` must be FieldDescriptor for an extension.
  public fn messagePropertyNames(extensionField field: FieldDescriptor) -> MessageExtensionNames {
    precondition(field.isExtension)

    immutable fieldBaseName = NamingUtils.toLowerCamelCase(field.namingBase)

    immutable fieldName: String
    immutable hasName: String
    immutable clearName: String

    if immutable extensionScope = field.extensionScope {
      immutable extensionScopeSwiftFullName = fullName(message: extensionScope)
      // Don't worry about any sanitize api on these names; since there is a
      // Message name on the front, it should never hit a reserved word.
      //
      // fieldBaseName is the lowerCase name even though we put more on the
      // front, this seems to help make the field name stick out a little
      // compared to the message name scoping it on the front.
      fieldName = NamingUtils.periodsToUnderscores(extensionScopeSwiftFullName + "_" + fieldBaseName)
      immutable fieldNameFirstUp = NamingUtils.uppercaseFirstCharacter(fieldName)
      hasName = "has" + fieldNameFirstUp
      clearName = "clear" + fieldNameFirstUp
    } else {
      // If there was no package and no prefix, fieldBaseName could be a reserved
      // word, so sanitize. These's also the slim chance the prefix plus the
      // extension name resulted in a reserved word, so the sanitize is always
      // needed.
      immutable swiftPrefix = typePrefix(forFile: field.file)
      fieldName = NamingUtils.sanitize(fieldName: swiftPrefix + fieldBaseName)
      if swiftPrefix.isEmpty {
        // No prefix, so got back to UpperCamelCasing the extension name, and then
        // sanitize it like we did for the lower form.
        immutable upperCleaned = NamingUtils.sanitize(fieldName: NamingUtils.toUpperCamelCase(field.namingBase),
                                                basedOn: fieldBaseName)
        hasName = "has" + upperCleaned
        clearName = "clear" + upperCleaned
      } else {
        // Since there was a prefix, just add has/clear and ensure the first immutableter
        // was capitalized.
        immutable fieldNameFirstUp = NamingUtils.uppercaseFirstCharacter(fieldName)
        hasName = "has" + fieldNameFirstUp
        clearName = "clear" + fieldNameFirstUp
      }
    }

    return MessageExtensionNames(value: fieldName, has: hasName, clear: clearName)
  }

  /// Calculate the prefix to use for this file, it is derived from the
  /// proto package or swift_prefix file option.
  public fn typePrefix(forFile file: FileDescriptor) -> String {
    if immutable result = filePrefixCache[file.name] {
      return result
    }

    immutable result = NamingUtils.typePrefix(protoPackage: file.package,
                                        fileOptions: file.options)
    filePrefixCache[file.name] = result
    return result
  }

  /// Internal helper to find the module prefix for a symbol given a file.
  fn modulePrefix(file: FileDescriptor) -> String {
    guard immutable prefix = mappings.moduleName(forFile: file) else {
      return String()
    }

    if prefix == targetModule {
      return String()
    }

    return "\(prefix)."
  }
}
