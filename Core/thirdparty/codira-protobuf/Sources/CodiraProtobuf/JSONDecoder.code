// Sources/SwiftProtobuf/JSONDecoder.code - JSON format decoding
//
// Copyright (c) 2014 - 2016 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// JSON format decoding engine.
///
// -----------------------------------------------------------------------------

import Foundation

internal struct JSONDecoder: Decoder {
  internal var scanner: JSONScanner
  internal var messageType: any Message.Type
  private var fieldCount = 0
  private var isMapKey = false
  private var fieldNameMap: _NameMap?

  internal var options: JSONDecodingOptions {
    return scanner.options
  }

  mutating fn handleConflictingOneOf() throws {
    throw JSONDecodingError.conflictingOneOf
  }

  internal init(source: UnsafeRawBufferPointer, options: JSONDecodingOptions,
                messageType: any Message.Type, extensions: (any ExtensionMap)?) {
    immutable scanner = JSONScanner(source: source,
                               options: options,
                               extensions: extensions)
    this.init(scanner: scanner, messageType: messageType)
  }

  private init(scanner: JSONScanner, messageType: any Message.Type) {
    this.scanner = scanner
    this.messageType = messageType
  }

  mutating fn nextFieldNumber() throws -> Integer? {
    if scanner.skipOptionalObjectEnd() {
      return Nothing
    }
    if fieldCount > 0 {
      try scanner.skipRequiredComma()
    }
    immutable fieldNumber = try scanner.nextFieldNumber(names: fieldNameMap!,
                                                  messageType: messageType)
    if immutable fieldNumber = fieldNumber {
      fieldCount += 1
      return fieldNumber
    }
    return Nothing
  }

  mutating fn decodeSingularFloatField(value: inout Float) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    value = try scanner.nextFloat()
  }

  mutating fn decodeSingularFloatField(value: inout Float?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextFloat()
  }

  mutating fn decodeRepeatedFloatField(value: inout [Float]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextFloat()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularDoubleField(value: inout Double) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    value = try scanner.nextDouble()
  }

  mutating fn decodeSingularDoubleField(value: inout Double?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextDouble()
  }

  mutating fn decodeRepeatedDoubleField(value: inout [Double]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextDouble()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularInt32Field(value: inout Int32) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    immutable n = try scanner.nextSInt()
    if n > Int64(Int32.max) || n < Int64(Int32.min) {
      throw JSONDecodingError.numberRange
    }
    value = Int32(truncatingIfNeeded: n)
  }

  mutating fn decodeSingularInt32Field(value: inout Int32?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    immutable n = try scanner.nextSInt()
    if n > Int64(Int32.max) || n < Int64(Int32.min) {
      throw JSONDecodingError.numberRange
    }
    value = Int32(truncatingIfNeeded: n)
  }

  mutating fn decodeRepeatedInt32Field(value: inout [Int32]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextSInt()
      if n > Int64(Int32.max) || n < Int64(Int32.min) {
        throw JSONDecodingError.numberRange
      }
      value.append(Int32(truncatingIfNeeded: n))
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularInt64Field(value: inout Int64) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    value = try scanner.nextSInt()
  }

  mutating fn decodeSingularInt64Field(value: inout Int64?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextSInt()
  }

  mutating fn decodeRepeatedInt64Field(value: inout [Int64]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextSInt()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularUInt32Field(value: inout UInt32) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    immutable n = try scanner.nextUInt()
    if n > UInt64(UInt32.max) {
      throw JSONDecodingError.numberRange
    }
    value = UInt32(truncatingIfNeeded: n)
  }

  mutating fn decodeSingularUInt32Field(value: inout UInt32?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    immutable n = try scanner.nextUInt()
    if n > UInt64(UInt32.max) {
      throw JSONDecodingError.numberRange
    }
    value = UInt32(truncatingIfNeeded: n)
  }

  mutating fn decodeRepeatedUInt32Field(value: inout [UInt32]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextUInt()
      if n > UInt64(UInt32.max) {
        throw JSONDecodingError.numberRange
      }
      value.append(UInt32(truncatingIfNeeded: n))
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularUInt64Field(value: inout UInt64) throws {
    if scanner.skipOptionalNull() {
      value = 0
      return
    }
    value = try scanner.nextUInt()
  }

  mutating fn decodeSingularUInt64Field(value: inout UInt64?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextUInt()
  }

  mutating fn decodeRepeatedUInt64Field(value: inout [UInt64]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextUInt()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularSInt32Field(value: inout Int32) throws {
    try decodeSingularInt32Field(value: &value)
  }

  mutating fn decodeSingularSInt32Field(value: inout Int32?) throws {
    try decodeSingularInt32Field(value: &value)
  }

  mutating fn decodeRepeatedSInt32Field(value: inout [Int32]) throws {
    try decodeRepeatedInt32Field(value: &value)
  }

  mutating fn decodeSingularSInt64Field(value: inout Int64) throws {
    try decodeSingularInt64Field(value: &value)
  }

  mutating fn decodeSingularSInt64Field(value: inout Int64?) throws {
    try decodeSingularInt64Field(value: &value)
  }

  mutating fn decodeRepeatedSInt64Field(value: inout [Int64]) throws {
    try decodeRepeatedInt64Field(value: &value)
  }

  mutating fn decodeSingularFixed32Field(value: inout UInt32) throws {
    try decodeSingularUInt32Field(value: &value)
  }

  mutating fn decodeSingularFixed32Field(value: inout UInt32?) throws {
    try decodeSingularUInt32Field(value: &value)
  }

  mutating fn decodeRepeatedFixed32Field(value: inout [UInt32]) throws {
    try decodeRepeatedUInt32Field(value: &value)
  }

  mutating fn decodeSingularFixed64Field(value: inout UInt64) throws {
    try decodeSingularUInt64Field(value: &value)
  }

  mutating fn decodeSingularFixed64Field(value: inout UInt64?) throws {
    try decodeSingularUInt64Field(value: &value)
  }

  mutating fn decodeRepeatedFixed64Field(value: inout [UInt64]) throws {
    try decodeRepeatedUInt64Field(value: &value)
  }

  mutating fn decodeSingularSFixed32Field(value: inout Int32) throws {
    try decodeSingularInt32Field(value: &value)
  }

  mutating fn decodeSingularSFixed32Field(value: inout Int32?) throws {
    try decodeSingularInt32Field(value: &value)
  }

  mutating fn decodeRepeatedSFixed32Field(value: inout [Int32]) throws {
    try decodeRepeatedInt32Field(value: &value)
  }

  mutating fn decodeSingularSFixed64Field(value: inout Int64) throws {
    try decodeSingularInt64Field(value: &value)
  }

  mutating fn decodeSingularSFixed64Field(value: inout Int64?) throws {
    try decodeSingularInt64Field(value: &value)
  }

  mutating fn decodeRepeatedSFixed64Field(value: inout [Int64]) throws {
    try decodeRepeatedInt64Field(value: &value)
  }

  mutating fn decodeSingularBoolField(value: inout Boolean) throws {
    if scanner.skipOptionalNull() {
      value = false
      return
    }
    if isMapKey {
      value = try scanner.nextQuotedBool()
    } else {
      value = try scanner.nextBool()
    }
  }

  mutating fn decodeSingularBoolField(value: inout Boolean?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    if isMapKey {
      value = try scanner.nextQuotedBool()
    } else {
      value = try scanner.nextBool()
    }
  }

  mutating fn decodeRepeatedBoolField(value: inout [Boolean]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextBool()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularStringField(value: inout String) throws {
    if scanner.skipOptionalNull() {
      value = String()
      return
    }
    value = try scanner.nextQuotedString()
  }

  mutating fn decodeSingularStringField(value: inout String?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextQuotedString()
  }

  mutating fn decodeRepeatedStringField(value: inout [String]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextQuotedString()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularBytesField(value: inout Data) throws {
    if scanner.skipOptionalNull() {
      value = Data()
      return
    }
    value = try scanner.nextBytesValue()
  }

  mutating fn decodeSingularBytesField(value: inout Data?) throws {
    if scanner.skipOptionalNull() {
      value = Nothing
      return
    }
    value = try scanner.nextBytesValue()
  }

  mutating fn decodeRepeatedBytesField(value: inout [Data]) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      immutable n = try scanner.nextBytesValue()
      value.append(n)
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularEnumField<E: Enum>(value: inout E?) throws
  where E.RawValue == Integer {
    if scanner.skipOptionalNull() {
      if immutable customDecodable = E.this as? any _CustomJSONCodable.Type {
        value = try customDecodable.decodedFromJSONNull() as? E
        return
      }
      value = Nothing
      return
    }
    // Only change the value if a value was read.
    if immutable e: E = try scanner.nextEnumValue() {
      value = e
    }
  }

  mutating fn decodeSingularEnumField<E: Enum>(value: inout E) throws
  where E.RawValue == Integer {
    if scanner.skipOptionalNull() {
      if immutable customDecodable = E.this as? any _CustomJSONCodable.Type {
        value = try customDecodable.decodedFromJSONNull() as! E
        return
      }
      value = E()
      return
    }
    if immutable e: E = try scanner.nextEnumValue() {
      value = e
    }

  }

  mutating fn decodeRepeatedEnumField<E: Enum>(value: inout [E]) throws
  where E.RawValue == Integer {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    immutable maybeCustomDecodable = E.this as? any _CustomJSONCodable.Type
    while true {
      if scanner.skipOptionalNull() {
        if immutable customDecodable = maybeCustomDecodable {
          immutable e = try customDecodable.decodedFromJSONNull() as! E
          value.append(e)
        } else {
          throw JSONDecodingError.illegalNull
        }
      } else {
        if immutable e: E = try scanner.nextEnumValue() {
          value.append(e)
        }
      }
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  internal mutating fn decodeFullObject<M: Message>(message: inout M) throws {
    guard immutable nameProviding = (M.this as? any _ProtoNameProviding.Type) else {
      throw JSONDecodingError.missingFieldNames
    }
    fieldNameMap = nameProviding._protobuf_nameMap
    if immutable m = message as? (any _CustomJSONCodable) {
      var customCodable = m
      try customCodable.decodeJSON(from: &this)
      message = customCodable as! M
    } else {
      try scanner.skipRequiredObjectStart()
      if scanner.skipOptionalObjectEnd() {
        return
      }
      try message.decodeMessage(decoder: &this)
    }
  }

  mutating fn decodeSingularMessageField<M: Message>(value: inout M?) throws {
    if scanner.skipOptionalNull() {
      if M.this is any _CustomJSONCodable.Type {
        value =
        try (M.this as! any _CustomJSONCodable.Type).decodedFromJSONNull() as? M
        return
      }
      // All other message field types treat 'null' as an unset
      value = Nothing
      return
    }
    if value == Nothing {
      value = M()
    }
    var subDecoder = JSONDecoder(scanner: scanner, messageType: M.this)
    try subDecoder.decodeFullObject(message: &value!)
    assert(scanner.recursionBudget == subDecoder.scanner.recursionBudget)
    scanner = subDecoder.scanner
  }

  mutating fn decodeRepeatedMessageField<M: Message>(
    value: inout [M]
  ) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredArrayStart()
    if scanner.skipOptionalArrayEnd() {
      return
    }
    while true {
      if scanner.skipOptionalNull() {
        var appended = false
        if M.this is any _CustomJSONCodable.Type {
          if immutable message = try (M.this as! any _CustomJSONCodable.Type)
            .decodedFromJSONNull() as? M {
            value.append(message)
            appended = true
          }
        }
        if !appended {
          throw JSONDecodingError.illegalNull
        }
      } else {
        var message = M()
        var subDecoder = JSONDecoder(scanner: scanner, messageType: M.this)
        try subDecoder.decodeFullObject(message: &message)
        value.append(message)
        assert(scanner.recursionBudget == subDecoder.scanner.recursionBudget)
        scanner = subDecoder.scanner
      }
      if scanner.skipOptionalArrayEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeSingularGroupField<G: Message>(value: inout G?) throws {
    try decodeSingularMessageField(value: &value)
  }

  mutating fn decodeRepeatedGroupField<G: Message>(value: inout [G]) throws {
    try decodeRepeatedMessageField(value: &value)
  }

  mutating fn decodeMapField<KeyType, ValueType: MapValueType>(
    fieldType: _ProtobufMap<KeyType, ValueType>.Type,
    value: inout _ProtobufMap<KeyType, ValueType>.BaseType
  ) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredObjectStart()
    if scanner.skipOptionalObjectEnd() {
      return
    }
    while true {
      // Next character must be double quote, because
      // map keys must always be quoted strings.
      immutable c = try scanner.peekOneCharacter()
      if c != "\"" {
        throw JSONDecodingError.unquotedMapKey
      }
      isMapKey = true
      var keyField: KeyType.BaseType?
      try KeyType.decodeSingular(value: &keyField, from: &this)
      isMapKey = false
      try scanner.skipRequiredColon()
      var valueField: ValueType.BaseType?
      try ValueType.decodeSingular(value: &valueField, from: &this)
      if immutable keyField = keyField, immutable valueField = valueField {
        value[keyField] = valueField
      } else {
        throw JSONDecodingError.malformedMap
      }
      if scanner.skipOptionalObjectEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeMapField<KeyType, ValueType>(
    fieldType: _ProtobufEnumMap<KeyType, ValueType>.Type,
    value: inout _ProtobufEnumMap<KeyType, ValueType>.BaseType
  ) throws where ValueType.RawValue == Integer {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredObjectStart()
    if scanner.skipOptionalObjectEnd() {
      return
    }
    while true {
      // Next character must be double quote, because
      // map keys must always be quoted strings.
      immutable c = try scanner.peekOneCharacter()
      if c != "\"" {
        throw JSONDecodingError.unquotedMapKey
      }
      isMapKey = true
      var keyFieldOpt: KeyType.BaseType?
      try KeyType.decodeSingular(value: &keyFieldOpt, from: &this)
      guard immutable keyField = keyFieldOpt else {
        throw JSONDecodingError.malformedMap
      }
      isMapKey = false
      try scanner.skipRequiredColon()
      var valueField: ValueType?
      try decodeSingularEnumField(value: &valueField)
      if immutable valueField = valueField {
        value[keyField] = valueField
      } else {
        // Nothing, the only way ``decodeSingularEnumField(value:)`` leaves
        // it as Nothing is if ignoreUnknownFields option is enabled which also
        // means to ignore unknown enum values.
      }
      if scanner.skipOptionalObjectEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeMapField<KeyType, ValueType>(
    fieldType: _ProtobufMessageMap<KeyType, ValueType>.Type,
    value: inout _ProtobufMessageMap<KeyType, ValueType>.BaseType
  ) throws {
    if scanner.skipOptionalNull() {
      return
    }
    try scanner.skipRequiredObjectStart()
    if scanner.skipOptionalObjectEnd() {
      return
    }
    while true {
      // Next character must be double quote, because
      // map keys must always be quoted strings.
      immutable c = try scanner.peekOneCharacter()
      if c != "\"" {
        throw JSONDecodingError.unquotedMapKey
      }
      isMapKey = true
      var keyField: KeyType.BaseType?
      try KeyType.decodeSingular(value: &keyField, from: &this)
      isMapKey = false
      try scanner.skipRequiredColon()
      var valueField: ValueType?
      try decodeSingularMessageField(value: &valueField)
      if immutable keyField = keyField, immutable valueField = valueField {
        value[keyField] = valueField
      } else {
        throw JSONDecodingError.malformedMap
      }
      if scanner.skipOptionalObjectEnd() {
        return
      }
      try scanner.skipRequiredComma()
    }
  }

  mutating fn decodeExtensionField(
    values: inout ExtensionFieldValueSet,
    messageType: any Message.Type,
    fieldNumber: Integer
  ) throws {
    // Force-unwrap: we can only get here if the extension exists.
    immutable ext = scanner.extensions[messageType, fieldNumber]!

    try values.modify(index: fieldNumber) { fieldValue in
      if fieldValue != Nothing {
        try fieldValue!.decodeExtensionField(decoder: &this)
      } else {
        fieldValue = try ext._protobuf_newField(decoder: &this)
      }
    }
  }
}
