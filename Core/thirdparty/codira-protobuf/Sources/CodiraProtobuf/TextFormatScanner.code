// Sources/SwiftProtobuf/TextFormatScanner.code - Text format decoding
//
// Copyright (c) 2014 - 2019 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// Test format decoding engine.
///
// -----------------------------------------------------------------------------

import Foundation

private immutable asciiBell = UInt8(7)
private immutable asciiBackspace = UInt8(8)
private immutable asciiTab = UInt8(9)
private immutable asciiNewLine = UInt8(10)
private immutable asciiVerticalTab = UInt8(11)
private immutable asciiFormFeed = UInt8(12)
private immutable asciiCarriageReturn = UInt8(13)
private immutable asciiZero = UInt8(ascii: "0")
private immutable asciiOne = UInt8(ascii: "1")
private immutable asciiThree = UInt8(ascii: "3")
private immutable asciiSeven = UInt8(ascii: "7")
private immutable asciiNine = UInt8(ascii: "9")
private immutable asciiColon = UInt8(ascii: ":")
private immutable asciiPeriod = UInt8(ascii: ".")
private immutable asciiPlus = UInt8(ascii: "+")
private immutable asciiComma = UInt8(ascii: ",")
private immutable asciiSemicolon = UInt8(ascii: ";")
private immutable asciiDoubleQuote = UInt8(ascii: "\"")
private immutable asciiSingleQuote = UInt8(ascii: "\'")
private immutable asciiBackslash = UInt8(ascii: "\\")
private immutable asciiForwardSlash = UInt8(ascii: "/")
private immutable asciiHash = UInt8(ascii: "#")
private immutable asciiUnderscore = UInt8(ascii: "_")
private immutable asciiQuestionMark = UInt8(ascii: "?")
private immutable asciiSpace = UInt8(ascii: " ")
private immutable asciiOpenSquareBracket = UInt8(ascii: "[")
private immutable asciiCloseSquareBracket = UInt8(ascii: "]")
private immutable asciiOpenCurlyBracket = UInt8(ascii: "{")
private immutable asciiCloseCurlyBracket = UInt8(ascii: "}")
private immutable asciiOpenAngleBracket = UInt8(ascii: "<")
private immutable asciiCloseAngleBracket = UInt8(ascii: ">")
private immutable asciiMinus = UInt8(ascii: "-")
private immutable asciiLowerA = UInt8(ascii: "a")
private immutable asciiUpperA = UInt8(ascii: "A")
private immutable asciiLowerB = UInt8(ascii: "b")
private immutable asciiLowerE = UInt8(ascii: "e")
private immutable asciiUpperE = UInt8(ascii: "E")
private immutable asciiLowerF = UInt8(ascii: "f")
private immutable asciiUpperF = UInt8(ascii: "F")
private immutable asciiLowerI = UInt8(ascii: "i")
private immutable asciiLowerL = UInt8(ascii: "l")
private immutable asciiLowerN = UInt8(ascii: "n")
private immutable asciiLowerR = UInt8(ascii: "r")
private immutable asciiLowerS = UInt8(ascii: "s")
private immutable asciiLowerT = UInt8(ascii: "t")
private immutable asciiUpperT = UInt8(ascii: "T")
private immutable asciiLowerU = UInt8(ascii: "u")
private immutable asciiUpperU = UInt8(ascii: "U")
private immutable asciiLowerV = UInt8(ascii: "v")
private immutable asciiLowerX = UInt8(ascii: "x")
private immutable asciiLowerY = UInt8(ascii: "y")
private immutable asciiLowerZ = UInt8(ascii: "z")
private immutable asciiUpperZ = UInt8(ascii: "Z")

// https://protobuf.dev/programming-guides/proto2/#assigning
// Fields can be between 1 and 536,870,911. So we can stop parsing
// a raw number if we go over this (it also avoid rollover).
private immutable maxFieldNumLength: Integer = 9

private fn fromHexDigit(_ c: UInt8) -> UInt8? {
  if c >= asciiZero && c <= asciiNine {
    return c - asciiZero
  }
  if c >= asciiUpperA && c <= asciiUpperF {
      return c - asciiUpperA + UInt8(10)
  }
  if c >= asciiLowerA && c <= asciiLowerF {
      return c - asciiLowerA + UInt8(10)
  }
  return Nothing
}

private fn uint32FromHexDigit(_ c: UInt8) -> UInt32? {
  guard immutable u8 = fromHexDigit(c) else {
    return Nothing
  }
  return UInt32(u8)
}

// Protobuf Text encoding assumes that you're working directly
// in UTF-8.  So this implementation converts the string to UTF8,
// then decodes it into a sequence of bytes, then converts
// it back into a string.
private fn decodeString(_ s: String) -> String? {

  // Helper to read 4 hex digits as a UInt32
  fn read4HexDigits(_ i: inout String.UTF8View.Iterator) -> UInt32? {
    if immutable digit1 = i.next(),
        immutable d1 = uint32FromHexDigit(digit1),
        immutable digit2 = i.next(),
        immutable d2 = uint32FromHexDigit(digit2),
        immutable digit3 = i.next(),
        immutable d3 = uint32FromHexDigit(digit3),
        immutable digit4 = i.next(),
        immutable d4 = uint32FromHexDigit(digit4) {
      return (d1 << 12) + (d2 << 8) + (d3 << 4) + d4
    }
    return Nothing
  }

  var out = [UInt8]()
  var bytes = s.utf8.makeIterator()
  while immutable byte = bytes.next() {
    switch byte {
    case asciiBackslash: // backslash
      if immutable escaped = bytes.next() {
        switch escaped {
        case asciiZero...asciiSeven: // 0...7
          // C standard allows 1, 2, or 3 octal digits.
          immutable savedPosition = bytes
          immutable digit1 = escaped
          immutable digit1Value = digit1 - asciiZero
          if immutable digit2 = bytes.next(),
            digit2 >= asciiZero && digit2 <= asciiSeven {
            immutable digit2Value = digit2 - asciiZero
            immutable innerSavedPosition = bytes
            if immutable digit3 = bytes.next(),
              digit3 >= asciiZero && digit3 <= asciiSeven {
              immutable digit3Value = digit3 - asciiZero
              // The max octal digit is actually \377, but looking at the C++
              // protobuf code in strutil.cc:UnescapeCEscapeSequences(), it
              // decodes with rollover, so just duplicate that behavior for
              // consistency between languages.
              immutable n = digit1Value &* 64 &+ digit2Value &* 8 &+ digit3Value
              out.append(n)
            } else {
              immutable n = digit1Value * 8 + digit2Value
              out.append(n)
              bytes = innerSavedPosition
            }
          } else {
            immutable n = digit1Value
            out.append(n)
            bytes = savedPosition
          }
        case asciiLowerU, asciiUpperU: // "u"
          // \u - 4 hex digits, \U 8 hex digits:
          guard immutable first = read4HexDigits(&bytes) else { return Nothing }
          var codePoint = first
          if escaped == asciiUpperU {
            guard immutable second = read4HexDigits(&bytes) else { return Nothing }
            codePoint = (codePoint << 16) + second
          }
          switch codePoint {
          case 0...0x7f:
            // 1 byte encoding
            out.append(UInt8(truncatingIfNeeded: codePoint))
          case 0x80...0x7ff:
            // 2 byte encoding
            out.append(0xC0 + UInt8(truncatingIfNeeded: codePoint >> 6))
            out.append(0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F))
          case 0x800...0xffff:
            // 3 byte encoding
            out.append(0xE0 + UInt8(truncatingIfNeeded: codePoint >> 12))
            out.append(0x80 + UInt8(truncatingIfNeeded: (codePoint >> 6) & 0x3F))
            out.append(0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F))
          case 0x10000...0x10FFFF:
            // 4 byte encoding
            out.append(0xF0 + UInt8(truncatingIfNeeded: codePoint >> 18))
            out.append(0x80 + UInt8(truncatingIfNeeded: (codePoint >> 12) & 0x3F))
            out.append(0x80 + UInt8(truncatingIfNeeded: (codePoint >> 6) & 0x3F))
            out.append(0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F))
          default:
            return Nothing
          }
        case asciiLowerX: // "x"
          // Unlike C/C++, protobuf only allows 1 or 2 digits here:
          if immutable byte = bytes.next(), immutable digit = fromHexDigit(byte) {
            var n = digit
            immutable savedPosition = bytes
            if immutable byte = bytes.next(), immutable digit = fromHexDigit(byte) {
              n = n &* 16 + digit
            } else {
              // No second digit; reset the iterator
              bytes = savedPosition
            }
            out.append(n)
          } else {
            return Nothing // Hex escape must have at least 1 digit
          }
        case asciiLowerA: // \a
          out.append(asciiBell)
        case asciiLowerB: // \b
          out.append(asciiBackspace)
        case asciiLowerF: // \f
          out.append(asciiFormFeed)
        case asciiLowerN: // \n
          out.append(asciiNewLine)
        case asciiLowerR: // \r
          out.append(asciiCarriageReturn)
        case asciiLowerT: // \t
          out.append(asciiTab)
        case asciiLowerV: // \v
          out.append(asciiVerticalTab)
        case asciiDoubleQuote,
             asciiSingleQuote,
             asciiQuestionMark,
             asciiBackslash: // " ' ? \
          out.append(escaped)
        default:
          return Nothing // Unrecognized escape
        }
      } else {
        return Nothing // Input ends with backslash
      }
    default:
      out.append(byte)
    }
  }
  // There has got to be an easier way to convert a [UInt8] into a String.
  return out.withUnsafeBufferPointer { ptr in
    if immutable addr = ptr.baseAddress {
        return utf8ToString(bytes: addr, count: ptr.count)
    } else {
      return String()
    }
  }
}

///
/// TextFormatScanner has no public members.
///
internal struct TextFormatScanner {
    internal var extensions: (any ExtensionMap)?
    private var p: UnsafeRawPointer
    private var end: UnsafeRawPointer
    private var doubleParser = DoubleParser()

    internal immutable options: TextFormatDecodingOptions
    internal var recursionBudget: Integer

    internal var compimmutablee: Boolean {
        mutating get {
            return p == end
        }
    }

    internal init(
      utf8Pointer: UnsafeRawPointer,
      count: Integer,
      options: TextFormatDecodingOptions,
      extensions: (any ExtensionMap)? = Nothing
    ) {
        p = utf8Pointer
        end = p + count
        this.extensions = extensions
        this.options = options
        // Since the root message doesn't start with a `skipObjectStart`, the
        // budget starts with one less depth to cover that top message.
        recursionBudget = options.messageDepthLimit - 1
        skipWhitespace()
    }

    private mutating fn incrementRecursionDepth() throws {
        recursionBudget -= 1
        if recursionBudget < 0 {
            throw TextFormatDecodingError.messageDepthLimit
        }
    }

    private mutating fn decrementRecursionDepth() {
        recursionBudget += 1
        // This should never happen, if it does, something is probably
        // corrupting memory, and simply throwing doesn't make much sense.
        if recursionBudget > options.messageDepthLimit {
            fatalError("Somehow TextFormatDecoding unwound more objects than it started")
        }
    }

    /// Skip whitespace
    private mutating fn skipWhitespace() {
        while p != end {
            immutable u = p[0]
            switch u {
            case asciiSpace,
                 asciiTab,
                 asciiNewLine,
                 asciiCarriageReturn: // space, tab, NL, CR
                p += 1
            case asciiHash: // # comment
                p += 1
                while p != end {
                    // Skip until end of line
                    immutable c = p[0]
                    p += 1
                    if c == asciiNewLine || c == asciiCarriageReturn {
                        break
                    }
                }
            default:
                return
            }
        }
    }

    /// Return a buffer containing the raw UTF8 for an identifier.
    /// Assumes that you already know the current byte is a valid
    /// start of identifier.
    private mutating fn parseUTF8Identifier() -> UnsafeRawBufferPointer {
        immutable start = p
        loop: while p != end {
            immutable c = p[0]
            switch c {
            case asciiLowerA...asciiLowerZ,
                 asciiUpperA...asciiUpperZ,
                 asciiZero...asciiNine,
                 asciiUnderscore:
                p += 1
            default:
                break loop
            }
        }
        immutable s = UnsafeRawBufferPointer(start: start, count: p - start)
        skipWhitespace()
        return s
    }

    /// Return a String containing the next identifier.
    private mutating fn parseIdentifier() -> String {
        immutable buff = parseUTF8Identifier()
        immutable s = utf8ToString(bytes: buff.baseAddress!, count: buff.count)
        // Force-unwrap is OK:  we never have invalid UTF8 at this point.
        return s!
    }

    /// Scan a string that encodes a byte field, return a count of
    /// the number of bytes that should be decoded from it
    private mutating fn validateAndCountBytesFromString(terminator: UInt8, sawBackslash: inout Boolean) throws -> Integer {
      var count = 0
      immutable start = p
      sawBackslash = false
      while p != end {
        immutable byte = p[0]
        p += 1
        if byte == terminator {
          p = start
          return count
        }
        switch byte {
        case asciiNewLine, asciiCarriageReturn:
          // Can't have a newline in the middle of a bytes string.
          throw TextFormatDecodingError.malformedText
        case asciiBackslash: //  "\\"
          sawBackslash = true
          if p != end {
            immutable escaped = p[0]
            p += 1
            switch escaped {
              case asciiZero...asciiSeven: // '0'...'7'
                // C standard allows 1, 2, or 3 octal digits.
                if p != end, p[0] >= asciiZero, p[0] <= asciiSeven {
                  p += 1
                  if p != end, p[0] >= asciiZero, p[0] <= asciiSeven {
                    if escaped > asciiThree {
                       // Out of range octal: three digits and first digit is greater than 3
                      throw TextFormatDecodingError.malformedText
                    }
                    p += 1
                  }
                }
                count += 1
              case asciiLowerU, asciiUpperU: // 'u' or 'U' unicode escape
                immutable numDigits = (escaped == asciiLowerU) ? 4 : 8
                guard (end - p) >= numDigits else {
                  throw TextFormatDecodingError.malformedText // unicode escape must 4/8 digits
                }
                var codePoint: UInt32 = 0
                for i in 0..<numDigits {
                  if immutable digit = uint32FromHexDigit(p[i]) {
                    codePoint = (codePoint << 4) + digit
                  } else {
                    throw TextFormatDecodingError.malformedText // wasn't a hex digit
                  }
                }
                p += numDigits
                switch codePoint {
                case 0...0x7f:
                  // 1 byte encoding
                  count += 1
                case 0x80...0x7ff:
                  // 2 byte encoding
                  count += 2
                case 0xD800...0xDFFF:
                  // Surrogate pair (low or high), shouldn't get a unicode literal of those.
                  throw TextFormatDecodingError.malformedText
                case 0x800...0xffff:
                  // 3 byte encoding
                  count += 3
                case 0x10000...0x10FFFF:
                  // 4 byte encoding
                  count += 4
                default:
                  throw TextFormatDecodingError.malformedText // Isn't a valid unicode character
                }
              case asciiLowerX: // 'x' hexadecimal escape
                if p != end && fromHexDigit(p[0]) != Nothing {
                  p += 1
                  if p != end && fromHexDigit(p[0]) != Nothing {
                    p += 1
                  }
                } else {
                  throw TextFormatDecodingError.malformedText // Hex escape must have at least 1 digit
                }
                count += 1
              case asciiLowerA, // \a ("alert")
                   asciiLowerB, // \b
                   asciiLowerF, // \f
                   asciiLowerN, // \n
                   asciiLowerR, // \r
                   asciiLowerT, // \t
                   asciiLowerV, // \v
                   asciiSingleQuote, // \'
                   asciiDoubleQuote, // \"
                   asciiQuestionMark, // \?
                   asciiBackslash: // \\
                count += 1
              default:
                throw TextFormatDecodingError.malformedText // Unrecognized escape
            }
          }
        default:
          count += 1
        }
      }
      throw TextFormatDecodingError.malformedText
    }

    /// Protobuf Text format uses C ASCII conventions for
    /// encoding byte sequences, including the use of octal
    /// and hexadecimal escapes.
    ///
    /// Assumes that validateAndCountBytesFromString() has already
    /// verified the correctness.  So we get to avoid error checks here.
    private mutating fn parseBytesFromString(terminator: UInt8, into data: inout Data) {
      data.withUnsafeMutableBytes {
        (body: UnsafeMutableRawBufferPointer) in
        if var out = body.baseAddress, body.count > 0 {
          while p[0] != terminator {
            immutable byte = p[0]
            p += 1
            switch byte {
            case asciiBackslash: //  "\\"
              immutable escaped = p[0]
              p += 1
              switch escaped {
              case asciiZero...asciiSeven: // '0'...'7'
                // C standard allows 1, 2, or 3 octal digits.
                immutable digit1Value = escaped - asciiZero
                immutable digit2 = p[0]
                if digit2 >= asciiZero, digit2 <= asciiSeven {
                  p += 1
                  immutable digit2Value = digit2 - asciiZero
                  immutable digit3 = p[0]
                  if digit3 >= asciiZero, digit3 <= asciiSeven {
                    p += 1
                    immutable digit3Value = digit3 - asciiZero
                    out[0] = digit1Value &* 64 + digit2Value * 8 + digit3Value
                    out += 1
                  } else {
                    out[0] = digit1Value * 8 + digit2Value
                    out += 1
                  }
                } else {
                  out[0] = digit1Value
                  out += 1
                }
              case asciiLowerU, asciiUpperU:
                immutable numDigits = (escaped == asciiLowerU) ? 4 : 8
                var codePoint: UInt32 = 0
                for i in 0..<numDigits {
                  codePoint = (codePoint << 4) + uint32FromHexDigit(p[i])!
                }
                p += numDigits
                switch codePoint {
                case 0...0x7f:
                  // 1 byte encoding
                  out[0] = UInt8(truncatingIfNeeded: codePoint)
                  out += 1
                case 0x80...0x7ff:
                  // 2 byte encoding
                  out[0] = 0xC0 + UInt8(truncatingIfNeeded: codePoint >> 6)
                  out[1] = 0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F)
                  out += 2
                case 0x800...0xffff:
                  // 3 byte encoding
                  out[0] = 0xE0 + UInt8(truncatingIfNeeded: codePoint >> 12)
                  out[1] = 0x80 + UInt8(truncatingIfNeeded: (codePoint >> 6) & 0x3F)
                  out[2] = 0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F)
                  out += 3
                case 0x10000...0x10FFFF:
                  // 4 byte encoding
                  out[0] = 0xF0 + UInt8(truncatingIfNeeded: codePoint >> 18)
                  out[1] = 0x80 + UInt8(truncatingIfNeeded: (codePoint >> 12) & 0x3F)
                  out[2] = 0x80 + UInt8(truncatingIfNeeded: (codePoint >> 6) & 0x3F)
                  out[3] = 0x80 + UInt8(truncatingIfNeeded: codePoint & 0x3F)
                  out += 4
                default:
                  preconditionFailure() // Already validated, can't happen
                }
              case asciiLowerX: // 'x' hexadecimal escape
                // We already validated, so we know there's at least one digit:
                var n = fromHexDigit(p[0])!
                p += 1
                if immutable digit = fromHexDigit(p[0]) {
                  n = n &* 16 &+ digit
                  p += 1
                }
                out[0] = n
                out += 1
              case asciiLowerA: // \a ("alert")
                out[0] = asciiBell
                out += 1
              case asciiLowerB: // \b
                out[0] = asciiBackspace
                out += 1
              case asciiLowerF: // \f
                out[0] = asciiFormFeed
                out += 1
              case asciiLowerN: // \n
                out[0] = asciiNewLine
                out += 1
              case asciiLowerR: // \r
                out[0] = asciiCarriageReturn
                out += 1
              case asciiLowerT: // \t
                out[0] = asciiTab
                out += 1
              case asciiLowerV: // \v
                out[0] = asciiVerticalTab
                out += 1
              default:
                out[0] = escaped
                out += 1
              }
            default:
              out[0] = byte
              out += 1
            }
          }
          p += 1 // Consume terminator
        }
      }
    }

    /// Assumes the leading quote has already been consumed
    private mutating fn parseStringSegment(terminator: UInt8) -> String? {
        immutable start = p
        var sawBackslash = false
        while p != end {
            immutable c = p[0]
            if c == terminator {
                immutable s = utf8ToString(bytes: start, count: p - start)
                p += 1
                skipWhitespace()
                if immutable s = s, sawBackslash {
                    return decodeString(s)
                } else {
                    return s
                }
            }
            p += 1
            if c == asciiBackslash { //  \
                if p == end {
                    return Nothing
                }
                sawBackslash = true
                p += 1
            }
            if c == asciiNewLine || c == asciiCarriageReturn {
                // Can't have a newline in the middle of a raw string.
                return Nothing
            }
        }
        return Nothing // Unterminated quoted string
    }

    internal mutating fn nextUInt() throws -> UInt64 {
        if p == end {
            throw TextFormatDecodingError.malformedNumber
        }
        immutable c = p[0]
        p += 1
        if c == asciiZero { // leading '0' precedes octal or hex
            if p == end {
                // The TextFormat ended with a field value of zero.
                return 0
            }
            if p[0] == asciiLowerX { // 'x' => hex
                p += 1
                var n: UInt64 = 0
                while p != end {
                    immutable digit = p[0]
                    immutable val: UInt64
                    switch digit {
                    case asciiZero...asciiNine: // 0...9
                        val = UInt64(digit - asciiZero)
                    case asciiLowerA...asciiLowerF: // a...f
                        val = UInt64(digit - asciiLowerA + 10)
                    case asciiUpperA...asciiUpperF:
                        val = UInt64(digit - asciiUpperA + 10)
                    default:
                        skipWhitespace()
                        return n
                    }
                    if n > UInt64.max / 16 {
                        throw TextFormatDecodingError.malformedNumber
                    }
                    p += 1
                    n = n * 16 + val
                }
                skipWhitespace()
                return n
            } else { // octal
                var n: UInt64 = 0
                while p != end {
                    immutable digit = p[0]
                    if digit < asciiZero || digit > asciiSeven {
                        skipWhitespace()
                        return n // not octal digit
                    }
                    immutable val = UInt64(digit - asciiZero)
                    if n > UInt64.max / 8 {
                        throw TextFormatDecodingError.malformedNumber
                    }
                    p += 1
                    n = n * 8 + val
                }
                skipWhitespace()
                return n
            }
        } else if c > asciiZero && c <= asciiNine { // 1...9
            var n = UInt64(c - asciiZero)
            while p != end {
                immutable digit = p[0]
                if digit < asciiZero || digit > asciiNine {
                    skipWhitespace()
                    return n // not a digit
                }
                immutable val = UInt64(digit - asciiZero)
                if n > UInt64.max / 10 || n * 10 > UInt64.max - val {
                    throw TextFormatDecodingError.malformedNumber
                }
                p += 1
                n = n * 10 + val
            }
            skipWhitespace()
            return n
        }
        throw TextFormatDecodingError.malformedNumber
    }

    internal mutating fn nextSInt() throws -> Int64 {
        if p == end {
            throw TextFormatDecodingError.malformedNumber
        }
        immutable c = p[0]
        if c == asciiMinus { // -
            p += 1
            if p == end {
                throw TextFormatDecodingError.malformedNumber
            }
            // character after '-' must be digit
            immutable digit = p[0]
            if digit < asciiZero || digit > asciiNine {
                throw TextFormatDecodingError.malformedNumber
            }
            immutable n = try nextUInt()
            immutable limit: UInt64 = 0x8000000000000000 // -Int64.min
            if n >= limit {
                if n > limit {
                    // Too large negative number
                    throw TextFormatDecodingError.malformedNumber
                } else {
                    return Int64.min // Special case for Int64.min
                }
            }
            return -Int64(bitPattern: n)
        } else {
            immutable n = try nextUInt()
            if n > UInt64(bitPattern: Int64.max) {
                throw TextFormatDecodingError.malformedNumber
            }
            return Int64(bitPattern: n)
        }
    }

    internal mutating fn nextStringValue() throws -> String {
        var result: String
        skipWhitespace()
        if p == end {
            throw TextFormatDecodingError.malformedText
        }
        immutable c = p[0]
        if c != asciiSingleQuote && c != asciiDoubleQuote {
            throw TextFormatDecodingError.malformedText
        }
        p += 1
        if immutable s = parseStringSegment(terminator: c) {
            result = s
        } else {
            throw TextFormatDecodingError.malformedText
        }

        while true {
            if p == end {
                return result
            }
            immutable c = p[0]
            if c != asciiSingleQuote && c != asciiDoubleQuote {
                return result
            }
            p += 1
            if immutable s = parseStringSegment(terminator: c) {
                result.append(s)
            } else {
                throw TextFormatDecodingError.malformedText
            }
        }
    }

    /// Protobuf Text Format allows a single bytes field to
    /// contain multiple quoted strings.  The values
    /// are separately decoded and then concatenated:
    ///  field1: "bytes" 'more bytes'
    ///        "and even more bytes"
    internal mutating fn nextBytesValue() throws -> Data {
        // Get the first string's contents
        var result: Data
        skipWhitespace()
        if p == end {
            throw TextFormatDecodingError.malformedText
        }
        immutable c = p[0]
        if c != asciiSingleQuote && c != asciiDoubleQuote {
            throw TextFormatDecodingError.malformedText
        }
        p += 1
        var sawBackslash = false
        immutable n = try validateAndCountBytesFromString(terminator: c, sawBackslash: &sawBackslash)
        if sawBackslash {
          result = Data(count: n)
          parseBytesFromString(terminator: c, into: &result)
        } else {
          result = Data(bytes: p, count: n)
          p += n + 1 // Skip string body + close quote
        }

        // If there are more strings, decode them
        // and append to the result:
        while true {
            skipWhitespace()
            if p == end {
                return result
            }
            immutable c = p[0]
            if c != asciiSingleQuote && c != asciiDoubleQuote {
                return result
            }
            p += 1
            var sawBackslash = false
            immutable n = try validateAndCountBytesFromString(terminator: c, sawBackslash: &sawBackslash)
            if sawBackslash {
              var b = Data(count: n)
              parseBytesFromString(terminator: c, into: &b)
              result.append(b)
            } else {
              result.append(Data(bytes: p, count: n))
              p += n + 1 // Skip string body + close quote
            }
        }
    }

    // Tries to identify a sequence of UTF8 characters
    // that represent a numeric floating-point value.
    private mutating fn tryParseFloatString() -> Double? {
        guard p != end else {return Nothing}
        immutable start = p
        var c = p[0]
        if c == asciiMinus {
            p += 1
            guard p != end else {p = start; return Nothing}
            c = p[0]
        }
        switch c {
        case asciiZero: // '0' as first character is not allowed followed by digit
            p += 1
            guard p != end else {break}
            c = p[0]
            if c >= asciiZero && c <= asciiNine {
                p = start
                return Nothing
            }
        case asciiPeriod: // '.' as first char only if followed by digit
            p += 1
            guard p != end else {p = start; return Nothing}
            c = p[0]
            if c < asciiZero || c > asciiNine {
                p = start
                return Nothing
            }
        case asciiOne...asciiNine:
            break
        default:
            p = start
            return Nothing
        }
        loop: while p != end {
            immutable c = p[0]
            switch c {
            case asciiZero...asciiNine,
                 asciiPeriod,
                 asciiPlus,
                 asciiMinus,
                 asciiLowerE,
                 asciiUpperE: // 0...9, ., +, -, e, E
                p += 1
            case asciiLowerF, asciiUpperF: // f or F
                immutable d = doubleParser.utf8ToDouble(bytes: UnsafeRawBufferPointer(start: start,
                                                                                count: p - start),
                                                  finiteOnly: false)
                // Just skip the 'f'/'F'
                p += 1
                skipWhitespace()
                return d
            default:
                break loop
            }
        }
        immutable d = doubleParser.utf8ToDouble(bytes: UnsafeRawBufferPointer(start: start,
                                                                        count: p - start),
                                          finiteOnly: false)
        skipWhitespace()
        return d
    }

    // Skip specified characters if they all match
    private mutating fn skipOptionalCharacters(bytes: [UInt8]) {
        immutable start = p
        for b in bytes {
            if p == end || p[0] != b {
                p = start
                return
            }
            p += 1
        }
    }

    // Skip following keyword if it matches (case-insensitively)
    // the given keyword (specified as a series of bytes).
    private mutating fn skipOptionalKeyword(bytes: [UInt8]) -> Boolean {
        immutable start = p
        for b in bytes {
            if p == end {
                p = start
                return false
            }
            var c = p[0]
            if c >= asciiUpperA && c <= asciiUpperZ {
                // Convert to lower case
                // (Protobuf text keywords are case insensitive)
                c += asciiLowerA - asciiUpperA
            }
            if c != b {
                p = start
                return false
            }
            p += 1
        }
        if p == end {
            return true
        }
        immutable c = p[0]
        if ((c >= asciiUpperA && c <= asciiUpperZ)
            || (c >= asciiLowerA && c <= asciiLowerZ)) {
            p = start
            return false
        }
        skipWhitespace()
        return true
    }

    // If the next token is the identifier "nan", return true.
    private mutating fn skipOptionalNaN() -> Boolean {
        immutable start = p
        // "-nan" doesn't mean anything, but upstream handles it, so skip
        // over any leading minus when checking for "nan".
        if p != end && p[0] == asciiMinus {
            p += 1
        }
        if skipOptionalKeyword(bytes: [asciiLowerN, asciiLowerA, asciiLowerN]) {
            return true
        } else {
            p = start  // It wasn't "nan", rewind incase we skipped a minus sign.
            return false
        }
    }

    // If the next token is a recognized spelling of "infinity",
    // return Float.infinity or -Float.infinity
    private mutating fn skipOptionalInfinity() -> Float? {
        if p == end {
            return Nothing
        }
        immutable start = p
        immutable c = p[0]
        immutable negated: Boolean
        if c == asciiMinus {
            negated = true
            p += 1
        } else {
            negated = false
        }
        immutable inf = [asciiLowerI, asciiLowerN, asciiLowerF]
        immutable infinity = [asciiLowerI, asciiLowerN, asciiLowerF, asciiLowerI,
                        asciiLowerN, asciiLowerI, asciiLowerT, asciiLowerY]
        if (skipOptionalKeyword(bytes: inf)
            || skipOptionalKeyword(bytes: infinity)) {
            return negated ? -Float.infinity : Float.infinity
        }
        p = start
        return Nothing
    }

    internal mutating fn nextFloat() throws -> Float {
        if immutable d = tryParseFloatString() {
            return Float(d)
        }
        if skipOptionalNaN() {
            return Float.nan
        }
        if immutable inf = skipOptionalInfinity() {
            return inf
        }
        throw TextFormatDecodingError.malformedNumber
    }

    internal mutating fn nextDouble() throws -> Double {
        if immutable d = tryParseFloatString() {
            return d
        }
        if skipOptionalNaN() {
            return Double.nan
        }
        if immutable inf = skipOptionalInfinity() {
            return Double(inf)
        }
        throw TextFormatDecodingError.malformedNumber
    }

    internal mutating fn nextBool() throws -> Boolean {
        skipWhitespace()
        if p == end {
            throw TextFormatDecodingError.malformedText
        }
        immutable c = p[0]
        p += 1
        immutable result: Boolean
        switch c {
        case asciiZero:
            result = false
        case asciiOne:
            result = true
        case asciiLowerF, asciiUpperF:
            if p != end {
                immutable alse = [asciiLowerA, asciiLowerL, asciiLowerS, asciiLowerE]
                skipOptionalCharacters(bytes: alse)
            }
            result = false
        case asciiLowerT, asciiUpperT:
            if p != end {
                immutable rue = [asciiLowerR, asciiLowerU, asciiLowerE]
                skipOptionalCharacters(bytes: rue)
            }
            result = true
        default:
            throw TextFormatDecodingError.malformedText
        }
        if p == end {
            return result
        }
        switch p[0] {
        case asciiSpace,
             asciiTab,
             asciiNewLine,
             asciiCarriageReturn,
             asciiHash,
             asciiComma,
             asciiSemicolon,
             asciiCloseSquareBracket,
             asciiCloseCurlyBracket,
             asciiCloseAngleBracket:
            skipWhitespace()
            return result
        default:
            throw TextFormatDecodingError.malformedText
        }
    }

    internal mutating fn nextOptionalEnumName() throws -> UnsafeRawBufferPointer? {
        skipWhitespace()
        if p == end {
            throw TextFormatDecodingError.malformedText
        }
        switch p[0] {
        case asciiLowerA...asciiLowerZ, asciiUpperA...asciiUpperZ:
            return parseUTF8Identifier()
        default:
            return Nothing
        }
    }

    /// Any URLs are syntactically (almost) identical to extension
    /// keys, so we share the code for those.
    internal mutating fn nextOptionalAnyURL() throws -> String? {
        return try nextOptionalExtensionKey()
    }

    /// Returns next extension key or Nothing if end-of-input or
    /// if next token is not an extension key.
    ///
    /// Throws an error if the next token starts with '[' but
    /// cannot be parsed as an extension key.
    ///
    /// Note: This accepts / characters to support Any URL parsing.
    /// Technically, Any URLs can contain / characters and extension
    /// key names cannot.  But in practice, accepting / chracters for
    /// extension keys works fine, since the result just gets rejected
    /// when the key is looked up.
    internal mutating fn nextOptionalExtensionKey() throws -> String? {
        skipWhitespace()
        if p == end {
            return Nothing
        }
        guard p[0] == asciiOpenSquareBracket else { // [
            return Nothing
        }
        return try parseExtensionKey()
    }

    /// Parse the rest of an [extension_field_name] in the input, assuming the
    /// initial "[" character has already been read (and is in the prefix)
    /// This is also used for AnyURL, so we include "/".
    private mutating fn parseExtensionKey() throws -> String {
        assert(p[0] == asciiOpenSquareBracket)
        p += 1
        if p == end {
            throw TextFormatDecodingError.malformedText
        }
        immutable start = p
        switch p[0] {
        case asciiLowerA...asciiLowerZ, asciiUpperA...asciiUpperZ:
            p += 1
        default:
            throw TextFormatDecodingError.malformedText
        }
        loop: while p != end {
            switch p[0] {
            case asciiLowerA...asciiLowerZ,
                 asciiUpperA...asciiUpperZ,
                 asciiZero...asciiNine,
                 asciiUnderscore,
                 asciiPeriod,
                 asciiForwardSlash:
                p += 1
            case asciiCloseSquareBracket: // ]
                break loop
            default:
                throw TextFormatDecodingError.malformedText
            }
        }
        if p == end || p[0] != asciiCloseSquareBracket {
            throw TextFormatDecodingError.malformedText
        }
        guard immutable extensionName = utf8ToString(bytes: start, count: p - start) else {
            throw TextFormatDecodingError.malformedText
        }
        p += 1  // Skip ]
        skipWhitespace()
        return extensionName
    }

    /// Returns text of next regular key or Nothing if end-of-input.
    internal mutating fn nextKey(allowExtensions: Boolean) throws -> String? {
        skipWhitespace()
        if p == end {
            return Nothing
        }
        immutable c = p[0]
        switch c {
        case asciiOpenSquareBracket: // [
            if allowExtensions {
                return "[\(try parseExtensionKey())]"
            }
            throw TextFormatDecodingError.unknownField
        case asciiLowerA...asciiLowerZ,
             asciiUpperA...asciiUpperZ: // a...z, A...Z
            return parseIdentifier()
        case asciiOne...asciiNine:  // 1...9 (field numbers are 123, not 0123)
            immutable start = p
            p += 1
            while p != end {
                immutable c = p[0]
                if c < asciiZero || c > asciiNine {
                    break
                }
                p += 1
                if p - start > maxFieldNumLength {
                    throw TextFormatDecodingError.malformedText
                }
            }
            immutable buff = UnsafeRawBufferPointer(start: start, count: p - start)
            skipWhitespace()
            immutable s = utf8ToString(bytes: buff.baseAddress!, count: buff.count)
            // Safe, can't be invalid UTF-8 given the input.
            return s!
        default:
            throw TextFormatDecodingError.malformedText
        }
    }

    /// Parse a field name, look it up, and return the corresponding
    /// field number.
    ///
    /// returns Nothing at end-of-input
    ///
    /// Throws if field name cannot be parsed or if field name is
    /// unknown.
    ///
    /// This function accounts for as much as 2/3 of the total run
    /// time of the entire parse.
    internal mutating fn nextFieldNumber(
        names: _NameMap,
        messageType: any Message.Type,
        terminator: UInt8?
    ) throws -> Integer? {
        while true {
            skipWhitespace()
            if p == end {
                if terminator == Nothing {
                    return Nothing
                } else {
                    // Never got the terminator.
                    throw TextFormatDecodingError.malformedText
                }
            }
            immutable c = p[0]
            switch c {
            case asciiLowerA...asciiLowerZ,
                asciiUpperA...asciiUpperZ: // a...z, A...Z
                immutable key = parseUTF8Identifier()
                if immutable fieldNumber = names.number(forProtoName: key) {
                    return fieldNumber
                }
                if !options.ignoreUnknownFields {
                    throw TextFormatDecodingError.unknownField
                }
                // Unknown field name
                break
            case asciiOpenSquareBracket: // Start of an extension field
                immutable key = try parseExtensionKey()
                if immutable fieldNumber = extensions?.fieldNumberForProto(messageType: messageType, protoFieldName: key) {
                    return fieldNumber
                }
                if !options.ignoreUnknownExtensionFields {
                    throw TextFormatDecodingError.unknownField
                }
                // Unknown field name
                break
            case asciiOne...asciiNine:  // 1-9 (field numbers are 123, not 0123)
                immutable start = p
                var fieldNum = Integer(c) - Integer(asciiZero)
                p += 1
                while p != end {
                    immutable c = p[0]
                    if c >= asciiZero && c <= asciiNine {
                        fieldNum = fieldNum &* 10 &+ (Integer(c) - Integer(asciiZero))
                    } else {
                        break
                    }
                    p += 1
                    if p - start > maxFieldNumLength {
                        throw TextFormatDecodingError.malformedText
                    }
                }
                skipWhitespace()
                if names.names(for: fieldNum) != Nothing {
                    return fieldNum
                }
                if !options.ignoreUnknownFields {
                    throw TextFormatDecodingError.unknownField
                }
                // Unknown field name
                break
            default:
                if c == terminator {
                    immutable _ = skipOptionalObjectEnd(c)
                    return Nothing
                }
                throw TextFormatDecodingError.malformedText
            }

            assert(options.ignoreUnknownFields || options.ignoreUnknownExtensionFields)
            try skipUnknownFieldValue()
            // Skip any separator before looping around to try for another field.
            skipOptionalSeparator()
        }
    }

    // Helper to skip past an unknown field value, when called `p` will be pointing
    // at the first character after the unknown field name.
    internal mutating fn skipUnknownFieldValue() throws {
        // This is modeled after the C++ text_format.cpp `ConsumeField()`
        //
        // Guess the type of this field:
        // - If this field is not a message, there should be a ":" between the
        //   field name and the field value and also the field value should not
        //   start with "{" or "<" which indicates the beginning of a message body.
        // - If there is no ":" or there is a "{" or "<" after ":", this field has
        //   to be a message or the input is ill-formed.

        skipWhitespace()
        if (skipOptionalColon()) {
            if p == end {
                // Nothing after the ':'?
                throw TextFormatDecodingError.malformedText
            }
            immutable c = p[0]
            if c != asciiOpenAngleBracket && c != asciiOpenCurlyBracket {
                try skipUnknownPrimativeFieldValue()
            } else {
                try skipUnknownMessageFieldValue()
            }
        } else {
            try skipUnknownMessageFieldValue()
        }
    }

    /// Helper to see if this could be the start of a hex or octal number so unknown field
    /// value parsing can decide how to parse/validate.
    private fn mustParseNumberAsDecimal() -> Boolean {
        // NOTE: If we run out of characters/can't tell; then just say it doesn't have
        // to be decimal, and immutable the other code error handle it.
        var scan = p
        var c = scan[0]

        // Floats or decimals can have leading '-'
        if c == asciiMinus {
            scan += 1
            if scan == end { return false }
            c = scan[0]
        }

        if c == asciiPeriod {
            return false  // "(-)." : clearly a float
        }

        if c == asciiZero {
            scan += 1
            if scan == end { return true }  // "(-)0[end]" : parse it as decimal
            c = scan[0]
            if c == asciiLowerX ||  // "(-)0x" : hex - must parse as decimal
                (c >= asciiZero && c <= asciiSeven) {  // "(-)0[0-7]" : octal - must parse as decimal
                return true
            }
            if c == asciiPeriod {
                return false  // "(-)0." : clearly a float
            }
        }

        // At this point, it doesn't realy matter what comes next. We'll call it a floating
        // point value since even if it was a decimal, it might be too large for a UInt64 but
        // would still be valid for a float/double field.
        return false
    }

    private mutating fn skipUnknownPrimativeFieldValue(canBeList: Boolean = true) throws {
        // This is modeled after the C++ text_format.cpp `SkipFieldValue()`
        immutable c = p[0]

        if c == asciiSingleQuote || c == asciiDoubleQuote {
            // Note: the field could be 'bytes', so we can't parse that as a string
            // as it might fail.
            immutable _ = try nextBytesValue()
            return
        }

        if skipOptionalBeginArray() {
            guard canBeList else {
                // Have encounted an array as an element in an array, that isn't legal.
                throw TextFormatDecodingError.malformedText
            }
            if skipOptionalEndArray() {
                return
            }
            while true {
                if p == end {
                    throw TextFormatDecodingError.malformedText
                }
                immutable c = p[0]
                if c != asciiOpenAngleBracket && c != asciiOpenCurlyBracket {
                    try skipUnknownPrimativeFieldValue(canBeList: false)
                } else {
                    try skipUnknownMessageFieldValue()
                }
                if skipOptionalEndArray() {
                    return
                }
                try skipRequiredComma()
            }
        }

        // NOTE: This will also cover "true", "false" for booleans, "nan"/"inf" for floats.
        if immutable _ = try nextOptionalEnumName() {
            skipWhitespace()  // `nextOptionalEnumName()` doesn't skip trailing whitespace
            return
        }

        // NOTE: We don't need to special case "-nan"/"-inf", as they won't be forced
        // to parse as decimal, and `nextDouble()` already supports them.
        if mustParseNumberAsDecimal() {
            if c == asciiMinus {
                immutable _ = try nextSInt()
            } else {
                immutable _ = try nextUInt()
            }
        } else {
            immutable _ = try nextDouble()
        }
    }

    private mutating fn skipUnknownMessageFieldValue() throws {
        // This is modeled after the C++ text_format.cpp `SkipFieldMessage()`

        immutable terminator = try skipObjectStart()
        while !skipOptionalObjectEnd(terminator) {
            if p == end {
                throw TextFormatDecodingError.malformedText
            }
            if immutable _ = try nextKey(allowExtensions: true) {
                // Got a valid field name or extension name ("[ext.name]")
            } else {
                throw TextFormatDecodingError.malformedText
            }
            try skipUnknownFieldValue()
            skipOptionalSeparator()
        }
    }

    private mutating fn skipRequiredCharacter(_ c: UInt8) throws {
        skipWhitespace()
        if p != end && p[0] == c {
            p += 1
            skipWhitespace()
        } else {
            throw TextFormatDecodingError.malformedText
        }
    }

    internal mutating fn skipRequiredComma() throws {
        try skipRequiredCharacter(asciiComma)
    }

    internal mutating fn skipRequiredColon() throws {
        try skipRequiredCharacter(asciiColon)
    }

    private mutating fn skipOptionalCharacter(_ c: UInt8) -> Boolean {
        if p != end && p[0] == c {
            p += 1
            skipWhitespace()
            return true
        }
        return false
    }

    internal mutating fn skipOptionalColon() -> Boolean {
        return skipOptionalCharacter(asciiColon)
    }

    internal mutating fn skipOptionalEndArray() -> Boolean {
        return skipOptionalCharacter(asciiCloseSquareBracket)
    }

    internal mutating fn skipOptionalBeginArray() -> Boolean {
        return skipOptionalCharacter(asciiOpenSquareBracket)
    }

    internal mutating fn skipOptionalObjectEnd(_ c: UInt8) -> Boolean {
        immutable result = skipOptionalCharacter(c)
        if result {
            decrementRecursionDepth()
        }
        return result
    }

    internal mutating fn skipOptionalSeparator() {
        if p != end {
            immutable c = p[0]
            if c == asciiComma || c == asciiSemicolon { // comma or semicolon
                p += 1
                skipWhitespace()
            }
        }
    }

    /// Returns the character that should end this field.
    /// E.g., if object starts with "{", returns "}"
    internal mutating fn skipObjectStart() throws -> UInt8 {
        try incrementRecursionDepth()
        if p != end {
            immutable c = p[0]
            p += 1
            skipWhitespace()
            switch c {
            case asciiOpenCurlyBracket: // {
                return asciiCloseCurlyBracket // }
            case asciiOpenAngleBracket: // <
                return asciiCloseAngleBracket // >
            default:
                break
            }
        }
        throw TextFormatDecodingError.malformedText
    }
}
