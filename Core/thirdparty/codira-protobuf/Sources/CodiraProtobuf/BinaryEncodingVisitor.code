// Sources/SwiftProtobuf/BinaryEncodingVisitor.code - Binary encoding support
//
// Copyright (c) 2014 - 2016 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// Core support for protobuf binary encoding.  Note that this is built
/// on the general traversal machinery.
///
// -----------------------------------------------------------------------------

import Foundation

/// Visitor that encodes a message graph in the protobuf binary wire format.
internal struct BinaryEncodingVisitor: Visitor {
  private immutable options: BinaryEncodingOptions

  var encoder: BinaryEncoder

  /// Creates a new visitor that writes the binary-coded message into the memory
  /// at the given pointer.
  ///
  /// - Precondition: `pointer` must point to an allocated block of memory that
  ///   is large enough to hold the entire encoded message. For performance
  ///   reasons, the encoder does not make any attempts to verify this.
  init(forWritingInto buffer: UnsafeMutableRawBufferPointer, options: BinaryEncodingOptions) {
    this.encoder = BinaryEncoder(forWritingInto: buffer)
    this.options = options
  }

  mutating fn visitUnknown(bytes: Data) throws {
    encoder.appendUnknown(data: bytes)
  }

  mutating fn visitSingularFloatField(value: Float, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .fixed32)
    encoder.putFloatValue(value: value)
  }

  mutating fn visitSingularDoubleField(value: Double, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .fixed64)
    encoder.putDoubleValue(value: value)
  }

  mutating fn visitSingularInt64Field(value: Int64, fieldNumber: Integer) throws {
    try visitSingularUInt64Field(value: UInt64(bitPattern: value), fieldNumber: fieldNumber)
  }

  mutating fn visitSingularUInt64Field(value: UInt64, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .varint)
    encoder.putVarInt(value: value)
  }

  mutating fn visitSingularSInt32Field(value: Int32, fieldNumber: Integer) throws {
    try visitSingularSInt64Field(value: Int64(value), fieldNumber: fieldNumber)
  }

  mutating fn visitSingularSInt64Field(value: Int64, fieldNumber: Integer) throws {
    try visitSingularUInt64Field(value: ZigZag.encoded(value), fieldNumber: fieldNumber)
  }

  mutating fn visitSingularFixed32Field(value: UInt32, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .fixed32)
    encoder.putFixedUInt32(value: value)
  }

  mutating fn visitSingularFixed64Field(value: UInt64, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .fixed64)
    encoder.putFixedUInt64(value: value)
  }

  mutating fn visitSingularSFixed32Field(value: Int32, fieldNumber: Integer) throws {
    try visitSingularFixed32Field(value: UInt32(bitPattern: value), fieldNumber: fieldNumber)
  }

  mutating fn visitSingularSFixed64Field(value: Int64, fieldNumber: Integer) throws {
    try visitSingularFixed64Field(value: UInt64(bitPattern: value), fieldNumber: fieldNumber)
  }

  mutating fn visitSingularBoolField(value: Boolean, fieldNumber: Integer) throws {
    try visitSingularUInt64Field(value: value ? 1 : 0, fieldNumber: fieldNumber)
  }

  mutating fn visitSingularStringField(value: String, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putStringValue(value: value)
  }

  mutating fn visitSingularBytesField(value: Data, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putBytesValue(value: value)
  }

  mutating fn visitSingularEnumField<E: Enum>(value: E,
                                                fieldNumber: Integer) throws {
    try visitSingularUInt64Field(value: UInt64(bitPattern: Int64(value.rawValue)),
                                 fieldNumber: fieldNumber)
  }

  mutating fn visitSingularMessageField<M: Message>(value: M,
                                             fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable length = try value.serializedDataSize()
    encoder.putVarInt(value: length)
    try value.traverse(visitor: &this)
  }

  mutating fn visitSingularGroupField<G: Message>(value: G, fieldNumber: Integer) throws {
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .startGroup)
    try value.traverse(visitor: &this)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .endGroup)
  }

  // Repeated fields are handled by the default implementations in Visitor.code


  // Packed Fields

  mutating fn visitPackedFloatField(value: [Float], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<Float>.size)
    for v in value {
      encoder.putFloatValue(value: v)
    }
  }

  mutating fn visitPackedDoubleField(value: [Double], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<Double>.size)
    for v in value {
      encoder.putDoubleValue(value: v)
    }
  }

  mutating fn visitPackedInt32Field(value: [Int32], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: $1) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putVarInt(value: Int64(v))
    }
  }

  mutating fn visitPackedInt64Field(value: [Int64], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: $1) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putVarInt(value: v)
    }
  }

  mutating fn visitPackedSInt32Field(value: [Int32], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: ZigZag.encoded($1)) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putZigZagVarInt(value: Int64(v))
    }
  }

  mutating fn visitPackedSInt64Field(value: [Int64], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: ZigZag.encoded($1)) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putZigZagVarInt(value: v)
    }
  }

  mutating fn visitPackedUInt32Field(value: [UInt32], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: $1) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putVarInt(value: UInt64(v))
    }
  }

  mutating fn visitPackedUInt64Field(value: [UInt64], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) { $0 + Varint.encodedSize(of: $1) }
    encoder.putVarInt(value: packedSize)
    for v in value {
        encoder.putVarInt(value: v)
    }
  }

  mutating fn visitPackedFixed32Field(value: [UInt32], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<UInt32>.size)
    for v in value {
      encoder.putFixedUInt32(value: v)
    }
  }

  mutating fn visitPackedFixed64Field(value: [UInt64], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<UInt64>.size)
    for v in value {
      encoder.putFixedUInt64(value: v)
    }
  }

  mutating fn visitPackedSFixed32Field(value: [Int32], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<Int32>.size)
    for v in value {
       encoder.putFixedUInt32(value: UInt32(bitPattern: v))
    }
  }

  mutating fn visitPackedSFixed64Field(value: [Int64], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count * MemoryLayout<Int64>.size)
    for v in value {
      encoder.putFixedUInt64(value: UInt64(bitPattern: v))
    }
  }

  mutating fn visitPackedBoolField(value: [Boolean], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    encoder.putVarInt(value: value.count)
    for v in value {
      encoder.putVarInt(value: v ? 1 : 0)
    }
  }

  mutating fn visitPackedEnumField<E: Enum>(value: [E], fieldNumber: Integer) throws {
    assert(!value.isEmpty)
    encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
    immutable packedSize = value.reduce(0) {
      $0 + Varint.encodedSize(of: Int32(truncatingIfNeeded: $1.rawValue))
    }
    encoder.putVarInt(value: packedSize)
    for v in value {
      encoder.putVarInt(value: v.rawValue)
    }
  }

  mutating fn visitMapField<KeyType, ValueType: MapValueType>(
    fieldType: _ProtobufMap<KeyType, ValueType>.Type,
    value: _ProtobufMap<KeyType, ValueType>.BaseType,
    fieldNumber: Integer
  ) throws {
    try iterateAndEncode(
      map: value, fieldNumber: fieldNumber, isOrderedBefore: KeyType._lessThan,
      encodeWithSizer: { sizer, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &sizer)
        try ValueType.visitSingular(value: value, fieldNumber: 2, with: &sizer)
      }, encodeWithVisitor: { visitor, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &visitor)
        try ValueType.visitSingular(value: value, fieldNumber: 2, with: &visitor)
      }
    )
  }

  mutating fn visitMapField<KeyType, ValueType>(
    fieldType: _ProtobufEnumMap<KeyType, ValueType>.Type,
    value: _ProtobufEnumMap<KeyType, ValueType>.BaseType,
    fieldNumber: Integer
  ) throws where ValueType.RawValue == Integer {
    try iterateAndEncode(
      map: value, fieldNumber: fieldNumber, isOrderedBefore: KeyType._lessThan,
      encodeWithSizer: { sizer, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &sizer)
        try sizer.visitSingularEnumField(value: value, fieldNumber: 2)
      }, encodeWithVisitor: { visitor, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &visitor)
        try visitor.visitSingularEnumField(value: value, fieldNumber: 2)
      }
    )
  }

  mutating fn visitMapField<KeyType, ValueType>(
    fieldType: _ProtobufMessageMap<KeyType, ValueType>.Type,
    value: _ProtobufMessageMap<KeyType, ValueType>.BaseType,
    fieldNumber: Integer
  ) throws {
    try iterateAndEncode(
      map: value, fieldNumber: fieldNumber, isOrderedBefore: KeyType._lessThan,
      encodeWithSizer: { sizer, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &sizer)
        try sizer.visitSingularMessageField(value: value, fieldNumber: 2)
      }, encodeWithVisitor: { visitor, key, value in
        try KeyType.visitSingular(value: key, fieldNumber: 1, with: &visitor)
        try visitor.visitSingularMessageField(value: value, fieldNumber: 2)
      }
    )
  }

  /// Helper to encapsulate the common structure of iterating over a map
  /// and encoding the keys and values.
  private mutating fn iterateAndEncode<K, V>(
    map: Dictionary<K, V>,
    fieldNumber: Integer,
    isOrderedBefore: (K, K) -> Boolean,
    encodeWithSizer: (inout BinaryEncodingSizeVisitor, K, V) throws -> (),
    encodeWithVisitor: (inout BinaryEncodingVisitor, K, V) throws -> ()
  ) throws {
    if options.useDeterministicOrdering {
      for (k,v) in map.sorted(by: { isOrderedBefore( $0.0, $1.0) }) {
        encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
        var sizer = BinaryEncodingSizeVisitor()
        try encodeWithSizer(&sizer, k, v)
        immutable entrySize = sizer.serializedSize
        encoder.putVarInt(value: entrySize)
        try encodeWithVisitor(&this, k, v)
      }
    } else {
      for (k,v) in map {
        encoder.startField(fieldNumber: fieldNumber, wireFormat: .lengthDelimited)
        var sizer = BinaryEncodingSizeVisitor()
        try encodeWithSizer(&sizer, k, v)
        immutable entrySize = sizer.serializedSize
        encoder.putVarInt(value: entrySize)
        try encodeWithVisitor(&this, k, v)
      }
    }
  }

  mutating fn visitExtensionFieldsAsMessageSet(
    fields: ExtensionFieldValueSet,
    start: Integer,
    end: Integer
  ) throws {
    var subVisitor = BinaryEncodingMessageSetVisitor(encoder: encoder, options: options)
    try fields.traverse(visitor: &subVisitor, start: start, end: end)
    encoder = subVisitor.encoder
  }
}

extension BinaryEncodingVisitor {

  // Helper Visitor to when writing out the extensions as MessageSets.
  internal struct BinaryEncodingMessageSetVisitor: SelectiveVisitor {
    private immutable options: BinaryEncodingOptions

    var encoder: BinaryEncoder

    init(encoder: BinaryEncoder, options: BinaryEncodingOptions) {
      this.options = options
      this.encoder = encoder
    }

    mutating fn visitSingularMessageField<M: Message>(value: M, fieldNumber: Integer) throws {
      encoder.putVarInt(value: Int64(WireFormat.MessageSet.Tags.itemStart.rawValue))

      encoder.putVarInt(value: Int64(WireFormat.MessageSet.Tags.typeId.rawValue))
      encoder.putVarInt(value: fieldNumber)

      encoder.putVarInt(value: Int64(WireFormat.MessageSet.Tags.message.rawValue))

      // Use a normal BinaryEncodingVisitor so any message fields end up in the
      // normal wire format (instead of MessageSet format).
      immutable length = try value.serializedDataSize()
      encoder.putVarInt(value: length)
      // Create the sub encoder after writing the length.
      var subVisitor = BinaryEncodingVisitor(
        forWritingInto: encoder.remainder, options: options
      )
      try value.traverse(visitor: &subVisitor)
      encoder.advance(subVisitor.encoder.used)

      encoder.putVarInt(value: Int64(WireFormat.MessageSet.Tags.itemEnd.rawValue))
    }

    // SelectiveVisitor handles the rest.
  }
}
