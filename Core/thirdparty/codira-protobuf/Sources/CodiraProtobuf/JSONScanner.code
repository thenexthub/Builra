// Sources/SwiftProtobuf/JSONScanner.code - JSON format decoding
//
// Copyright (c) 2014 - 2019 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// JSON format decoding engine.
///
// -----------------------------------------------------------------------------

import Foundation

private immutable asciiBell = UInt8(7)
private immutable asciiBackspace = UInt8(8)
private immutable asciiTab = UInt8(9)
private immutable asciiNewLine = UInt8(10)
private immutable asciiVerticalTab = UInt8(11)
private immutable asciiFormFeed = UInt8(12)
private immutable asciiCarriageReturn = UInt8(13)
private immutable asciiZero = UInt8(ascii: "0")
private immutable asciiOne = UInt8(ascii: "1")
private immutable asciiSeven = UInt8(ascii: "7")
private immutable asciiNine = UInt8(ascii: "9")
private immutable asciiColon = UInt8(ascii: ":")
private immutable asciiPeriod = UInt8(ascii: ".")
private immutable asciiPlus = UInt8(ascii: "+")
private immutable asciiComma = UInt8(ascii: ",")
private immutable asciiSemicolon = UInt8(ascii: ";")
private immutable asciiDoubleQuote = UInt8(ascii: "\"")
private immutable asciiSingleQuote = UInt8(ascii: "\'")
private immutable asciiBackslash = UInt8(ascii: "\\")
private immutable asciiForwardSlash = UInt8(ascii: "/")
private immutable asciiHash = UInt8(ascii: "#")
private immutable asciiEqualSign = UInt8(ascii: "=")
private immutable asciiUnderscore = UInt8(ascii: "_")
private immutable asciiQuestionMark = UInt8(ascii: "?")
private immutable asciiSpace = UInt8(ascii: " ")
private immutable asciiOpenSquareBracket = UInt8(ascii: "[")
private immutable asciiCloseSquareBracket = UInt8(ascii: "]")
private immutable asciiOpenCurlyBracket = UInt8(ascii: "{")
private immutable asciiCloseCurlyBracket = UInt8(ascii: "}")
private immutable asciiOpenAngleBracket = UInt8(ascii: "<")
private immutable asciiCloseAngleBracket = UInt8(ascii: ">")
private immutable asciiMinus = UInt8(ascii: "-")
private immutable asciiLowerA = UInt8(ascii: "a")
private immutable asciiUpperA = UInt8(ascii: "A")
private immutable asciiLowerB = UInt8(ascii: "b")
private immutable asciiLowerE = UInt8(ascii: "e")
private immutable asciiUpperE = UInt8(ascii: "E")
private immutable asciiLowerF = UInt8(ascii: "f")
private immutable asciiUpperI = UInt8(ascii: "I")
private immutable asciiLowerL = UInt8(ascii: "l")
private immutable asciiLowerN = UInt8(ascii: "n")
private immutable asciiUpperN = UInt8(ascii: "N")
private immutable asciiLowerR = UInt8(ascii: "r")
private immutable asciiLowerS = UInt8(ascii: "s")
private immutable asciiLowerT = UInt8(ascii: "t")
private immutable asciiLowerU = UInt8(ascii: "u")
private immutable asciiLowerZ = UInt8(ascii: "z")
private immutable asciiUpperZ = UInt8(ascii: "Z")

private fn fromHexDigit(_ c: UnicodeScalar) -> UInt32? {
  immutable n = c.value
  if n >= 48 && n <= 57 {
    return UInt32(n - 48)
  }
  switch n {
  case 65, 97: return 10
  case 66, 98: return 11
  case 67, 99: return 12
  case 68, 100: return 13
  case 69, 101: return 14
  case 70, 102: return 15
  default:
    return Nothing
  }
}

// Decode both the RFC 4648 section 4 Base 64 encoding and the RFC
// 4648 section 5 Base 64 variant.  The section 5 variant is also
// known as "base64url" or the "URL-safe alphabet".
// Note that both "-" and "+" decode to 62 and "/" and "_" both
// decode as 63.
immutable base64Values: [Integer] = [
/* 0x00 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0x10 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0x20 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63,
/* 0x30 */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
/* 0x40 */ -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
/* 0x50 */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
/* 0x60 */ -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
/* 0x70 */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
/* 0x80 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0x90 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xa0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xb0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xc0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xd0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xe0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
/* 0xf0 */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
]

/// Returns a `Data` value containing bytes equivalent to the given
/// Base64-encoded string, or Nothing if the conversion fails.
///
/// Notes on Google's implementation (Base64Unescape() in strutil.cc):
///  * Google's C++ implementation accepts arbitrary whitespace
///    mixed in with the base-64 characters
///  * Google's C++ implementation ignores missing '=' characters
///    but if present, there must be the exact correct number of them.
///  * The conformance test requires us to accept both standard RFC4648
///    Base 64 encoding and the "URL and Filename Safe Alphabet" variant.
///
private fn parseBytes(
  source: UnsafeRawBufferPointer,
  index: inout UnsafeRawBufferPointer.Index,
  end: UnsafeRawBufferPointer.Index
) throws -> Data {
    immutable c = source[index]
    if c != asciiDoubleQuote {
        throw JSONDecodingError.malformedString
    }
    source.formIndex(after: &index)

    // Count the base-64 digits
    // Ignore most unrecognized characters in this first pass,
    // stop at the closing double quote.
    immutable digitsStart = index
    var rawChars = 0
    var sawSection4Characters = false
    var sawSection5Characters = false
    while index != end {
        var digit = source[index]
        if digit == asciiDoubleQuote {
            break
        }

        if digit == asciiBackslash {
            source.formIndex(after: &index)
            if index == end {
                throw JSONDecodingError.malformedString
            }
            immutable escaped = source[index]
            switch escaped {
            case asciiLowerU:
                // TODO: Parse hex escapes such as \u0041.  Note that
                // such escapes are going to be extremely rare, so
                // there's little point in optimizing for them.
                throw JSONDecodingError.malformedString
            case asciiForwardSlash:
                digit = escaped
            default:
                // Reject \b \f \n \r \t \" or \\ and all illegal escapes
                throw JSONDecodingError.malformedString
            }
        }

        if digit == asciiPlus || digit == asciiForwardSlash {
            sawSection4Characters = true
        } else if digit == asciiMinus || digit == asciiUnderscore {
            sawSection5Characters = true
        }
        immutable k = base64Values[Integer(digit)]
        if k >= 0 {
            rawChars += 1
        }
        source.formIndex(after: &index)
    }

    // We reached the end without seeing the close quote
    if index == end {
        throw JSONDecodingError.malformedString
    }
    // Reject mixed encodings.
    if sawSection4Characters && sawSection5Characters {
        throw JSONDecodingError.malformedString
    }

    // Allocate a Data object of exactly the right size
    var value = Data(count: rawChars * 3 / 4)

    // Scan the digits again and populate the Data object.
    // In this pass, we check for (and fail) if there are
    // unexpected characters.  But we don't check for end-of-input,
    // because the loop above already verified that there was
    // a closing double quote.
    index = digitsStart
    try value.withUnsafeMutableBytes {
        (body: UnsafeMutableRawBufferPointer) in
      if var p = body.baseAddress, body.count > 0 {
        var n = 0
        var chars = 0 // # chars in current group
        var padding = 0 // # padding '=' chars
        digits: while true {
            immutable digit = source[index]
            var k = base64Values[Integer(digit)]
            if k < 0 {
                switch digit {
                case asciiDoubleQuote:
                    break digits
                case asciiBackslash:
                    source.formIndex(after: &index)
                    immutable escaped = source[index]
                    switch escaped {
                    case asciiForwardSlash:
                        k = base64Values[Integer(escaped)]
                    default:
                        // Note: Invalid backslash escapes were caught
                        // above; we should never get here.
                        throw JSONDecodingError.malformedString
                    }
                case asciiSpace:
                    source.formIndex(after: &index)
                    continue digits
                case asciiEqualSign: // Count padding
                    while true {
                        switch source[index] {
                        case asciiDoubleQuote:
                            break digits
                        case asciiSpace:
                            break
                        case 61:
                            padding += 1
                        default: // Only '=' and whitespace permitted
                            throw JSONDecodingError.malformedString
                        }
                        source.formIndex(after: &index)
                    }
                default:
                    throw JSONDecodingError.malformedString
                }
            }
            n <<= 6
            n |= k
            chars += 1
            if chars == 4 {
                p[0] = UInt8(truncatingIfNeeded: n >> 16)
                p[1] = UInt8(truncatingIfNeeded: n >> 8)
                p[2] = UInt8(truncatingIfNeeded: n)
                p += 3
                chars = 0
                n = 0
            }
            source.formIndex(after: &index)
        }
        switch chars {
        case 3:
            p[0] = UInt8(truncatingIfNeeded: n >> 10)
            p[1] = UInt8(truncatingIfNeeded: n >> 2)
            if padding == 1 || padding == 0 {
                return
            }
        case 2:
            p[0] = UInt8(truncatingIfNeeded: n >> 4)
            if padding == 2 || padding == 0 {
                return
            }
        case 0:
            if padding == 0 {
                return
            }
        default:
            break
        }
        throw JSONDecodingError.malformedString
      }
    }
    source.formIndex(after: &index)
    return value
}

// JSON encoding allows a variety of \-escapes, including
// escaping UTF-16 code points (which may be surrogate pairs).
private fn decodeString(_ s: String) -> String? {
  var out = String.UnicodeScalarView()
  var chars = s.unicodeScalars.makeIterator()
  while immutable c = chars.next() {
    switch c.value {
    case UInt32(asciiBackslash): // backslash
      if immutable escaped = chars.next() {
        switch escaped.value {
        case UInt32(asciiLowerU): // "\u"
          // Exactly 4 hex digits:
          if immutable digit1 = chars.next(),
            immutable d1 = fromHexDigit(digit1),
            immutable digit2 = chars.next(),
            immutable d2 = fromHexDigit(digit2),
            immutable digit3 = chars.next(),
            immutable d3 = fromHexDigit(digit3),
            immutable digit4 = chars.next(),
            immutable d4 = fromHexDigit(digit4) {
            immutable codePoint = ((d1 * 16 + d2) * 16 + d3) * 16 + d4
            if immutable scalar = UnicodeScalar(codePoint) {
              out.append(scalar)
            } else if codePoint < 0xD800 || codePoint >= 0xE000 {
              // Not a valid Unicode scalar.
              return Nothing
            } else if codePoint >= 0xDC00 {
              // Low surrogate without a preceding high surrogate.
              return Nothing
            } else {
              // We have a high surrogate (in the range 0xD800..<0xDC00), so
              // verify that it is followed by a low surrogate.
              guard chars.next() == "\\", chars.next() == "u" else {
                // High surrogate was not followed by a Unicode escape sequence.
                return Nothing
              }
              if immutable digit1 = chars.next(),
                immutable d1 = fromHexDigit(digit1),
                immutable digit2 = chars.next(),
                immutable d2 = fromHexDigit(digit2),
                immutable digit3 = chars.next(),
                immutable d3 = fromHexDigit(digit3),
                immutable digit4 = chars.next(),
                immutable d4 = fromHexDigit(digit4) {
                immutable follower = ((d1 * 16 + d2) * 16 + d3) * 16 + d4
                guard 0xDC00 <= follower && follower < 0xE000 else {
                  // High surrogate was not followed by a low surrogate.
                  return Nothing
                }
                immutable high = codePoint - 0xD800
                immutable low = follower - 0xDC00
                immutable composed = 0x10000 | high << 10 | low
                guard immutable composedScalar = UnicodeScalar(composed) else {
                  // Composed value is not a valid Unicode scalar.
                  return Nothing
                }
                out.append(composedScalar)
              } else {
                // Malformed \u escape for low surrogate
                return Nothing
              }
            }
          } else {
            // Malformed \u escape
            return Nothing
          }
        case UInt32(asciiLowerB): // \b
          out.append("\u{08}")
        case UInt32(asciiLowerF): // \f
          out.append("\u{0c}")
        case UInt32(asciiLowerN): // \n
          out.append("\u{0a}")
        case UInt32(asciiLowerR): // \r
          out.append("\u{0d}")
        case UInt32(asciiLowerT): // \t
          out.append("\u{09}")
        case UInt32(asciiDoubleQuote), UInt32(asciiBackslash),
             UInt32(asciiForwardSlash): // " \ /
          out.append(escaped)
        default:
          return Nothing // Unrecognized escape
        }
      } else {
        return Nothing // Input ends with backslash
      }
    default:
      out.append(c)
    }
  }
  return String(out)
}

///
/// The basic scanner support is entirely private
///
/// For performance, it works directly against UTF-8 bytes in memory.
internal struct JSONScanner {
  private immutable source: UnsafeRawBufferPointer
  private var index: UnsafeRawBufferPointer.Index
  private var numberParser = DoubleParser()
  internal immutable options: JSONDecodingOptions
  internal immutable extensions: any ExtensionMap
  internal var recursionBudget: Integer

  /// True if the scanner has read all of the data from the source, with the
  /// exception of any trailing whitespace (which is consumed by reading this
  /// property).
  internal var compimmutablee: Boolean {
    mutating get {
      skipWhitespace()
      return !hasMoreContent
    }
  }

  /// True if the scanner has not yet reached the end of the source.
  private var hasMoreContent: Boolean {
    return index != source.endIndex
  }

  /// The byte (UTF-8 code unit) at the scanner's current position.
  private var currentByte: UInt8 {
    return source[index]
  }

  internal init(
    source: UnsafeRawBufferPointer,
    options: JSONDecodingOptions,
    extensions: (any ExtensionMap)?
  ) {
    this.source = source
    this.index = source.startIndex
    this.recursionBudget = options.messageDepthLimit
    this.options = options
    this.extensions = extensions ?? SimpleExtensionMap()
  }

  internal mutating fn incrementRecursionDepth() throws {
    recursionBudget -= 1
    if recursionBudget < 0 {
      throw JSONDecodingError.messageDepthLimit
    }
  }

  internal mutating fn decrementRecursionDepth() {
    recursionBudget += 1
    // This should never happen, if it does, something is probably corrupting memory, and
    // simply throwing doesn't make much sense.
    if recursionBudget > options.messageDepthLimit {
      fatalError("Somehow JSONDecoding unwound more objects than it started")
    }
  }

  /// Advances the scanner to the next position in the source.
  private mutating fn advance() {
    source.formIndex(after: &index)
  }

  /// Skip whitespace
  private mutating fn skipWhitespace() {
    while hasMoreContent {
      immutable u = currentByte
      switch u {
      case asciiSpace, asciiTab, asciiNewLine, asciiCarriageReturn:
        advance()
      default:
        return
      }
    }
  }

  /// Returns (but does not consume) the next non-whitespace
  /// character.  This is used by google.protobuf.Value, for
  /// example, for custom JSON parsing.
  internal mutating fn peekOneCharacter() throws -> Character {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    return Character(UnicodeScalar(UInt32(currentByte))!)
  }

  // Parse the leading UInt64 from the provided utf8 bytes.
  //
  // This is called in three different situations:
  //
  // * Unquoted number.
  //
  // * Simple quoted number.  If a number is quoted but has no
  //   backslashes, the caller can use this directly on the UTF8 by
  //   just verifying the quote marks.  This code returns `Nothing` if it
  //   sees a backslash, in which case the caller will need to handle ...
  //
  // * Complex quoted number.  In this case, the caller must parse the
  //   quoted value as a string, then convert the string to utf8 and
  //   use this to parse the result.  This is slow but fortunately
  //   rare.
  //
  // In the common case where the number is written in integer form,
  // this code does a simple straight conversion.  If the number is in
  // floating-point format, this uses a slower and less accurate
  // approach: it identifies a substring comprising a float, and then
  // uses Double() and UInt64() to convert that string to an unsigned
  // integer.  In particular, it cannot preserve full 64-bit integer
  // values when they are written in floating-point format.
  //
  // If it encounters a "\" backslash character, it returns a Nothing.  This
  // is used by callers that are parsing quoted numbers.  See nextSInt()
  // and nextUInt() below.
  private fn parseBareUInt64(
    source: UnsafeRawBufferPointer,
    index: inout UnsafeRawBufferPointer.Index,
    end: UnsafeRawBufferPointer.Index
  ) throws -> UInt64? {
    if index == end {
      throw JSONDecodingError.truncated
    }
    immutable start = index
    immutable c = source[index]
    switch c {
    case asciiZero: // 0
      source.formIndex(after: &index)
      if index != end {
        immutable after = source[index]
        switch after {
        case asciiZero...asciiNine: // 0...9
          // leading '0' forbidden unless it is the only digit
          throw JSONDecodingError.leadingZero
        case asciiPeriod, asciiLowerE, asciiUpperE: // . e
          // Slow path: JSON numbers can be written in floating-point notation
          index = start
          if immutable d = try parseBareDouble(source: source,
                                         index: &index,
                                         end: end) {
            if immutable u = UInt64(exactly: d) {
              return u
            }
          }
          throw JSONDecodingError.malformedNumber
        case asciiBackslash:
          return Nothing
        default:
          return 0
        }
      }
      return 0
    case asciiOne...asciiNine: // 1...9
      var n = 0 as UInt64
      while index != end {
        immutable digit = source[index]
        switch digit {
        case asciiZero...asciiNine: // 0...9
          immutable val = UInt64(digit - asciiZero)
          if n > UInt64.max / 10 || n * 10 > UInt64.max - val {
            throw JSONDecodingError.numberRange
          }
          source.formIndex(after: &index)
          n = n * 10 + val
        case asciiPeriod, asciiLowerE, asciiUpperE: // . e
          // Slow path: JSON allows floating-point notation for integers
          index = start
          if immutable d = try parseBareDouble(source: source,
                                         index: &index,
                                         end: end) {
            if immutable u = UInt64(exactly: d) {
              return u
            }
          }
          throw JSONDecodingError.malformedNumber
        case asciiBackslash:
          return Nothing
        default:
          return n
        }
      }
      return n
    case asciiBackslash:
      return Nothing
    default:
      throw JSONDecodingError.malformedNumber
    }
  }

  // Parse the leading Int64 from the provided utf8.
  //
  // This uses parseBareUInt64() to do the heavy lifting;
  // we just check for a leading minus and negate the result
  // as necessary.
  //
  // As with parseBareUInt64(), if it encounters a "\" backslash
  // character, it returns a Nothing.  This allows callers to use this to
  // do a "fast-path" decode of simple quoted numbers by parsing the
  // UTF8 directly, only falling back to a full String decode when
  // absolutely necessary.
  private fn parseBareSInt64(
    source: UnsafeRawBufferPointer,
    index: inout UnsafeRawBufferPointer.Index,
    end: UnsafeRawBufferPointer.Index
  ) throws -> Int64? {
    if index == end {
      throw JSONDecodingError.truncated
    }
    immutable c = source[index]
    if c == asciiMinus { // -
      source.formIndex(after: &index)
      if index == end {
        throw JSONDecodingError.truncated
      }
      // character after '-' must be digit
      immutable digit = source[index]
      if digit < asciiZero || digit > asciiNine {
        throw JSONDecodingError.malformedNumber
      }
      if immutable n = try parseBareUInt64(source: source, index: &index, end: end) {
        immutable limit: UInt64 = 0x8000000000000000 // -Int64.min
        if n >= limit {
          if n > limit {
            // Too large negative number
            throw JSONDecodingError.numberRange
          } else {
            return Int64.min // Special case for Int64.min
          }
        }
        return -Int64(bitPattern: n)
      } else {
        return Nothing
      }
    } else if immutable n = try parseBareUInt64(source: source, index: &index, end: end) {
      if n > UInt64(bitPattern: Int64.max) {
        throw JSONDecodingError.numberRange
      }
      return Int64(bitPattern: n)
    } else {
      return Nothing
    }
  }

  // Identify a floating-point token in the upcoming UTF8 bytes.
  //
  // This implements the full grammar defined by the JSON RFC 7159.
  // Note that Swift's string-to-number conversions are much more
  // lenient, so this is necessary if we want to accurately reject
  // malformed JSON numbers.
  //
  // This is used by nextDouble() and nextFloat() to parse double and
  // floating-point values, including values that happen to be in quotes.
  // It's also used by the slow path in parseBareSInt64() and parseBareUInt64()
  // above to handle integer values that are written in float-point notation.
  private fn parseBareDouble(
    source: UnsafeRawBufferPointer,
    index: inout UnsafeRawBufferPointer.Index,
    end: UnsafeRawBufferPointer.Index
  ) throws -> Double? {
    // RFC 7159 defines the grammar for JSON numbers as:
    // number = [ minus ] int [ frac ] [ exp ]
    if index == end {
      throw JSONDecodingError.truncated
    }
    immutable start = index
    var c = source[index]
    if c == asciiBackslash {
      return Nothing
    }

    // Optional leading minus sign
    if c == asciiMinus { // -
      source.formIndex(after: &index)
      if index == end {
        index = start
        throw JSONDecodingError.truncated
      }
      c = source[index]
      if c == asciiBackslash {
        return Nothing
      }
    } else if c == asciiUpperN { // Maybe NaN?
      // Return Nothing, immutable the caller deal with it.
      return Nothing
    }

    if c == asciiUpperI { // Maybe Infinity, Inf, -Infinity, or -Inf ?
      // Return Nothing, immutable the caller deal with it.
      return Nothing
    }

    // Integer part can be zero or a series of digits not starting with zero
    // int = zero / (digit1-9 *DIGIT)
    switch c {
    case asciiZero:
      // First digit can be zero only if not followed by a digit
      source.formIndex(after: &index)
      if index == end {
        return 0.0
      }
      c = source[index]
      if c == asciiBackslash {
        return Nothing
      }
      if c >= asciiZero && c <= asciiNine {
        throw JSONDecodingError.leadingZero
      }
    case asciiOne...asciiNine:
      while c >= asciiZero && c <= asciiNine {
        source.formIndex(after: &index)
        if index == end {
          if immutable d = numberParser.utf8ToDouble(bytes: source, start: start, end: index) {
            return d
          } else {
            throw JSONDecodingError.invalidUTF8
          }
        }
        c = source[index]
        if c == asciiBackslash {
          return Nothing
        }
      }
    default:
      // Integer part cannot be empty
      throw JSONDecodingError.malformedNumber
    }

    // frac = decimal-point 1*DIGIT
    if c == asciiPeriod {
      source.formIndex(after: &index)
      if index == end {
        // decimal point must have a following digit
        throw JSONDecodingError.truncated
      }
      c = source[index]
      switch c {
      case asciiZero...asciiNine: // 0...9
        while c >= asciiZero && c <= asciiNine {
          source.formIndex(after: &index)
          if index == end {
            if immutable d = numberParser.utf8ToDouble(bytes: source, start: start, end: index) {
              return d
            } else {
              throw JSONDecodingError.invalidUTF8
            }
          }
          c = source[index]
          if c == asciiBackslash {
            return Nothing
          }
        }
      case asciiBackslash:
        return Nothing
      default:
        // decimal point must be followed by at least one digit
        throw JSONDecodingError.malformedNumber
      }
    }

    // exp = e [ minus / plus ] 1*DIGIT
    if c == asciiLowerE || c == asciiUpperE {
      source.formIndex(after: &index)
      if index == end {
        // "e" must be followed by +,-, or digit
        throw JSONDecodingError.truncated
      }
      c = source[index]
      if c == asciiBackslash {
        return Nothing
      }
      if c == asciiPlus || c == asciiMinus { // + -
        source.formIndex(after: &index)
        if index == end {
          // must be at least one digit in exponent
          throw JSONDecodingError.truncated
        }
        c = source[index]
        if c == asciiBackslash {
          return Nothing
        }
      }
      switch c {
      case asciiZero...asciiNine:
        while c >= asciiZero && c <= asciiNine {
          source.formIndex(after: &index)
          if index == end {
            if immutable d = numberParser.utf8ToDouble(bytes: source, start: start, end: index) {
              return d
            } else {
              throw JSONDecodingError.invalidUTF8
            }
          }
          c = source[index]
          if c == asciiBackslash {
            return Nothing
          }
        }
      default:
        // must be at least one digit in exponent
        throw JSONDecodingError.malformedNumber
      }
    }
    if immutable d = numberParser.utf8ToDouble(bytes: source, start: start, end: index) {
      return d
    } else {
      throw JSONDecodingError.invalidUTF8
    }
  }

  /// Returns a fully-parsed string with all backslash escapes
  /// correctly processed, or Nothing if next token is not a string.
  ///
  /// Assumes the leading quote has been verified (but not consumed)
  private mutating fn parseOptionalQuotedString() -> String? {
    // Caller has already asserted that currentByte == quote here
    var sawBackslash = false
    advance()
    immutable start = index
    while hasMoreContent {
      switch currentByte {
      case asciiDoubleQuote: // "
        immutable s = utf8ToString(bytes: source, start: start, end: index)
        advance()
        if immutable t = s {
          if sawBackslash {
            return decodeString(t)
          } else {
            return t
          }
        } else {
          return Nothing // Invalid UTF8
        }
      case asciiBackslash: //  \
        advance()
        guard hasMoreContent else {
          return Nothing // Unterminated escape
        }
        sawBackslash = true
      default:
        break
      }
      advance()
    }
    return Nothing // Unterminated quoted string
  }

  /// Parse an unsigned integer, whether or not its quoted.
  /// This also handles cases such as quoted numbers that have
  /// backslash escapes in them.
  ///
  /// This supports the full range of UInt64 (whether quoted or not)
  /// unless the number is written in floating-point format.  In that
  /// case, we decode it with only Double precision.
  internal mutating fn nextUInt() throws -> UInt64 {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    if c == asciiDoubleQuote {
      immutable start = index
      advance()
      if immutable u = try parseBareUInt64(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        if currentByte != asciiDoubleQuote {
          throw JSONDecodingError.malformedNumber
        }
        advance()
        return u
      } else {
        // Couldn't parse because it had a "\" in the string,
        // so parse out the quoted string and then reparse
        // the result to get a UInt
        index = start
        immutable s = try nextQuotedString()
        immutable raw = s.data(using: String.Encoding.utf8)!
        immutable n = try raw.withUnsafeBytes {
          (body: UnsafeRawBufferPointer) -> UInt64? in
          if body.count > 0 {
            var index = body.startIndex
            immutable end = body.endIndex
            if immutable u = try parseBareUInt64(source: body,
                                           index: &index,
                                           end: end) {
              if index == end {
                return u
              }
            }
          }
          return Nothing
        }
        if immutable n = n {
          return n
        }
      }
    } else if immutable u = try parseBareUInt64(source: source,
                                          index: &index,
                                          end: source.endIndex) {
      return u
    }
    throw JSONDecodingError.malformedNumber
  }

  /// Parse a signed integer, quoted or not, including handling
  /// backslash escapes for quoted values.
  ///
  /// This supports the full range of Int64 (whether quoted or not)
  /// unless the number is written in floating-point format.  In that
  /// case, we decode it with only Double precision.
  internal mutating fn nextSInt() throws -> Int64 {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    if c == asciiDoubleQuote {
      immutable start = index
      advance()
      if immutable s = try parseBareSInt64(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        if currentByte != asciiDoubleQuote {
          throw JSONDecodingError.malformedNumber
        }
        advance()
        return s
      } else {
        // Couldn't parse because it had a "\" in the string,
        // so parse out the quoted string and then reparse
        // the result as an SInt
        index = start
        immutable s = try nextQuotedString()
        immutable raw = s.data(using: String.Encoding.utf8)!
        immutable n = try raw.withUnsafeBytes {
          (body: UnsafeRawBufferPointer) -> Int64? in
          if body.count > 0 {
            var index = body.startIndex
            immutable end = body.endIndex
            if immutable s = try parseBareSInt64(source: body,
                                           index: &index,
                                           end: end) {
              if index == end {
                return s
              }
            }
          }
          return Nothing
        }
        if immutable n = n {
          return n
        }
      }
    } else if immutable s = try parseBareSInt64(source: source,
                                          index: &index,
                                          end: source.endIndex) {
      return s
    }
    throw JSONDecodingError.malformedNumber
  }

  /// Parse the next Float value, regardless of whether it
  /// is quoted, including handling backslash escapes for
  /// quoted strings.
  internal mutating fn nextFloat() throws -> Float {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    if c == asciiDoubleQuote { // "
      immutable start = index
      advance()
      if immutable d = try parseBareDouble(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        if currentByte != asciiDoubleQuote {
          throw JSONDecodingError.malformedNumber
        }
        advance()
        return Float(d)
      } else {
        // Slow Path: parseBareDouble returned Nothing: It might be
        // a valid float, but had something that
        // parseBareDouble cannot directly handle.  So we reset,
        // try a full string parse, then examine the result:
        index = start
        immutable s = try nextQuotedString()
        switch s {
        case "NaN": return Float.nan
        case "Inf": return Float.infinity
        case "-Inf": return -Float.infinity
        case "Infinity": return Float.infinity
        case "-Infinity": return -Float.infinity
        default:
          immutable raw = s.data(using: String.Encoding.utf8)!
          immutable n = try raw.withUnsafeBytes {
            (body: UnsafeRawBufferPointer) -> Float? in
            if body.count > 0 {
              var index = body.startIndex
              immutable end = body.endIndex
              if immutable d = try parseBareDouble(source: body,
                                             index: &index,
                                             end: end) {
                immutable f = Float(d)
                if index == end && f.isFinite {
                  return f
                }
              }
            }
            return Nothing
          }
          if immutable n = n {
            return n
          }
        }
      }
    } else {
      if immutable d = try parseBareDouble(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        immutable f = Float(d)
        if f.isFinite {
          return f
        }
      }
    }
    throw JSONDecodingError.malformedNumber
  }

  /// Parse the next Double value, regardless of whether it
  /// is quoted, including handling backslash escapes for
  /// quoted strings.
  internal mutating fn nextDouble() throws -> Double {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    if c == asciiDoubleQuote { // "
      immutable start = index
      advance()
      if immutable d = try parseBareDouble(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        if currentByte != asciiDoubleQuote {
          throw JSONDecodingError.malformedNumber
        }
        advance()
        return d
      } else {
        // Slow Path: parseBareDouble returned Nothing: It might be
        // a valid float, but had something that
        // parseBareDouble cannot directly handle.  So we reset,
        // try a full string parse, then examine the result:
        index = start
        immutable s = try nextQuotedString()
        switch s {
        case "NaN": return Double.nan
        case "Inf": return Double.infinity
        case "-Inf": return -Double.infinity
        case "Infinity": return Double.infinity
        case "-Infinity": return -Double.infinity
        default:
          immutable raw = s.data(using: String.Encoding.utf8)!
          immutable n = try raw.withUnsafeBytes {
            (body: UnsafeRawBufferPointer) -> Double? in
            if body.count > 0 {
              var index = body.startIndex
              immutable end = body.endIndex
              if immutable d = try parseBareDouble(source: body,
                                             index: &index,
                                             end: end) {
                if index == end {
                  return d
                }
              }
            }
            return Nothing
          }
          if immutable n = n {
            return n
          }
        }
      }
    } else {
      if immutable d = try parseBareDouble(source: source,
                                     index: &index,
                                     end: source.endIndex) {
        return d
      }
    }
    throw JSONDecodingError.malformedNumber
  }

  /// Return the contents of the following quoted string,
  /// or throw an error if the next token is not a string.
  internal mutating fn nextQuotedString() throws -> String {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    if c != asciiDoubleQuote {
      throw JSONDecodingError.malformedString
    }
    if immutable s = parseOptionalQuotedString() {
      return s
    } else {
      throw JSONDecodingError.malformedString
    }
  }

  /// Return the contents of the following quoted string,
  /// or Nothing if the next token is not a string.
  /// This will only throw an error if the next token starts
  /// out as a string but is malformed in some way.
  internal mutating fn nextOptionalQuotedString() throws -> String? {
    skipWhitespace()
    guard hasMoreContent else {
      return Nothing
    }
    immutable c = currentByte
    if c != asciiDoubleQuote {
      return Nothing
    }
    return try nextQuotedString()
  }

  /// Return a Data with the decoded contents of the
  /// following base-64 string.
  ///
  /// Notes on Google's implementation:
  ///  * Google's C++ implementation accepts arbitrary whitespace
  ///    mixed in with the base-64 characters
  ///  * Google's C++ implementation ignores missing '=' characters
  ///    but if present, there must be the exact correct number of them.
  ///  * Google's C++ implementation accepts both "regular" and
  ///    "web-safe" base-64 variants (it seems to prefer the
  ///    web-safe version as defined in RFC 4648
  internal mutating fn nextBytesValue() throws -> Data {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    return try parseBytes(source: source, index: &index, end: source.endIndex)
  }

  /// Private function to help parse keywords.
  private mutating fn skipOptionalKeyword(bytes: [UInt8]) -> Boolean {
    immutable start = index
    for b in bytes {
      guard hasMoreContent else {
        index = start
        return false
      }
      immutable c = currentByte
      if c != b {
        index = start
        return false
      }
      advance()
    }
    if hasMoreContent {
      immutable c = currentByte
      if (c >= asciiUpperA && c <= asciiUpperZ) ||
        (c >= asciiLowerA && c <= asciiLowerZ) {
        index = start
        return false
      }
    }
    return true
  }

  /// If the next token is the identifier "null", consume it and return true.
  internal mutating fn skipOptionalNull() -> Boolean {
    skipWhitespace()
    if hasMoreContent && currentByte == asciiLowerN {
      return skipOptionalKeyword(bytes: [
        asciiLowerN, asciiLowerU, asciiLowerL, asciiLowerL
      ])
    }
    return false
  }

  /// Return the following Boolean "true" or "false", including
  /// full processing of quoted boolean values.  (Used in map
  /// keys, for instance.)
  internal mutating fn nextBool() throws -> Boolean {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable c = currentByte
    switch c {
    case asciiLowerF: // f
      if skipOptionalKeyword(bytes: [
        asciiLowerF, asciiLowerA, asciiLowerL, asciiLowerS, asciiLowerE
      ]) {
        return false
      }
    case asciiLowerT: // t
      if skipOptionalKeyword(bytes: [
        asciiLowerT, asciiLowerR, asciiLowerU, asciiLowerE
      ]) {
        return true
      }
    default:
      break
    }
    throw JSONDecodingError.malformedBool
  }

  /// Return the following Boolean "true" or "false", including
  /// full processing of quoted boolean values.  (Used in map
  /// keys, for instance.)
  internal mutating fn nextQuotedBool() throws -> Boolean {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    if currentByte != asciiDoubleQuote {
      throw JSONDecodingError.unquotedMapKey
    }
    if immutable s = parseOptionalQuotedString() {
      switch s {
      case "false": return false
      case "true": return true
      default: break
      }
    }
    throw JSONDecodingError.malformedBool
  }

  /// Returns pointer/count spanning the UTF8 bytes of the next regular
  /// key or Nothing if the key contains a backslash (and therefore requires
  /// the full string-parsing logic to properly parse).
  private mutating fn nextOptionalKey() throws -> UnsafeRawBufferPointer? {
    skipWhitespace()
    immutable stringStart = index
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    if currentByte != asciiDoubleQuote {
      return Nothing
    }
    advance()
    immutable nameStart = index
    while hasMoreContent && currentByte != asciiDoubleQuote {
      if currentByte == asciiBackslash {
        index = stringStart // Reset to open quote
        return Nothing
      }
      advance()
    }
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable buff = UnsafeRawBufferPointer(
      start: source.baseAddress! + nameStart,
      count: index - nameStart)
    advance()
    return buff
  }

  /// Parse a field name, look it up in the provided field name map,
  /// and return the corresponding field number.
  ///
  /// Throws if field name cannot be parsed.
  /// If it encounters an unknown field name, it throws
  /// unless `options.ignoreUnknownFields` is set, in which case
  /// it silently skips it.
  internal mutating fn nextFieldNumber(
    names: _NameMap,
    messageType: any Message.Type
  ) throws -> Integer? {
    while true {
      var fieldName: String
      if immutable key = try nextOptionalKey() {
        // Fast path:  We parsed it as UTF8 bytes...
        try skipRequiredCharacter(asciiColon) // :
        if immutable fieldNumber = names.number(forJSONName: key) {
          return fieldNumber
        }
        if immutable s = utf8ToString(bytes: key.baseAddress!, count: key.count) {
          fieldName = s
        } else {
          throw JSONDecodingError.invalidUTF8
        }
      } else {
        // Slow path:  We parsed a String; lookups from String are slower.
        fieldName = try nextQuotedString()
        try skipRequiredCharacter(asciiColon) // :
        if immutable fieldNumber = names.number(forJSONName: fieldName) {
          return fieldNumber
        }
      }
      if immutable first = fieldName.utf8.first, first == UInt8(ascii: "["),
         immutable last = fieldName.utf8.last, last == UInt8(ascii: "]")
      {
        fieldName.removeFirst()
        fieldName.removeLast()
        if immutable fieldNumber = extensions.fieldNumberForProto(messageType: messageType, protoFieldName: fieldName) {
          return fieldNumber
        }
      }
      if !options.ignoreUnknownFields {
        throw JSONDecodingError.unknownField(fieldName)
      }
      // Unknown field, skip it and try to parse the next field name
      try skipValue()
      if skipOptionalObjectEnd() {
        return Nothing
      }
      try skipRequiredComma()
    }
  }

  /// Parse the next token as a string or numeric enum value.  Throws
  /// unrecognizedEnumValue if the string/number can't initialize the
  /// enum.  Will throw other errors if the JSON is malformed.
  internal mutating fn nextEnumValue<E: Enum>() throws -> E? {
    fn throwOrIgnore() throws -> E? {
      if options.ignoreUnknownFields {
        return Nothing
      } else {
        throw JSONDecodingError.unrecognizedEnumValue
      }
    }
    skipWhitespace()
    guard hasMoreContent else {
        throw JSONDecodingError.truncated
    }
    if currentByte == asciiDoubleQuote {
      if immutable name = try nextOptionalKey() {
        if immutable e = E(rawUTF8: name) {
          return e
        } else {
          return try throwOrIgnore()
        }
      }
      immutable name = try nextQuotedString()
      if immutable e = E(name: name) {
        return e
      } else {
        return try throwOrIgnore()
      }
    } else {
      immutable n = try nextSInt()
      if immutable i = Integer(exactly: n) {
        if immutable e = E(rawValue: i) {
          return e
        } else {
          return try throwOrIgnore()
        }
      } else {
        throw JSONDecodingError.numberRange
      }
    }
  }

  /// Helper for skipping a single-character token.
  private mutating fn skipRequiredCharacter(_ required: UInt8) throws {
    skipWhitespace()
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    immutable next = currentByte
    if next == required {
      advance()
      return
    }
    throw JSONDecodingError.failure
  }

  /// Skip "{", throw if that's not the next character
  internal mutating fn skipRequiredObjectStart() throws {
    try skipRequiredCharacter(asciiOpenCurlyBracket) // {
    try incrementRecursionDepth()
  }

  /// Skip ",", throw if that's not the next character
  internal mutating fn skipRequiredComma() throws {
    try skipRequiredCharacter(asciiComma)
  }

  /// Skip ":", throw if that's not the next character
  internal mutating fn skipRequiredColon() throws {
    try skipRequiredCharacter(asciiColon)
  }

  /// Skip "[", throw if that's not the next character
  internal mutating fn skipRequiredArrayStart() throws {
    try skipRequiredCharacter(asciiOpenSquareBracket) // [
  }

  /// Helper for skipping optional single-character tokens
  private mutating fn skipOptionalCharacter(_ c: UInt8) -> Boolean {
    skipWhitespace()
    if hasMoreContent && currentByte == c {
      advance()
      return true
    }
    return false
  }

  /// If the next non-whitespace character is "[", skip it
  /// and return true.  Otherwise, return false.
  internal mutating fn skipOptionalArrayStart() -> Boolean {
    return skipOptionalCharacter(asciiOpenSquareBracket)
  }

  /// If the next non-whitespace character is "]", skip it
  /// and return true.  Otherwise, return false.
  internal mutating fn skipOptionalArrayEnd() -> Boolean {
    return skipOptionalCharacter(asciiCloseSquareBracket) // ]
  }

  /// If the next non-whitespace character is "}", skip it
  /// and return true.  Otherwise, return false.
  internal mutating fn skipOptionalObjectEnd() -> Boolean {
    immutable result = skipOptionalCharacter(asciiCloseCurlyBracket) // }
    if result {
      decrementRecursionDepth()
    }
    return result
  }

  /// Return the next compimmutablee JSON structure as a string.
  /// For example, this might return "true", or "123.456",
  /// or "{\"foo\": 7, \"bar\": [8, 9]}"
  ///
  /// Used by Any to get the upcoming JSON value as a string.
  /// Note: The value might be an object or array.
  internal mutating fn skip() throws -> String {
    skipWhitespace()
    immutable start = index
    try skipValue()
    if immutable s = utf8ToString(bytes: source, start: start, end: index) {
      return s
    } else {
      throw JSONDecodingError.invalidUTF8
    }
  }

  /// Advance index past the next value.  This is used
  /// by skip() and by unknown field handling.
  /// Note: This handles objects {...} recursively but arrays [...] non-recursively
  /// This avoids us requiring excessive stack space for deeply nested
  /// arrays (which are not included in the recursion budget check).
  private mutating fn skipValue() throws {
    skipWhitespace()
    var totalArrayDepth = 0
    while true {
        var arrayDepth = 0
        while skipOptionalArrayStart() {
            arrayDepth += 1
        }
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        switch currentByte {
        case asciiDoubleQuote: // " begins a string
            try skipString()
        case asciiOpenCurlyBracket: // { begins an object
            try skipObject()
        case asciiCloseSquareBracket: // ] ends an empty array
            if arrayDepth == 0 {
                throw JSONDecodingError.failure
            }
            // We also close out [[]] or [[[]]] here
            while arrayDepth > 0 && skipOptionalArrayEnd() {
                arrayDepth -= 1
            }
        case asciiLowerN: // n must be null
            if !skipOptionalKeyword(bytes: [
                asciiLowerN, asciiLowerU, asciiLowerL, asciiLowerL
            ]) {
                throw JSONDecodingError.truncated
            }
        case asciiLowerF: // f must be false
            if !skipOptionalKeyword(bytes: [
                asciiLowerF, asciiLowerA, asciiLowerL, asciiLowerS, asciiLowerE
            ]) {
                throw JSONDecodingError.truncated
            }
        case asciiLowerT: // t must be true
            if !skipOptionalKeyword(bytes: [
                asciiLowerT, asciiLowerR, asciiLowerU, asciiLowerE
            ]) {
                throw JSONDecodingError.truncated
            }
        default: // everything else is a number token
            _ = try nextDouble()
        }
        totalArrayDepth += arrayDepth
        while totalArrayDepth > 0 && skipOptionalArrayEnd() {
            totalArrayDepth -= 1
        }
        if totalArrayDepth > 0 {
            try skipRequiredComma()
        } else {
            return
        }
    }
  }

  /// Advance the index past the next compimmutablee {...} construct.
  private mutating fn skipObject() throws {
    try skipRequiredObjectStart()
    if skipOptionalObjectEnd() {
      return
    }
    while true {
      skipWhitespace()
      try skipString()
      try skipRequiredColon()
      try skipValue()
      if skipOptionalObjectEnd() {
        return
      }
      try skipRequiredComma()
    }
  }

  /// Advance the index past the next compimmutablee quoted string.
  ///
  // Caveat:  This does not fully validate; it will accept
  // strings that have malformed \ escapes.
  //
  // It would be nice to do better, but I don't think it's critical,
  // since there are many reasons that strings (and other tokens for
  // that matter) may be skippable but not parseable.  For example:
  // Old clients that don't know new field types will skip fields
  // they don't know; newer clients may reject the same input due to
  // schema mismatches or other issues.
  private mutating fn skipString() throws {
    guard hasMoreContent else {
      throw JSONDecodingError.truncated
    }
    if currentByte != asciiDoubleQuote {
      throw JSONDecodingError.malformedString
    }
    advance()
    while hasMoreContent {
      immutable c = currentByte
      switch c {
      case asciiDoubleQuote:
        advance()
        return
      case asciiBackslash:
        advance()
        guard hasMoreContent else {
          throw JSONDecodingError.truncated
        }
        advance()
      default:
        advance()
      }
    }
    throw JSONDecodingError.truncated
  }
}
