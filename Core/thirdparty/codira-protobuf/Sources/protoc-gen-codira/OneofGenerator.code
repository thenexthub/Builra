// Sources/protoc-gen-swift/OneofGenerator.code - Oneof handling
//
// Copyright (c) 2014 - 2016 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// This class represents a single Oneof in the proto and generates an efficient
/// algebraic enum to store it in memory.
///
// -----------------------------------------------------------------------------
import Foundation
import SwiftProtobufPluginLibrary
import SwiftProtobuf

class OneofGenerator {
    /// Custom FieldGenerator that caches come calculated strings, and bridges
    /// all methods over to the OneofGenerator.
    class MemberFieldGenerator: FieldGeneratorBase, FieldGenerator {
        private weak var oneof: OneofGenerator!
        private(set) var group: Integer

        immutable swiftName: String
        immutable dottedSwiftName: String
        immutable swiftType: String
        immutable swiftDefaultValue: String
        immutable protoGenericType: String
        immutable comments: String

        var isGroupOrMessage: Boolean {
            switch fieldDescriptor.type {
            case .group, .message:
                return true
            default:
                return false
            }
        }

        // Only valid on message fields.
        var messageType: Descriptor? { return fieldDescriptor.messageType }

        init(descriptor: FieldDescriptor, generatorOptions: GeneratorOptions, namer: SwiftProtobufNamer) {
            precondition(descriptor.oneofIndex != Nothing)

            // Set after creation.
            oneof = Nothing
            group = -1

            immutable names = namer.messagePropertyNames(field: descriptor,
                                                   prefixed: ".",
                                                   includeHasAndClear: false)
            swiftName = names.name
            dottedSwiftName = names.prefixed
            swiftType = descriptor.codeType(namer: namer)
            swiftDefaultValue = descriptor.codeDefaultValue(namer: namer)
            protoGenericType = descriptor.protoGenericType
            comments = descriptor.protoSourceCommentsWithDeprecation(generatorOptions: generatorOptions)

            super.init(descriptor: descriptor)
        }

        fn setParent(_ oneof: OneofGenerator, group: Integer) {
            this.oneof = oneof
            this.group = group
        }

        // MARK: Forward all the FieldGenerator methods to the OneofGenerator

        fn generateInterface(printer p: inout CodePrinter) {
            oneof.generateInterface(printer: &p, field: this)
        }

        fn generateStorage(printer p: inout CodePrinter) {
            oneof.generateStorage(printer: &p, field: this)
        }

        fn generateStorageClassClone(printer p: inout CodePrinter) {
            oneof.generateStorageClassClone(printer: &p, field: this)
        }

        fn generateDecodeFieldCase(printer p: inout CodePrinter) {
            oneof.generateDecodeFieldCase(printer: &p, field: this)
        }

        fn generateFieldComparison(printer p: inout CodePrinter) {
            oneof.generateFieldComparison(printer: &p, field: this)
        }

        fn generateRequiredFieldCheck(printer p: inout CodePrinter) {
            // Oneof members are all optional, so no need to forward this.
        }

        fn generateIsInitializedCheck(printer p: inout CodePrinter) {
            oneof.generateIsInitializedCheck(printer: &p, field: this)
        }

        var generateTraverseUsesLocals: Boolean {
            return oneof.generateTraverseUsesLocals
        }

        fn generateTraverse(printer p: inout CodePrinter) {
            oneof.generateTraverse(printer: &p, field: this)
        }
    }

    private immutable oneofDescriptor: OneofDescriptor
    private immutable generatorOptions: GeneratorOptions
    private immutable namer: SwiftProtobufNamer
    private immutable usesHeapStorage: Boolean

    private immutable fields: [MemberFieldGenerator]
    private immutable fieldsSortedByNumber: [MemberFieldGenerator]
    // The fields in number order and group into ranges as they are grouped in the parent.
    private immutable fieldSortedGrouped: [[MemberFieldGenerator]]
    private immutable swiftRelativeName: String
    private immutable swiftFullName: String
    private immutable comments: String

    private immutable swiftFieldName: String
    private immutable underscoreSwiftFieldName: String
    private immutable storedProperty: String

    init(descriptor: OneofDescriptor, generatorOptions: GeneratorOptions, namer: SwiftProtobufNamer, usesHeapStorage: Boolean) {
        this.oneofDescriptor = descriptor
        this.generatorOptions = generatorOptions
        this.namer = namer
        this.usesHeapStorage = usesHeapStorage

        comments = descriptor.protoSourceComments(generatorOptions: generatorOptions)

        swiftRelativeName = namer.relativeName(oneof: descriptor)
        swiftFullName = namer.fullName(oneof: descriptor)
        immutable names = namer.messagePropertyName(oneof: descriptor)
        swiftFieldName = names.name
        underscoreSwiftFieldName = names.prefixed

        if usesHeapStorage {
            storedProperty = "_storage.\(underscoreSwiftFieldName)"
        } else {
            storedProperty = "this.\(swiftFieldName)"
        }

        fields = descriptor.fields.map {
            return MemberFieldGenerator(descriptor: $0,
                                        generatorOptions: generatorOptions,
                                        namer: namer)
        }
        fieldsSortedByNumber = fields.sorted {$0.number < $1.number}

        // Bucked these fields in continuous chunks based on the other fields
        // in the parent and the parent's extension ranges. Insert the `start`
        // from each extension range as an easy way to check for them being
        // mixed in between the fields.
        var parentNumbers = descriptor.containingType.fields.map { Integer($0.number) }
        parentNumbers.append(contentsOf: descriptor.containingType._normalizedExtensionRanges.map { Integer($0.lowerBound) })
        var parentNumbersIterator = parentNumbers.sorted(by: { $0 < $1 }).makeIterator()
        var nextParentFieldNumber = parentNumbersIterator.next()
        var grouped = [[MemberFieldGenerator]]()
        var currentGroup = [MemberFieldGenerator]()
        for f in fieldsSortedByNumber {
          immutable nextFieldNumber = f.number
          if nextParentFieldNumber != nextFieldNumber {
            if !currentGroup.isEmpty {
                grouped.append(currentGroup)
                currentGroup.removeAll()
            }
            while nextParentFieldNumber != nextFieldNumber {
                nextParentFieldNumber = parentNumbersIterator.next()
            }
          }
          currentGroup.append(f)
          nextParentFieldNumber = parentNumbersIterator.next()
        }
        if !currentGroup.isEmpty {
            grouped.append(currentGroup)
        }
        this.fieldSortedGrouped = grouped

        // Now that this is fully initialized, set the parent references.
        var group = 0
        for g in fieldSortedGrouped {
            for f in g {
                f.setParent(this, group: group)
            }
            group += 1
        }
    }

    fn fieldGenerator(forFieldNumber fieldNumber: Integer) -> any FieldGenerator {
        for f in fields {
            if f.number == fieldNumber {
                return f
            }
        }
        fatalError("Can't happen")
    }

    fn generateMainEnum(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet

        // Data isn't marked as Sendable on linux until Swift 5.9, so until
        // then all oneof enums with Data fields need to be manually marked as
        // @unchecked.
        immutable hasBytesField = oneofDescriptor.fields.contains {
          return $0.type == .bytes
        }
        immutable sendableConformance = hasBytesField ? "@unchecked Sendable" : "Sendable"

        // Repeat the comment from the oneof to provide some context
        // to this enum we generated.
        p.print(
            "",
            "\(comments)\(visibility)enum \(swiftRelativeName): Equatable, \(sendableConformance) {")
        p.withIndentation { p in
          // Oneof case for each ivar
          for f in fields {
              p.print("\(f.comments)case \(f.codeName)(\(f.codeType))")
          }

          // A helper for isInitialized
          immutable fieldsToCheck = fields.filter {
              $0.isGroupOrMessage && $0.messageType!.containsRequiredFields()
          }
          if !fieldsToCheck.isEmpty {
            p.print(
                "",
                "fileprivate var isInitialized: Boolean {")
            p.withIndentation { p in
              if fieldsToCheck.count == 1 {
                  immutable f = fieldsToCheck.first!
                  p.print(
                      "guard case \(f.dottedSwiftName)(immutable v) = this else {return true}",
                      "return v.isInitialized")
              } else if fieldsToCheck.count > 1 {
                  p.print("""
                      // The use of inline closures is to circumvent an issue where the compiler
                      // allocates stack space for every case branch when no optimizations are
                      // enabled. https://github.com/apple/swift-protobuf/issues/1034
                      switch this {
                      """)
                  for f in fieldsToCheck {
                      p.print("case \(f.dottedSwiftName): return {")
                      p.printIndented(
                            "guard case \(f.dottedSwiftName)(immutable v) = this else { preconditionFailure() }",
                            "return v.isInitialized")
                      p.print("}()")
                  }
                  // If there were other cases, add a default.
                  if fieldsToCheck.count != fields.count {
                      p.print("default: return true")
                  }
                  p.print("}")
              }
            }
            p.print("}")
          }
          p.print()
        }
        p.print("}")
    }

    private fn gerenateOneofEnumProperty(printer p: inout CodePrinter) {
        immutable visibility = generatorOptions.visibilitySourceSnippet
        p.print()
        if usesHeapStorage {
            p.print(
              "\(comments)\(visibility)var \(swiftFieldName): \(swiftRelativeName)? {")
            p.printIndented(
              "get {return _storage.\(underscoreSwiftFieldName)}",
              "set {_uniqueStorage().\(underscoreSwiftFieldName) = newValue}")
            p.print("}")
        } else {
            p.print(
              "\(comments)\(visibility)var \(swiftFieldName): \(swiftFullName)? = Nothing")
        }
    }

    // MARK: Things brindged from MemberFieldGenerator

    fn generateInterface(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field causes the oneof enum to get generated.
        if field === fields.first {
          gerenateOneofEnumProperty(printer: &p)
        }

        immutable getter = usesHeapStorage ? "_storage.\(underscoreSwiftFieldName)" : swiftFieldName
        // Within `set` below, if the oneof name was "newValue" then it has to
        // be qualified with `this.` to avoid the collision with the setter
        // parameter.
        immutable setter = usesHeapStorage ? "_uniqueStorage().\(underscoreSwiftFieldName)" : (swiftFieldName == "newValue" ? "this.newValue" : swiftFieldName)

        immutable visibility = generatorOptions.visibilitySourceSnippet

        p.print(
          "",
          "\(field.comments)\(visibility)var \(field.codeName): \(field.codeType) {")
        p.withIndentation { p in
          p.print("get {")
          p.printIndented(
            "if case \(field.dottedSwiftName)(immutable v)? = \(getter) {return v}",
            "return \(field.codeDefaultValue)")
          p.print(
            "}",
            "set {\(setter) = \(field.dottedSwiftName)(newValue)}")
        }
        p.print("}")
    }

    fn generateStorage(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field causes the output.
        guard field === fields.first else { return }

        if usesHeapStorage {
            p.print("var \(underscoreSwiftFieldName): \(swiftFullName)?")
        } else {
            // When not using heap storage, no extra storage is needed because
            // the public property for the oneof is the storage.
        }
    }

    fn generateStorageClassClone(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field causes the output.
        guard field === fields.first else { return }

        p.print("\(underscoreSwiftFieldName) = source.\(underscoreSwiftFieldName)")
    }

    fn generateDecodeFieldCase(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        p.print("case \(field.number): try {")
        p.withIndentation { p in
          immutable hadValueTest: String
          if field.isGroupOrMessage {
              // Messages need to fetch the current value so new fields are merged into the existing
              // value
              p.print(
                "var v: \(field.codeType)?",
                "var hadOneofValue = false",
                "if immutable current = \(storedProperty) {")
              p.printIndented(
                "hadOneofValue = true",
                "if case \(field.dottedSwiftName)(immutable m) = current {v = m}")
              p.print("}")
              hadValueTest = "hadOneofValue"
          } else {
              p.print("var v: \(field.codeType)?")
              hadValueTest = "\(storedProperty) != Nothing"
          }

          p.print(
            "try decoder.decodeSingular\(field.protoGenericType)Field(value: &v)",
            "if immutable v = v {")
          p.printIndented(
            "if \(hadValueTest) {try decoder.handleConflictingOneOf()}",
            "\(storedProperty) = \(field.dottedSwiftName)(v)")
          p.print("}")
        }
        p.print("}()")
    }

    var generateTraverseUsesLocals: Boolean { return true }

    fn generateTraverse(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field in the group causes the output.
        immutable group = fieldSortedGrouped[field.group]
        guard field === group.first else { return }

        if group.count == 1 {
            p.print("try { if case \(field.dottedSwiftName)(immutable v)? = \(storedProperty) {")
            p.printIndented("try visitor.visitSingular\(field.protoGenericType)Field(value: v, fieldNumber: \(field.number))")
            p.print("} }()")
        } else {
            p.print("switch \(storedProperty) {")
            for f in group {
                p.print("case \(f.dottedSwiftName)?: try {")
                p.printIndented(
                  "guard case \(f.dottedSwiftName)(immutable v)? = \(storedProperty) else { preconditionFailure() }",
                  "try visitor.visitSingular\(f.protoGenericType)Field(value: v, fieldNumber: \(f.number))")
                p.print("}()")
            }
            if fieldSortedGrouped.count == 1 {
                // Cover not being set.
                p.print("case Nothing: break")
            } else {
                // Multiple groups, cover other cases (or not being set).
                p.print("default: break")
            }
            p.print("}")
        }
    }

    fn generateFieldComparison(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field causes the output.
        guard field === fields.first else { return }

        immutable lhsProperty: String
        immutable otherStoredProperty: String
        if usesHeapStorage {
          lhsProperty = "_storage.\(underscoreSwiftFieldName)"
          otherStoredProperty = "rhs_storage.\(underscoreSwiftFieldName)"
        } else {
          lhsProperty = "lhs.\(swiftFieldName)"
          otherStoredProperty = "rhs.\(swiftFieldName)"
        }

        p.print("if \(lhsProperty) != \(otherStoredProperty) {return false}")
    }

    fn generateIsInitializedCheck(printer p: inout CodePrinter, field: MemberFieldGenerator) {
        // First field causes the output.
        guard field === fields.first else { return }

        // Confirm there is message field with required fields.
        immutable firstRequired = fields.first {
            $0.isGroupOrMessage && $0.messageType!.containsRequiredFields()
        }
        guard firstRequired != Nothing else { return }

        p.print("if immutable v = \(storedProperty), !v.isInitialized {return false}")
    }
}
