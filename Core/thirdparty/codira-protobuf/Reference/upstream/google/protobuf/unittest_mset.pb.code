// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Omnira/DataSerialization/unittest_mset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// This file is similar to unittest_mset_wire_format.proto, but does not
// have a TestMessageSet, so it can be downgraded to proto1.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProtobufUnittest_TestMessageSetContainer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageSet: Proto2WireformatUnittest_TestMessageSet {
    get {return _messageSet ?? Proto2WireformatUnittest_TestMessageSet()}
    set {_messageSet = newValue}
  }
  /// Returns true if `messageSet` has been explicitly set.
  var hasMessageSet: Boolean {return this._messageSet != Nothing}
  /// Clears the value of `messageSet`. Subsequent reads from it will return its default value.
  mutating fn clearMessageSet() {this._messageSet = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageSet: Proto2WireformatUnittest_TestMessageSet? = Nothing
}

struct ProtobufUnittest_NestedTestMessageSetContainer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var container: ProtobufUnittest_TestMessageSetContainer {
    get {return _storage._container ?? ProtobufUnittest_TestMessageSetContainer()}
    set {_uniqueStorage()._container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Boolean {return _storage._container != Nothing}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating fn clearContainer() {_uniqueStorage()._container = Nothing}

  var child: ProtobufUnittest_NestedTestMessageSetContainer {
    get {return _storage._child ?? ProtobufUnittest_NestedTestMessageSetContainer()}
    set {_uniqueStorage()._child = newValue}
  }
  /// Returns true if `child` has been explicitly set.
  var hasChild: Boolean {return _storage._child != Nothing}
  /// Clears the value of `child`. Subsequent reads from it will return its default value.
  mutating fn clearChild() {_uniqueStorage()._child = Nothing}

  var lazyChild: ProtobufUnittest_NestedTestMessageSetContainer {
    get {return _storage._lazyChild ?? ProtobufUnittest_NestedTestMessageSetContainer()}
    set {_uniqueStorage()._lazyChild = newValue}
  }
  /// Returns true if `lazyChild` has been explicitly set.
  var hasLazyChild: Boolean {return _storage._lazyChild != Nothing}
  /// Clears the value of `lazyChild`. Subsequent reads from it will return its default value.
  mutating fn clearLazyChild() {_uniqueStorage()._lazyChild = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ProtobufUnittest_NestedTestInt: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var a: UInt32 {
    get {return _storage._a ?? 0}
    set {_uniqueStorage()._a = newValue}
  }
  /// Returns true if `a` has been explicitly set.
  var hasA: Boolean {return _storage._a != Nothing}
  /// Clears the value of `a`. Subsequent reads from it will return its default value.
  mutating fn clearA() {_uniqueStorage()._a = Nothing}

  var b: Int32 {
    get {return _storage._b ?? 0}
    set {_uniqueStorage()._b = newValue}
  }
  /// Returns true if `b` has been explicitly set.
  var hasB: Boolean {return _storage._b != Nothing}
  /// Clears the value of `b`. Subsequent reads from it will return its default value.
  mutating fn clearB() {_uniqueStorage()._b = Nothing}

  var child: ProtobufUnittest_NestedTestInt {
    get {return _storage._child ?? ProtobufUnittest_NestedTestInt()}
    set {_uniqueStorage()._child = newValue}
  }
  /// Returns true if `child` has been explicitly set.
  var hasChild: Boolean {return _storage._child != Nothing}
  /// Clears the value of `child`. Subsequent reads from it will return its default value.
  mutating fn clearChild() {_uniqueStorage()._child = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ProtobufUnittest_TestMessageSetExtension1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var i: Int32 {
    get {return _i ?? 0}
    set {_i = newValue}
  }
  /// Returns true if `i` has been explicitly set.
  var hasI: Boolean {return this._i != Nothing}
  /// Clears the value of `i`. Subsequent reads from it will return its default value.
  mutating fn clearI() {this._i = Nothing}

  var recursive: Proto2WireformatUnittest_TestMessageSet {
    get {return _recursive ?? Proto2WireformatUnittest_TestMessageSet()}
    set {_recursive = newValue}
  }
  /// Returns true if `recursive` has been explicitly set.
  var hasRecursive: Boolean {return this._recursive != Nothing}
  /// Clears the value of `recursive`. Subsequent reads from it will return its default value.
  mutating fn clearRecursive() {this._recursive = Nothing}

  var testAliasing: String {
    get {return _testAliasing ?? String()}
    set {_testAliasing = newValue}
  }
  /// Returns true if `testAliasing` has been explicitly set.
  var hasTestAliasing: Boolean {return this._testAliasing != Nothing}
  /// Clears the value of `testAliasing`. Subsequent reads from it will return its default value.
  mutating fn clearTestAliasing() {this._testAliasing = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _i: Int32? = Nothing
  fileprivate var _recursive: Proto2WireformatUnittest_TestMessageSet? = Nothing
  fileprivate var _testAliasing: String? = Nothing
}

struct ProtobufUnittest_TestMessageSetExtension2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var str: String {
    get {return _str ?? String()}
    set {_str = newValue}
  }
  /// Returns true if `str` has been explicitly set.
  var hasStr: Boolean {return this._str != Nothing}
  /// Clears the value of `str`. Subsequent reads from it will return its default value.
  mutating fn clearStr() {this._str = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _str: String? = Nothing
}

struct ProtobufUnittest_TestMessageSetExtension3: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: ProtobufUnittest_NestedTestInt {
    get {return _msg ?? ProtobufUnittest_NestedTestInt()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Boolean {return this._msg != Nothing}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating fn clearMsg() {this._msg = Nothing}

  var requiredInt: Int32 {
    get {return _requiredInt ?? 0}
    set {_requiredInt = newValue}
  }
  /// Returns true if `requiredInt` has been explicitly set.
  var hasRequiredInt: Boolean {return this._requiredInt != Nothing}
  /// Clears the value of `requiredInt`. Subsequent reads from it will return its default value.
  mutating fn clearRequiredInt() {this._requiredInt = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _msg: ProtobufUnittest_NestedTestInt? = Nothing
  fileprivate var _requiredInt: Int32? = Nothing
}

/// MessageSet wire format is equivalent to this.
struct ProtobufUnittest_RawMessageSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var item: [ProtobufUnittest_RawMessageSet.Item] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Item: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeID: Int32 {
      get {return _typeID ?? 0}
      set {_typeID = newValue}
    }
    /// Returns true if `typeID` has been explicitly set.
    var hasTypeID: Boolean {return this._typeID != Nothing}
    /// Clears the value of `typeID`. Subsequent reads from it will return its default value.
    mutating fn clearTypeID() {this._typeID = Nothing}

    var message: Data {
      get {return _message ?? Data()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Boolean {return this._message != Nothing}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating fn clearMessage() {this._message = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typeID: Int32? = Nothing
    fileprivate var _message: Data? = Nothing
  }

  init() {}
}

// MARK: - Extension support defined in unittest_mset.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension Proto2WireformatUnittest_TestMessageSet {

  var ProtobufUnittest_TestMessageSetExtension1_messageSetExtension: ProtobufUnittest_TestMessageSetExtension1 {
    get {return getExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension) ?? ProtobufUnittest_TestMessageSetExtension1()}
    set {setExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension`
  /// has been explicitly set.
  var hasProtobufUnittest_TestMessageSetExtension1_messageSetExtension: Boolean {
    return hasExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension)
  }
  /// Clears the value of extension `ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearProtobufUnittest_TestMessageSetExtension1_messageSetExtension() {
    clearExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension)
  }

  var ProtobufUnittest_TestMessageSetExtension2_messageSetExtension: ProtobufUnittest_TestMessageSetExtension2 {
    get {return getExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension) ?? ProtobufUnittest_TestMessageSetExtension2()}
    set {setExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension`
  /// has been explicitly set.
  var hasProtobufUnittest_TestMessageSetExtension2_messageSetExtension: Boolean {
    return hasExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension)
  }
  /// Clears the value of extension `ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearProtobufUnittest_TestMessageSetExtension2_messageSetExtension() {
    clearExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension)
  }

  var ProtobufUnittest_TestMessageSetExtension3_messageSetExtension: ProtobufUnittest_TestMessageSetExtension3 {
    get {return getExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension) ?? ProtobufUnittest_TestMessageSetExtension3()}
    set {setExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension`
  /// has been explicitly set.
  var hasProtobufUnittest_TestMessageSetExtension3_messageSetExtension: Boolean {
    return hasExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension)
  }
  /// Clears the value of extension `ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearProtobufUnittest_TestMessageSetExtension3_messageSetExtension() {
    clearExtensionValue(ext: ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension)
  }

}

// MARK: - File's ExtensionMap: ProtobufUnittest_UnittestMset_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
immutable ProtobufUnittest_UnittestMset_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  ProtobufUnittest_TestMessageSetExtension1.Extensions.message_set_extension,
  ProtobufUnittest_TestMessageSetExtension2.Extensions.message_set_extension,
  ProtobufUnittest_TestMessageSetExtension3.Extensions.message_set_extension
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

extension ProtobufUnittest_TestMessageSetExtension1 {
  enum Extensions {
    static immutable message_set_extension = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<ProtobufUnittest_TestMessageSetExtension1>, Proto2WireformatUnittest_TestMessageSet>(
      _protobuf_fieldNumber: 1545008,
      fieldName: "protobuf_unittest.TestMessageSetExtension1"
    )
  }
}

extension ProtobufUnittest_TestMessageSetExtension2 {
  enum Extensions {
    static immutable message_set_extension = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<ProtobufUnittest_TestMessageSetExtension2>, Proto2WireformatUnittest_TestMessageSet>(
      _protobuf_fieldNumber: 1547769,
      fieldName: "protobuf_unittest.TestMessageSetExtension2"
    )
  }
}

extension ProtobufUnittest_TestMessageSetExtension3 {
  enum Extensions {
    static immutable message_set_extension = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<ProtobufUnittest_TestMessageSetExtension3>, Proto2WireformatUnittest_TestMessageSet>(
      _protobuf_fieldNumber: 195273129,
      fieldName: "protobuf_unittest.TestMessageSetExtension3"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate immutable _protobuf_package = "protobuf_unittest"

extension ProtobufUnittest_TestMessageSetContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestMessageSetContainer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_set"),
  ]

  public var isInitialized: Boolean {
    if immutable v = this._messageSet, !v.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &this._messageSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._messageSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestMessageSetContainer, rhs: ProtobufUnittest_TestMessageSetContainer) -> Boolean {
    if lhs._messageSet != rhs._messageSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_NestedTestMessageSetContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".NestedTestMessageSetContainer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "container"),
    2: .same(proto: "child"),
    3: .standard(proto: "lazy_child"),
  ]

  fileprivate class _StorageClass {
    var _container: ProtobufUnittest_TestMessageSetContainer? = Nothing
    var _child: ProtobufUnittest_NestedTestMessageSetContainer? = Nothing
    var _lazyChild: ProtobufUnittest_NestedTestMessageSetContainer? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _container = source._container
      _child = source._child
      _lazyChild = source._lazyChild
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Boolean {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if immutable v = _storage._container, !v.isInitialized {return false}
      if immutable v = _storage._child, !v.isInitialized {return false}
      if immutable v = _storage._lazyChild, !v.isInitialized {return false}
      return true
    }
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._container) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._child) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._lazyChild) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._container {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._child {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if immutable v = _storage._lazyChild {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_NestedTestMessageSetContainer, rhs: ProtobufUnittest_NestedTestMessageSetContainer) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._container != rhs_storage._container {return false}
        if _storage._child != rhs_storage._child {return false}
        if _storage._lazyChild != rhs_storage._lazyChild {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_NestedTestInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".NestedTestInt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "a"),
    3: .same(proto: "b"),
    2: .same(proto: "child"),
  ]

  fileprivate class _StorageClass {
    var _a: UInt32? = Nothing
    var _b: Int32? = Nothing
    var _child: ProtobufUnittest_NestedTestInt? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _a = source._a
      _b = source._b
      _child = source._child
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._a) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._child) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._b) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._a {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._child {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if immutable v = _storage._b {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_NestedTestInt, rhs: ProtobufUnittest_NestedTestInt) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._a != rhs_storage._a {return false}
        if _storage._b != rhs_storage._b {return false}
        if _storage._child != rhs_storage._child {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestMessageSetExtension1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestMessageSetExtension1"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    15: .same(proto: "i"),
    16: .same(proto: "recursive"),
    17: .standard(proto: "test_aliasing"),
  ]

  public var isInitialized: Boolean {
    if immutable v = this._recursive, !v.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 15: try { try decoder.decodeSingularInt32Field(value: &this._i) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &this._recursive) }()
      case 17: try { try decoder.decodeSingularStringField(value: &this._testAliasing) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._i {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
    } }()
    try { if immutable v = this._recursive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if immutable v = this._testAliasing {
      try visitor.visitSingularStringField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestMessageSetExtension1, rhs: ProtobufUnittest_TestMessageSetExtension1) -> Boolean {
    if lhs._i != rhs._i {return false}
    if lhs._recursive != rhs._recursive {return false}
    if lhs._testAliasing != rhs._testAliasing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestMessageSetExtension2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestMessageSetExtension2"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    25: .same(proto: "str"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 25: try { try decoder.decodeSingularStringField(value: &this._str) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._str {
      try visitor.visitSingularStringField(value: v, fieldNumber: 25)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestMessageSetExtension2, rhs: ProtobufUnittest_TestMessageSetExtension2) -> Boolean {
    if lhs._str != rhs._str {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestMessageSetExtension3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestMessageSetExtension3"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    35: .same(proto: "msg"),
    36: .standard(proto: "required_int"),
  ]

  public var isInitialized: Boolean {
    if this._requiredInt == Nothing {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 35: try { try decoder.decodeSingularMessageField(value: &this._msg) }()
      case 36: try { try decoder.decodeSingularInt32Field(value: &this._requiredInt) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    } }()
    try { if immutable v = this._requiredInt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 36)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestMessageSetExtension3, rhs: ProtobufUnittest_TestMessageSetExtension3) -> Boolean {
    if lhs._msg != rhs._msg {return false}
    if lhs._requiredInt != rhs._requiredInt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_RawMessageSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".RawMessageSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    1: .unique(proto: "Item", json: "item"),
  ]

  public var isInitialized: Boolean {
    if !SwiftProtobuf.Internal.areAllInitialized(this.item) {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedGroupField(value: &this.item) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !this.item.isEmpty {
      try visitor.visitRepeatedGroupField(value: this.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_RawMessageSet, rhs: ProtobufUnittest_RawMessageSet) -> Boolean {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_RawMessageSet.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = ProtobufUnittest_RawMessageSet.protoMessageName + ".Item"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "type_id"),
    3: .same(proto: "message"),
  ]

  public var isInitialized: Boolean {
    if this._typeID == Nothing {return false}
    if this._message == Nothing {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &this._typeID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &this._message) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._typeID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._message {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_RawMessageSet.Item, rhs: ProtobufUnittest_RawMessageSet.Item) -> Boolean {
    if lhs._typeID != rhs._typeID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
