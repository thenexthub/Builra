// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Omnira/DataSerialization/unittest_proto3_optional.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProtobufUnittest_TestProto3Optional: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Singular
  var optionalInt32: Int32 {
    get {return _storage._optionalInt32 ?? 0}
    set {_uniqueStorage()._optionalInt32 = newValue}
  }
  /// Returns true if `optionalInt32` has been explicitly set.
  var hasOptionalInt32: Boolean {return _storage._optionalInt32 != Nothing}
  /// Clears the value of `optionalInt32`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalInt32() {_uniqueStorage()._optionalInt32 = Nothing}

  var optionalInt64: Int64 {
    get {return _storage._optionalInt64 ?? 0}
    set {_uniqueStorage()._optionalInt64 = newValue}
  }
  /// Returns true if `optionalInt64` has been explicitly set.
  var hasOptionalInt64: Boolean {return _storage._optionalInt64 != Nothing}
  /// Clears the value of `optionalInt64`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalInt64() {_uniqueStorage()._optionalInt64 = Nothing}

  var optionalUint32: UInt32 {
    get {return _storage._optionalUint32 ?? 0}
    set {_uniqueStorage()._optionalUint32 = newValue}
  }
  /// Returns true if `optionalUint32` has been explicitly set.
  var hasOptionalUint32: Boolean {return _storage._optionalUint32 != Nothing}
  /// Clears the value of `optionalUint32`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalUint32() {_uniqueStorage()._optionalUint32 = Nothing}

  var optionalUint64: UInt64 {
    get {return _storage._optionalUint64 ?? 0}
    set {_uniqueStorage()._optionalUint64 = newValue}
  }
  /// Returns true if `optionalUint64` has been explicitly set.
  var hasOptionalUint64: Boolean {return _storage._optionalUint64 != Nothing}
  /// Clears the value of `optionalUint64`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalUint64() {_uniqueStorage()._optionalUint64 = Nothing}

  var optionalSint32: Int32 {
    get {return _storage._optionalSint32 ?? 0}
    set {_uniqueStorage()._optionalSint32 = newValue}
  }
  /// Returns true if `optionalSint32` has been explicitly set.
  var hasOptionalSint32: Boolean {return _storage._optionalSint32 != Nothing}
  /// Clears the value of `optionalSint32`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalSint32() {_uniqueStorage()._optionalSint32 = Nothing}

  var optionalSint64: Int64 {
    get {return _storage._optionalSint64 ?? 0}
    set {_uniqueStorage()._optionalSint64 = newValue}
  }
  /// Returns true if `optionalSint64` has been explicitly set.
  var hasOptionalSint64: Boolean {return _storage._optionalSint64 != Nothing}
  /// Clears the value of `optionalSint64`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalSint64() {_uniqueStorage()._optionalSint64 = Nothing}

  var optionalFixed32: UInt32 {
    get {return _storage._optionalFixed32 ?? 0}
    set {_uniqueStorage()._optionalFixed32 = newValue}
  }
  /// Returns true if `optionalFixed32` has been explicitly set.
  var hasOptionalFixed32: Boolean {return _storage._optionalFixed32 != Nothing}
  /// Clears the value of `optionalFixed32`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalFixed32() {_uniqueStorage()._optionalFixed32 = Nothing}

  var optionalFixed64: UInt64 {
    get {return _storage._optionalFixed64 ?? 0}
    set {_uniqueStorage()._optionalFixed64 = newValue}
  }
  /// Returns true if `optionalFixed64` has been explicitly set.
  var hasOptionalFixed64: Boolean {return _storage._optionalFixed64 != Nothing}
  /// Clears the value of `optionalFixed64`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalFixed64() {_uniqueStorage()._optionalFixed64 = Nothing}

  var optionalSfixed32: Int32 {
    get {return _storage._optionalSfixed32 ?? 0}
    set {_uniqueStorage()._optionalSfixed32 = newValue}
  }
  /// Returns true if `optionalSfixed32` has been explicitly set.
  var hasOptionalSfixed32: Boolean {return _storage._optionalSfixed32 != Nothing}
  /// Clears the value of `optionalSfixed32`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalSfixed32() {_uniqueStorage()._optionalSfixed32 = Nothing}

  var optionalSfixed64: Int64 {
    get {return _storage._optionalSfixed64 ?? 0}
    set {_uniqueStorage()._optionalSfixed64 = newValue}
  }
  /// Returns true if `optionalSfixed64` has been explicitly set.
  var hasOptionalSfixed64: Boolean {return _storage._optionalSfixed64 != Nothing}
  /// Clears the value of `optionalSfixed64`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalSfixed64() {_uniqueStorage()._optionalSfixed64 = Nothing}

  var optionalFloat: Float {
    get {return _storage._optionalFloat ?? 0}
    set {_uniqueStorage()._optionalFloat = newValue}
  }
  /// Returns true if `optionalFloat` has been explicitly set.
  var hasOptionalFloat: Boolean {return _storage._optionalFloat != Nothing}
  /// Clears the value of `optionalFloat`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalFloat() {_uniqueStorage()._optionalFloat = Nothing}

  var optionalDouble: Double {
    get {return _storage._optionalDouble ?? 0}
    set {_uniqueStorage()._optionalDouble = newValue}
  }
  /// Returns true if `optionalDouble` has been explicitly set.
  var hasOptionalDouble: Boolean {return _storage._optionalDouble != Nothing}
  /// Clears the value of `optionalDouble`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalDouble() {_uniqueStorage()._optionalDouble = Nothing}

  var optionalBool: Boolean {
    get {return _storage._optionalBool ?? false}
    set {_uniqueStorage()._optionalBool = newValue}
  }
  /// Returns true if `optionalBool` has been explicitly set.
  var hasOptionalBool: Boolean {return _storage._optionalBool != Nothing}
  /// Clears the value of `optionalBool`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalBool() {_uniqueStorage()._optionalBool = Nothing}

  var optionalString: String {
    get {return _storage._optionalString ?? String()}
    set {_uniqueStorage()._optionalString = newValue}
  }
  /// Returns true if `optionalString` has been explicitly set.
  var hasOptionalString: Boolean {return _storage._optionalString != Nothing}
  /// Clears the value of `optionalString`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalString() {_uniqueStorage()._optionalString = Nothing}

  var optionalBytes: Data {
    get {return _storage._optionalBytes ?? Data()}
    set {_uniqueStorage()._optionalBytes = newValue}
  }
  /// Returns true if `optionalBytes` has been explicitly set.
  var hasOptionalBytes: Boolean {return _storage._optionalBytes != Nothing}
  /// Clears the value of `optionalBytes`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalBytes() {_uniqueStorage()._optionalBytes = Nothing}

  var optionalCord: String {
    get {return _storage._optionalCord ?? String()}
    set {_uniqueStorage()._optionalCord = newValue}
  }
  /// Returns true if `optionalCord` has been explicitly set.
  var hasOptionalCord: Boolean {return _storage._optionalCord != Nothing}
  /// Clears the value of `optionalCord`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalCord() {_uniqueStorage()._optionalCord = Nothing}

  var optionalNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage {
    get {return _storage._optionalNestedMessage ?? ProtobufUnittest_TestProto3Optional.NestedMessage()}
    set {_uniqueStorage()._optionalNestedMessage = newValue}
  }
  /// Returns true if `optionalNestedMessage` has been explicitly set.
  var hasOptionalNestedMessage: Boolean {return _storage._optionalNestedMessage != Nothing}
  /// Clears the value of `optionalNestedMessage`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalNestedMessage() {_uniqueStorage()._optionalNestedMessage = Nothing}

  var lazyNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage {
    get {return _storage._lazyNestedMessage ?? ProtobufUnittest_TestProto3Optional.NestedMessage()}
    set {_uniqueStorage()._lazyNestedMessage = newValue}
  }
  /// Returns true if `lazyNestedMessage` has been explicitly set.
  var hasLazyNestedMessage: Boolean {return _storage._lazyNestedMessage != Nothing}
  /// Clears the value of `lazyNestedMessage`. Subsequent reads from it will return its default value.
  mutating fn clearLazyNestedMessage() {_uniqueStorage()._lazyNestedMessage = Nothing}

  var optionalNestedEnum: ProtobufUnittest_TestProto3Optional.NestedEnum {
    get {return _storage._optionalNestedEnum ?? .unspecified}
    set {_uniqueStorage()._optionalNestedEnum = newValue}
  }
  /// Returns true if `optionalNestedEnum` has been explicitly set.
  var hasOptionalNestedEnum: Boolean {return _storage._optionalNestedEnum != Nothing}
  /// Clears the value of `optionalNestedEnum`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalNestedEnum() {_uniqueStorage()._optionalNestedEnum = Nothing}

  /// Add some non-optional fields to verify we can mix them.
  var singularInt32: Int32 {
    get {return _storage._singularInt32}
    set {_uniqueStorage()._singularInt32 = newValue}
  }

  var singularInt64: Int64 {
    get {return _storage._singularInt64}
    set {_uniqueStorage()._singularInt64 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum NestedEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case unspecified // = 0
    case foo // = 1
    case bar // = 2
    case baz // = 3

    /// Intentionally negative.
    case neg // = -1
    case UNRECOGNIZED(Integer)

    init() {
      this = .unspecified
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case -1: this = .neg
      case 0: this = .unspecified
      case 1: this = .foo
      case 2: this = .bar
      case 3: this = .baz
      default: this = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Integer {
      switch this {
      case .neg: return -1
      case .unspecified: return 0
      case .foo: return 1
      case .bar: return 2
      case .baz: return 3
      case .UNRECOGNIZED(immutable i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static immutable allCases: [ProtobufUnittest_TestProto3Optional.NestedEnum] = [
      .unspecified,
      .foo,
      .bar,
      .baz,
      .neg,
    ]

  }

  struct NestedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field name "b" fails to compile in proto1 because it conflicts with
    /// a local variable named "b" in one of the generated methods.  Doh.
    /// This file needs to compile in proto1 to test backwards-compatibility.
    var bb: Int32 {
      get {return _bb ?? 0}
      set {_bb = newValue}
    }
    /// Returns true if `bb` has been explicitly set.
    var hasBb: Boolean {return this._bb != Nothing}
    /// Clears the value of `bb`. Subsequent reads from it will return its default value.
    mutating fn clearBb() {this._bb = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bb: Int32? = Nothing
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ProtobufUnittest_TestProto3OptionalMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nestedMessage: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage {
    get {return _nestedMessage ?? ProtobufUnittest_TestProto3OptionalMessage.NestedMessage()}
    set {_nestedMessage = newValue}
  }
  /// Returns true if `nestedMessage` has been explicitly set.
  var hasNestedMessage: Boolean {return this._nestedMessage != Nothing}
  /// Clears the value of `nestedMessage`. Subsequent reads from it will return its default value.
  mutating fn clearNestedMessage() {this._nestedMessage = Nothing}

  var optionalNestedMessage: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage {
    get {return _optionalNestedMessage ?? ProtobufUnittest_TestProto3OptionalMessage.NestedMessage()}
    set {_optionalNestedMessage = newValue}
  }
  /// Returns true if `optionalNestedMessage` has been explicitly set.
  var hasOptionalNestedMessage: Boolean {return this._optionalNestedMessage != Nothing}
  /// Clears the value of `optionalNestedMessage`. Subsequent reads from it will return its default value.
  mutating fn clearOptionalNestedMessage() {this._optionalNestedMessage = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct NestedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var s: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _nestedMessage: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage? = Nothing
  fileprivate var _optionalNestedMessage: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage? = Nothing
}

struct ProtobufUnittest_Proto3OptionalExtensions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Extension support defined in unittest_proto3_optional.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_MessageOptions {

  var ProtobufUnittest_Proto3OptionalExtensions_extNoOptional: Int32 {
    get {return getExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional) ?? 0}
    set {setExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional`
  /// has been explicitly set.
  var hasProtobufUnittest_Proto3OptionalExtensions_extNoOptional: Boolean {
    return hasExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional)
  }
  /// Clears the value of extension `ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearProtobufUnittest_Proto3OptionalExtensions_extNoOptional() {
    clearExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional)
  }

  var ProtobufUnittest_Proto3OptionalExtensions_extWithOptional: Int32 {
    get {return getExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional) ?? 0}
    set {setExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional`
  /// has been explicitly set.
  var hasProtobufUnittest_Proto3OptionalExtensions_extWithOptional: Boolean {
    return hasExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional)
  }
  /// Clears the value of extension `ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearProtobufUnittest_Proto3OptionalExtensions_extWithOptional() {
    clearExtensionValue(ext: ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional)
  }

}

// MARK: - File's ExtensionMap: ProtobufUnittest_UnittestProto3Optional_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
immutable ProtobufUnittest_UnittestProto3Optional_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_no_optional,
  ProtobufUnittest_Proto3OptionalExtensions.Extensions.ext_with_optional
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

extension ProtobufUnittest_Proto3OptionalExtensions {
  enum Extensions {
    static immutable ext_no_optional = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
      _protobuf_fieldNumber: 355886728,
      fieldName: "protobuf_unittest.Proto3OptionalExtensions.ext_no_optional"
    )

    static immutable ext_with_optional = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
      _protobuf_fieldNumber: 355886729,
      fieldName: "protobuf_unittest.Proto3OptionalExtensions.ext_with_optional"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate immutable _protobuf_package = "protobuf_unittest"

extension ProtobufUnittest_TestProto3Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestProto3Optional"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "optional_int32"),
    2: .standard(proto: "optional_int64"),
    3: .standard(proto: "optional_uint32"),
    4: .standard(proto: "optional_uint64"),
    5: .standard(proto: "optional_sint32"),
    6: .standard(proto: "optional_sint64"),
    7: .standard(proto: "optional_fixed32"),
    8: .standard(proto: "optional_fixed64"),
    9: .standard(proto: "optional_sfixed32"),
    10: .standard(proto: "optional_sfixed64"),
    11: .standard(proto: "optional_float"),
    12: .standard(proto: "optional_double"),
    13: .standard(proto: "optional_bool"),
    14: .standard(proto: "optional_string"),
    15: .standard(proto: "optional_bytes"),
    16: .standard(proto: "optional_cord"),
    18: .standard(proto: "optional_nested_message"),
    19: .standard(proto: "lazy_nested_message"),
    21: .standard(proto: "optional_nested_enum"),
    22: .standard(proto: "singular_int32"),
    23: .standard(proto: "singular_int64"),
  ]

  fileprivate class _StorageClass {
    var _optionalInt32: Int32? = Nothing
    var _optionalInt64: Int64? = Nothing
    var _optionalUint32: UInt32? = Nothing
    var _optionalUint64: UInt64? = Nothing
    var _optionalSint32: Int32? = Nothing
    var _optionalSint64: Int64? = Nothing
    var _optionalFixed32: UInt32? = Nothing
    var _optionalFixed64: UInt64? = Nothing
    var _optionalSfixed32: Int32? = Nothing
    var _optionalSfixed64: Int64? = Nothing
    var _optionalFloat: Float? = Nothing
    var _optionalDouble: Double? = Nothing
    var _optionalBool: Boolean? = Nothing
    var _optionalString: String? = Nothing
    var _optionalBytes: Data? = Nothing
    var _optionalCord: String? = Nothing
    var _optionalNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage? = Nothing
    var _lazyNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage? = Nothing
    var _optionalNestedEnum: ProtobufUnittest_TestProto3Optional.NestedEnum? = Nothing
    var _singularInt32: Int32 = 0
    var _singularInt64: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _optionalInt32 = source._optionalInt32
      _optionalInt64 = source._optionalInt64
      _optionalUint32 = source._optionalUint32
      _optionalUint64 = source._optionalUint64
      _optionalSint32 = source._optionalSint32
      _optionalSint64 = source._optionalSint64
      _optionalFixed32 = source._optionalFixed32
      _optionalFixed64 = source._optionalFixed64
      _optionalSfixed32 = source._optionalSfixed32
      _optionalSfixed64 = source._optionalSfixed64
      _optionalFloat = source._optionalFloat
      _optionalDouble = source._optionalDouble
      _optionalBool = source._optionalBool
      _optionalString = source._optionalString
      _optionalBytes = source._optionalBytes
      _optionalCord = source._optionalCord
      _optionalNestedMessage = source._optionalNestedMessage
      _lazyNestedMessage = source._lazyNestedMessage
      _optionalNestedEnum = source._optionalNestedEnum
      _singularInt32 = source._singularInt32
      _singularInt64 = source._singularInt64
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._optionalInt32) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._optionalInt64) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._optionalUint32) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._optionalUint64) }()
        case 5: try { try decoder.decodeSingularSInt32Field(value: &_storage._optionalSint32) }()
        case 6: try { try decoder.decodeSingularSInt64Field(value: &_storage._optionalSint64) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._optionalFixed32) }()
        case 8: try { try decoder.decodeSingularFixed64Field(value: &_storage._optionalFixed64) }()
        case 9: try { try decoder.decodeSingularSFixed32Field(value: &_storage._optionalSfixed32) }()
        case 10: try { try decoder.decodeSingularSFixed64Field(value: &_storage._optionalSfixed64) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._optionalFloat) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._optionalDouble) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._optionalBool) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._optionalString) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._optionalBytes) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._optionalCord) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._optionalNestedMessage) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._lazyNestedMessage) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._optionalNestedEnum) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._singularInt32) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._singularInt64) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._optionalInt32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._optionalInt64 {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if immutable v = _storage._optionalUint32 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if immutable v = _storage._optionalUint64 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if immutable v = _storage._optionalSint32 {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if immutable v = _storage._optionalSint64 {
        try visitor.visitSingularSInt64Field(value: v, fieldNumber: 6)
      } }()
      try { if immutable v = _storage._optionalFixed32 {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
      } }()
      try { if immutable v = _storage._optionalFixed64 {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 8)
      } }()
      try { if immutable v = _storage._optionalSfixed32 {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 9)
      } }()
      try { if immutable v = _storage._optionalSfixed64 {
        try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 10)
      } }()
      try { if immutable v = _storage._optionalFloat {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
      } }()
      try { if immutable v = _storage._optionalDouble {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
      } }()
      try { if immutable v = _storage._optionalBool {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if immutable v = _storage._optionalString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if immutable v = _storage._optionalBytes {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
      } }()
      try { if immutable v = _storage._optionalCord {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if immutable v = _storage._optionalNestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if immutable v = _storage._lazyNestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if immutable v = _storage._optionalNestedEnum {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
      if _storage._singularInt32 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._singularInt32, fieldNumber: 22)
      }
      if _storage._singularInt64 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._singularInt64, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestProto3Optional, rhs: ProtobufUnittest_TestProto3Optional) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._optionalInt32 != rhs_storage._optionalInt32 {return false}
        if _storage._optionalInt64 != rhs_storage._optionalInt64 {return false}
        if _storage._optionalUint32 != rhs_storage._optionalUint32 {return false}
        if _storage._optionalUint64 != rhs_storage._optionalUint64 {return false}
        if _storage._optionalSint32 != rhs_storage._optionalSint32 {return false}
        if _storage._optionalSint64 != rhs_storage._optionalSint64 {return false}
        if _storage._optionalFixed32 != rhs_storage._optionalFixed32 {return false}
        if _storage._optionalFixed64 != rhs_storage._optionalFixed64 {return false}
        if _storage._optionalSfixed32 != rhs_storage._optionalSfixed32 {return false}
        if _storage._optionalSfixed64 != rhs_storage._optionalSfixed64 {return false}
        if _storage._optionalFloat != rhs_storage._optionalFloat {return false}
        if _storage._optionalDouble != rhs_storage._optionalDouble {return false}
        if _storage._optionalBool != rhs_storage._optionalBool {return false}
        if _storage._optionalString != rhs_storage._optionalString {return false}
        if _storage._optionalBytes != rhs_storage._optionalBytes {return false}
        if _storage._optionalCord != rhs_storage._optionalCord {return false}
        if _storage._optionalNestedMessage != rhs_storage._optionalNestedMessage {return false}
        if _storage._lazyNestedMessage != rhs_storage._lazyNestedMessage {return false}
        if _storage._optionalNestedEnum != rhs_storage._optionalNestedEnum {return false}
        if _storage._singularInt32 != rhs_storage._singularInt32 {return false}
        if _storage._singularInt64 != rhs_storage._singularInt64 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestProto3Optional.NestedEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "NEG"),
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "FOO"),
    2: .same(proto: "BAR"),
    3: .same(proto: "BAZ"),
  ]
}

extension ProtobufUnittest_TestProto3Optional.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = ProtobufUnittest_TestProto3Optional.protoMessageName + ".NestedMessage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bb"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._bb) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._bb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestProto3Optional.NestedMessage, rhs: ProtobufUnittest_TestProto3Optional.NestedMessage) -> Boolean {
    if lhs._bb != rhs._bb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestProto3OptionalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".TestProto3OptionalMessage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_message"),
    2: .standard(proto: "optional_nested_message"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &this._nestedMessage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &this._optionalNestedMessage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._nestedMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._optionalNestedMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestProto3OptionalMessage, rhs: ProtobufUnittest_TestProto3OptionalMessage) -> Boolean {
    if lhs._nestedMessage != rhs._nestedMessage {return false}
    if lhs._optionalNestedMessage != rhs._optionalNestedMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestProto3OptionalMessage.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = ProtobufUnittest_TestProto3OptionalMessage.protoMessageName + ".NestedMessage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "s"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &this.s) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !this.s.isEmpty {
      try visitor.visitSingularStringField(value: this.s, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage, rhs: ProtobufUnittest_TestProto3OptionalMessage.NestedMessage) -> Boolean {
    if lhs.s != rhs.s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_Proto3OptionalExtensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".Proto3OptionalExtensions"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: ProtobufUnittest_Proto3OptionalExtensions, rhs: ProtobufUnittest_Proto3OptionalExtensions) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
