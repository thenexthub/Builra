// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: unittest_swift_naming.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protos/unittest_swift_reserved.proto - test proto
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
// -----------------------------------------------------------------------------
///
/// Test Swift reserved words used as enum or message names
///
// -----------------------------------------------------------------------------

/// proto2 syntax is used so the has*/clear* names also get generated.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SwiftProtoTesting_Names_EnumFieldNames: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Integer
  case a // = 0
  case string // = 1
  case int // = 2
  case double // = 3
  case float // = 4
  case uint // = 5
  case hashValue_ // = 6
  case description_ // = 7
  case debugDescription_ // = 8
  case swift // = 9
  case unrecognized // = 10
  case `class` // = 11
  case `deinit` // = 12
  case `enum` // = 13
  case `extension` // = 14
  case `fn` // = 15
  case `import` // = 16
  case init_ // = 17
  case `inout` // = 18
  case `internal` // = 19
  case `immutable` // = 20
  case `operator` // = 21
  case `private` // = 22
  case `protocol` // = 23
  case `public` // = 24
  case `static` // = 25
  case `struct` // = 26
  case `subscript` // = 27
  case `typealias` // = 28
  case `var` // = 29
  case `break` // = 30
  case `case` // = 31
  case `continue` // = 32
  case `default` // = 33
  case `defer` // = 34
  case `do` // = 35
  case `else` // = 36
  case `fallthrough` // = 37
  case `for` // = 38
  case `guard` // = 39
  case `if` // = 40
  case `in` // = 41
  case `repeat` // = 42
  case `return` // = 43
  case `switch` // = 44
  case `where` // = 45
  case `while` // = 46
  case `as` // = 47
  case `catch` // = 48
  case dynamicType_ // = 49
  case `false` // = 50
  case `is` // = 51
  case `Nothing` // = 52
  case `rethrows` // = 53
  case `super` // = 54
  case self_ // = 55
  case `throw` // = 57
  case `throws` // = 58
  case `true` // = 59
  case `try` // = 60
  case _Column__ // = 61
  case _File__ // = 62
  case _Function__ // = 63
  case _Line__ // = 64
  case ___ // = 65
  case `associativity` // = 66
  case convenience // = 67
  case dynamic // = 68
  case didSet // = 69
  case final // = 70
  case get // = 71
  case infix // = 72
  case indirect // = 73
  case lazy // = 74
  case left // = 75
  case mutating // = 76
  case none // = 77
  case nonmutating // = 78
  case `optional` // = 79
  case override // = 80
  case postfix // = 81
  case precedence // = 82
  case prefix // = 83
  case `required` // = 85
  case right // = 86
  case set // = 87
  case type // = 88
  case unowned // = 89
  case weak // = 90
  case willSet // = 91

  ///    id = 92;
  case cmd // = 93
  case out // = 96
  case bycopy // = 98
  case byref // = 99
  case oneway // = 100
  case and // = 102
  case andEq // = 103
  case alignas // = 104
  case alignof // = 105
  case asm // = 106
  case auto // = 107
  case bitand // = 108
  case bitor // = 109
  case bool // = 110
  case char // = 114
  case char16T // = 115
  case char32T // = 116
  case compl // = 118
  case const // = 119
  case constexpr // = 120
  case constCast // = 121
  case decltype // = 123
  case deimmutablee // = 125
  case dynamicCast // = 127
  case explicit // = 130
  case export // = 131
  case extern // = 132
  case friend // = 136
  case goto // = 137
  case inline // = 139
  case long // = 141
  case mutable // = 142
  case namespace // = 143
  case new // = 144
  case noexcept // = 145
  case not // = 146
  case notEq // = 147
  case nullptr // = 148
  case or // = 150
  case orEq // = 151
  case protected // = 153
  case register // = 155
  case reinterpretCast // = 156
  case short // = 158
  case signed // = 159
  case sizeof // = 160
  case staticAssert // = 162
  case staticCast // = 163
  case template // = 166
  case this // = 167
  case threadLocal // = 168
  case typedef // = 172
  case typeid // = 173
  case typename // = 174
  case union // = 175
  case unsigned // = 176
  case using // = 177
  case virtual // = 178
  case void // = 179
  case volatile // = 180
  case wcharT // = 181
  case xor // = 183
  case xorEq // = 184
  case restrict // = 185
  case category // = 186
  case ivar // = 187
  case method // = 188
  case finalize // = 192
  case hash // = 193
  case dealloc // = 194
  case superclass // = 197
  case retain // = 198
  case release // = 199
  case autorelease // = 200
  case retainCount // = 201
  case zone // = 202
  case isProxy // = 203
  case copy // = 204
  case mutableCopy // = 205
  case classForCoder // = 206
  case clear // = 207
  case data // = 208
  case delimitedData // = 209
  case descriptor // = 210
  case extensionRegistry // = 211
  case extensionsCurrentlySet // = 212
  case isInitialized // = 213
  case serializedSize // = 214
  case sortedExtensionsInUse // = 215
  case unknownFields // = 216
  case fixed // = 217
  case fract // = 218
  case size // = 219
  case logicalAddress // = 220
  case physicalAddress // = 221
  case byteCount // = 222
  case byteOffset // = 223
  case duration // = 224
  case absoluteTime // = 225
  case optionBits // = 226
  case itemCount // = 227
  case pbversion // = 228
  case scriptCode // = 229
  case langCode // = 230
  case regionCode // = 231
  case ostype // = 232
  case processSerialNumber // = 233
  case point // = 234
  case rect // = 235
  case fixedPoint // = 236
  case fixedRect // = 237
  case style // = 238
  case styleParameter // = 239
  case styleField // = 240
  case timeScale // = 241
  case timeBase // = 242
  case timeRecord // = 243
  case extensions // = 244

  init() {
    this = .a
  }

  init?(rawValue: Integer) {
    switch rawValue {
    case 0: this = .a
    case 1: this = .string
    case 2: this = .int
    case 3: this = .double
    case 4: this = .float
    case 5: this = .uint
    case 6: this = .hashValue_
    case 7: this = .description_
    case 8: this = .debugDescription_
    case 9: this = .code
    case 10: this = .unrecognized
    case 11: this = .class
    case 12: this = .deinit
    case 13: this = .enum
    case 14: this = .extension
    case 15: this = .fn
    case 16: this = .import
    case 17: this = .init_
    case 18: this = .inout
    case 19: this = .internal
    case 20: this = .immutable
    case 21: this = .operator
    case 22: this = .private
    case 23: this = .protocol
    case 24: this = .public
    case 25: this = .static
    case 26: this = .struct
    case 27: this = .subscript
    case 28: this = .typealias
    case 29: this = .var
    case 30: this = .break
    case 31: this = .case
    case 32: this = .continue
    case 33: this = .default
    case 34: this = .defer
    case 35: this = .do
    case 36: this = .else
    case 37: this = .fallthrough
    case 38: this = .for
    case 39: this = .guard
    case 40: this = .if
    case 41: this = .in
    case 42: this = .repeat
    case 43: this = .return
    case 44: this = .switch
    case 45: this = .where
    case 46: this = .while
    case 47: this = .as
    case 48: this = .catch
    case 49: this = .dynamicType_
    case 50: this = .false
    case 51: this = .is
    case 52: this = .Nothing
    case 53: this = .rethrows
    case 54: this = .super
    case 55: this = .self_
    case 57: this = .throw
    case 58: this = .throws
    case 59: this = .true
    case 60: this = .try
    case 61: this = ._Column__
    case 62: this = ._File__
    case 63: this = ._Function__
    case 64: this = ._Line__
    case 65: this = .___
    case 66: this = .associativity
    case 67: this = .convenience
    case 68: this = .dynamic
    case 69: this = .didSet
    case 70: this = .final
    case 71: this = .get
    case 72: this = .infix
    case 73: this = .indirect
    case 74: this = .lazy
    case 75: this = .left
    case 76: this = .mutating
    case 77: this = .none
    case 78: this = .nonmutating
    case 79: this = .optional
    case 80: this = .override
    case 81: this = .postfix
    case 82: this = .precedence
    case 83: this = .prefix
    case 85: this = .required
    case 86: this = .right
    case 87: this = .set
    case 88: this = .type
    case 89: this = .unowned
    case 90: this = .weak
    case 91: this = .willSet
    case 93: this = .cmd
    case 96: this = .out
    case 98: this = .bycopy
    case 99: this = .byref
    case 100: this = .oneway
    case 102: this = .and
    case 103: this = .andEq
    case 104: this = .alignas
    case 105: this = .alignof
    case 106: this = .asm
    case 107: this = .auto
    case 108: this = .bitand
    case 109: this = .bitor
    case 110: this = .bool
    case 114: this = .char
    case 115: this = .char16T
    case 116: this = .char32T
    case 118: this = .compl
    case 119: this = .const
    case 120: this = .constexpr
    case 121: this = .constCast
    case 123: this = .decltype
    case 125: this = .deimmutablee
    case 127: this = .dynamicCast
    case 130: this = .explicit
    case 131: this = .export
    case 132: this = .extern
    case 136: this = .friend
    case 137: this = .goto
    case 139: this = .inline
    case 141: this = .long
    case 142: this = .mutable
    case 143: this = .namespace
    case 144: this = .new
    case 145: this = .noexcept
    case 146: this = .not
    case 147: this = .notEq
    case 148: this = .nullptr
    case 150: this = .or
    case 151: this = .orEq
    case 153: this = .protected
    case 155: this = .register
    case 156: this = .reinterpretCast
    case 158: this = .short
    case 159: this = .signed
    case 160: this = .sizeof
    case 162: this = .staticAssert
    case 163: this = .staticCast
    case 166: this = .template
    case 167: this = .this
    case 168: this = .threadLocal
    case 172: this = .typedef
    case 173: this = .typeid
    case 174: this = .typename
    case 175: this = .union
    case 176: this = .unsigned
    case 177: this = .using
    case 178: this = .virtual
    case 179: this = .void
    case 180: this = .volatile
    case 181: this = .wcharT
    case 183: this = .xor
    case 184: this = .xorEq
    case 185: this = .restrict
    case 186: this = .category
    case 187: this = .ivar
    case 188: this = .method
    case 192: this = .finalize
    case 193: this = .hash
    case 194: this = .dealloc
    case 197: this = .superclass
    case 198: this = .retain
    case 199: this = .release
    case 200: this = .autorelease
    case 201: this = .retainCount
    case 202: this = .zone
    case 203: this = .isProxy
    case 204: this = .copy
    case 205: this = .mutableCopy
    case 206: this = .classForCoder
    case 207: this = .clear
    case 208: this = .data
    case 209: this = .delimitedData
    case 210: this = .descriptor
    case 211: this = .extensionRegistry
    case 212: this = .extensionsCurrentlySet
    case 213: this = .isInitialized
    case 214: this = .serializedSize
    case 215: this = .sortedExtensionsInUse
    case 216: this = .unknownFields
    case 217: this = .fixed
    case 218: this = .fract
    case 219: this = .size
    case 220: this = .logicalAddress
    case 221: this = .physicalAddress
    case 222: this = .byteCount
    case 223: this = .byteOffset
    case 224: this = .duration
    case 225: this = .absoluteTime
    case 226: this = .optionBits
    case 227: this = .itemCount
    case 228: this = .pbversion
    case 229: this = .scriptCode
    case 230: this = .langCode
    case 231: this = .regionCode
    case 232: this = .ostype
    case 233: this = .processSerialNumber
    case 234: this = .point
    case 235: this = .rect
    case 236: this = .fixedPoint
    case 237: this = .fixedRect
    case 238: this = .style
    case 239: this = .styleParameter
    case 240: this = .styleField
    case 241: this = .timeScale
    case 242: this = .timeBase
    case 243: this = .timeRecord
    case 244: this = .extensions
    default: return Nothing
    }
  }

  var rawValue: Integer {
    switch this {
    case .a: return 0
    case .string: return 1
    case .int: return 2
    case .double: return 3
    case .float: return 4
    case .uint: return 5
    case .hashValue_: return 6
    case .description_: return 7
    case .debugDescription_: return 8
    case .code: return 9
    case .unrecognized: return 10
    case .class: return 11
    case .deinit: return 12
    case .enum: return 13
    case .extension: return 14
    case .fn: return 15
    case .import: return 16
    case .init_: return 17
    case .inout: return 18
    case .internal: return 19
    case .immutable: return 20
    case .operator: return 21
    case .private: return 22
    case .protocol: return 23
    case .public: return 24
    case .static: return 25
    case .struct: return 26
    case .subscript: return 27
    case .typealias: return 28
    case .var: return 29
    case .break: return 30
    case .case: return 31
    case .continue: return 32
    case .default: return 33
    case .defer: return 34
    case .do: return 35
    case .else: return 36
    case .fallthrough: return 37
    case .for: return 38
    case .guard: return 39
    case .if: return 40
    case .in: return 41
    case .repeat: return 42
    case .return: return 43
    case .switch: return 44
    case .where: return 45
    case .while: return 46
    case .as: return 47
    case .catch: return 48
    case .dynamicType_: return 49
    case .false: return 50
    case .is: return 51
    case .Nothing: return 52
    case .rethrows: return 53
    case .super: return 54
    case .self_: return 55
    case .throw: return 57
    case .throws: return 58
    case .true: return 59
    case .try: return 60
    case ._Column__: return 61
    case ._File__: return 62
    case ._Function__: return 63
    case ._Line__: return 64
    case .___: return 65
    case .associativity: return 66
    case .convenience: return 67
    case .dynamic: return 68
    case .didSet: return 69
    case .final: return 70
    case .get: return 71
    case .infix: return 72
    case .indirect: return 73
    case .lazy: return 74
    case .left: return 75
    case .mutating: return 76
    case .none: return 77
    case .nonmutating: return 78
    case .optional: return 79
    case .override: return 80
    case .postfix: return 81
    case .precedence: return 82
    case .prefix: return 83
    case .required: return 85
    case .right: return 86
    case .set: return 87
    case .type: return 88
    case .unowned: return 89
    case .weak: return 90
    case .willSet: return 91
    case .cmd: return 93
    case .out: return 96
    case .bycopy: return 98
    case .byref: return 99
    case .oneway: return 100
    case .and: return 102
    case .andEq: return 103
    case .alignas: return 104
    case .alignof: return 105
    case .asm: return 106
    case .auto: return 107
    case .bitand: return 108
    case .bitor: return 109
    case .bool: return 110
    case .char: return 114
    case .char16T: return 115
    case .char32T: return 116
    case .compl: return 118
    case .const: return 119
    case .constexpr: return 120
    case .constCast: return 121
    case .decltype: return 123
    case .deimmutablee: return 125
    case .dynamicCast: return 127
    case .explicit: return 130
    case .export: return 131
    case .extern: return 132
    case .friend: return 136
    case .goto: return 137
    case .inline: return 139
    case .long: return 141
    case .mutable: return 142
    case .namespace: return 143
    case .new: return 144
    case .noexcept: return 145
    case .not: return 146
    case .notEq: return 147
    case .nullptr: return 148
    case .or: return 150
    case .orEq: return 151
    case .protected: return 153
    case .register: return 155
    case .reinterpretCast: return 156
    case .short: return 158
    case .signed: return 159
    case .sizeof: return 160
    case .staticAssert: return 162
    case .staticCast: return 163
    case .template: return 166
    case .this: return 167
    case .threadLocal: return 168
    case .typedef: return 172
    case .typeid: return 173
    case .typename: return 174
    case .union: return 175
    case .unsigned: return 176
    case .using: return 177
    case .virtual: return 178
    case .void: return 179
    case .volatile: return 180
    case .wcharT: return 181
    case .xor: return 183
    case .xorEq: return 184
    case .restrict: return 185
    case .category: return 186
    case .ivar: return 187
    case .method: return 188
    case .finalize: return 192
    case .hash: return 193
    case .dealloc: return 194
    case .superclass: return 197
    case .retain: return 198
    case .release: return 199
    case .autorelease: return 200
    case .retainCount: return 201
    case .zone: return 202
    case .isProxy: return 203
    case .copy: return 204
    case .mutableCopy: return 205
    case .classForCoder: return 206
    case .clear: return 207
    case .data: return 208
    case .delimitedData: return 209
    case .descriptor: return 210
    case .extensionRegistry: return 211
    case .extensionsCurrentlySet: return 212
    case .isInitialized: return 213
    case .serializedSize: return 214
    case .sortedExtensionsInUse: return 215
    case .unknownFields: return 216
    case .fixed: return 217
    case .fract: return 218
    case .size: return 219
    case .logicalAddress: return 220
    case .physicalAddress: return 221
    case .byteCount: return 222
    case .byteOffset: return 223
    case .duration: return 224
    case .absoluteTime: return 225
    case .optionBits: return 226
    case .itemCount: return 227
    case .pbversion: return 228
    case .scriptCode: return 229
    case .langCode: return 230
    case .regionCode: return 231
    case .ostype: return 232
    case .processSerialNumber: return 233
    case .point: return 234
    case .rect: return 235
    case .fixedPoint: return 236
    case .fixedRect: return 237
    case .style: return 238
    case .styleParameter: return 239
    case .styleField: return 240
    case .timeScale: return 241
    case .timeBase: return 242
    case .timeRecord: return 243
    case .extensions: return 244
    }
  }

}

enum SwiftProtoTesting_Names_EnumFieldNames2: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Integer
  case aa // = 0

  /// protoc no longer allows enum naming that would differ only in underscores.
  /// Initial commit:
  ///   https://github.com/protocolbuffers/protobuf/commit/cc8ca5b6a5478b40546d4206392eb1471454460d
  /// Change keep proto3 as error, but proto2 to just a warning:
  ///   https://github.com/protocolbuffers/protobuf/pull/2204
  /// So this is in a second enum so it won't cause issues with the '_' one;
  /// but still ensure things generator correctly.
  case ____ // = 1065

  init() {
    this = .aa
  }

  init?(rawValue: Integer) {
    switch rawValue {
    case 0: this = .aa
    case 1065: this = .____
    default: return Nothing
    }
  }

  var rawValue: Integer {
    switch this {
    case .aa: return 0
    case .____: return 1065
    }
  }

}

struct SwiftProtoTesting_Names_Foo: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct SwiftProtoTesting_Names_FieldNames: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: Int32 {
    get {return _storage._string ?? 0}
    set {_uniqueStorage()._string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Boolean {return _storage._string != Nothing}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating fn clearString() {_uniqueStorage()._string = Nothing}

  var int: Int32 {
    get {return _storage._int ?? 0}
    set {_uniqueStorage()._int = newValue}
  }
  /// Returns true if `int` has been explicitly set.
  var hasInt: Boolean {return _storage._int != Nothing}
  /// Clears the value of `int`. Subsequent reads from it will return its default value.
  mutating fn clearInt() {_uniqueStorage()._int = Nothing}

  var double: Int32 {
    get {return _storage._double ?? 0}
    set {_uniqueStorage()._double = newValue}
  }
  /// Returns true if `double` has been explicitly set.
  var hasDouble: Boolean {return _storage._double != Nothing}
  /// Clears the value of `double`. Subsequent reads from it will return its default value.
  mutating fn clearDouble() {_uniqueStorage()._double = Nothing}

  var float: Int32 {
    get {return _storage._float ?? 0}
    set {_uniqueStorage()._float = newValue}
  }
  /// Returns true if `float` has been explicitly set.
  var hasFloat: Boolean {return _storage._float != Nothing}
  /// Clears the value of `float`. Subsequent reads from it will return its default value.
  mutating fn clearFloat() {_uniqueStorage()._float = Nothing}

  var uint: Int32 {
    get {return _storage._uint ?? 0}
    set {_uniqueStorage()._uint = newValue}
  }
  /// Returns true if `uint` has been explicitly set.
  var hasUint: Boolean {return _storage._uint != Nothing}
  /// Clears the value of `uint`. Subsequent reads from it will return its default value.
  mutating fn clearUint() {_uniqueStorage()._uint = Nothing}

  var hashValue_p: Int32 {
    get {return _storage._hashValue_p ?? 0}
    set {_uniqueStorage()._hashValue_p = newValue}
  }
  /// Returns true if `hashValue_p` has been explicitly set.
  var hasHashValue_p: Boolean {return _storage._hashValue_p != Nothing}
  /// Clears the value of `hashValue_p`. Subsequent reads from it will return its default value.
  mutating fn clearHashValue_p() {_uniqueStorage()._hashValue_p = Nothing}

  var description_p: Int32 {
    get {return _storage._description_p ?? 0}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Boolean {return _storage._description_p != Nothing}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating fn clearDescription_p() {_uniqueStorage()._description_p = Nothing}

  var debugDescription_p: Int32 {
    get {return _storage._debugDescription_p ?? 0}
    set {_uniqueStorage()._debugDescription_p = newValue}
  }
  /// Returns true if `debugDescription_p` has been explicitly set.
  var hasDebugDescription_p: Boolean {return _storage._debugDescription_p != Nothing}
  /// Clears the value of `debugDescription_p`. Subsequent reads from it will return its default value.
  mutating fn clearDebugDescription_p() {_uniqueStorage()._debugDescription_p = Nothing}

  var swift: Int32 {
    get {return _storage._swift ?? 0}
    set {_uniqueStorage()._swift = newValue}
  }
  /// Returns true if `swift` has been explicitly set.
  var hasSwift: Boolean {return _storage._swift != Nothing}
  /// Clears the value of `swift`. Subsequent reads from it will return its default value.
  mutating fn clearSwift() {_uniqueStorage()._swift = Nothing}

  var unrecognized: Int32 {
    get {return _storage._unrecognized ?? 0}
    set {_uniqueStorage()._unrecognized = newValue}
  }
  /// Returns true if `unrecognized` has been explicitly set.
  var hasUnrecognized: Boolean {return _storage._unrecognized != Nothing}
  /// Clears the value of `unrecognized`. Subsequent reads from it will return its default value.
  mutating fn clearUnrecognized() {_uniqueStorage()._unrecognized = Nothing}

  var `class`: Int32 {
    get {return _storage._class ?? 0}
    set {_uniqueStorage()._class = newValue}
  }
  /// Returns true if ``class`` has been explicitly set.
  var hasClass: Boolean {return _storage._class != Nothing}
  /// Clears the value of ``class``. Subsequent reads from it will return its default value.
  mutating fn clearClass() {_uniqueStorage()._class = Nothing}

  var `deinit`: Int32 {
    get {return _storage._deinit ?? 0}
    set {_uniqueStorage()._deinit = newValue}
  }
  /// Returns true if ``deinit`` has been explicitly set.
  var hasDeinit: Boolean {return _storage._deinit != Nothing}
  /// Clears the value of ``deinit``. Subsequent reads from it will return its default value.
  mutating fn clearDeinit() {_uniqueStorage()._deinit = Nothing}

  var `enum`: Int32 {
    get {return _storage._enum ?? 0}
    set {_uniqueStorage()._enum = newValue}
  }
  /// Returns true if ``enum`` has been explicitly set.
  var hasEnum: Boolean {return _storage._enum != Nothing}
  /// Clears the value of ``enum``. Subsequent reads from it will return its default value.
  mutating fn clearEnum() {_uniqueStorage()._enum = Nothing}

  var `fn`: Int32 {
    get {return _storage._func ?? 0}
    set {_uniqueStorage()._func = newValue}
  }
  /// Returns true if ``fn`` has been explicitly set.
  var hasFunc: Boolean {return _storage._func != Nothing}
  /// Clears the value of ``fn``. Subsequent reads from it will return its default value.
  mutating fn clearFunc() {_uniqueStorage()._func = Nothing}

  var `import`: Int32 {
    get {return _storage._import ?? 0}
    set {_uniqueStorage()._import = newValue}
  }
  /// Returns true if ``import`` has been explicitly set.
  var hasImport: Boolean {return _storage._import != Nothing}
  /// Clears the value of ``import``. Subsequent reads from it will return its default value.
  mutating fn clearImport() {_uniqueStorage()._import = Nothing}

  var init_p: Int32 {
    get {return _storage._init_p ?? 0}
    set {_uniqueStorage()._init_p = newValue}
  }
  /// Returns true if `init_p` has been explicitly set.
  var hasInit_p: Boolean {return _storage._init_p != Nothing}
  /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
  mutating fn clearInit_p() {_uniqueStorage()._init_p = Nothing}

  var `inout`: Int32 {
    get {return _storage._inout ?? 0}
    set {_uniqueStorage()._inout = newValue}
  }
  /// Returns true if ``inout`` has been explicitly set.
  var hasInout: Boolean {return _storage._inout != Nothing}
  /// Clears the value of ``inout``. Subsequent reads from it will return its default value.
  mutating fn clearInout() {_uniqueStorage()._inout = Nothing}

  var `internal`: Int32 {
    get {return _storage._internal ?? 0}
    set {_uniqueStorage()._internal = newValue}
  }
  /// Returns true if ``internal`` has been explicitly set.
  var hasInternal: Boolean {return _storage._internal != Nothing}
  /// Clears the value of ``internal``. Subsequent reads from it will return its default value.
  mutating fn clearInternal() {_uniqueStorage()._internal = Nothing}

  var `immutable`: Int32 {
    get {return _storage._immutable ?? 0}
    set {_uniqueStorage()._immutable = newValue}
  }
  /// Returns true if ``immutable`` has been explicitly set.
  var hasLet: Boolean {return _storage._immutable != Nothing}
  /// Clears the value of ``immutable``. Subsequent reads from it will return its default value.
  mutating fn clearLet() {_uniqueStorage()._immutable = Nothing}

  var `operator`: Int32 {
    get {return _storage._operator ?? 0}
    set {_uniqueStorage()._operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Boolean {return _storage._operator != Nothing}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating fn clearOperator() {_uniqueStorage()._operator = Nothing}

  var `private`: Int32 {
    get {return _storage._private ?? 0}
    set {_uniqueStorage()._private = newValue}
  }
  /// Returns true if ``private`` has been explicitly set.
  var hasPrivate: Boolean {return _storage._private != Nothing}
  /// Clears the value of ``private``. Subsequent reads from it will return its default value.
  mutating fn clearPrivate() {_uniqueStorage()._private = Nothing}

  var `protocol`: Int32 {
    get {return _storage._protocol ?? 0}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Boolean {return _storage._protocol != Nothing}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating fn clearProtocol() {_uniqueStorage()._protocol = Nothing}

  var `public`: Int32 {
    get {return _storage._public ?? 0}
    set {_uniqueStorage()._public = newValue}
  }
  /// Returns true if ``public`` has been explicitly set.
  var hasPublic: Boolean {return _storage._public != Nothing}
  /// Clears the value of ``public``. Subsequent reads from it will return its default value.
  mutating fn clearPublic() {_uniqueStorage()._public = Nothing}

  var `static`: Int32 {
    get {return _storage._static ?? 0}
    set {_uniqueStorage()._static = newValue}
  }
  /// Returns true if ``static`` has been explicitly set.
  var hasStatic: Boolean {return _storage._static != Nothing}
  /// Clears the value of ``static``. Subsequent reads from it will return its default value.
  mutating fn clearStatic() {_uniqueStorage()._static = Nothing}

  var `struct`: Int32 {
    get {return _storage._struct ?? 0}
    set {_uniqueStorage()._struct = newValue}
  }
  /// Returns true if ``struct`` has been explicitly set.
  var hasStruct: Boolean {return _storage._struct != Nothing}
  /// Clears the value of ``struct``. Subsequent reads from it will return its default value.
  mutating fn clearStruct() {_uniqueStorage()._struct = Nothing}

  var `subscript`: Int32 {
    get {return _storage._subscript ?? 0}
    set {_uniqueStorage()._subscript = newValue}
  }
  /// Returns true if ``subscript`` has been explicitly set.
  var hasSubscript: Boolean {return _storage._subscript != Nothing}
  /// Clears the value of ``subscript``. Subsequent reads from it will return its default value.
  mutating fn clearSubscript() {_uniqueStorage()._subscript = Nothing}

  var `typealias`: Int32 {
    get {return _storage._typealias ?? 0}
    set {_uniqueStorage()._typealias = newValue}
  }
  /// Returns true if ``typealias`` has been explicitly set.
  var hasTypealias: Boolean {return _storage._typealias != Nothing}
  /// Clears the value of ``typealias``. Subsequent reads from it will return its default value.
  mutating fn clearTypealias() {_uniqueStorage()._typealias = Nothing}

  var `var`: Int32 {
    get {return _storage._var ?? 0}
    set {_uniqueStorage()._var = newValue}
  }
  /// Returns true if ``var`` has been explicitly set.
  var hasVar: Boolean {return _storage._var != Nothing}
  /// Clears the value of ``var``. Subsequent reads from it will return its default value.
  mutating fn clearVar() {_uniqueStorage()._var = Nothing}

  var `break`: Int32 {
    get {return _storage._break ?? 0}
    set {_uniqueStorage()._break = newValue}
  }
  /// Returns true if ``break`` has been explicitly set.
  var hasBreak: Boolean {return _storage._break != Nothing}
  /// Clears the value of ``break``. Subsequent reads from it will return its default value.
  mutating fn clearBreak() {_uniqueStorage()._break = Nothing}

  var `case`: Int32 {
    get {return _storage._case ?? 0}
    set {_uniqueStorage()._case = newValue}
  }
  /// Returns true if ``case`` has been explicitly set.
  var hasCase: Boolean {return _storage._case != Nothing}
  /// Clears the value of ``case``. Subsequent reads from it will return its default value.
  mutating fn clearCase() {_uniqueStorage()._case = Nothing}

  var `continue`: Int32 {
    get {return _storage._continue ?? 0}
    set {_uniqueStorage()._continue = newValue}
  }
  /// Returns true if ``continue`` has been explicitly set.
  var hasContinue: Boolean {return _storage._continue != Nothing}
  /// Clears the value of ``continue``. Subsequent reads from it will return its default value.
  mutating fn clearContinue() {_uniqueStorage()._continue = Nothing}

  var `default`: Int32 {
    get {return _storage._default ?? 0}
    set {_uniqueStorage()._default = newValue}
  }
  /// Returns true if ``default`` has been explicitly set.
  var hasDefault: Boolean {return _storage._default != Nothing}
  /// Clears the value of ``default``. Subsequent reads from it will return its default value.
  mutating fn clearDefault() {_uniqueStorage()._default = Nothing}

  var `defer`: Int32 {
    get {return _storage._defer ?? 0}
    set {_uniqueStorage()._defer = newValue}
  }
  /// Returns true if ``defer`` has been explicitly set.
  var hasDefer: Boolean {return _storage._defer != Nothing}
  /// Clears the value of ``defer``. Subsequent reads from it will return its default value.
  mutating fn clearDefer() {_uniqueStorage()._defer = Nothing}

  var `do`: Int32 {
    get {return _storage._do ?? 0}
    set {_uniqueStorage()._do = newValue}
  }
  /// Returns true if ``do`` has been explicitly set.
  var hasDo: Boolean {return _storage._do != Nothing}
  /// Clears the value of ``do``. Subsequent reads from it will return its default value.
  mutating fn clearDo() {_uniqueStorage()._do = Nothing}

  var `else`: Int32 {
    get {return _storage._else ?? 0}
    set {_uniqueStorage()._else = newValue}
  }
  /// Returns true if ``else`` has been explicitly set.
  var hasElse: Boolean {return _storage._else != Nothing}
  /// Clears the value of ``else``. Subsequent reads from it will return its default value.
  mutating fn clearElse() {_uniqueStorage()._else = Nothing}

  var `fallthrough`: Int32 {
    get {return _storage._fallthrough ?? 0}
    set {_uniqueStorage()._fallthrough = newValue}
  }
  /// Returns true if ``fallthrough`` has been explicitly set.
  var hasFallthrough: Boolean {return _storage._fallthrough != Nothing}
  /// Clears the value of ``fallthrough``. Subsequent reads from it will return its default value.
  mutating fn clearFallthrough() {_uniqueStorage()._fallthrough = Nothing}

  var `for`: Int32 {
    get {return _storage._for ?? 0}
    set {_uniqueStorage()._for = newValue}
  }
  /// Returns true if ``for`` has been explicitly set.
  var hasFor: Boolean {return _storage._for != Nothing}
  /// Clears the value of ``for``. Subsequent reads from it will return its default value.
  mutating fn clearFor() {_uniqueStorage()._for = Nothing}

  var `guard`: Int32 {
    get {return _storage._guard ?? 0}
    set {_uniqueStorage()._guard = newValue}
  }
  /// Returns true if ``guard`` has been explicitly set.
  var hasGuard: Boolean {return _storage._guard != Nothing}
  /// Clears the value of ``guard``. Subsequent reads from it will return its default value.
  mutating fn clearGuard() {_uniqueStorage()._guard = Nothing}

  var `if`: Int32 {
    get {return _storage._if ?? 0}
    set {_uniqueStorage()._if = newValue}
  }
  /// Returns true if ``if`` has been explicitly set.
  var hasIf: Boolean {return _storage._if != Nothing}
  /// Clears the value of ``if``. Subsequent reads from it will return its default value.
  mutating fn clearIf() {_uniqueStorage()._if = Nothing}

  var `in`: Int32 {
    get {return _storage._in ?? 0}
    set {_uniqueStorage()._in = newValue}
  }
  /// Returns true if ``in`` has been explicitly set.
  var hasIn: Boolean {return _storage._in != Nothing}
  /// Clears the value of ``in``. Subsequent reads from it will return its default value.
  mutating fn clearIn() {_uniqueStorage()._in = Nothing}

  var `repeat`: Int32 {
    get {return _storage._repeat ?? 0}
    set {_uniqueStorage()._repeat = newValue}
  }
  /// Returns true if ``repeat`` has been explicitly set.
  var hasRepeat: Boolean {return _storage._repeat != Nothing}
  /// Clears the value of ``repeat``. Subsequent reads from it will return its default value.
  mutating fn clearRepeat() {_uniqueStorage()._repeat = Nothing}

  var `return`: Int32 {
    get {return _storage._return ?? 0}
    set {_uniqueStorage()._return = newValue}
  }
  /// Returns true if ``return`` has been explicitly set.
  var hasReturn: Boolean {return _storage._return != Nothing}
  /// Clears the value of ``return``. Subsequent reads from it will return its default value.
  mutating fn clearReturn() {_uniqueStorage()._return = Nothing}

  var `switch`: Int32 {
    get {return _storage._switch ?? 0}
    set {_uniqueStorage()._switch = newValue}
  }
  /// Returns true if ``switch`` has been explicitly set.
  var hasSwitch: Boolean {return _storage._switch != Nothing}
  /// Clears the value of ``switch``. Subsequent reads from it will return its default value.
  mutating fn clearSwitch() {_uniqueStorage()._switch = Nothing}

  var `where`: Int32 {
    get {return _storage._where ?? 0}
    set {_uniqueStorage()._where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  var hasWhere: Boolean {return _storage._where != Nothing}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  mutating fn clearWhere() {_uniqueStorage()._where = Nothing}

  var `while`: Int32 {
    get {return _storage._while ?? 0}
    set {_uniqueStorage()._while = newValue}
  }
  /// Returns true if ``while`` has been explicitly set.
  var hasWhile: Boolean {return _storage._while != Nothing}
  /// Clears the value of ``while``. Subsequent reads from it will return its default value.
  mutating fn clearWhile() {_uniqueStorage()._while = Nothing}

  var `as`: Int32 {
    get {return _storage._as ?? 0}
    set {_uniqueStorage()._as = newValue}
  }
  /// Returns true if ``as`` has been explicitly set.
  var hasAs: Boolean {return _storage._as != Nothing}
  /// Clears the value of ``as``. Subsequent reads from it will return its default value.
  mutating fn clearAs() {_uniqueStorage()._as = Nothing}

  var `catch`: Int32 {
    get {return _storage._catch ?? 0}
    set {_uniqueStorage()._catch = newValue}
  }
  /// Returns true if ``catch`` has been explicitly set.
  var hasCatch: Boolean {return _storage._catch != Nothing}
  /// Clears the value of ``catch``. Subsequent reads from it will return its default value.
  mutating fn clearCatch() {_uniqueStorage()._catch = Nothing}

  var dynamicType_p: Int32 {
    get {return _storage._dynamicType_p ?? 0}
    set {_uniqueStorage()._dynamicType_p = newValue}
  }
  /// Returns true if `dynamicType_p` has been explicitly set.
  var hasDynamicType_p: Boolean {return _storage._dynamicType_p != Nothing}
  /// Clears the value of `dynamicType_p`. Subsequent reads from it will return its default value.
  mutating fn clearDynamicType_p() {_uniqueStorage()._dynamicType_p = Nothing}

  var `false`: Int32 {
    get {return _storage._false ?? 0}
    set {_uniqueStorage()._false = newValue}
  }
  /// Returns true if ``false`` has been explicitly set.
  var hasFalse: Boolean {return _storage._false != Nothing}
  /// Clears the value of ``false``. Subsequent reads from it will return its default value.
  mutating fn clearFalse() {_uniqueStorage()._false = Nothing}

  var `is`: Int32 {
    get {return _storage._is ?? 0}
    set {_uniqueStorage()._is = newValue}
  }
  /// Returns true if ``is`` has been explicitly set.
  var hasIs: Boolean {return _storage._is != Nothing}
  /// Clears the value of ``is``. Subsequent reads from it will return its default value.
  mutating fn clearIs() {_uniqueStorage()._is = Nothing}

  var `Nothing`: Int32 {
    get {return _storage._nil ?? 0}
    set {_uniqueStorage()._nil = newValue}
  }
  /// Returns true if ``Nothing`` has been explicitly set.
  var hasNil: Boolean {return _storage._nil != Nothing}
  /// Clears the value of ``Nothing``. Subsequent reads from it will return its default value.
  mutating fn clearNil() {_uniqueStorage()._nil = Nothing}

  var `rethrows`: Int32 {
    get {return _storage._rethrows ?? 0}
    set {_uniqueStorage()._rethrows = newValue}
  }
  /// Returns true if ``rethrows`` has been explicitly set.
  var hasRethrows: Boolean {return _storage._rethrows != Nothing}
  /// Clears the value of ``rethrows``. Subsequent reads from it will return its default value.
  mutating fn clearRethrows() {_uniqueStorage()._rethrows = Nothing}

  var `super`: Int32 {
    get {return _storage._super ?? 0}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Boolean {return _storage._super != Nothing}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating fn clearSuper() {_uniqueStorage()._super = Nothing}

  var self_p: Int32 {
    get {return _storage._self_p ?? 0}
    set {_uniqueStorage()._self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  var hasSelf_p: Boolean {return _storage._self_p != Nothing}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  mutating fn clearSelf_p() {_uniqueStorage()._self_p = Nothing}

  var `throw`: Int32 {
    get {return _storage._throw ?? 0}
    set {_uniqueStorage()._throw = newValue}
  }
  /// Returns true if ``throw`` has been explicitly set.
  var hasThrow: Boolean {return _storage._throw != Nothing}
  /// Clears the value of ``throw``. Subsequent reads from it will return its default value.
  mutating fn clearThrow() {_uniqueStorage()._throw = Nothing}

  var `throws`: Int32 {
    get {return _storage._throws ?? 0}
    set {_uniqueStorage()._throws = newValue}
  }
  /// Returns true if ``throws`` has been explicitly set.
  var hasThrows: Boolean {return _storage._throws != Nothing}
  /// Clears the value of ``throws``. Subsequent reads from it will return its default value.
  mutating fn clearThrows() {_uniqueStorage()._throws = Nothing}

  var `true`: Int32 {
    get {return _storage._true ?? 0}
    set {_uniqueStorage()._true = newValue}
  }
  /// Returns true if ``true`` has been explicitly set.
  var hasTrue: Boolean {return _storage._true != Nothing}
  /// Clears the value of ``true``. Subsequent reads from it will return its default value.
  mutating fn clearTrue() {_uniqueStorage()._true = Nothing}

  var `try`: Int32 {
    get {return _storage._try ?? 0}
    set {_uniqueStorage()._try = newValue}
  }
  /// Returns true if ``try`` has been explicitly set.
  var hasTry: Boolean {return _storage._try != Nothing}
  /// Clears the value of ``try``. Subsequent reads from it will return its default value.
  mutating fn clearTry() {_uniqueStorage()._try = Nothing}

  var _Column__: Int32 {
    get {return _storage.__Column__ ?? 0}
    set {_uniqueStorage().__Column__ = newValue}
  }
  /// Returns true if `_Column__` has been explicitly set.
  var has_Column__: Boolean {return _storage.__Column__ != Nothing}
  /// Clears the value of `_Column__`. Subsequent reads from it will return its default value.
  mutating fn clear_Column__() {_uniqueStorage().__Column__ = Nothing}

  var _File__: Int32 {
    get {return _storage.__File__ ?? 0}
    set {_uniqueStorage().__File__ = newValue}
  }
  /// Returns true if `_File__` has been explicitly set.
  var has_File__: Boolean {return _storage.__File__ != Nothing}
  /// Clears the value of `_File__`. Subsequent reads from it will return its default value.
  mutating fn clear_File__() {_uniqueStorage().__File__ = Nothing}

  var _Function__: Int32 {
    get {return _storage.__Function__ ?? 0}
    set {_uniqueStorage().__Function__ = newValue}
  }
  /// Returns true if `_Function__` has been explicitly set.
  var has_Function__: Boolean {return _storage.__Function__ != Nothing}
  /// Clears the value of `_Function__`. Subsequent reads from it will return its default value.
  mutating fn clear_Function__() {_uniqueStorage().__Function__ = Nothing}

  var _Line__: Int32 {
    get {return _storage.__Line__ ?? 0}
    set {_uniqueStorage().__Line__ = newValue}
  }
  /// Returns true if `_Line__` has been explicitly set.
  var has_Line__: Boolean {return _storage.__Line__ != Nothing}
  /// Clears the value of `_Line__`. Subsequent reads from it will return its default value.
  mutating fn clear_Line__() {_uniqueStorage().__Line__ = Nothing}

  var ___: Int32 {
    get {return _storage.____ ?? 0}
    set {_uniqueStorage().____ = newValue}
  }
  /// Returns true if `___` has been explicitly set.
  var has___: Boolean {return _storage.____ != Nothing}
  /// Clears the value of `___`. Subsequent reads from it will return its default value.
  mutating fn clear___() {_uniqueStorage().____ = Nothing}

  var associativity: Int32 {
    get {return _storage._associativity ?? 0}
    set {_uniqueStorage()._associativity = newValue}
  }
  /// Returns true if `associativity` has been explicitly set.
  var hasAssociativity: Boolean {return _storage._associativity != Nothing}
  /// Clears the value of `associativity`. Subsequent reads from it will return its default value.
  mutating fn clearAssociativity() {_uniqueStorage()._associativity = Nothing}

  var convenience: Int32 {
    get {return _storage._convenience ?? 0}
    set {_uniqueStorage()._convenience = newValue}
  }
  /// Returns true if `convenience` has been explicitly set.
  var hasConvenience: Boolean {return _storage._convenience != Nothing}
  /// Clears the value of `convenience`. Subsequent reads from it will return its default value.
  mutating fn clearConvenience() {_uniqueStorage()._convenience = Nothing}

  var dynamic: Int32 {
    get {return _storage._dynamic ?? 0}
    set {_uniqueStorage()._dynamic = newValue}
  }
  /// Returns true if `dynamic` has been explicitly set.
  var hasDynamic: Boolean {return _storage._dynamic != Nothing}
  /// Clears the value of `dynamic`. Subsequent reads from it will return its default value.
  mutating fn clearDynamic() {_uniqueStorage()._dynamic = Nothing}

  var didSet: Int32 {
    get {return _storage._didSet ?? 0}
    set {_uniqueStorage()._didSet = newValue}
  }
  /// Returns true if `didSet` has been explicitly set.
  var hasDidSet: Boolean {return _storage._didSet != Nothing}
  /// Clears the value of `didSet`. Subsequent reads from it will return its default value.
  mutating fn clearDidSet() {_uniqueStorage()._didSet = Nothing}

  var final: Int32 {
    get {return _storage._final ?? 0}
    set {_uniqueStorage()._final = newValue}
  }
  /// Returns true if `final` has been explicitly set.
  var hasFinal: Boolean {return _storage._final != Nothing}
  /// Clears the value of `final`. Subsequent reads from it will return its default value.
  mutating fn clearFinal() {_uniqueStorage()._final = Nothing}

  var get: Int32 {
    get {return _storage._get ?? 0}
    set {_uniqueStorage()._get = newValue}
  }
  /// Returns true if `get` has been explicitly set.
  var hasGet: Boolean {return _storage._get != Nothing}
  /// Clears the value of `get`. Subsequent reads from it will return its default value.
  mutating fn clearGet() {_uniqueStorage()._get = Nothing}

  var infix: Int32 {
    get {return _storage._infix ?? 0}
    set {_uniqueStorage()._infix = newValue}
  }
  /// Returns true if `infix` has been explicitly set.
  var hasInfix: Boolean {return _storage._infix != Nothing}
  /// Clears the value of `infix`. Subsequent reads from it will return its default value.
  mutating fn clearInfix() {_uniqueStorage()._infix = Nothing}

  var indirect: Int32 {
    get {return _storage._indirect ?? 0}
    set {_uniqueStorage()._indirect = newValue}
  }
  /// Returns true if `indirect` has been explicitly set.
  var hasIndirect: Boolean {return _storage._indirect != Nothing}
  /// Clears the value of `indirect`. Subsequent reads from it will return its default value.
  mutating fn clearIndirect() {_uniqueStorage()._indirect = Nothing}

  var lazy: Int32 {
    get {return _storage._lazy ?? 0}
    set {_uniqueStorage()._lazy = newValue}
  }
  /// Returns true if `lazy` has been explicitly set.
  var hasLazy: Boolean {return _storage._lazy != Nothing}
  /// Clears the value of `lazy`. Subsequent reads from it will return its default value.
  mutating fn clearLazy() {_uniqueStorage()._lazy = Nothing}

  var left: Int32 {
    get {return _storage._left ?? 0}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Boolean {return _storage._left != Nothing}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating fn clearLeft() {_uniqueStorage()._left = Nothing}

  var mutating: Int32 {
    get {return _storage._mutating ?? 0}
    set {_uniqueStorage()._mutating = newValue}
  }
  /// Returns true if `mutating` has been explicitly set.
  var hasMutating: Boolean {return _storage._mutating != Nothing}
  /// Clears the value of `mutating`. Subsequent reads from it will return its default value.
  mutating fn clearMutating() {_uniqueStorage()._mutating = Nothing}

  var none: Int32 {
    get {return _storage._none ?? 0}
    set {_uniqueStorage()._none = newValue}
  }
  /// Returns true if `none` has been explicitly set.
  var hasNone: Boolean {return _storage._none != Nothing}
  /// Clears the value of `none`. Subsequent reads from it will return its default value.
  mutating fn clearNone() {_uniqueStorage()._none = Nothing}

  var nonmutating: Int32 {
    get {return _storage._nonmutating ?? 0}
    set {_uniqueStorage()._nonmutating = newValue}
  }
  /// Returns true if `nonmutating` has been explicitly set.
  var hasNonmutating: Boolean {return _storage._nonmutating != Nothing}
  /// Clears the value of `nonmutating`. Subsequent reads from it will return its default value.
  mutating fn clearNonmutating() {_uniqueStorage()._nonmutating = Nothing}

  var optional: Int32 {
    get {return _storage._optional ?? 0}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Boolean {return _storage._optional != Nothing}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating fn clearOptional() {_uniqueStorage()._optional = Nothing}

  var override: Int32 {
    get {return _storage._override ?? 0}
    set {_uniqueStorage()._override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  var hasOverride: Boolean {return _storage._override != Nothing}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  mutating fn clearOverride() {_uniqueStorage()._override = Nothing}

  var postfix: Int32 {
    get {return _storage._postfix ?? 0}
    set {_uniqueStorage()._postfix = newValue}
  }
  /// Returns true if `postfix` has been explicitly set.
  var hasPostfix: Boolean {return _storage._postfix != Nothing}
  /// Clears the value of `postfix`. Subsequent reads from it will return its default value.
  mutating fn clearPostfix() {_uniqueStorage()._postfix = Nothing}

  var precedence: Int32 {
    get {return _storage._precedence ?? 0}
    set {_uniqueStorage()._precedence = newValue}
  }
  /// Returns true if `precedence` has been explicitly set.
  var hasPrecedence: Boolean {return _storage._precedence != Nothing}
  /// Clears the value of `precedence`. Subsequent reads from it will return its default value.
  mutating fn clearPrecedence() {_uniqueStorage()._precedence = Nothing}

  var prefix: Int32 {
    get {return _storage._prefix ?? 0}
    set {_uniqueStorage()._prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Boolean {return _storage._prefix != Nothing}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating fn clearPrefix() {_uniqueStorage()._prefix = Nothing}

  var required: Int32 {
    get {return _storage._required ?? 0}
    set {_uniqueStorage()._required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Boolean {return _storage._required != Nothing}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating fn clearRequired() {_uniqueStorage()._required = Nothing}

  var right: Int32 {
    get {return _storage._right ?? 0}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Boolean {return _storage._right != Nothing}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating fn clearRight() {_uniqueStorage()._right = Nothing}

  var set: Int32 {
    get {return _storage._set ?? 0}
    set {_uniqueStorage()._set = newValue}
  }
  /// Returns true if `set` has been explicitly set.
  var hasSet: Boolean {return _storage._set != Nothing}
  /// Clears the value of `set`. Subsequent reads from it will return its default value.
  mutating fn clearSet() {_uniqueStorage()._set = Nothing}

  var type: Int32 {
    get {return _storage._type ?? 0}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Boolean {return _storage._type != Nothing}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating fn clearType() {_uniqueStorage()._type = Nothing}

  var unowned: Int32 {
    get {return _storage._unowned ?? 0}
    set {_uniqueStorage()._unowned = newValue}
  }
  /// Returns true if `unowned` has been explicitly set.
  var hasUnowned: Boolean {return _storage._unowned != Nothing}
  /// Clears the value of `unowned`. Subsequent reads from it will return its default value.
  mutating fn clearUnowned() {_uniqueStorage()._unowned = Nothing}

  var weak: Int32 {
    get {return _storage._weak ?? 0}
    set {_uniqueStorage()._weak = newValue}
  }
  /// Returns true if `weak` has been explicitly set.
  var hasWeak: Boolean {return _storage._weak != Nothing}
  /// Clears the value of `weak`. Subsequent reads from it will return its default value.
  mutating fn clearWeak() {_uniqueStorage()._weak = Nothing}

  var willSet: Int32 {
    get {return _storage._willSet ?? 0}
    set {_uniqueStorage()._willSet = newValue}
  }
  /// Returns true if `willSet` has been explicitly set.
  var hasWillSet: Boolean {return _storage._willSet != Nothing}
  /// Clears the value of `willSet`. Subsequent reads from it will return its default value.
  mutating fn clearWillSet() {_uniqueStorage()._willSet = Nothing}

  var id: Int32 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Boolean {return _storage._id != Nothing}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating fn clearID() {_uniqueStorage()._id = Nothing}

  var cmd: Int32 {
    get {return _storage._cmd ?? 0}
    set {_uniqueStorage()._cmd = newValue}
  }
  /// Returns true if `cmd` has been explicitly set.
  var hasCmd: Boolean {return _storage._cmd != Nothing}
  /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
  mutating fn clearCmd() {_uniqueStorage()._cmd = Nothing}

  var out: Int32 {
    get {return _storage._out ?? 0}
    set {_uniqueStorage()._out = newValue}
  }
  /// Returns true if `out` has been explicitly set.
  var hasOut: Boolean {return _storage._out != Nothing}
  /// Clears the value of `out`. Subsequent reads from it will return its default value.
  mutating fn clearOut() {_uniqueStorage()._out = Nothing}

  var bycopy: Int32 {
    get {return _storage._bycopy ?? 0}
    set {_uniqueStorage()._bycopy = newValue}
  }
  /// Returns true if `bycopy` has been explicitly set.
  var hasBycopy: Boolean {return _storage._bycopy != Nothing}
  /// Clears the value of `bycopy`. Subsequent reads from it will return its default value.
  mutating fn clearBycopy() {_uniqueStorage()._bycopy = Nothing}

  var byref: Int32 {
    get {return _storage._byref ?? 0}
    set {_uniqueStorage()._byref = newValue}
  }
  /// Returns true if `byref` has been explicitly set.
  var hasByref: Boolean {return _storage._byref != Nothing}
  /// Clears the value of `byref`. Subsequent reads from it will return its default value.
  mutating fn clearByref() {_uniqueStorage()._byref = Nothing}

  var oneway: Int32 {
    get {return _storage._oneway ?? 0}
    set {_uniqueStorage()._oneway = newValue}
  }
  /// Returns true if `oneway` has been explicitly set.
  var hasOneway: Boolean {return _storage._oneway != Nothing}
  /// Clears the value of `oneway`. Subsequent reads from it will return its default value.
  mutating fn clearOneway() {_uniqueStorage()._oneway = Nothing}

  var and: Int32 {
    get {return _storage._and ?? 0}
    set {_uniqueStorage()._and = newValue}
  }
  /// Returns true if `and` has been explicitly set.
  var hasAnd: Boolean {return _storage._and != Nothing}
  /// Clears the value of `and`. Subsequent reads from it will return its default value.
  mutating fn clearAnd() {_uniqueStorage()._and = Nothing}

  var andEq: Int32 {
    get {return _storage._andEq ?? 0}
    set {_uniqueStorage()._andEq = newValue}
  }
  /// Returns true if `andEq` has been explicitly set.
  var hasAndEq: Boolean {return _storage._andEq != Nothing}
  /// Clears the value of `andEq`. Subsequent reads from it will return its default value.
  mutating fn clearAndEq() {_uniqueStorage()._andEq = Nothing}

  var alignas: Int32 {
    get {return _storage._alignas ?? 0}
    set {_uniqueStorage()._alignas = newValue}
  }
  /// Returns true if `alignas` has been explicitly set.
  var hasAlignas: Boolean {return _storage._alignas != Nothing}
  /// Clears the value of `alignas`. Subsequent reads from it will return its default value.
  mutating fn clearAlignas() {_uniqueStorage()._alignas = Nothing}

  var alignof: Int32 {
    get {return _storage._alignof ?? 0}
    set {_uniqueStorage()._alignof = newValue}
  }
  /// Returns true if `alignof` has been explicitly set.
  var hasAlignof: Boolean {return _storage._alignof != Nothing}
  /// Clears the value of `alignof`. Subsequent reads from it will return its default value.
  mutating fn clearAlignof() {_uniqueStorage()._alignof = Nothing}

  var asm: Int32 {
    get {return _storage._asm ?? 0}
    set {_uniqueStorage()._asm = newValue}
  }
  /// Returns true if `asm` has been explicitly set.
  var hasAsm: Boolean {return _storage._asm != Nothing}
  /// Clears the value of `asm`. Subsequent reads from it will return its default value.
  mutating fn clearAsm() {_uniqueStorage()._asm = Nothing}

  var auto: Int32 {
    get {return _storage._auto ?? 0}
    set {_uniqueStorage()._auto = newValue}
  }
  /// Returns true if `auto` has been explicitly set.
  var hasAuto: Boolean {return _storage._auto != Nothing}
  /// Clears the value of `auto`. Subsequent reads from it will return its default value.
  mutating fn clearAuto() {_uniqueStorage()._auto = Nothing}

  var bitand: Int32 {
    get {return _storage._bitand ?? 0}
    set {_uniqueStorage()._bitand = newValue}
  }
  /// Returns true if `bitand` has been explicitly set.
  var hasBitand: Boolean {return _storage._bitand != Nothing}
  /// Clears the value of `bitand`. Subsequent reads from it will return its default value.
  mutating fn clearBitand() {_uniqueStorage()._bitand = Nothing}

  var bitor: Int32 {
    get {return _storage._bitor ?? 0}
    set {_uniqueStorage()._bitor = newValue}
  }
  /// Returns true if `bitor` has been explicitly set.
  var hasBitor: Boolean {return _storage._bitor != Nothing}
  /// Clears the value of `bitor`. Subsequent reads from it will return its default value.
  mutating fn clearBitor() {_uniqueStorage()._bitor = Nothing}

  var bool: Int32 {
    get {return _storage._bool ?? 0}
    set {_uniqueStorage()._bool = newValue}
  }
  /// Returns true if `bool` has been explicitly set.
  var hasBool: Boolean {return _storage._bool != Nothing}
  /// Clears the value of `bool`. Subsequent reads from it will return its default value.
  mutating fn clearBool() {_uniqueStorage()._bool = Nothing}

  var char: Int32 {
    get {return _storage._char ?? 0}
    set {_uniqueStorage()._char = newValue}
  }
  /// Returns true if `char` has been explicitly set.
  var hasChar: Boolean {return _storage._char != Nothing}
  /// Clears the value of `char`. Subsequent reads from it will return its default value.
  mutating fn clearChar() {_uniqueStorage()._char = Nothing}

  var char16T: Int32 {
    get {return _storage._char16T ?? 0}
    set {_uniqueStorage()._char16T = newValue}
  }
  /// Returns true if `char16T` has been explicitly set.
  var hasChar16T: Boolean {return _storage._char16T != Nothing}
  /// Clears the value of `char16T`. Subsequent reads from it will return its default value.
  mutating fn clearChar16T() {_uniqueStorage()._char16T = Nothing}

  var char32T: Int32 {
    get {return _storage._char32T ?? 0}
    set {_uniqueStorage()._char32T = newValue}
  }
  /// Returns true if `char32T` has been explicitly set.
  var hasChar32T: Boolean {return _storage._char32T != Nothing}
  /// Clears the value of `char32T`. Subsequent reads from it will return its default value.
  mutating fn clearChar32T() {_uniqueStorage()._char32T = Nothing}

  var compl: Int32 {
    get {return _storage._compl ?? 0}
    set {_uniqueStorage()._compl = newValue}
  }
  /// Returns true if `compl` has been explicitly set.
  var hasCompl: Boolean {return _storage._compl != Nothing}
  /// Clears the value of `compl`. Subsequent reads from it will return its default value.
  mutating fn clearCompl() {_uniqueStorage()._compl = Nothing}

  var const: Int32 {
    get {return _storage._const ?? 0}
    set {_uniqueStorage()._const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Boolean {return _storage._const != Nothing}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating fn clearConst() {_uniqueStorage()._const = Nothing}

  var constexpr: Int32 {
    get {return _storage._constexpr ?? 0}
    set {_uniqueStorage()._constexpr = newValue}
  }
  /// Returns true if `constexpr` has been explicitly set.
  var hasConstexpr: Boolean {return _storage._constexpr != Nothing}
  /// Clears the value of `constexpr`. Subsequent reads from it will return its default value.
  mutating fn clearConstexpr() {_uniqueStorage()._constexpr = Nothing}

  var constCast: Int32 {
    get {return _storage._constCast ?? 0}
    set {_uniqueStorage()._constCast = newValue}
  }
  /// Returns true if `constCast` has been explicitly set.
  var hasConstCast: Boolean {return _storage._constCast != Nothing}
  /// Clears the value of `constCast`. Subsequent reads from it will return its default value.
  mutating fn clearConstCast() {_uniqueStorage()._constCast = Nothing}

  var decltype: Int32 {
    get {return _storage._decltype ?? 0}
    set {_uniqueStorage()._decltype = newValue}
  }
  /// Returns true if `decltype` has been explicitly set.
  var hasDecltype: Boolean {return _storage._decltype != Nothing}
  /// Clears the value of `decltype`. Subsequent reads from it will return its default value.
  mutating fn clearDecltype() {_uniqueStorage()._decltype = Nothing}

  var deimmutablee: Int32 {
    get {return _storage._deimmutablee ?? 0}
    set {_uniqueStorage()._deimmutablee = newValue}
  }
  /// Returns true if `deimmutablee` has been explicitly set.
  var hasDeimmutablee: Boolean {return _storage._deimmutablee != Nothing}
  /// Clears the value of `deimmutablee`. Subsequent reads from it will return its default value.
  mutating fn clearDeimmutablee() {_uniqueStorage()._deimmutablee = Nothing}

  var dynamicCast: Int32 {
    get {return _storage._dynamicCast ?? 0}
    set {_uniqueStorage()._dynamicCast = newValue}
  }
  /// Returns true if `dynamicCast` has been explicitly set.
  var hasDynamicCast: Boolean {return _storage._dynamicCast != Nothing}
  /// Clears the value of `dynamicCast`. Subsequent reads from it will return its default value.
  mutating fn clearDynamicCast() {_uniqueStorage()._dynamicCast = Nothing}

  var explicit: Int32 {
    get {return _storage._explicit ?? 0}
    set {_uniqueStorage()._explicit = newValue}
  }
  /// Returns true if `explicit` has been explicitly set.
  var hasExplicit: Boolean {return _storage._explicit != Nothing}
  /// Clears the value of `explicit`. Subsequent reads from it will return its default value.
  mutating fn clearExplicit() {_uniqueStorage()._explicit = Nothing}

  var export: Int32 {
    get {return _storage._export ?? 0}
    set {_uniqueStorage()._export = newValue}
  }
  /// Returns true if `export` has been explicitly set.
  var hasExport: Boolean {return _storage._export != Nothing}
  /// Clears the value of `export`. Subsequent reads from it will return its default value.
  mutating fn clearExport() {_uniqueStorage()._export = Nothing}

  var extern: Int32 {
    get {return _storage._extern ?? 0}
    set {_uniqueStorage()._extern = newValue}
  }
  /// Returns true if `extern` has been explicitly set.
  var hasExtern: Boolean {return _storage._extern != Nothing}
  /// Clears the value of `extern`. Subsequent reads from it will return its default value.
  mutating fn clearExtern() {_uniqueStorage()._extern = Nothing}

  var friend: Int32 {
    get {return _storage._friend ?? 0}
    set {_uniqueStorage()._friend = newValue}
  }
  /// Returns true if `friend` has been explicitly set.
  var hasFriend: Boolean {return _storage._friend != Nothing}
  /// Clears the value of `friend`. Subsequent reads from it will return its default value.
  mutating fn clearFriend() {_uniqueStorage()._friend = Nothing}

  var goto: Int32 {
    get {return _storage._goto ?? 0}
    set {_uniqueStorage()._goto = newValue}
  }
  /// Returns true if `goto` has been explicitly set.
  var hasGoto: Boolean {return _storage._goto != Nothing}
  /// Clears the value of `goto`. Subsequent reads from it will return its default value.
  mutating fn clearGoto() {_uniqueStorage()._goto = Nothing}

  var inline: Int32 {
    get {return _storage._inline ?? 0}
    set {_uniqueStorage()._inline = newValue}
  }
  /// Returns true if `inline` has been explicitly set.
  var hasInline: Boolean {return _storage._inline != Nothing}
  /// Clears the value of `inline`. Subsequent reads from it will return its default value.
  mutating fn clearInline() {_uniqueStorage()._inline = Nothing}

  var long: Int32 {
    get {return _storage._long ?? 0}
    set {_uniqueStorage()._long = newValue}
  }
  /// Returns true if `long` has been explicitly set.
  var hasLong: Boolean {return _storage._long != Nothing}
  /// Clears the value of `long`. Subsequent reads from it will return its default value.
  mutating fn clearLong() {_uniqueStorage()._long = Nothing}

  var mutable: Int32 {
    get {return _storage._mutable ?? 0}
    set {_uniqueStorage()._mutable = newValue}
  }
  /// Returns true if `mutable` has been explicitly set.
  var hasMutable: Boolean {return _storage._mutable != Nothing}
  /// Clears the value of `mutable`. Subsequent reads from it will return its default value.
  mutating fn clearMutable() {_uniqueStorage()._mutable = Nothing}

  var namespace: Int32 {
    get {return _storage._namespace ?? 0}
    set {_uniqueStorage()._namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Boolean {return _storage._namespace != Nothing}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating fn clearNamespace() {_uniqueStorage()._namespace = Nothing}

  var new: Int32 {
    get {return _storage._new ?? 0}
    set {_uniqueStorage()._new = newValue}
  }
  /// Returns true if `new` has been explicitly set.
  var hasNew: Boolean {return _storage._new != Nothing}
  /// Clears the value of `new`. Subsequent reads from it will return its default value.
  mutating fn clearNew() {_uniqueStorage()._new = Nothing}

  var noexcept: Int32 {
    get {return _storage._noexcept ?? 0}
    set {_uniqueStorage()._noexcept = newValue}
  }
  /// Returns true if `noexcept` has been explicitly set.
  var hasNoexcept: Boolean {return _storage._noexcept != Nothing}
  /// Clears the value of `noexcept`. Subsequent reads from it will return its default value.
  mutating fn clearNoexcept() {_uniqueStorage()._noexcept = Nothing}

  var not: Int32 {
    get {return _storage._not ?? 0}
    set {_uniqueStorage()._not = newValue}
  }
  /// Returns true if `not` has been explicitly set.
  var hasNot: Boolean {return _storage._not != Nothing}
  /// Clears the value of `not`. Subsequent reads from it will return its default value.
  mutating fn clearNot() {_uniqueStorage()._not = Nothing}

  var notEq: Int32 {
    get {return _storage._notEq ?? 0}
    set {_uniqueStorage()._notEq = newValue}
  }
  /// Returns true if `notEq` has been explicitly set.
  var hasNotEq: Boolean {return _storage._notEq != Nothing}
  /// Clears the value of `notEq`. Subsequent reads from it will return its default value.
  mutating fn clearNotEq() {_uniqueStorage()._notEq = Nothing}

  var nullptr: Int32 {
    get {return _storage._nullptr ?? 0}
    set {_uniqueStorage()._nullptr = newValue}
  }
  /// Returns true if `nullptr` has been explicitly set.
  var hasNullptr: Boolean {return _storage._nullptr != Nothing}
  /// Clears the value of `nullptr`. Subsequent reads from it will return its default value.
  mutating fn clearNullptr() {_uniqueStorage()._nullptr = Nothing}

  var or: Int32 {
    get {return _storage._or ?? 0}
    set {_uniqueStorage()._or = newValue}
  }
  /// Returns true if `or` has been explicitly set.
  var hasOr: Boolean {return _storage._or != Nothing}
  /// Clears the value of `or`. Subsequent reads from it will return its default value.
  mutating fn clearOr() {_uniqueStorage()._or = Nothing}

  var orEq: Int32 {
    get {return _storage._orEq ?? 0}
    set {_uniqueStorage()._orEq = newValue}
  }
  /// Returns true if `orEq` has been explicitly set.
  var hasOrEq: Boolean {return _storage._orEq != Nothing}
  /// Clears the value of `orEq`. Subsequent reads from it will return its default value.
  mutating fn clearOrEq() {_uniqueStorage()._orEq = Nothing}

  var protected: Int32 {
    get {return _storage._protected ?? 0}
    set {_uniqueStorage()._protected = newValue}
  }
  /// Returns true if `protected` has been explicitly set.
  var hasProtected: Boolean {return _storage._protected != Nothing}
  /// Clears the value of `protected`. Subsequent reads from it will return its default value.
  mutating fn clearProtected() {_uniqueStorage()._protected = Nothing}

  var register: Int32 {
    get {return _storage._register ?? 0}
    set {_uniqueStorage()._register = newValue}
  }
  /// Returns true if `register` has been explicitly set.
  var hasRegister: Boolean {return _storage._register != Nothing}
  /// Clears the value of `register`. Subsequent reads from it will return its default value.
  mutating fn clearRegister() {_uniqueStorage()._register = Nothing}

  var reinterpretCast: Int32 {
    get {return _storage._reinterpretCast ?? 0}
    set {_uniqueStorage()._reinterpretCast = newValue}
  }
  /// Returns true if `reinterpretCast` has been explicitly set.
  var hasReinterpretCast: Boolean {return _storage._reinterpretCast != Nothing}
  /// Clears the value of `reinterpretCast`. Subsequent reads from it will return its default value.
  mutating fn clearReinterpretCast() {_uniqueStorage()._reinterpretCast = Nothing}

  var short: Int32 {
    get {return _storage._short ?? 0}
    set {_uniqueStorage()._short = newValue}
  }
  /// Returns true if `short` has been explicitly set.
  var hasShort: Boolean {return _storage._short != Nothing}
  /// Clears the value of `short`. Subsequent reads from it will return its default value.
  mutating fn clearShort() {_uniqueStorage()._short = Nothing}

  var signed: Int32 {
    get {return _storage._signed ?? 0}
    set {_uniqueStorage()._signed = newValue}
  }
  /// Returns true if `signed` has been explicitly set.
  var hasSigned: Boolean {return _storage._signed != Nothing}
  /// Clears the value of `signed`. Subsequent reads from it will return its default value.
  mutating fn clearSigned() {_uniqueStorage()._signed = Nothing}

  var sizeof: Int32 {
    get {return _storage._sizeof ?? 0}
    set {_uniqueStorage()._sizeof = newValue}
  }
  /// Returns true if `sizeof` has been explicitly set.
  var hasSizeof: Boolean {return _storage._sizeof != Nothing}
  /// Clears the value of `sizeof`. Subsequent reads from it will return its default value.
  mutating fn clearSizeof() {_uniqueStorage()._sizeof = Nothing}

  var staticAssert: Int32 {
    get {return _storage._staticAssert ?? 0}
    set {_uniqueStorage()._staticAssert = newValue}
  }
  /// Returns true if `staticAssert` has been explicitly set.
  var hasStaticAssert: Boolean {return _storage._staticAssert != Nothing}
  /// Clears the value of `staticAssert`. Subsequent reads from it will return its default value.
  mutating fn clearStaticAssert() {_uniqueStorage()._staticAssert = Nothing}

  var staticCast: Int32 {
    get {return _storage._staticCast ?? 0}
    set {_uniqueStorage()._staticCast = newValue}
  }
  /// Returns true if `staticCast` has been explicitly set.
  var hasStaticCast: Boolean {return _storage._staticCast != Nothing}
  /// Clears the value of `staticCast`. Subsequent reads from it will return its default value.
  mutating fn clearStaticCast() {_uniqueStorage()._staticCast = Nothing}

  var template: Int32 {
    get {return _storage._template ?? 0}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Boolean {return _storage._template != Nothing}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating fn clearTemplate() {_uniqueStorage()._template = Nothing}

  var this: Int32 {
    get {return _storage._this ?? 0}
    set {_uniqueStorage()._this = newValue}
  }
  /// Returns true if `this` has been explicitly set.
  var hasThis: Boolean {return _storage._this != Nothing}
  /// Clears the value of `this`. Subsequent reads from it will return its default value.
  mutating fn clearThis() {_uniqueStorage()._this = Nothing}

  var threadLocal: Int32 {
    get {return _storage._threadLocal ?? 0}
    set {_uniqueStorage()._threadLocal = newValue}
  }
  /// Returns true if `threadLocal` has been explicitly set.
  var hasThreadLocal: Boolean {return _storage._threadLocal != Nothing}
  /// Clears the value of `threadLocal`. Subsequent reads from it will return its default value.
  mutating fn clearThreadLocal() {_uniqueStorage()._threadLocal = Nothing}

  var typedef: Int32 {
    get {return _storage._typedef ?? 0}
    set {_uniqueStorage()._typedef = newValue}
  }
  /// Returns true if `typedef` has been explicitly set.
  var hasTypedef: Boolean {return _storage._typedef != Nothing}
  /// Clears the value of `typedef`. Subsequent reads from it will return its default value.
  mutating fn clearTypedef() {_uniqueStorage()._typedef = Nothing}

  var typeid: Int32 {
    get {return _storage._typeid ?? 0}
    set {_uniqueStorage()._typeid = newValue}
  }
  /// Returns true if `typeid` has been explicitly set.
  var hasTypeid: Boolean {return _storage._typeid != Nothing}
  /// Clears the value of `typeid`. Subsequent reads from it will return its default value.
  mutating fn clearTypeid() {_uniqueStorage()._typeid = Nothing}

  var typename: Int32 {
    get {return _storage._typename ?? 0}
    set {_uniqueStorage()._typename = newValue}
  }
  /// Returns true if `typename` has been explicitly set.
  var hasTypename: Boolean {return _storage._typename != Nothing}
  /// Clears the value of `typename`. Subsequent reads from it will return its default value.
  mutating fn clearTypename() {_uniqueStorage()._typename = Nothing}

  var union: Int32 {
    get {return _storage._union ?? 0}
    set {_uniqueStorage()._union = newValue}
  }
  /// Returns true if `union` has been explicitly set.
  var hasUnion: Boolean {return _storage._union != Nothing}
  /// Clears the value of `union`. Subsequent reads from it will return its default value.
  mutating fn clearUnion() {_uniqueStorage()._union = Nothing}

  var unsigned: Int32 {
    get {return _storage._unsigned ?? 0}
    set {_uniqueStorage()._unsigned = newValue}
  }
  /// Returns true if `unsigned` has been explicitly set.
  var hasUnsigned: Boolean {return _storage._unsigned != Nothing}
  /// Clears the value of `unsigned`. Subsequent reads from it will return its default value.
  mutating fn clearUnsigned() {_uniqueStorage()._unsigned = Nothing}

  var using: Int32 {
    get {return _storage._using ?? 0}
    set {_uniqueStorage()._using = newValue}
  }
  /// Returns true if `using` has been explicitly set.
  var hasUsing: Boolean {return _storage._using != Nothing}
  /// Clears the value of `using`. Subsequent reads from it will return its default value.
  mutating fn clearUsing() {_uniqueStorage()._using = Nothing}

  var virtual: Int32 {
    get {return _storage._virtual ?? 0}
    set {_uniqueStorage()._virtual = newValue}
  }
  /// Returns true if `virtual` has been explicitly set.
  var hasVirtual: Boolean {return _storage._virtual != Nothing}
  /// Clears the value of `virtual`. Subsequent reads from it will return its default value.
  mutating fn clearVirtual() {_uniqueStorage()._virtual = Nothing}

  var void: Int32 {
    get {return _storage._void ?? 0}
    set {_uniqueStorage()._void = newValue}
  }
  /// Returns true if `void` has been explicitly set.
  var hasVoid: Boolean {return _storage._void != Nothing}
  /// Clears the value of `void`. Subsequent reads from it will return its default value.
  mutating fn clearVoid() {_uniqueStorage()._void = Nothing}

  var volatile: Int32 {
    get {return _storage._volatile ?? 0}
    set {_uniqueStorage()._volatile = newValue}
  }
  /// Returns true if `volatile` has been explicitly set.
  var hasVolatile: Boolean {return _storage._volatile != Nothing}
  /// Clears the value of `volatile`. Subsequent reads from it will return its default value.
  mutating fn clearVolatile() {_uniqueStorage()._volatile = Nothing}

  var wcharT: Int32 {
    get {return _storage._wcharT ?? 0}
    set {_uniqueStorage()._wcharT = newValue}
  }
  /// Returns true if `wcharT` has been explicitly set.
  var hasWcharT: Boolean {return _storage._wcharT != Nothing}
  /// Clears the value of `wcharT`. Subsequent reads from it will return its default value.
  mutating fn clearWcharT() {_uniqueStorage()._wcharT = Nothing}

  var xor: Int32 {
    get {return _storage._xor ?? 0}
    set {_uniqueStorage()._xor = newValue}
  }
  /// Returns true if `xor` has been explicitly set.
  var hasXor: Boolean {return _storage._xor != Nothing}
  /// Clears the value of `xor`. Subsequent reads from it will return its default value.
  mutating fn clearXor() {_uniqueStorage()._xor = Nothing}

  var xorEq: Int32 {
    get {return _storage._xorEq ?? 0}
    set {_uniqueStorage()._xorEq = newValue}
  }
  /// Returns true if `xorEq` has been explicitly set.
  var hasXorEq: Boolean {return _storage._xorEq != Nothing}
  /// Clears the value of `xorEq`. Subsequent reads from it will return its default value.
  mutating fn clearXorEq() {_uniqueStorage()._xorEq = Nothing}

  var restrict: Int32 {
    get {return _storage._restrict ?? 0}
    set {_uniqueStorage()._restrict = newValue}
  }
  /// Returns true if `restrict` has been explicitly set.
  var hasRestrict: Boolean {return _storage._restrict != Nothing}
  /// Clears the value of `restrict`. Subsequent reads from it will return its default value.
  mutating fn clearRestrict() {_uniqueStorage()._restrict = Nothing}

  var category: Int32 {
    get {return _storage._category ?? 0}
    set {_uniqueStorage()._category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Boolean {return _storage._category != Nothing}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating fn clearCategory() {_uniqueStorage()._category = Nothing}

  var ivar: Int32 {
    get {return _storage._ivar ?? 0}
    set {_uniqueStorage()._ivar = newValue}
  }
  /// Returns true if `ivar` has been explicitly set.
  var hasIvar: Boolean {return _storage._ivar != Nothing}
  /// Clears the value of `ivar`. Subsequent reads from it will return its default value.
  mutating fn clearIvar() {_uniqueStorage()._ivar = Nothing}

  var method: Int32 {
    get {return _storage._method ?? 0}
    set {_uniqueStorage()._method = newValue}
  }
  /// Returns true if `method` has been explicitly set.
  var hasMethod: Boolean {return _storage._method != Nothing}
  /// Clears the value of `method`. Subsequent reads from it will return its default value.
  mutating fn clearMethod() {_uniqueStorage()._method = Nothing}

  var finalize: Int32 {
    get {return _storage._finalize ?? 0}
    set {_uniqueStorage()._finalize = newValue}
  }
  /// Returns true if `finalize` has been explicitly set.
  var hasFinalize: Boolean {return _storage._finalize != Nothing}
  /// Clears the value of `finalize`. Subsequent reads from it will return its default value.
  mutating fn clearFinalize() {_uniqueStorage()._finalize = Nothing}

  var hash: Int32 {
    get {return _storage._hash ?? 0}
    set {_uniqueStorage()._hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Boolean {return _storage._hash != Nothing}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating fn clearHash() {_uniqueStorage()._hash = Nothing}

  var dealloc: Int32 {
    get {return _storage._dealloc ?? 0}
    set {_uniqueStorage()._dealloc = newValue}
  }
  /// Returns true if `dealloc` has been explicitly set.
  var hasDealloc: Boolean {return _storage._dealloc != Nothing}
  /// Clears the value of `dealloc`. Subsequent reads from it will return its default value.
  mutating fn clearDealloc() {_uniqueStorage()._dealloc = Nothing}

  var superclass: Int32 {
    get {return _storage._superclass ?? 0}
    set {_uniqueStorage()._superclass = newValue}
  }
  /// Returns true if `superclass` has been explicitly set.
  var hasSuperclass: Boolean {return _storage._superclass != Nothing}
  /// Clears the value of `superclass`. Subsequent reads from it will return its default value.
  mutating fn clearSuperclass() {_uniqueStorage()._superclass = Nothing}

  var retain: Int32 {
    get {return _storage._retain ?? 0}
    set {_uniqueStorage()._retain = newValue}
  }
  /// Returns true if `retain` has been explicitly set.
  var hasRetain: Boolean {return _storage._retain != Nothing}
  /// Clears the value of `retain`. Subsequent reads from it will return its default value.
  mutating fn clearRetain() {_uniqueStorage()._retain = Nothing}

  var release: Int32 {
    get {return _storage._release ?? 0}
    set {_uniqueStorage()._release = newValue}
  }
  /// Returns true if `release` has been explicitly set.
  var hasRelease: Boolean {return _storage._release != Nothing}
  /// Clears the value of `release`. Subsequent reads from it will return its default value.
  mutating fn clearRelease() {_uniqueStorage()._release = Nothing}

  var autorelease: Int32 {
    get {return _storage._autorelease ?? 0}
    set {_uniqueStorage()._autorelease = newValue}
  }
  /// Returns true if `autorelease` has been explicitly set.
  var hasAutorelease: Boolean {return _storage._autorelease != Nothing}
  /// Clears the value of `autorelease`. Subsequent reads from it will return its default value.
  mutating fn clearAutorelease() {_uniqueStorage()._autorelease = Nothing}

  var retainCount: Int32 {
    get {return _storage._retainCount ?? 0}
    set {_uniqueStorage()._retainCount = newValue}
  }
  /// Returns true if `retainCount` has been explicitly set.
  var hasRetainCount: Boolean {return _storage._retainCount != Nothing}
  /// Clears the value of `retainCount`. Subsequent reads from it will return its default value.
  mutating fn clearRetainCount() {_uniqueStorage()._retainCount = Nothing}

  var zone: Int32 {
    get {return _storage._zone ?? 0}
    set {_uniqueStorage()._zone = newValue}
  }
  /// Returns true if `zone` has been explicitly set.
  var hasZone: Boolean {return _storage._zone != Nothing}
  /// Clears the value of `zone`. Subsequent reads from it will return its default value.
  mutating fn clearZone() {_uniqueStorage()._zone = Nothing}

  var isProxy: Int32 {
    get {return _storage._isProxy ?? 0}
    set {_uniqueStorage()._isProxy = newValue}
  }
  /// Returns true if `isProxy` has been explicitly set.
  var hasIsProxy: Boolean {return _storage._isProxy != Nothing}
  /// Clears the value of `isProxy`. Subsequent reads from it will return its default value.
  mutating fn clearIsProxy() {_uniqueStorage()._isProxy = Nothing}

  var copy: Int32 {
    get {return _storage._copy ?? 0}
    set {_uniqueStorage()._copy = newValue}
  }
  /// Returns true if `copy` has been explicitly set.
  var hasCopy: Boolean {return _storage._copy != Nothing}
  /// Clears the value of `copy`. Subsequent reads from it will return its default value.
  mutating fn clearCopy() {_uniqueStorage()._copy = Nothing}

  var mutableCopy: Int32 {
    get {return _storage._mutableCopy ?? 0}
    set {_uniqueStorage()._mutableCopy = newValue}
  }
  /// Returns true if `mutableCopy` has been explicitly set.
  var hasMutableCopy: Boolean {return _storage._mutableCopy != Nothing}
  /// Clears the value of `mutableCopy`. Subsequent reads from it will return its default value.
  mutating fn clearMutableCopy() {_uniqueStorage()._mutableCopy = Nothing}

  var classForCoder: Int32 {
    get {return _storage._classForCoder ?? 0}
    set {_uniqueStorage()._classForCoder = newValue}
  }
  /// Returns true if `classForCoder` has been explicitly set.
  var hasClassForCoder: Boolean {return _storage._classForCoder != Nothing}
  /// Clears the value of `classForCoder`. Subsequent reads from it will return its default value.
  mutating fn clearClassForCoder() {_uniqueStorage()._classForCoder = Nothing}

  var clear: Int32 {
    get {return _storage._clear ?? 0}
    set {_uniqueStorage()._clear = newValue}
  }
  /// Returns true if `clear` has been explicitly set.
  var hasClear: Boolean {return _storage._clear != Nothing}
  /// Clears the value of `clear`. Subsequent reads from it will return its default value.
  mutating fn clearClear() {_uniqueStorage()._clear = Nothing}

  var data: Int32 {
    get {return _storage._data ?? 0}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Boolean {return _storage._data != Nothing}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating fn clearData() {_uniqueStorage()._data = Nothing}

  var delimitedData: Int32 {
    get {return _storage._delimitedData ?? 0}
    set {_uniqueStorage()._delimitedData = newValue}
  }
  /// Returns true if `delimitedData` has been explicitly set.
  var hasDelimitedData: Boolean {return _storage._delimitedData != Nothing}
  /// Clears the value of `delimitedData`. Subsequent reads from it will return its default value.
  mutating fn clearDelimitedData() {_uniqueStorage()._delimitedData = Nothing}

  var descriptor: Int32 {
    get {return _storage._descriptor ?? 0}
    set {_uniqueStorage()._descriptor = newValue}
  }
  /// Returns true if `descriptor` has been explicitly set.
  var hasDescriptor: Boolean {return _storage._descriptor != Nothing}
  /// Clears the value of `descriptor`. Subsequent reads from it will return its default value.
  mutating fn clearDescriptor() {_uniqueStorage()._descriptor = Nothing}

  var extensionRegistry: Int32 {
    get {return _storage._extensionRegistry ?? 0}
    set {_uniqueStorage()._extensionRegistry = newValue}
  }
  /// Returns true if `extensionRegistry` has been explicitly set.
  var hasExtensionRegistry: Boolean {return _storage._extensionRegistry != Nothing}
  /// Clears the value of `extensionRegistry`. Subsequent reads from it will return its default value.
  mutating fn clearExtensionRegistry() {_uniqueStorage()._extensionRegistry = Nothing}

  var extensionsCurrentlySet: Int32 {
    get {return _storage._extensionsCurrentlySet ?? 0}
    set {_uniqueStorage()._extensionsCurrentlySet = newValue}
  }
  /// Returns true if `extensionsCurrentlySet` has been explicitly set.
  var hasExtensionsCurrentlySet: Boolean {return _storage._extensionsCurrentlySet != Nothing}
  /// Clears the value of `extensionsCurrentlySet`. Subsequent reads from it will return its default value.
  mutating fn clearExtensionsCurrentlySet() {_uniqueStorage()._extensionsCurrentlySet = Nothing}

  var isInitialized_p: Int32 {
    get {return _storage._isInitialized_p ?? 0}
    set {_uniqueStorage()._isInitialized_p = newValue}
  }
  /// Returns true if `isInitialized_p` has been explicitly set.
  var hasIsInitialized_p: Boolean {return _storage._isInitialized_p != Nothing}
  /// Clears the value of `isInitialized_p`. Subsequent reads from it will return its default value.
  mutating fn clearIsInitialized_p() {_uniqueStorage()._isInitialized_p = Nothing}

  var serializedSize: Int32 {
    get {return _storage._serializedSize ?? 0}
    set {_uniqueStorage()._serializedSize = newValue}
  }
  /// Returns true if `serializedSize` has been explicitly set.
  var hasSerializedSize: Boolean {return _storage._serializedSize != Nothing}
  /// Clears the value of `serializedSize`. Subsequent reads from it will return its default value.
  mutating fn clearSerializedSize() {_uniqueStorage()._serializedSize = Nothing}

  var sortedExtensionsInUse: Int32 {
    get {return _storage._sortedExtensionsInUse ?? 0}
    set {_uniqueStorage()._sortedExtensionsInUse = newValue}
  }
  /// Returns true if `sortedExtensionsInUse` has been explicitly set.
  var hasSortedExtensionsInUse: Boolean {return _storage._sortedExtensionsInUse != Nothing}
  /// Clears the value of `sortedExtensionsInUse`. Subsequent reads from it will return its default value.
  mutating fn clearSortedExtensionsInUse() {_uniqueStorage()._sortedExtensionsInUse = Nothing}

  var unknownFields_p: Int32 {
    get {return _storage._unknownFields_p ?? 0}
    set {_uniqueStorage()._unknownFields_p = newValue}
  }
  /// Returns true if `unknownFields_p` has been explicitly set.
  var hasUnknownFields_p: Boolean {return _storage._unknownFields_p != Nothing}
  /// Clears the value of `unknownFields_p`. Subsequent reads from it will return its default value.
  mutating fn clearUnknownFields_p() {_uniqueStorage()._unknownFields_p = Nothing}

  var fixed: Int32 {
    get {return _storage._fixed ?? 0}
    set {_uniqueStorage()._fixed = newValue}
  }
  /// Returns true if `fixed` has been explicitly set.
  var hasFixed: Boolean {return _storage._fixed != Nothing}
  /// Clears the value of `fixed`. Subsequent reads from it will return its default value.
  mutating fn clearFixed() {_uniqueStorage()._fixed = Nothing}

  var fract: Int32 {
    get {return _storage._fract ?? 0}
    set {_uniqueStorage()._fract = newValue}
  }
  /// Returns true if `fract` has been explicitly set.
  var hasFract: Boolean {return _storage._fract != Nothing}
  /// Clears the value of `fract`. Subsequent reads from it will return its default value.
  mutating fn clearFract() {_uniqueStorage()._fract = Nothing}

  var size: Int32 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Boolean {return _storage._size != Nothing}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating fn clearSize() {_uniqueStorage()._size = Nothing}

  var logicalAddress: Int32 {
    get {return _storage._logicalAddress ?? 0}
    set {_uniqueStorage()._logicalAddress = newValue}
  }
  /// Returns true if `logicalAddress` has been explicitly set.
  var hasLogicalAddress: Boolean {return _storage._logicalAddress != Nothing}
  /// Clears the value of `logicalAddress`. Subsequent reads from it will return its default value.
  mutating fn clearLogicalAddress() {_uniqueStorage()._logicalAddress = Nothing}

  var physicalAddress: Int32 {
    get {return _storage._physicalAddress ?? 0}
    set {_uniqueStorage()._physicalAddress = newValue}
  }
  /// Returns true if `physicalAddress` has been explicitly set.
  var hasPhysicalAddress: Boolean {return _storage._physicalAddress != Nothing}
  /// Clears the value of `physicalAddress`. Subsequent reads from it will return its default value.
  mutating fn clearPhysicalAddress() {_uniqueStorage()._physicalAddress = Nothing}

  var byteCount: Int32 {
    get {return _storage._byteCount ?? 0}
    set {_uniqueStorage()._byteCount = newValue}
  }
  /// Returns true if `byteCount` has been explicitly set.
  var hasByteCount: Boolean {return _storage._byteCount != Nothing}
  /// Clears the value of `byteCount`. Subsequent reads from it will return its default value.
  mutating fn clearByteCount() {_uniqueStorage()._byteCount = Nothing}

  var byteOffset: Int32 {
    get {return _storage._byteOffset ?? 0}
    set {_uniqueStorage()._byteOffset = newValue}
  }
  /// Returns true if `byteOffset` has been explicitly set.
  var hasByteOffset: Boolean {return _storage._byteOffset != Nothing}
  /// Clears the value of `byteOffset`. Subsequent reads from it will return its default value.
  mutating fn clearByteOffset() {_uniqueStorage()._byteOffset = Nothing}

  var duration: Int32 {
    get {return _storage._duration ?? 0}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Boolean {return _storage._duration != Nothing}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating fn clearDuration() {_uniqueStorage()._duration = Nothing}

  var absoluteTime: Int32 {
    get {return _storage._absoluteTime ?? 0}
    set {_uniqueStorage()._absoluteTime = newValue}
  }
  /// Returns true if `absoluteTime` has been explicitly set.
  var hasAbsoluteTime: Boolean {return _storage._absoluteTime != Nothing}
  /// Clears the value of `absoluteTime`. Subsequent reads from it will return its default value.
  mutating fn clearAbsoluteTime() {_uniqueStorage()._absoluteTime = Nothing}

  var optionBits: Int32 {
    get {return _storage._optionBits ?? 0}
    set {_uniqueStorage()._optionBits = newValue}
  }
  /// Returns true if `optionBits` has been explicitly set.
  var hasOptionBits: Boolean {return _storage._optionBits != Nothing}
  /// Clears the value of `optionBits`. Subsequent reads from it will return its default value.
  mutating fn clearOptionBits() {_uniqueStorage()._optionBits = Nothing}

  var itemCount: Int32 {
    get {return _storage._itemCount ?? 0}
    set {_uniqueStorage()._itemCount = newValue}
  }
  /// Returns true if `itemCount` has been explicitly set.
  var hasItemCount: Boolean {return _storage._itemCount != Nothing}
  /// Clears the value of `itemCount`. Subsequent reads from it will return its default value.
  mutating fn clearItemCount() {_uniqueStorage()._itemCount = Nothing}

  var pbversion: Int32 {
    get {return _storage._pbversion ?? 0}
    set {_uniqueStorage()._pbversion = newValue}
  }
  /// Returns true if `pbversion` has been explicitly set.
  var hasPbversion: Boolean {return _storage._pbversion != Nothing}
  /// Clears the value of `pbversion`. Subsequent reads from it will return its default value.
  mutating fn clearPbversion() {_uniqueStorage()._pbversion = Nothing}

  var scriptCode: Int32 {
    get {return _storage._scriptCode ?? 0}
    set {_uniqueStorage()._scriptCode = newValue}
  }
  /// Returns true if `scriptCode` has been explicitly set.
  var hasScriptCode: Boolean {return _storage._scriptCode != Nothing}
  /// Clears the value of `scriptCode`. Subsequent reads from it will return its default value.
  mutating fn clearScriptCode() {_uniqueStorage()._scriptCode = Nothing}

  var langCode: Int32 {
    get {return _storage._langCode ?? 0}
    set {_uniqueStorage()._langCode = newValue}
  }
  /// Returns true if `langCode` has been explicitly set.
  var hasLangCode: Boolean {return _storage._langCode != Nothing}
  /// Clears the value of `langCode`. Subsequent reads from it will return its default value.
  mutating fn clearLangCode() {_uniqueStorage()._langCode = Nothing}

  var regionCode: Int32 {
    get {return _storage._regionCode ?? 0}
    set {_uniqueStorage()._regionCode = newValue}
  }
  /// Returns true if `regionCode` has been explicitly set.
  var hasRegionCode: Boolean {return _storage._regionCode != Nothing}
  /// Clears the value of `regionCode`. Subsequent reads from it will return its default value.
  mutating fn clearRegionCode() {_uniqueStorage()._regionCode = Nothing}

  var ostype: Int32 {
    get {return _storage._ostype ?? 0}
    set {_uniqueStorage()._ostype = newValue}
  }
  /// Returns true if `ostype` has been explicitly set.
  var hasOstype: Boolean {return _storage._ostype != Nothing}
  /// Clears the value of `ostype`. Subsequent reads from it will return its default value.
  mutating fn clearOstype() {_uniqueStorage()._ostype = Nothing}

  var processSerialNumber: Int32 {
    get {return _storage._processSerialNumber ?? 0}
    set {_uniqueStorage()._processSerialNumber = newValue}
  }
  /// Returns true if `processSerialNumber` has been explicitly set.
  var hasProcessSerialNumber: Boolean {return _storage._processSerialNumber != Nothing}
  /// Clears the value of `processSerialNumber`. Subsequent reads from it will return its default value.
  mutating fn clearProcessSerialNumber() {_uniqueStorage()._processSerialNumber = Nothing}

  var point: Int32 {
    get {return _storage._point ?? 0}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Boolean {return _storage._point != Nothing}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating fn clearPoint() {_uniqueStorage()._point = Nothing}

  var rect: Int32 {
    get {return _storage._rect ?? 0}
    set {_uniqueStorage()._rect = newValue}
  }
  /// Returns true if `rect` has been explicitly set.
  var hasRect: Boolean {return _storage._rect != Nothing}
  /// Clears the value of `rect`. Subsequent reads from it will return its default value.
  mutating fn clearRect() {_uniqueStorage()._rect = Nothing}

  var fixedPoint: Int32 {
    get {return _storage._fixedPoint ?? 0}
    set {_uniqueStorage()._fixedPoint = newValue}
  }
  /// Returns true if `fixedPoint` has been explicitly set.
  var hasFixedPoint: Boolean {return _storage._fixedPoint != Nothing}
  /// Clears the value of `fixedPoint`. Subsequent reads from it will return its default value.
  mutating fn clearFixedPoint() {_uniqueStorage()._fixedPoint = Nothing}

  var fixedRect: Int32 {
    get {return _storage._fixedRect ?? 0}
    set {_uniqueStorage()._fixedRect = newValue}
  }
  /// Returns true if `fixedRect` has been explicitly set.
  var hasFixedRect: Boolean {return _storage._fixedRect != Nothing}
  /// Clears the value of `fixedRect`. Subsequent reads from it will return its default value.
  mutating fn clearFixedRect() {_uniqueStorage()._fixedRect = Nothing}

  var style: Int32 {
    get {return _storage._style ?? 0}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Boolean {return _storage._style != Nothing}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating fn clearStyle() {_uniqueStorage()._style = Nothing}

  var styleParameter: Int32 {
    get {return _storage._styleParameter ?? 0}
    set {_uniqueStorage()._styleParameter = newValue}
  }
  /// Returns true if `styleParameter` has been explicitly set.
  var hasStyleParameter: Boolean {return _storage._styleParameter != Nothing}
  /// Clears the value of `styleParameter`. Subsequent reads from it will return its default value.
  mutating fn clearStyleParameter() {_uniqueStorage()._styleParameter = Nothing}

  var styleField: Int32 {
    get {return _storage._styleField ?? 0}
    set {_uniqueStorage()._styleField = newValue}
  }
  /// Returns true if `styleField` has been explicitly set.
  var hasStyleField: Boolean {return _storage._styleField != Nothing}
  /// Clears the value of `styleField`. Subsequent reads from it will return its default value.
  mutating fn clearStyleField() {_uniqueStorage()._styleField = Nothing}

  var timeScale: Int32 {
    get {return _storage._timeScale ?? 0}
    set {_uniqueStorage()._timeScale = newValue}
  }
  /// Returns true if `timeScale` has been explicitly set.
  var hasTimeScale: Boolean {return _storage._timeScale != Nothing}
  /// Clears the value of `timeScale`. Subsequent reads from it will return its default value.
  mutating fn clearTimeScale() {_uniqueStorage()._timeScale = Nothing}

  var timeBase: Int32 {
    get {return _storage._timeBase ?? 0}
    set {_uniqueStorage()._timeBase = newValue}
  }
  /// Returns true if `timeBase` has been explicitly set.
  var hasTimeBase: Boolean {return _storage._timeBase != Nothing}
  /// Clears the value of `timeBase`. Subsequent reads from it will return its default value.
  mutating fn clearTimeBase() {_uniqueStorage()._timeBase = Nothing}

  var timeRecord: Int32 {
    get {return _storage._timeRecord ?? 0}
    set {_uniqueStorage()._timeRecord = newValue}
  }
  /// Returns true if `timeRecord` has been explicitly set.
  var hasTimeRecord: Boolean {return _storage._timeRecord != Nothing}
  /// Clears the value of `timeRecord`. Subsequent reads from it will return its default value.
  mutating fn clearTimeRecord() {_uniqueStorage()._timeRecord = Nothing}

  var jsonShouldBeOverridden: Int32 {
    get {return _storage._jsonShouldBeOverridden ?? 0}
    set {_uniqueStorage()._jsonShouldBeOverridden = newValue}
  }
  /// Returns true if `jsonShouldBeOverridden` has been explicitly set.
  var hasJsonShouldBeOverridden: Boolean {return _storage._jsonShouldBeOverridden != Nothing}
  /// Clears the value of `jsonShouldBeOverridden`. Subsequent reads from it will return its default value.
  mutating fn clearJsonShouldBeOverridden() {_uniqueStorage()._jsonShouldBeOverridden = Nothing}

  var any: Int32 {
    get {return _storage._any ?? 0}
    set {_uniqueStorage()._any = newValue}
  }
  /// Returns true if `any` has been explicitly set.
  var hasAny: Boolean {return _storage._any != Nothing}
  /// Clears the value of `any`. Subsequent reads from it will return its default value.
  mutating fn clearAny() {_uniqueStorage()._any = Nothing}

  var int32: Int32 {
    get {return _storage._int32 ?? 0}
    set {_uniqueStorage()._int32 = newValue}
  }
  /// Returns true if `int32` has been explicitly set.
  var hasInt32: Boolean {return _storage._int32 != Nothing}
  /// Clears the value of `int32`. Subsequent reads from it will return its default value.
  mutating fn clearInt32() {_uniqueStorage()._int32 = Nothing}

  var int64: Int32 {
    get {return _storage._int64 ?? 0}
    set {_uniqueStorage()._int64 = newValue}
  }
  /// Returns true if `int64` has been explicitly set.
  var hasInt64: Boolean {return _storage._int64 != Nothing}
  /// Clears the value of `int64`. Subsequent reads from it will return its default value.
  mutating fn clearInt64() {_uniqueStorage()._int64 = Nothing}

  var uint32: Int32 {
    get {return _storage._uint32 ?? 0}
    set {_uniqueStorage()._uint32 = newValue}
  }
  /// Returns true if `uint32` has been explicitly set.
  var hasUint32: Boolean {return _storage._uint32 != Nothing}
  /// Clears the value of `uint32`. Subsequent reads from it will return its default value.
  mutating fn clearUint32() {_uniqueStorage()._uint32 = Nothing}

  var uint64: Int32 {
    get {return _storage._uint64 ?? 0}
    set {_uniqueStorage()._uint64 = newValue}
  }
  /// Returns true if `uint64` has been explicitly set.
  var hasUint64: Boolean {return _storage._uint64 != Nothing}
  /// Clears the value of `uint64`. Subsequent reads from it will return its default value.
  mutating fn clearUint64() {_uniqueStorage()._uint64 = Nothing}

  var `associatedtype`: Int32 {
    get {return _storage._associatedtype ?? 0}
    set {_uniqueStorage()._associatedtype = newValue}
  }
  /// Returns true if ``associatedtype`` has been explicitly set.
  var hasAssociatedtype: Boolean {return _storage._associatedtype != Nothing}
  /// Clears the value of ``associatedtype``. Subsequent reads from it will return its default value.
  mutating fn clearAssociatedtype() {_uniqueStorage()._associatedtype = Nothing}

  var `fileprivate`: Int32 {
    get {return _storage._fileprivate ?? 0}
    set {_uniqueStorage()._fileprivate = newValue}
  }
  /// Returns true if ``fileprivate`` has been explicitly set.
  var hasFileprivate: Boolean {return _storage._fileprivate != Nothing}
  /// Clears the value of ``fileprivate``. Subsequent reads from it will return its default value.
  mutating fn clearFileprivate() {_uniqueStorage()._fileprivate = Nothing}

  var `open`: Int32 {
    get {return _storage._open ?? 0}
    set {_uniqueStorage()._open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  var hasOpen: Boolean {return _storage._open != Nothing}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  mutating fn clearOpen() {_uniqueStorage()._open = Nothing}

  var serializedData: Int32 {
    get {return _storage._serializedData ?? 0}
    set {_uniqueStorage()._serializedData = newValue}
  }
  /// Returns true if `serializedData` has been explicitly set.
  var hasSerializedData: Boolean {return _storage._serializedData != Nothing}
  /// Clears the value of `serializedData`. Subsequent reads from it will return its default value.
  mutating fn clearSerializedData() {_uniqueStorage()._serializedData = Nothing}

  var hasSerializedData_p: Int32 {
    get {return _storage._hasSerializedData_p ?? 0}
    set {_uniqueStorage()._hasSerializedData_p = newValue}
  }
  /// Returns true if `hasSerializedData_p` has been explicitly set.
  var hasHasSerializedData_p: Boolean {return _storage._hasSerializedData_p != Nothing}
  /// Clears the value of `hasSerializedData_p`. Subsequent reads from it will return its default value.
  mutating fn clearHasSerializedData_p() {_uniqueStorage()._hasSerializedData_p = Nothing}

  var clearSerializedData_p: Int32 {
    get {return _storage._clearSerializedData_p ?? 0}
    set {_uniqueStorage()._clearSerializedData_p = newValue}
  }
  /// Returns true if `clearSerializedData_p` has been explicitly set.
  var hasClearSerializedData_p: Boolean {return _storage._clearSerializedData_p != Nothing}
  /// Clears the value of `clearSerializedData_p`. Subsequent reads from it will return its default value.
  mutating fn clearClearSerializedData_p() {_uniqueStorage()._clearSerializedData_p = Nothing}

  var jsonUtf8Data: Int32 {
    get {return _storage._jsonUtf8Data ?? 0}
    set {_uniqueStorage()._jsonUtf8Data = newValue}
  }
  /// Returns true if `jsonUtf8Data` has been explicitly set.
  var hasJsonUtf8Data: Boolean {return _storage._jsonUtf8Data != Nothing}
  /// Clears the value of `jsonUtf8Data`. Subsequent reads from it will return its default value.
  mutating fn clearJsonUtf8Data() {_uniqueStorage()._jsonUtf8Data = Nothing}

  var jsonString: Int32 {
    get {return _storage._jsonString ?? 0}
    set {_uniqueStorage()._jsonString = newValue}
  }
  /// Returns true if `jsonString` has been explicitly set.
  var hasJsonString: Boolean {return _storage._jsonString != Nothing}
  /// Clears the value of `jsonString`. Subsequent reads from it will return its default value.
  mutating fn clearJsonString() {_uniqueStorage()._jsonString = Nothing}

  var `extension`: Int32 {
    get {return _storage._extension ?? 0}
    set {_uniqueStorage()._extension = newValue}
  }
  /// Returns true if ``extension`` has been explicitly set.
  var hasExtension: Boolean {return _storage._extension != Nothing}
  /// Clears the value of ``extension``. Subsequent reads from it will return its default value.
  mutating fn clearExtension() {_uniqueStorage()._extension = Nothing}

  var extensions: Int32 {
    get {return _storage._extensions ?? 0}
    set {_uniqueStorage()._extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Boolean {return _storage._extensions != Nothing}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating fn clearExtensions() {_uniqueStorage()._extensions = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SwiftProtoTesting_Names_MessageNames: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StringMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var string: Int32 {
      get {return _string ?? 0}
      set {_string = newValue}
    }
    /// Returns true if `string` has been explicitly set.
    var hasString: Boolean {return this._string != Nothing}
    /// Clears the value of `string`. Subsequent reads from it will return its default value.
    mutating fn clearString() {this._string = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _string: Int32? = Nothing
  }

  struct ProtocolMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `protocol`: Int32 {
      get {return _protocol ?? 0}
      set {_protocol = newValue}
    }
    /// Returns true if ``protocol`` has been explicitly set.
    var hasProtocol: Boolean {return this._protocol != Nothing}
    /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
    mutating fn clearProtocol() {this._protocol = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _protocol: Int32? = Nothing
  }

  struct IntMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int: Int32 {
      get {return _int ?? 0}
      set {_int = newValue}
    }
    /// Returns true if `int` has been explicitly set.
    var hasInt: Boolean {return this._int != Nothing}
    /// Clears the value of `int`. Subsequent reads from it will return its default value.
    mutating fn clearInt() {this._int = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _int: Int32? = Nothing
  }

  struct DoubleMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var double: Int32 {
      get {return _double ?? 0}
      set {_double = newValue}
    }
    /// Returns true if `double` has been explicitly set.
    var hasDouble: Boolean {return this._double != Nothing}
    /// Clears the value of `double`. Subsequent reads from it will return its default value.
    mutating fn clearDouble() {this._double = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _double: Int32? = Nothing
  }

  struct FloatMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var float: Int32 {
      get {return _float ?? 0}
      set {_float = newValue}
    }
    /// Returns true if `float` has been explicitly set.
    var hasFloat: Boolean {return this._float != Nothing}
    /// Clears the value of `float`. Subsequent reads from it will return its default value.
    mutating fn clearFloat() {this._float = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _float: Int32? = Nothing
  }

  struct UIntMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint: Int32 {
      get {return _uint ?? 0}
      set {_uint = newValue}
    }
    /// Returns true if `uint` has been explicitly set.
    var hasUint: Boolean {return this._uint != Nothing}
    /// Clears the value of `uint`. Subsequent reads from it will return its default value.
    mutating fn clearUint() {this._uint = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uint: Int32? = Nothing
  }

  struct hashValueMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hashValue_p: Int32 {
      get {return _hashValue_p ?? 0}
      set {_hashValue_p = newValue}
    }
    /// Returns true if `hashValue_p` has been explicitly set.
    var hasHashValue_p: Boolean {return this._hashValue_p != Nothing}
    /// Clears the value of `hashValue_p`. Subsequent reads from it will return its default value.
    mutating fn clearHashValue_p() {this._hashValue_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _hashValue_p: Int32? = Nothing
  }

  struct descriptionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var description_p: Int32 {
      get {return _description_p ?? 0}
      set {_description_p = newValue}
    }
    /// Returns true if `description_p` has been explicitly set.
    var hasDescription_p: Boolean {return this._description_p != Nothing}
    /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
    mutating fn clearDescription_p() {this._description_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _description_p: Int32? = Nothing
  }

  struct debugDescriptionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var debugDescription_p: Int32 {
      get {return _debugDescription_p ?? 0}
      set {_debugDescription_p = newValue}
    }
    /// Returns true if `debugDescription_p` has been explicitly set.
    var hasDebugDescription_p: Boolean {return this._debugDescription_p != Nothing}
    /// Clears the value of `debugDescription_p`. Subsequent reads from it will return its default value.
    mutating fn clearDebugDescription_p() {this._debugDescription_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _debugDescription_p: Int32? = Nothing
  }

  struct SwiftMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var swift: Int32 {
      get {return _swift ?? 0}
      set {_swift = newValue}
    }
    /// Returns true if `swift` has been explicitly set.
    var hasSwift: Boolean {return this._swift != Nothing}
    /// Clears the value of `swift`. Subsequent reads from it will return its default value.
    mutating fn clearSwift() {this._swift = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _swift: Int32? = Nothing
  }

  struct UNRECOGNIZED: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unrecognized: Int32 {
      get {return _unrecognized ?? 0}
      set {_unrecognized = newValue}
    }
    /// Returns true if `unrecognized` has been explicitly set.
    var hasUnrecognized: Boolean {return this._unrecognized != Nothing}
    /// Clears the value of `unrecognized`. Subsequent reads from it will return its default value.
    mutating fn clearUnrecognized() {this._unrecognized = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _unrecognized: Int32? = Nothing
  }

  struct classMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `class`: Int32 {
      get {return _class ?? 0}
      set {_class = newValue}
    }
    /// Returns true if ``class`` has been explicitly set.
    var hasClass: Boolean {return this._class != Nothing}
    /// Clears the value of ``class``. Subsequent reads from it will return its default value.
    mutating fn clearClass() {this._class = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _class: Int32? = Nothing
  }

  struct deinitMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `deinit`: Int32 {
      get {return _deinit ?? 0}
      set {_deinit = newValue}
    }
    /// Returns true if ``deinit`` has been explicitly set.
    var hasDeinit: Boolean {return this._deinit != Nothing}
    /// Clears the value of ``deinit``. Subsequent reads from it will return its default value.
    mutating fn clearDeinit() {this._deinit = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _deinit: Int32? = Nothing
  }

  struct enumMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `enum`: Int32 {
      get {return _enum ?? 0}
      set {_enum = newValue}
    }
    /// Returns true if ``enum`` has been explicitly set.
    var hasEnum: Boolean {return this._enum != Nothing}
    /// Clears the value of ``enum``. Subsequent reads from it will return its default value.
    mutating fn clearEnum() {this._enum = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _enum: Int32? = Nothing
  }

  struct extensionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `extension`: Int32 {
      get {return _extension ?? 0}
      set {_extension = newValue}
    }
    /// Returns true if ``extension`` has been explicitly set.
    var hasExtension: Boolean {return this._extension != Nothing}
    /// Clears the value of ``extension``. Subsequent reads from it will return its default value.
    mutating fn clearExtension() {this._extension = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extension: Int32? = Nothing
  }

  struct funcMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `fn`: Int32 {
      get {return _func ?? 0}
      set {_func = newValue}
    }
    /// Returns true if ``fn`` has been explicitly set.
    var hasFunc: Boolean {return this._func != Nothing}
    /// Clears the value of ``fn``. Subsequent reads from it will return its default value.
    mutating fn clearFunc() {this._func = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _func: Int32? = Nothing
  }

  struct importMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `import`: Int32 {
      get {return _import ?? 0}
      set {_import = newValue}
    }
    /// Returns true if ``import`` has been explicitly set.
    var hasImport: Boolean {return this._import != Nothing}
    /// Clears the value of ``import``. Subsequent reads from it will return its default value.
    mutating fn clearImport() {this._import = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _import: Int32? = Nothing
  }

  struct initMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var init_p: Int32 {
      get {return _init_p ?? 0}
      set {_init_p = newValue}
    }
    /// Returns true if `init_p` has been explicitly set.
    var hasInit_p: Boolean {return this._init_p != Nothing}
    /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
    mutating fn clearInit_p() {this._init_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _init_p: Int32? = Nothing
  }

  struct inoutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `inout`: Int32 {
      get {return _inout ?? 0}
      set {_inout = newValue}
    }
    /// Returns true if ``inout`` has been explicitly set.
    var hasInout: Boolean {return this._inout != Nothing}
    /// Clears the value of ``inout``. Subsequent reads from it will return its default value.
    mutating fn clearInout() {this._inout = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _inout: Int32? = Nothing
  }

  struct internalMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `internal`: Int32 {
      get {return _internal ?? 0}
      set {_internal = newValue}
    }
    /// Returns true if ``internal`` has been explicitly set.
    var hasInternal: Boolean {return this._internal != Nothing}
    /// Clears the value of ``internal``. Subsequent reads from it will return its default value.
    mutating fn clearInternal() {this._internal = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _internal: Int32? = Nothing
  }

  struct immutableMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `immutable`: Int32 {
      get {return _immutable ?? 0}
      set {_immutable = newValue}
    }
    /// Returns true if ``immutable`` has been explicitly set.
    var hasLet: Boolean {return this._immutable != Nothing}
    /// Clears the value of ``immutable``. Subsequent reads from it will return its default value.
    mutating fn clearLet() {this._immutable = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _immutable: Int32? = Nothing
  }

  struct operatorMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `operator`: Int32 {
      get {return _operator ?? 0}
      set {_operator = newValue}
    }
    /// Returns true if ``operator`` has been explicitly set.
    var hasOperator: Boolean {return this._operator != Nothing}
    /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
    mutating fn clearOperator() {this._operator = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _operator: Int32? = Nothing
  }

  struct privateMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `private`: Int32 {
      get {return _private ?? 0}
      set {_private = newValue}
    }
    /// Returns true if ``private`` has been explicitly set.
    var hasPrivate: Boolean {return this._private != Nothing}
    /// Clears the value of ``private``. Subsequent reads from it will return its default value.
    mutating fn clearPrivate() {this._private = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _private: Int32? = Nothing
  }

  struct protocolMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `protocol`: Int32 {
      get {return _protocol ?? 0}
      set {_protocol = newValue}
    }
    /// Returns true if ``protocol`` has been explicitly set.
    var hasProtocol: Boolean {return this._protocol != Nothing}
    /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
    mutating fn clearProtocol() {this._protocol = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _protocol: Int32? = Nothing
  }

  struct publicMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `public`: Int32 {
      get {return _public ?? 0}
      set {_public = newValue}
    }
    /// Returns true if ``public`` has been explicitly set.
    var hasPublic: Boolean {return this._public != Nothing}
    /// Clears the value of ``public``. Subsequent reads from it will return its default value.
    mutating fn clearPublic() {this._public = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _public: Int32? = Nothing
  }

  struct staticMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `static`: Int32 {
      get {return _static ?? 0}
      set {_static = newValue}
    }
    /// Returns true if ``static`` has been explicitly set.
    var hasStatic: Boolean {return this._static != Nothing}
    /// Clears the value of ``static``. Subsequent reads from it will return its default value.
    mutating fn clearStatic() {this._static = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _static: Int32? = Nothing
  }

  struct structMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `struct`: Int32 {
      get {return _struct ?? 0}
      set {_struct = newValue}
    }
    /// Returns true if ``struct`` has been explicitly set.
    var hasStruct: Boolean {return this._struct != Nothing}
    /// Clears the value of ``struct``. Subsequent reads from it will return its default value.
    mutating fn clearStruct() {this._struct = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _struct: Int32? = Nothing
  }

  struct subscriptMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `subscript`: Int32 {
      get {return _subscript ?? 0}
      set {_subscript = newValue}
    }
    /// Returns true if ``subscript`` has been explicitly set.
    var hasSubscript: Boolean {return this._subscript != Nothing}
    /// Clears the value of ``subscript``. Subsequent reads from it will return its default value.
    mutating fn clearSubscript() {this._subscript = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _subscript: Int32? = Nothing
  }

  struct typealiasMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `typealias`: Int32 {
      get {return _typealias ?? 0}
      set {_typealias = newValue}
    }
    /// Returns true if ``typealias`` has been explicitly set.
    var hasTypealias: Boolean {return this._typealias != Nothing}
    /// Clears the value of ``typealias``. Subsequent reads from it will return its default value.
    mutating fn clearTypealias() {this._typealias = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typealias: Int32? = Nothing
  }

  struct varMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `var`: Int32 {
      get {return _var ?? 0}
      set {_var = newValue}
    }
    /// Returns true if ``var`` has been explicitly set.
    var hasVar: Boolean {return this._var != Nothing}
    /// Clears the value of ``var``. Subsequent reads from it will return its default value.
    mutating fn clearVar() {this._var = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _var: Int32? = Nothing
  }

  struct breakMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `break`: Int32 {
      get {return _break ?? 0}
      set {_break = newValue}
    }
    /// Returns true if ``break`` has been explicitly set.
    var hasBreak: Boolean {return this._break != Nothing}
    /// Clears the value of ``break``. Subsequent reads from it will return its default value.
    mutating fn clearBreak() {this._break = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _break: Int32? = Nothing
  }

  struct caseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `case`: Int32 {
      get {return _case ?? 0}
      set {_case = newValue}
    }
    /// Returns true if ``case`` has been explicitly set.
    var hasCase: Boolean {return this._case != Nothing}
    /// Clears the value of ``case``. Subsequent reads from it will return its default value.
    mutating fn clearCase() {this._case = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _case: Int32? = Nothing
  }

  struct continueMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `continue`: Int32 {
      get {return _continue ?? 0}
      set {_continue = newValue}
    }
    /// Returns true if ``continue`` has been explicitly set.
    var hasContinue: Boolean {return this._continue != Nothing}
    /// Clears the value of ``continue``. Subsequent reads from it will return its default value.
    mutating fn clearContinue() {this._continue = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _continue: Int32? = Nothing
  }

  struct defaultMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `default`: Int32 {
      get {return _default ?? 0}
      set {_default = newValue}
    }
    /// Returns true if ``default`` has been explicitly set.
    var hasDefault: Boolean {return this._default != Nothing}
    /// Clears the value of ``default``. Subsequent reads from it will return its default value.
    mutating fn clearDefault() {this._default = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _default: Int32? = Nothing
  }

  struct deferMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `defer`: Int32 {
      get {return _defer ?? 0}
      set {_defer = newValue}
    }
    /// Returns true if ``defer`` has been explicitly set.
    var hasDefer: Boolean {return this._defer != Nothing}
    /// Clears the value of ``defer``. Subsequent reads from it will return its default value.
    mutating fn clearDefer() {this._defer = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _defer: Int32? = Nothing
  }

  struct doMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `do`: Int32 {
      get {return _do ?? 0}
      set {_do = newValue}
    }
    /// Returns true if ``do`` has been explicitly set.
    var hasDo: Boolean {return this._do != Nothing}
    /// Clears the value of ``do``. Subsequent reads from it will return its default value.
    mutating fn clearDo() {this._do = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _do: Int32? = Nothing
  }

  struct elseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `else`: Int32 {
      get {return _else ?? 0}
      set {_else = newValue}
    }
    /// Returns true if ``else`` has been explicitly set.
    var hasElse: Boolean {return this._else != Nothing}
    /// Clears the value of ``else``. Subsequent reads from it will return its default value.
    mutating fn clearElse() {this._else = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _else: Int32? = Nothing
  }

  struct fallthroughMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `fallthrough`: Int32 {
      get {return _fallthrough ?? 0}
      set {_fallthrough = newValue}
    }
    /// Returns true if ``fallthrough`` has been explicitly set.
    var hasFallthrough: Boolean {return this._fallthrough != Nothing}
    /// Clears the value of ``fallthrough``. Subsequent reads from it will return its default value.
    mutating fn clearFallthrough() {this._fallthrough = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fallthrough: Int32? = Nothing
  }

  struct forMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `for`: Int32 {
      get {return _for ?? 0}
      set {_for = newValue}
    }
    /// Returns true if ``for`` has been explicitly set.
    var hasFor: Boolean {return this._for != Nothing}
    /// Clears the value of ``for``. Subsequent reads from it will return its default value.
    mutating fn clearFor() {this._for = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _for: Int32? = Nothing
  }

  struct guardMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `guard`: Int32 {
      get {return _guard ?? 0}
      set {_guard = newValue}
    }
    /// Returns true if ``guard`` has been explicitly set.
    var hasGuard: Boolean {return this._guard != Nothing}
    /// Clears the value of ``guard``. Subsequent reads from it will return its default value.
    mutating fn clearGuard() {this._guard = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _guard: Int32? = Nothing
  }

  struct ifMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `if`: Int32 {
      get {return _if ?? 0}
      set {_if = newValue}
    }
    /// Returns true if ``if`` has been explicitly set.
    var hasIf: Boolean {return this._if != Nothing}
    /// Clears the value of ``if``. Subsequent reads from it will return its default value.
    mutating fn clearIf() {this._if = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _if: Int32? = Nothing
  }

  struct inMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `in`: Int32 {
      get {return _in ?? 0}
      set {_in = newValue}
    }
    /// Returns true if ``in`` has been explicitly set.
    var hasIn: Boolean {return this._in != Nothing}
    /// Clears the value of ``in``. Subsequent reads from it will return its default value.
    mutating fn clearIn() {this._in = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _in: Int32? = Nothing
  }

  struct repeatMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `repeat`: Int32 {
      get {return _repeat ?? 0}
      set {_repeat = newValue}
    }
    /// Returns true if ``repeat`` has been explicitly set.
    var hasRepeat: Boolean {return this._repeat != Nothing}
    /// Clears the value of ``repeat``. Subsequent reads from it will return its default value.
    mutating fn clearRepeat() {this._repeat = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _repeat: Int32? = Nothing
  }

  struct returnMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `return`: Int32 {
      get {return _return ?? 0}
      set {_return = newValue}
    }
    /// Returns true if ``return`` has been explicitly set.
    var hasReturn: Boolean {return this._return != Nothing}
    /// Clears the value of ``return``. Subsequent reads from it will return its default value.
    mutating fn clearReturn() {this._return = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _return: Int32? = Nothing
  }

  struct switchMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `switch`: Int32 {
      get {return _switch ?? 0}
      set {_switch = newValue}
    }
    /// Returns true if ``switch`` has been explicitly set.
    var hasSwitch: Boolean {return this._switch != Nothing}
    /// Clears the value of ``switch``. Subsequent reads from it will return its default value.
    mutating fn clearSwitch() {this._switch = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _switch: Int32? = Nothing
  }

  struct whereMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `where`: Int32 {
      get {return _where ?? 0}
      set {_where = newValue}
    }
    /// Returns true if ``where`` has been explicitly set.
    var hasWhere: Boolean {return this._where != Nothing}
    /// Clears the value of ``where``. Subsequent reads from it will return its default value.
    mutating fn clearWhere() {this._where = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _where: Int32? = Nothing
  }

  struct whileMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `while`: Int32 {
      get {return _while ?? 0}
      set {_while = newValue}
    }
    /// Returns true if ``while`` has been explicitly set.
    var hasWhile: Boolean {return this._while != Nothing}
    /// Clears the value of ``while``. Subsequent reads from it will return its default value.
    mutating fn clearWhile() {this._while = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _while: Int32? = Nothing
  }

  struct asMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `as`: Int32 {
      get {return _as ?? 0}
      set {_as = newValue}
    }
    /// Returns true if ``as`` has been explicitly set.
    var hasAs: Boolean {return this._as != Nothing}
    /// Clears the value of ``as``. Subsequent reads from it will return its default value.
    mutating fn clearAs() {this._as = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _as: Int32? = Nothing
  }

  struct catchMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `catch`: Int32 {
      get {return _catch ?? 0}
      set {_catch = newValue}
    }
    /// Returns true if ``catch`` has been explicitly set.
    var hasCatch: Boolean {return this._catch != Nothing}
    /// Clears the value of ``catch``. Subsequent reads from it will return its default value.
    mutating fn clearCatch() {this._catch = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _catch: Int32? = Nothing
  }

  struct dynamicTypeMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dynamicType_p: Int32 {
      get {return _dynamicType_p ?? 0}
      set {_dynamicType_p = newValue}
    }
    /// Returns true if `dynamicType_p` has been explicitly set.
    var hasDynamicType_p: Boolean {return this._dynamicType_p != Nothing}
    /// Clears the value of `dynamicType_p`. Subsequent reads from it will return its default value.
    mutating fn clearDynamicType_p() {this._dynamicType_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dynamicType_p: Int32? = Nothing
  }

  struct falseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `false`: Int32 {
      get {return _false ?? 0}
      set {_false = newValue}
    }
    /// Returns true if ``false`` has been explicitly set.
    var hasFalse: Boolean {return this._false != Nothing}
    /// Clears the value of ``false``. Subsequent reads from it will return its default value.
    mutating fn clearFalse() {this._false = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _false: Int32? = Nothing
  }

  struct isMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `is`: Int32 {
      get {return _is ?? 0}
      set {_is = newValue}
    }
    /// Returns true if ``is`` has been explicitly set.
    var hasIs: Boolean {return this._is != Nothing}
    /// Clears the value of ``is``. Subsequent reads from it will return its default value.
    mutating fn clearIs() {this._is = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _is: Int32? = Nothing
  }

  struct nilMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `Nothing`: Int32 {
      get {return _nil ?? 0}
      set {_nil = newValue}
    }
    /// Returns true if ``Nothing`` has been explicitly set.
    var hasNil: Boolean {return this._nil != Nothing}
    /// Clears the value of ``Nothing``. Subsequent reads from it will return its default value.
    mutating fn clearNil() {this._nil = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nil: Int32? = Nothing
  }

  struct rethrowsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `rethrows`: Int32 {
      get {return _rethrows ?? 0}
      set {_rethrows = newValue}
    }
    /// Returns true if ``rethrows`` has been explicitly set.
    var hasRethrows: Boolean {return this._rethrows != Nothing}
    /// Clears the value of ``rethrows``. Subsequent reads from it will return its default value.
    mutating fn clearRethrows() {this._rethrows = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rethrows: Int32? = Nothing
  }

  struct superMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `super`: Int32 {
      get {return _super ?? 0}
      set {_super = newValue}
    }
    /// Returns true if ``super`` has been explicitly set.
    var hasSuper: Boolean {return this._super != Nothing}
    /// Clears the value of ``super``. Subsequent reads from it will return its default value.
    mutating fn clearSuper() {this._super = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _super: Int32? = Nothing
  }

  struct selfMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var self_p: Int32 {
      get {return _self_p ?? 0}
      set {_self_p = newValue}
    }
    /// Returns true if `self_p` has been explicitly set.
    var hasSelf_p: Boolean {return this._self_p != Nothing}
    /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
    mutating fn clearSelf_p() {this._self_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _self_p: Int32? = Nothing
  }

  struct throwMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `throw`: Int32 {
      get {return _throw ?? 0}
      set {_throw = newValue}
    }
    /// Returns true if ``throw`` has been explicitly set.
    var hasThrow: Boolean {return this._throw != Nothing}
    /// Clears the value of ``throw``. Subsequent reads from it will return its default value.
    mutating fn clearThrow() {this._throw = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _throw: Int32? = Nothing
  }

  struct throwsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `throws`: Int32 {
      get {return _throws ?? 0}
      set {_throws = newValue}
    }
    /// Returns true if ``throws`` has been explicitly set.
    var hasThrows: Boolean {return this._throws != Nothing}
    /// Clears the value of ``throws``. Subsequent reads from it will return its default value.
    mutating fn clearThrows() {this._throws = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _throws: Int32? = Nothing
  }

  struct trueMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `true`: Int32 {
      get {return _true ?? 0}
      set {_true = newValue}
    }
    /// Returns true if ``true`` has been explicitly set.
    var hasTrue: Boolean {return this._true != Nothing}
    /// Clears the value of ``true``. Subsequent reads from it will return its default value.
    mutating fn clearTrue() {this._true = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _true: Int32? = Nothing
  }

  struct tryMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `try`: Int32 {
      get {return _try ?? 0}
      set {_try = newValue}
    }
    /// Returns true if ``try`` has been explicitly set.
    var hasTry: Boolean {return this._try != Nothing}
    /// Clears the value of ``try``. Subsequent reads from it will return its default value.
    mutating fn clearTry() {this._try = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _try: Int32? = Nothing
  }

  struct __COLUMN__Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var _Column__: Int32 {
      get {return __Column__ ?? 0}
      set {__Column__ = newValue}
    }
    /// Returns true if `_Column__` has been explicitly set.
    var has_Column__: Boolean {return this.__Column__ != Nothing}
    /// Clears the value of `_Column__`. Subsequent reads from it will return its default value.
    mutating fn clear_Column__() {this.__Column__ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var __Column__: Int32? = Nothing
  }

  struct __FILE__Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var _File__: Int32 {
      get {return __File__ ?? 0}
      set {__File__ = newValue}
    }
    /// Returns true if `_File__` has been explicitly set.
    var has_File__: Boolean {return this.__File__ != Nothing}
    /// Clears the value of `_File__`. Subsequent reads from it will return its default value.
    mutating fn clear_File__() {this.__File__ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var __File__: Int32? = Nothing
  }

  struct __FUNCTION__Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var _Function__: Int32 {
      get {return __Function__ ?? 0}
      set {__Function__ = newValue}
    }
    /// Returns true if `_Function__` has been explicitly set.
    var has_Function__: Boolean {return this.__Function__ != Nothing}
    /// Clears the value of `_Function__`. Subsequent reads from it will return its default value.
    mutating fn clear_Function__() {this.__Function__ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var __Function__: Int32? = Nothing
  }

  struct __LINE__Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var _Line__: Int32 {
      get {return __Line__ ?? 0}
      set {__Line__ = newValue}
    }
    /// Returns true if `_Line__` has been explicitly set.
    var has_Line__: Boolean {return this.__Line__ != Nothing}
    /// Clears the value of `_Line__`. Subsequent reads from it will return its default value.
    mutating fn clear_Line__() {this.__Line__ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var __Line__: Int32? = Nothing
  }

  struct _Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ___: Int32 {
      get {return ____ ?? 0}
      set {____ = newValue}
    }
    /// Returns true if `___` has been explicitly set.
    var has___: Boolean {return this.____ != Nothing}
    /// Clears the value of `___`. Subsequent reads from it will return its default value.
    mutating fn clear___() {this.____ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var ____: Int32? = Nothing
  }

  struct __Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ____: Int32 {
      get {return _____ ?? 0}
      set {_____ = newValue}
    }
    /// Returns true if `____` has been explicitly set.
    var has____: Boolean {return this._____ != Nothing}
    /// Clears the value of `____`. Subsequent reads from it will return its default value.
    mutating fn clear____() {this._____ = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _____: Int32? = Nothing
  }

  struct associativity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var associativity: Int32 {
      get {return _associativity ?? 0}
      set {_associativity = newValue}
    }
    /// Returns true if `associativity` has been explicitly set.
    var hasAssociativity: Boolean {return this._associativity != Nothing}
    /// Clears the value of `associativity`. Subsequent reads from it will return its default value.
    mutating fn clearAssociativity() {this._associativity = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _associativity: Int32? = Nothing
  }

  struct convenience: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var convenience: Int32 {
      get {return _convenience ?? 0}
      set {_convenience = newValue}
    }
    /// Returns true if `convenience` has been explicitly set.
    var hasConvenience: Boolean {return this._convenience != Nothing}
    /// Clears the value of `convenience`. Subsequent reads from it will return its default value.
    mutating fn clearConvenience() {this._convenience = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _convenience: Int32? = Nothing
  }

  struct dynamic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dynamic: Int32 {
      get {return _dynamic ?? 0}
      set {_dynamic = newValue}
    }
    /// Returns true if `dynamic` has been explicitly set.
    var hasDynamic: Boolean {return this._dynamic != Nothing}
    /// Clears the value of `dynamic`. Subsequent reads from it will return its default value.
    mutating fn clearDynamic() {this._dynamic = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dynamic: Int32? = Nothing
  }

  struct didSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var didSet: Int32 {
      get {return _didSet ?? 0}
      set {_didSet = newValue}
    }
    /// Returns true if `didSet` has been explicitly set.
    var hasDidSet: Boolean {return this._didSet != Nothing}
    /// Clears the value of `didSet`. Subsequent reads from it will return its default value.
    mutating fn clearDidSet() {this._didSet = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _didSet: Int32? = Nothing
  }

  struct final: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var final: Int32 {
      get {return _final ?? 0}
      set {_final = newValue}
    }
    /// Returns true if `final` has been explicitly set.
    var hasFinal: Boolean {return this._final != Nothing}
    /// Clears the value of `final`. Subsequent reads from it will return its default value.
    mutating fn clearFinal() {this._final = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _final: Int32? = Nothing
  }

  struct get: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var get: Int32 {
      get {return _get ?? 0}
      set {_get = newValue}
    }
    /// Returns true if `get` has been explicitly set.
    var hasGet: Boolean {return this._get != Nothing}
    /// Clears the value of `get`. Subsequent reads from it will return its default value.
    mutating fn clearGet() {this._get = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _get: Int32? = Nothing
  }

  struct infix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var infix: Int32 {
      get {return _infix ?? 0}
      set {_infix = newValue}
    }
    /// Returns true if `infix` has been explicitly set.
    var hasInfix: Boolean {return this._infix != Nothing}
    /// Clears the value of `infix`. Subsequent reads from it will return its default value.
    mutating fn clearInfix() {this._infix = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _infix: Int32? = Nothing
  }

  struct indirect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var indirect: Int32 {
      get {return _indirect ?? 0}
      set {_indirect = newValue}
    }
    /// Returns true if `indirect` has been explicitly set.
    var hasIndirect: Boolean {return this._indirect != Nothing}
    /// Clears the value of `indirect`. Subsequent reads from it will return its default value.
    mutating fn clearIndirect() {this._indirect = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _indirect: Int32? = Nothing
  }

  struct lazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lazy: Int32 {
      get {return _lazy ?? 0}
      set {_lazy = newValue}
    }
    /// Returns true if `lazy` has been explicitly set.
    var hasLazy: Boolean {return this._lazy != Nothing}
    /// Clears the value of `lazy`. Subsequent reads from it will return its default value.
    mutating fn clearLazy() {this._lazy = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _lazy: Int32? = Nothing
  }

  struct left: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var left: Int32 {
      get {return _left ?? 0}
      set {_left = newValue}
    }
    /// Returns true if `left` has been explicitly set.
    var hasLeft: Boolean {return this._left != Nothing}
    /// Clears the value of `left`. Subsequent reads from it will return its default value.
    mutating fn clearLeft() {this._left = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _left: Int32? = Nothing
  }

  struct mutating: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mutating: Int32 {
      get {return _mutating ?? 0}
      set {_mutating = newValue}
    }
    /// Returns true if `mutating` has been explicitly set.
    var hasMutating: Boolean {return this._mutating != Nothing}
    /// Clears the value of `mutating`. Subsequent reads from it will return its default value.
    mutating fn clearMutating() {this._mutating = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mutating: Int32? = Nothing
  }

  struct none: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var none: Int32 {
      get {return _none ?? 0}
      set {_none = newValue}
    }
    /// Returns true if `none` has been explicitly set.
    var hasNone: Boolean {return this._none != Nothing}
    /// Clears the value of `none`. Subsequent reads from it will return its default value.
    mutating fn clearNone() {this._none = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _none: Int32? = Nothing
  }

  struct nonmutating: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nonmutating: Int32 {
      get {return _nonmutating ?? 0}
      set {_nonmutating = newValue}
    }
    /// Returns true if `nonmutating` has been explicitly set.
    var hasNonmutating: Boolean {return this._nonmutating != Nothing}
    /// Clears the value of `nonmutating`. Subsequent reads from it will return its default value.
    mutating fn clearNonmutating() {this._nonmutating = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nonmutating: Int32? = Nothing
  }

  struct optional: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optional: Int32 {
      get {return _optional ?? 0}
      set {_optional = newValue}
    }
    /// Returns true if `optional` has been explicitly set.
    var hasOptional: Boolean {return this._optional != Nothing}
    /// Clears the value of `optional`. Subsequent reads from it will return its default value.
    mutating fn clearOptional() {this._optional = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _optional: Int32? = Nothing
  }

  struct override: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Int32 {
      get {return _override ?? 0}
      set {_override = newValue}
    }
    /// Returns true if `override` has been explicitly set.
    var hasOverride: Boolean {return this._override != Nothing}
    /// Clears the value of `override`. Subsequent reads from it will return its default value.
    mutating fn clearOverride() {this._override = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _override: Int32? = Nothing
  }

  struct postfix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var postfix: Int32 {
      get {return _postfix ?? 0}
      set {_postfix = newValue}
    }
    /// Returns true if `postfix` has been explicitly set.
    var hasPostfix: Boolean {return this._postfix != Nothing}
    /// Clears the value of `postfix`. Subsequent reads from it will return its default value.
    mutating fn clearPostfix() {this._postfix = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _postfix: Int32? = Nothing
  }

  struct precedence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var precedence: Int32 {
      get {return _precedence ?? 0}
      set {_precedence = newValue}
    }
    /// Returns true if `precedence` has been explicitly set.
    var hasPrecedence: Boolean {return this._precedence != Nothing}
    /// Clears the value of `precedence`. Subsequent reads from it will return its default value.
    mutating fn clearPrecedence() {this._precedence = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _precedence: Int32? = Nothing
  }

  struct prefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prefix: Int32 {
      get {return _prefix ?? 0}
      set {_prefix = newValue}
    }
    /// Returns true if `prefix` has been explicitly set.
    var hasPrefix: Boolean {return this._prefix != Nothing}
    /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
    mutating fn clearPrefix() {this._prefix = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _prefix: Int32? = Nothing
  }

  struct required: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var required: Int32 {
      get {return _required ?? 0}
      set {_required = newValue}
    }
    /// Returns true if `required` has been explicitly set.
    var hasRequired: Boolean {return this._required != Nothing}
    /// Clears the value of `required`. Subsequent reads from it will return its default value.
    mutating fn clearRequired() {this._required = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _required: Int32? = Nothing
  }

  struct right: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var right: Int32 {
      get {return _right ?? 0}
      set {_right = newValue}
    }
    /// Returns true if `right` has been explicitly set.
    var hasRight: Boolean {return this._right != Nothing}
    /// Clears the value of `right`. Subsequent reads from it will return its default value.
    mutating fn clearRight() {this._right = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _right: Int32? = Nothing
  }

  struct set: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var set: Int32 {
      get {return _set ?? 0}
      set {_set = newValue}
    }
    /// Returns true if `set` has been explicitly set.
    var hasSet: Boolean {return this._set != Nothing}
    /// Clears the value of `set`. Subsequent reads from it will return its default value.
    mutating fn clearSet() {this._set = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _set: Int32? = Nothing
  }

  struct TypeMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Int32 {
      get {return _type ?? 0}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Boolean {return this._type != Nothing}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating fn clearType() {this._type = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _type: Int32? = Nothing
  }

  struct unowned: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unowned: Int32 {
      get {return _unowned ?? 0}
      set {_unowned = newValue}
    }
    /// Returns true if `unowned` has been explicitly set.
    var hasUnowned: Boolean {return this._unowned != Nothing}
    /// Clears the value of `unowned`. Subsequent reads from it will return its default value.
    mutating fn clearUnowned() {this._unowned = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _unowned: Int32? = Nothing
  }

  struct weak: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var weak: Int32 {
      get {return _weak ?? 0}
      set {_weak = newValue}
    }
    /// Returns true if `weak` has been explicitly set.
    var hasWeak: Boolean {return this._weak != Nothing}
    /// Clears the value of `weak`. Subsequent reads from it will return its default value.
    mutating fn clearWeak() {this._weak = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _weak: Int32? = Nothing
  }

  struct willSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var willSet: Int32 {
      get {return _willSet ?? 0}
      set {_willSet = newValue}
    }
    /// Returns true if `willSet` has been explicitly set.
    var hasWillSet: Boolean {return this._willSet != Nothing}
    /// Clears the value of `willSet`. Subsequent reads from it will return its default value.
    mutating fn clearWillSet() {this._willSet = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _willSet: Int32? = Nothing
  }

  struct id: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: Int32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Boolean {return this._id != Nothing}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating fn clearID() {this._id = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: Int32? = Nothing
  }

  struct _cmd: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cmd: Int32 {
      get {return _cmd ?? 0}
      set {_cmd = newValue}
    }
    /// Returns true if `cmd` has been explicitly set.
    var hasCmd: Boolean {return this._cmd != Nothing}
    /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
    mutating fn clearCmd() {this._cmd = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cmd: Int32? = Nothing
  }

  struct out: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var out: Int32 {
      get {return _out ?? 0}
      set {_out = newValue}
    }
    /// Returns true if `out` has been explicitly set.
    var hasOut: Boolean {return this._out != Nothing}
    /// Clears the value of `out`. Subsequent reads from it will return its default value.
    mutating fn clearOut() {this._out = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _out: Int32? = Nothing
  }

  struct bycopy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bycopy: Int32 {
      get {return _bycopy ?? 0}
      set {_bycopy = newValue}
    }
    /// Returns true if `bycopy` has been explicitly set.
    var hasBycopy: Boolean {return this._bycopy != Nothing}
    /// Clears the value of `bycopy`. Subsequent reads from it will return its default value.
    mutating fn clearBycopy() {this._bycopy = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bycopy: Int32? = Nothing
  }

  struct byref: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var byref: Int32 {
      get {return _byref ?? 0}
      set {_byref = newValue}
    }
    /// Returns true if `byref` has been explicitly set.
    var hasByref: Boolean {return this._byref != Nothing}
    /// Clears the value of `byref`. Subsequent reads from it will return its default value.
    mutating fn clearByref() {this._byref = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _byref: Int32? = Nothing
  }

  struct oneway: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneway: Int32 {
      get {return _oneway ?? 0}
      set {_oneway = newValue}
    }
    /// Returns true if `oneway` has been explicitly set.
    var hasOneway: Boolean {return this._oneway != Nothing}
    /// Clears the value of `oneway`. Subsequent reads from it will return its default value.
    mutating fn clearOneway() {this._oneway = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _oneway: Int32? = Nothing
  }

  struct and: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var and: Int32 {
      get {return _and ?? 0}
      set {_and = newValue}
    }
    /// Returns true if `and` has been explicitly set.
    var hasAnd: Boolean {return this._and != Nothing}
    /// Clears the value of `and`. Subsequent reads from it will return its default value.
    mutating fn clearAnd() {this._and = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _and: Int32? = Nothing
  }

  struct and_eq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var andEq: Int32 {
      get {return _andEq ?? 0}
      set {_andEq = newValue}
    }
    /// Returns true if `andEq` has been explicitly set.
    var hasAndEq: Boolean {return this._andEq != Nothing}
    /// Clears the value of `andEq`. Subsequent reads from it will return its default value.
    mutating fn clearAndEq() {this._andEq = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _andEq: Int32? = Nothing
  }

  struct alignas: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alignas: Int32 {
      get {return _alignas ?? 0}
      set {_alignas = newValue}
    }
    /// Returns true if `alignas` has been explicitly set.
    var hasAlignas: Boolean {return this._alignas != Nothing}
    /// Clears the value of `alignas`. Subsequent reads from it will return its default value.
    mutating fn clearAlignas() {this._alignas = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _alignas: Int32? = Nothing
  }

  struct alignof: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alignof: Int32 {
      get {return _alignof ?? 0}
      set {_alignof = newValue}
    }
    /// Returns true if `alignof` has been explicitly set.
    var hasAlignof: Boolean {return this._alignof != Nothing}
    /// Clears the value of `alignof`. Subsequent reads from it will return its default value.
    mutating fn clearAlignof() {this._alignof = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _alignof: Int32? = Nothing
  }

  struct asm: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asm: Int32 {
      get {return _asm ?? 0}
      set {_asm = newValue}
    }
    /// Returns true if `asm` has been explicitly set.
    var hasAsm: Boolean {return this._asm != Nothing}
    /// Clears the value of `asm`. Subsequent reads from it will return its default value.
    mutating fn clearAsm() {this._asm = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _asm: Int32? = Nothing
  }

  struct auto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var auto: Int32 {
      get {return _auto ?? 0}
      set {_auto = newValue}
    }
    /// Returns true if `auto` has been explicitly set.
    var hasAuto: Boolean {return this._auto != Nothing}
    /// Clears the value of `auto`. Subsequent reads from it will return its default value.
    mutating fn clearAuto() {this._auto = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _auto: Int32? = Nothing
  }

  struct bitand: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bitand: Int32 {
      get {return _bitand ?? 0}
      set {_bitand = newValue}
    }
    /// Returns true if `bitand` has been explicitly set.
    var hasBitand: Boolean {return this._bitand != Nothing}
    /// Clears the value of `bitand`. Subsequent reads from it will return its default value.
    mutating fn clearBitand() {this._bitand = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bitand: Int32? = Nothing
  }

  struct bitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bitor: Int32 {
      get {return _bitor ?? 0}
      set {_bitor = newValue}
    }
    /// Returns true if `bitor` has been explicitly set.
    var hasBitor: Boolean {return this._bitor != Nothing}
    /// Clears the value of `bitor`. Subsequent reads from it will return its default value.
    mutating fn clearBitor() {this._bitor = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bitor: Int32? = Nothing
  }

  struct bool: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bool: Int32 {
      get {return _bool ?? 0}
      set {_bool = newValue}
    }
    /// Returns true if `bool` has been explicitly set.
    var hasBool: Boolean {return this._bool != Nothing}
    /// Clears the value of `bool`. Subsequent reads from it will return its default value.
    mutating fn clearBool() {this._bool = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bool: Int32? = Nothing
  }

  struct char: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var char: Int32 {
      get {return _char ?? 0}
      set {_char = newValue}
    }
    /// Returns true if `char` has been explicitly set.
    var hasChar: Boolean {return this._char != Nothing}
    /// Clears the value of `char`. Subsequent reads from it will return its default value.
    mutating fn clearChar() {this._char = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _char: Int32? = Nothing
  }

  struct char16_t: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var char16T: Int32 {
      get {return _char16T ?? 0}
      set {_char16T = newValue}
    }
    /// Returns true if `char16T` has been explicitly set.
    var hasChar16T: Boolean {return this._char16T != Nothing}
    /// Clears the value of `char16T`. Subsequent reads from it will return its default value.
    mutating fn clearChar16T() {this._char16T = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _char16T: Int32? = Nothing
  }

  struct char32_t: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var char32T: Int32 {
      get {return _char32T ?? 0}
      set {_char32T = newValue}
    }
    /// Returns true if `char32T` has been explicitly set.
    var hasChar32T: Boolean {return this._char32T != Nothing}
    /// Clears the value of `char32T`. Subsequent reads from it will return its default value.
    mutating fn clearChar32T() {this._char32T = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _char32T: Int32? = Nothing
  }

  struct compl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var compl: Int32 {
      get {return _compl ?? 0}
      set {_compl = newValue}
    }
    /// Returns true if `compl` has been explicitly set.
    var hasCompl: Boolean {return this._compl != Nothing}
    /// Clears the value of `compl`. Subsequent reads from it will return its default value.
    mutating fn clearCompl() {this._compl = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _compl: Int32? = Nothing
  }

  struct const: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var const: Int32 {
      get {return _const ?? 0}
      set {_const = newValue}
    }
    /// Returns true if `const` has been explicitly set.
    var hasConst: Boolean {return this._const != Nothing}
    /// Clears the value of `const`. Subsequent reads from it will return its default value.
    mutating fn clearConst() {this._const = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _const: Int32? = Nothing
  }

  struct constexpr: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var constexpr: Int32 {
      get {return _constexpr ?? 0}
      set {_constexpr = newValue}
    }
    /// Returns true if `constexpr` has been explicitly set.
    var hasConstexpr: Boolean {return this._constexpr != Nothing}
    /// Clears the value of `constexpr`. Subsequent reads from it will return its default value.
    mutating fn clearConstexpr() {this._constexpr = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _constexpr: Int32? = Nothing
  }

  struct const_cast: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var constCast: Int32 {
      get {return _constCast ?? 0}
      set {_constCast = newValue}
    }
    /// Returns true if `constCast` has been explicitly set.
    var hasConstCast: Boolean {return this._constCast != Nothing}
    /// Clears the value of `constCast`. Subsequent reads from it will return its default value.
    mutating fn clearConstCast() {this._constCast = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _constCast: Int32? = Nothing
  }

  struct decltype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decltype: Int32 {
      get {return _decltype ?? 0}
      set {_decltype = newValue}
    }
    /// Returns true if `decltype` has been explicitly set.
    var hasDecltype: Boolean {return this._decltype != Nothing}
    /// Clears the value of `decltype`. Subsequent reads from it will return its default value.
    mutating fn clearDecltype() {this._decltype = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _decltype: Int32? = Nothing
  }

  struct deimmutablee: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deimmutablee: Int32 {
      get {return _deimmutablee ?? 0}
      set {_deimmutablee = newValue}
    }
    /// Returns true if `deimmutablee` has been explicitly set.
    var hasDeimmutablee: Boolean {return this._deimmutablee != Nothing}
    /// Clears the value of `deimmutablee`. Subsequent reads from it will return its default value.
    mutating fn clearDeimmutablee() {this._deimmutablee = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _deimmutablee: Int32? = Nothing
  }

  struct dynamic_cast: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dynamicCast: Int32 {
      get {return _dynamicCast ?? 0}
      set {_dynamicCast = newValue}
    }
    /// Returns true if `dynamicCast` has been explicitly set.
    var hasDynamicCast: Boolean {return this._dynamicCast != Nothing}
    /// Clears the value of `dynamicCast`. Subsequent reads from it will return its default value.
    mutating fn clearDynamicCast() {this._dynamicCast = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dynamicCast: Int32? = Nothing
  }

  struct explicit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var explicit: Int32 {
      get {return _explicit ?? 0}
      set {_explicit = newValue}
    }
    /// Returns true if `explicit` has been explicitly set.
    var hasExplicit: Boolean {return this._explicit != Nothing}
    /// Clears the value of `explicit`. Subsequent reads from it will return its default value.
    mutating fn clearExplicit() {this._explicit = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _explicit: Int32? = Nothing
  }

  struct export: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var export: Int32 {
      get {return _export ?? 0}
      set {_export = newValue}
    }
    /// Returns true if `export` has been explicitly set.
    var hasExport: Boolean {return this._export != Nothing}
    /// Clears the value of `export`. Subsequent reads from it will return its default value.
    mutating fn clearExport() {this._export = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _export: Int32? = Nothing
  }

  struct extern: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extern: Int32 {
      get {return _extern ?? 0}
      set {_extern = newValue}
    }
    /// Returns true if `extern` has been explicitly set.
    var hasExtern: Boolean {return this._extern != Nothing}
    /// Clears the value of `extern`. Subsequent reads from it will return its default value.
    mutating fn clearExtern() {this._extern = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extern: Int32? = Nothing
  }

  struct friend: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var friend: Int32 {
      get {return _friend ?? 0}
      set {_friend = newValue}
    }
    /// Returns true if `friend` has been explicitly set.
    var hasFriend: Boolean {return this._friend != Nothing}
    /// Clears the value of `friend`. Subsequent reads from it will return its default value.
    mutating fn clearFriend() {this._friend = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _friend: Int32? = Nothing
  }

  struct goto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var goto: Int32 {
      get {return _goto ?? 0}
      set {_goto = newValue}
    }
    /// Returns true if `goto` has been explicitly set.
    var hasGoto: Boolean {return this._goto != Nothing}
    /// Clears the value of `goto`. Subsequent reads from it will return its default value.
    mutating fn clearGoto() {this._goto = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _goto: Int32? = Nothing
  }

  struct inline: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inline: Int32 {
      get {return _inline ?? 0}
      set {_inline = newValue}
    }
    /// Returns true if `inline` has been explicitly set.
    var hasInline: Boolean {return this._inline != Nothing}
    /// Clears the value of `inline`. Subsequent reads from it will return its default value.
    mutating fn clearInline() {this._inline = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _inline: Int32? = Nothing
  }

  struct long: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var long: Int32 {
      get {return _long ?? 0}
      set {_long = newValue}
    }
    /// Returns true if `long` has been explicitly set.
    var hasLong: Boolean {return this._long != Nothing}
    /// Clears the value of `long`. Subsequent reads from it will return its default value.
    mutating fn clearLong() {this._long = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _long: Int32? = Nothing
  }

  struct mutable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mutable: Int32 {
      get {return _mutable ?? 0}
      set {_mutable = newValue}
    }
    /// Returns true if `mutable` has been explicitly set.
    var hasMutable: Boolean {return this._mutable != Nothing}
    /// Clears the value of `mutable`. Subsequent reads from it will return its default value.
    mutating fn clearMutable() {this._mutable = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mutable: Int32? = Nothing
  }

  struct namespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var namespace: Int32 {
      get {return _namespace ?? 0}
      set {_namespace = newValue}
    }
    /// Returns true if `namespace` has been explicitly set.
    var hasNamespace: Boolean {return this._namespace != Nothing}
    /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
    mutating fn clearNamespace() {this._namespace = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _namespace: Int32? = Nothing
  }

  struct new: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var new: Int32 {
      get {return _new ?? 0}
      set {_new = newValue}
    }
    /// Returns true if `new` has been explicitly set.
    var hasNew: Boolean {return this._new != Nothing}
    /// Clears the value of `new`. Subsequent reads from it will return its default value.
    mutating fn clearNew() {this._new = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _new: Int32? = Nothing
  }

  struct noexcept: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var noexcept: Int32 {
      get {return _noexcept ?? 0}
      set {_noexcept = newValue}
    }
    /// Returns true if `noexcept` has been explicitly set.
    var hasNoexcept: Boolean {return this._noexcept != Nothing}
    /// Clears the value of `noexcept`. Subsequent reads from it will return its default value.
    mutating fn clearNoexcept() {this._noexcept = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _noexcept: Int32? = Nothing
  }

  struct not: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var not: Int32 {
      get {return _not ?? 0}
      set {_not = newValue}
    }
    /// Returns true if `not` has been explicitly set.
    var hasNot: Boolean {return this._not != Nothing}
    /// Clears the value of `not`. Subsequent reads from it will return its default value.
    mutating fn clearNot() {this._not = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _not: Int32? = Nothing
  }

  struct not_eq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var notEq: Int32 {
      get {return _notEq ?? 0}
      set {_notEq = newValue}
    }
    /// Returns true if `notEq` has been explicitly set.
    var hasNotEq: Boolean {return this._notEq != Nothing}
    /// Clears the value of `notEq`. Subsequent reads from it will return its default value.
    mutating fn clearNotEq() {this._notEq = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _notEq: Int32? = Nothing
  }

  struct nullptr: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nullptr: Int32 {
      get {return _nullptr ?? 0}
      set {_nullptr = newValue}
    }
    /// Returns true if `nullptr` has been explicitly set.
    var hasNullptr: Boolean {return this._nullptr != Nothing}
    /// Clears the value of `nullptr`. Subsequent reads from it will return its default value.
    mutating fn clearNullptr() {this._nullptr = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nullptr: Int32? = Nothing
  }

  struct or: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var or: Int32 {
      get {return _or ?? 0}
      set {_or = newValue}
    }
    /// Returns true if `or` has been explicitly set.
    var hasOr: Boolean {return this._or != Nothing}
    /// Clears the value of `or`. Subsequent reads from it will return its default value.
    mutating fn clearOr() {this._or = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _or: Int32? = Nothing
  }

  struct or_eq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var orEq: Int32 {
      get {return _orEq ?? 0}
      set {_orEq = newValue}
    }
    /// Returns true if `orEq` has been explicitly set.
    var hasOrEq: Boolean {return this._orEq != Nothing}
    /// Clears the value of `orEq`. Subsequent reads from it will return its default value.
    mutating fn clearOrEq() {this._orEq = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _orEq: Int32? = Nothing
  }

  struct protected: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protected: Int32 {
      get {return _protected ?? 0}
      set {_protected = newValue}
    }
    /// Returns true if `protected` has been explicitly set.
    var hasProtected: Boolean {return this._protected != Nothing}
    /// Clears the value of `protected`. Subsequent reads from it will return its default value.
    mutating fn clearProtected() {this._protected = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _protected: Int32? = Nothing
  }

  struct register: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var register: Int32 {
      get {return _register ?? 0}
      set {_register = newValue}
    }
    /// Returns true if `register` has been explicitly set.
    var hasRegister: Boolean {return this._register != Nothing}
    /// Clears the value of `register`. Subsequent reads from it will return its default value.
    mutating fn clearRegister() {this._register = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _register: Int32? = Nothing
  }

  struct reinterpret_cast: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var reinterpretCast: Int32 {
      get {return _reinterpretCast ?? 0}
      set {_reinterpretCast = newValue}
    }
    /// Returns true if `reinterpretCast` has been explicitly set.
    var hasReinterpretCast: Boolean {return this._reinterpretCast != Nothing}
    /// Clears the value of `reinterpretCast`. Subsequent reads from it will return its default value.
    mutating fn clearReinterpretCast() {this._reinterpretCast = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _reinterpretCast: Int32? = Nothing
  }

  struct short: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var short: Int32 {
      get {return _short ?? 0}
      set {_short = newValue}
    }
    /// Returns true if `short` has been explicitly set.
    var hasShort: Boolean {return this._short != Nothing}
    /// Clears the value of `short`. Subsequent reads from it will return its default value.
    mutating fn clearShort() {this._short = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _short: Int32? = Nothing
  }

  struct signed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var signed: Int32 {
      get {return _signed ?? 0}
      set {_signed = newValue}
    }
    /// Returns true if `signed` has been explicitly set.
    var hasSigned: Boolean {return this._signed != Nothing}
    /// Clears the value of `signed`. Subsequent reads from it will return its default value.
    mutating fn clearSigned() {this._signed = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _signed: Int32? = Nothing
  }

  struct sizeof: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sizeof: Int32 {
      get {return _sizeof ?? 0}
      set {_sizeof = newValue}
    }
    /// Returns true if `sizeof` has been explicitly set.
    var hasSizeof: Boolean {return this._sizeof != Nothing}
    /// Clears the value of `sizeof`. Subsequent reads from it will return its default value.
    mutating fn clearSizeof() {this._sizeof = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sizeof: Int32? = Nothing
  }

  struct static_assert: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var staticAssert: Int32 {
      get {return _staticAssert ?? 0}
      set {_staticAssert = newValue}
    }
    /// Returns true if `staticAssert` has been explicitly set.
    var hasStaticAssert: Boolean {return this._staticAssert != Nothing}
    /// Clears the value of `staticAssert`. Subsequent reads from it will return its default value.
    mutating fn clearStaticAssert() {this._staticAssert = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _staticAssert: Int32? = Nothing
  }

  struct static_cast: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var staticCast: Int32 {
      get {return _staticCast ?? 0}
      set {_staticCast = newValue}
    }
    /// Returns true if `staticCast` has been explicitly set.
    var hasStaticCast: Boolean {return this._staticCast != Nothing}
    /// Clears the value of `staticCast`. Subsequent reads from it will return its default value.
    mutating fn clearStaticCast() {this._staticCast = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _staticCast: Int32? = Nothing
  }

  struct template: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var template: Int32 {
      get {return _template ?? 0}
      set {_template = newValue}
    }
    /// Returns true if `template` has been explicitly set.
    var hasTemplate: Boolean {return this._template != Nothing}
    /// Clears the value of `template`. Subsequent reads from it will return its default value.
    mutating fn clearTemplate() {this._template = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _template: Int32? = Nothing
  }

  struct this: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var this: Int32 {
      get {return _this ?? 0}
      set {_this = newValue}
    }
    /// Returns true if `this` has been explicitly set.
    var hasThis: Boolean {return this._this != Nothing}
    /// Clears the value of `this`. Subsequent reads from it will return its default value.
    mutating fn clearThis() {this._this = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _this: Int32? = Nothing
  }

  struct thread_local: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var threadLocal: Int32 {
      get {return _threadLocal ?? 0}
      set {_threadLocal = newValue}
    }
    /// Returns true if `threadLocal` has been explicitly set.
    var hasThreadLocal: Boolean {return this._threadLocal != Nothing}
    /// Clears the value of `threadLocal`. Subsequent reads from it will return its default value.
    mutating fn clearThreadLocal() {this._threadLocal = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _threadLocal: Int32? = Nothing
  }

  struct typedef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typedef: Int32 {
      get {return _typedef ?? 0}
      set {_typedef = newValue}
    }
    /// Returns true if `typedef` has been explicitly set.
    var hasTypedef: Boolean {return this._typedef != Nothing}
    /// Clears the value of `typedef`. Subsequent reads from it will return its default value.
    mutating fn clearTypedef() {this._typedef = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typedef: Int32? = Nothing
  }

  struct typeid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeid: Int32 {
      get {return _typeid ?? 0}
      set {_typeid = newValue}
    }
    /// Returns true if `typeid` has been explicitly set.
    var hasTypeid: Boolean {return this._typeid != Nothing}
    /// Clears the value of `typeid`. Subsequent reads from it will return its default value.
    mutating fn clearTypeid() {this._typeid = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typeid: Int32? = Nothing
  }

  struct typename: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typename: Int32 {
      get {return _typename ?? 0}
      set {_typename = newValue}
    }
    /// Returns true if `typename` has been explicitly set.
    var hasTypename: Boolean {return this._typename != Nothing}
    /// Clears the value of `typename`. Subsequent reads from it will return its default value.
    mutating fn clearTypename() {this._typename = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typename: Int32? = Nothing
  }

  struct union: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var union: Int32 {
      get {return _union ?? 0}
      set {_union = newValue}
    }
    /// Returns true if `union` has been explicitly set.
    var hasUnion: Boolean {return this._union != Nothing}
    /// Clears the value of `union`. Subsequent reads from it will return its default value.
    mutating fn clearUnion() {this._union = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _union: Int32? = Nothing
  }

  struct unsigned: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsigned: Int32 {
      get {return _unsigned ?? 0}
      set {_unsigned = newValue}
    }
    /// Returns true if `unsigned` has been explicitly set.
    var hasUnsigned: Boolean {return this._unsigned != Nothing}
    /// Clears the value of `unsigned`. Subsequent reads from it will return its default value.
    mutating fn clearUnsigned() {this._unsigned = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _unsigned: Int32? = Nothing
  }

  struct using: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var using: Int32 {
      get {return _using ?? 0}
      set {_using = newValue}
    }
    /// Returns true if `using` has been explicitly set.
    var hasUsing: Boolean {return this._using != Nothing}
    /// Clears the value of `using`. Subsequent reads from it will return its default value.
    mutating fn clearUsing() {this._using = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _using: Int32? = Nothing
  }

  struct virtual: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var virtual: Int32 {
      get {return _virtual ?? 0}
      set {_virtual = newValue}
    }
    /// Returns true if `virtual` has been explicitly set.
    var hasVirtual: Boolean {return this._virtual != Nothing}
    /// Clears the value of `virtual`. Subsequent reads from it will return its default value.
    mutating fn clearVirtual() {this._virtual = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _virtual: Int32? = Nothing
  }

  struct void: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var void: Int32 {
      get {return _void ?? 0}
      set {_void = newValue}
    }
    /// Returns true if `void` has been explicitly set.
    var hasVoid: Boolean {return this._void != Nothing}
    /// Clears the value of `void`. Subsequent reads from it will return its default value.
    mutating fn clearVoid() {this._void = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _void: Int32? = Nothing
  }

  struct volatile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var volatile: Int32 {
      get {return _volatile ?? 0}
      set {_volatile = newValue}
    }
    /// Returns true if `volatile` has been explicitly set.
    var hasVolatile: Boolean {return this._volatile != Nothing}
    /// Clears the value of `volatile`. Subsequent reads from it will return its default value.
    mutating fn clearVolatile() {this._volatile = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _volatile: Int32? = Nothing
  }

  struct wchar_t: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wcharT: Int32 {
      get {return _wcharT ?? 0}
      set {_wcharT = newValue}
    }
    /// Returns true if `wcharT` has been explicitly set.
    var hasWcharT: Boolean {return this._wcharT != Nothing}
    /// Clears the value of `wcharT`. Subsequent reads from it will return its default value.
    mutating fn clearWcharT() {this._wcharT = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _wcharT: Int32? = Nothing
  }

  struct xor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var xor: Int32 {
      get {return _xor ?? 0}
      set {_xor = newValue}
    }
    /// Returns true if `xor` has been explicitly set.
    var hasXor: Boolean {return this._xor != Nothing}
    /// Clears the value of `xor`. Subsequent reads from it will return its default value.
    mutating fn clearXor() {this._xor = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _xor: Int32? = Nothing
  }

  struct xor_eq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var xorEq: Int32 {
      get {return _xorEq ?? 0}
      set {_xorEq = newValue}
    }
    /// Returns true if `xorEq` has been explicitly set.
    var hasXorEq: Boolean {return this._xorEq != Nothing}
    /// Clears the value of `xorEq`. Subsequent reads from it will return its default value.
    mutating fn clearXorEq() {this._xorEq = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _xorEq: Int32? = Nothing
  }

  struct restrict: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var restrict: Int32 {
      get {return _restrict ?? 0}
      set {_restrict = newValue}
    }
    /// Returns true if `restrict` has been explicitly set.
    var hasRestrict: Boolean {return this._restrict != Nothing}
    /// Clears the value of `restrict`. Subsequent reads from it will return its default value.
    mutating fn clearRestrict() {this._restrict = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _restrict: Int32? = Nothing
  }

  struct Category: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var category: Int32 {
      get {return _category ?? 0}
      set {_category = newValue}
    }
    /// Returns true if `category` has been explicitly set.
    var hasCategory: Boolean {return this._category != Nothing}
    /// Clears the value of `category`. Subsequent reads from it will return its default value.
    mutating fn clearCategory() {this._category = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _category: Int32? = Nothing
  }

  struct Ivar: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ivar: Int32 {
      get {return _ivar ?? 0}
      set {_ivar = newValue}
    }
    /// Returns true if `ivar` has been explicitly set.
    var hasIvar: Boolean {return this._ivar != Nothing}
    /// Clears the value of `ivar`. Subsequent reads from it will return its default value.
    mutating fn clearIvar() {this._ivar = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ivar: Int32? = Nothing
  }

  struct Method: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var method: Int32 {
      get {return _method ?? 0}
      set {_method = newValue}
    }
    /// Returns true if `method` has been explicitly set.
    var hasMethod: Boolean {return this._method != Nothing}
    /// Clears the value of `method`. Subsequent reads from it will return its default value.
    mutating fn clearMethod() {this._method = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _method: Int32? = Nothing
  }

  struct finalize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var finalize: Int32 {
      get {return _finalize ?? 0}
      set {_finalize = newValue}
    }
    /// Returns true if `finalize` has been explicitly set.
    var hasFinalize: Boolean {return this._finalize != Nothing}
    /// Clears the value of `finalize`. Subsequent reads from it will return its default value.
    mutating fn clearFinalize() {this._finalize = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _finalize: Int32? = Nothing
  }

  struct hash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Int32 {
      get {return _hash ?? 0}
      set {_hash = newValue}
    }
    /// Returns true if `hash` has been explicitly set.
    var hasHash: Boolean {return this._hash != Nothing}
    /// Clears the value of `hash`. Subsequent reads from it will return its default value.
    mutating fn clearHash() {this._hash = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _hash: Int32? = Nothing
  }

  struct dealloc: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dealloc: Int32 {
      get {return _dealloc ?? 0}
      set {_dealloc = newValue}
    }
    /// Returns true if `dealloc` has been explicitly set.
    var hasDealloc: Boolean {return this._dealloc != Nothing}
    /// Clears the value of `dealloc`. Subsequent reads from it will return its default value.
    mutating fn clearDealloc() {this._dealloc = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dealloc: Int32? = Nothing
  }

  struct superclass: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var superclass: Int32 {
      get {return _superclass ?? 0}
      set {_superclass = newValue}
    }
    /// Returns true if `superclass` has been explicitly set.
    var hasSuperclass: Boolean {return this._superclass != Nothing}
    /// Clears the value of `superclass`. Subsequent reads from it will return its default value.
    mutating fn clearSuperclass() {this._superclass = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _superclass: Int32? = Nothing
  }

  struct retain: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var retain: Int32 {
      get {return _retain ?? 0}
      set {_retain = newValue}
    }
    /// Returns true if `retain` has been explicitly set.
    var hasRetain: Boolean {return this._retain != Nothing}
    /// Clears the value of `retain`. Subsequent reads from it will return its default value.
    mutating fn clearRetain() {this._retain = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _retain: Int32? = Nothing
  }

  struct release: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var release: Int32 {
      get {return _release ?? 0}
      set {_release = newValue}
    }
    /// Returns true if `release` has been explicitly set.
    var hasRelease: Boolean {return this._release != Nothing}
    /// Clears the value of `release`. Subsequent reads from it will return its default value.
    mutating fn clearRelease() {this._release = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _release: Int32? = Nothing
  }

  struct autorelease: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var autorelease: Int32 {
      get {return _autorelease ?? 0}
      set {_autorelease = newValue}
    }
    /// Returns true if `autorelease` has been explicitly set.
    var hasAutorelease: Boolean {return this._autorelease != Nothing}
    /// Clears the value of `autorelease`. Subsequent reads from it will return its default value.
    mutating fn clearAutorelease() {this._autorelease = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _autorelease: Int32? = Nothing
  }

  struct retainCount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var retainCount: Int32 {
      get {return _retainCount ?? 0}
      set {_retainCount = newValue}
    }
    /// Returns true if `retainCount` has been explicitly set.
    var hasRetainCount: Boolean {return this._retainCount != Nothing}
    /// Clears the value of `retainCount`. Subsequent reads from it will return its default value.
    mutating fn clearRetainCount() {this._retainCount = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _retainCount: Int32? = Nothing
  }

  struct zone: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var zone: Int32 {
      get {return _zone ?? 0}
      set {_zone = newValue}
    }
    /// Returns true if `zone` has been explicitly set.
    var hasZone: Boolean {return this._zone != Nothing}
    /// Clears the value of `zone`. Subsequent reads from it will return its default value.
    mutating fn clearZone() {this._zone = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _zone: Int32? = Nothing
  }

  struct isProxy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isProxy: Int32 {
      get {return _isProxy ?? 0}
      set {_isProxy = newValue}
    }
    /// Returns true if `isProxy` has been explicitly set.
    var hasIsProxy: Boolean {return this._isProxy != Nothing}
    /// Clears the value of `isProxy`. Subsequent reads from it will return its default value.
    mutating fn clearIsProxy() {this._isProxy = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _isProxy: Int32? = Nothing
  }

  struct copy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var copy: Int32 {
      get {return _copy ?? 0}
      set {_copy = newValue}
    }
    /// Returns true if `copy` has been explicitly set.
    var hasCopy: Boolean {return this._copy != Nothing}
    /// Clears the value of `copy`. Subsequent reads from it will return its default value.
    mutating fn clearCopy() {this._copy = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _copy: Int32? = Nothing
  }

  struct mutableCopy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mutableCopy: Int32 {
      get {return _mutableCopy ?? 0}
      set {_mutableCopy = newValue}
    }
    /// Returns true if `mutableCopy` has been explicitly set.
    var hasMutableCopy: Boolean {return this._mutableCopy != Nothing}
    /// Clears the value of `mutableCopy`. Subsequent reads from it will return its default value.
    mutating fn clearMutableCopy() {this._mutableCopy = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mutableCopy: Int32? = Nothing
  }

  struct classForCoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var classForCoder: Int32 {
      get {return _classForCoder ?? 0}
      set {_classForCoder = newValue}
    }
    /// Returns true if `classForCoder` has been explicitly set.
    var hasClassForCoder: Boolean {return this._classForCoder != Nothing}
    /// Clears the value of `classForCoder`. Subsequent reads from it will return its default value.
    mutating fn clearClassForCoder() {this._classForCoder = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _classForCoder: Int32? = Nothing
  }

  struct clear: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clear: Int32 {
      get {return _clear ?? 0}
      set {_clear = newValue}
    }
    /// Returns true if `clear` has been explicitly set.
    var hasClear: Boolean {return this._clear != Nothing}
    /// Clears the value of `clear`. Subsequent reads from it will return its default value.
    mutating fn clearClear() {this._clear = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _clear: Int32? = Nothing
  }

  struct data: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Int32 {
      get {return _data ?? 0}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Boolean {return this._data != Nothing}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating fn clearData() {this._data = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _data: Int32? = Nothing
  }

  struct delimitedData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var delimitedData: Int32 {
      get {return _delimitedData ?? 0}
      set {_delimitedData = newValue}
    }
    /// Returns true if `delimitedData` has been explicitly set.
    var hasDelimitedData: Boolean {return this._delimitedData != Nothing}
    /// Clears the value of `delimitedData`. Subsequent reads from it will return its default value.
    mutating fn clearDelimitedData() {this._delimitedData = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delimitedData: Int32? = Nothing
  }

  struct descriptor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var descriptor: Int32 {
      get {return _descriptor ?? 0}
      set {_descriptor = newValue}
    }
    /// Returns true if `descriptor` has been explicitly set.
    var hasDescriptor: Boolean {return this._descriptor != Nothing}
    /// Clears the value of `descriptor`. Subsequent reads from it will return its default value.
    mutating fn clearDescriptor() {this._descriptor = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _descriptor: Int32? = Nothing
  }

  struct extensionRegistry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionRegistry: Int32 {
      get {return _extensionRegistry ?? 0}
      set {_extensionRegistry = newValue}
    }
    /// Returns true if `extensionRegistry` has been explicitly set.
    var hasExtensionRegistry: Boolean {return this._extensionRegistry != Nothing}
    /// Clears the value of `extensionRegistry`. Subsequent reads from it will return its default value.
    mutating fn clearExtensionRegistry() {this._extensionRegistry = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extensionRegistry: Int32? = Nothing
  }

  struct extensionsCurrentlySet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionsCurrentlySet: Int32 {
      get {return _extensionsCurrentlySet ?? 0}
      set {_extensionsCurrentlySet = newValue}
    }
    /// Returns true if `extensionsCurrentlySet` has been explicitly set.
    var hasExtensionsCurrentlySet: Boolean {return this._extensionsCurrentlySet != Nothing}
    /// Clears the value of `extensionsCurrentlySet`. Subsequent reads from it will return its default value.
    mutating fn clearExtensionsCurrentlySet() {this._extensionsCurrentlySet = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extensionsCurrentlySet: Int32? = Nothing
  }

  struct isInitializedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isInitialized_p: Int32 {
      get {return _isInitialized_p ?? 0}
      set {_isInitialized_p = newValue}
    }
    /// Returns true if `isInitialized_p` has been explicitly set.
    var hasIsInitialized_p: Boolean {return this._isInitialized_p != Nothing}
    /// Clears the value of `isInitialized_p`. Subsequent reads from it will return its default value.
    mutating fn clearIsInitialized_p() {this._isInitialized_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _isInitialized_p: Int32? = Nothing
  }

  struct serializedSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serializedSize: Int32 {
      get {return _serializedSize ?? 0}
      set {_serializedSize = newValue}
    }
    /// Returns true if `serializedSize` has been explicitly set.
    var hasSerializedSize: Boolean {return this._serializedSize != Nothing}
    /// Clears the value of `serializedSize`. Subsequent reads from it will return its default value.
    mutating fn clearSerializedSize() {this._serializedSize = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _serializedSize: Int32? = Nothing
  }

  struct sortedExtensionsInUse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sortedExtensionsInUse: Int32 {
      get {return _sortedExtensionsInUse ?? 0}
      set {_sortedExtensionsInUse = newValue}
    }
    /// Returns true if `sortedExtensionsInUse` has been explicitly set.
    var hasSortedExtensionsInUse: Boolean {return this._sortedExtensionsInUse != Nothing}
    /// Clears the value of `sortedExtensionsInUse`. Subsequent reads from it will return its default value.
    mutating fn clearSortedExtensionsInUse() {this._sortedExtensionsInUse = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sortedExtensionsInUse: Int32? = Nothing
  }

  struct unknownFieldsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields_p: Int32 {
      get {return _unknownFields_p ?? 0}
      set {_unknownFields_p = newValue}
    }
    /// Returns true if `unknownFields_p` has been explicitly set.
    var hasUnknownFields_p: Boolean {return this._unknownFields_p != Nothing}
    /// Clears the value of `unknownFields_p`. Subsequent reads from it will return its default value.
    mutating fn clearUnknownFields_p() {this._unknownFields_p = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _unknownFields_p: Int32? = Nothing
  }

  struct Fixed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fixed: Int32 {
      get {return _fixed ?? 0}
      set {_fixed = newValue}
    }
    /// Returns true if `fixed` has been explicitly set.
    var hasFixed: Boolean {return this._fixed != Nothing}
    /// Clears the value of `fixed`. Subsequent reads from it will return its default value.
    mutating fn clearFixed() {this._fixed = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fixed: Int32? = Nothing
  }

  struct Fract: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fract: Int32 {
      get {return _fract ?? 0}
      set {_fract = newValue}
    }
    /// Returns true if `fract` has been explicitly set.
    var hasFract: Boolean {return this._fract != Nothing}
    /// Clears the value of `fract`. Subsequent reads from it will return its default value.
    mutating fn clearFract() {this._fract = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fract: Int32? = Nothing
  }

  struct Size: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var size: Int32 {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Boolean {return this._size != Nothing}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating fn clearSize() {this._size = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _size: Int32? = Nothing
  }

  struct LogicalAddress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var logicalAddress: Int32 {
      get {return _logicalAddress ?? 0}
      set {_logicalAddress = newValue}
    }
    /// Returns true if `logicalAddress` has been explicitly set.
    var hasLogicalAddress: Boolean {return this._logicalAddress != Nothing}
    /// Clears the value of `logicalAddress`. Subsequent reads from it will return its default value.
    mutating fn clearLogicalAddress() {this._logicalAddress = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _logicalAddress: Int32? = Nothing
  }

  struct PhysicalAddress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var physicalAddress: Int32 {
      get {return _physicalAddress ?? 0}
      set {_physicalAddress = newValue}
    }
    /// Returns true if `physicalAddress` has been explicitly set.
    var hasPhysicalAddress: Boolean {return this._physicalAddress != Nothing}
    /// Clears the value of `physicalAddress`. Subsequent reads from it will return its default value.
    mutating fn clearPhysicalAddress() {this._physicalAddress = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _physicalAddress: Int32? = Nothing
  }

  struct ByteCount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var byteCount: Int32 {
      get {return _byteCount ?? 0}
      set {_byteCount = newValue}
    }
    /// Returns true if `byteCount` has been explicitly set.
    var hasByteCount: Boolean {return this._byteCount != Nothing}
    /// Clears the value of `byteCount`. Subsequent reads from it will return its default value.
    mutating fn clearByteCount() {this._byteCount = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _byteCount: Int32? = Nothing
  }

  struct ByteOffset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var byteOffset: Int32 {
      get {return _byteOffset ?? 0}
      set {_byteOffset = newValue}
    }
    /// Returns true if `byteOffset` has been explicitly set.
    var hasByteOffset: Boolean {return this._byteOffset != Nothing}
    /// Clears the value of `byteOffset`. Subsequent reads from it will return its default value.
    mutating fn clearByteOffset() {this._byteOffset = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _byteOffset: Int32? = Nothing
  }

  struct Duration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var duration: Int32 {
      get {return _duration ?? 0}
      set {_duration = newValue}
    }
    /// Returns true if `duration` has been explicitly set.
    var hasDuration: Boolean {return this._duration != Nothing}
    /// Clears the value of `duration`. Subsequent reads from it will return its default value.
    mutating fn clearDuration() {this._duration = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _duration: Int32? = Nothing
  }

  struct AbsoluteTime: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var absoluteTime: Int32 {
      get {return _absoluteTime ?? 0}
      set {_absoluteTime = newValue}
    }
    /// Returns true if `absoluteTime` has been explicitly set.
    var hasAbsoluteTime: Boolean {return this._absoluteTime != Nothing}
    /// Clears the value of `absoluteTime`. Subsequent reads from it will return its default value.
    mutating fn clearAbsoluteTime() {this._absoluteTime = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _absoluteTime: Int32? = Nothing
  }

  struct OptionBits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionBits: Int32 {
      get {return _optionBits ?? 0}
      set {_optionBits = newValue}
    }
    /// Returns true if `optionBits` has been explicitly set.
    var hasOptionBits: Boolean {return this._optionBits != Nothing}
    /// Clears the value of `optionBits`. Subsequent reads from it will return its default value.
    mutating fn clearOptionBits() {this._optionBits = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _optionBits: Int32? = Nothing
  }

  struct ItemCount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemCount: Int32 {
      get {return _itemCount ?? 0}
      set {_itemCount = newValue}
    }
    /// Returns true if `itemCount` has been explicitly set.
    var hasItemCount: Boolean {return this._itemCount != Nothing}
    /// Clears the value of `itemCount`. Subsequent reads from it will return its default value.
    mutating fn clearItemCount() {this._itemCount = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _itemCount: Int32? = Nothing
  }

  struct PBVersion: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pbversion: Int32 {
      get {return _pbversion ?? 0}
      set {_pbversion = newValue}
    }
    /// Returns true if `pbversion` has been explicitly set.
    var hasPbversion: Boolean {return this._pbversion != Nothing}
    /// Clears the value of `pbversion`. Subsequent reads from it will return its default value.
    mutating fn clearPbversion() {this._pbversion = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pbversion: Int32? = Nothing
  }

  struct ScriptCode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scriptCode: Int32 {
      get {return _scriptCode ?? 0}
      set {_scriptCode = newValue}
    }
    /// Returns true if `scriptCode` has been explicitly set.
    var hasScriptCode: Boolean {return this._scriptCode != Nothing}
    /// Clears the value of `scriptCode`. Subsequent reads from it will return its default value.
    mutating fn clearScriptCode() {this._scriptCode = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _scriptCode: Int32? = Nothing
  }

  struct LangCode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var langCode: Int32 {
      get {return _langCode ?? 0}
      set {_langCode = newValue}
    }
    /// Returns true if `langCode` has been explicitly set.
    var hasLangCode: Boolean {return this._langCode != Nothing}
    /// Clears the value of `langCode`. Subsequent reads from it will return its default value.
    mutating fn clearLangCode() {this._langCode = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _langCode: Int32? = Nothing
  }

  struct RegionCode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var regionCode: Int32 {
      get {return _regionCode ?? 0}
      set {_regionCode = newValue}
    }
    /// Returns true if `regionCode` has been explicitly set.
    var hasRegionCode: Boolean {return this._regionCode != Nothing}
    /// Clears the value of `regionCode`. Subsequent reads from it will return its default value.
    mutating fn clearRegionCode() {this._regionCode = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _regionCode: Int32? = Nothing
  }

  struct OSType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ostype: Int32 {
      get {return _ostype ?? 0}
      set {_ostype = newValue}
    }
    /// Returns true if `ostype` has been explicitly set.
    var hasOstype: Boolean {return this._ostype != Nothing}
    /// Clears the value of `ostype`. Subsequent reads from it will return its default value.
    mutating fn clearOstype() {this._ostype = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ostype: Int32? = Nothing
  }

  struct ProcessSerialNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var processSerialNumber: Int32 {
      get {return _processSerialNumber ?? 0}
      set {_processSerialNumber = newValue}
    }
    /// Returns true if `processSerialNumber` has been explicitly set.
    var hasProcessSerialNumber: Boolean {return this._processSerialNumber != Nothing}
    /// Clears the value of `processSerialNumber`. Subsequent reads from it will return its default value.
    mutating fn clearProcessSerialNumber() {this._processSerialNumber = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _processSerialNumber: Int32? = Nothing
  }

  struct Point: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var point: Int32 {
      get {return _point ?? 0}
      set {_point = newValue}
    }
    /// Returns true if `point` has been explicitly set.
    var hasPoint: Boolean {return this._point != Nothing}
    /// Clears the value of `point`. Subsequent reads from it will return its default value.
    mutating fn clearPoint() {this._point = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _point: Int32? = Nothing
  }

  struct Rect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rect: Int32 {
      get {return _rect ?? 0}
      set {_rect = newValue}
    }
    /// Returns true if `rect` has been explicitly set.
    var hasRect: Boolean {return this._rect != Nothing}
    /// Clears the value of `rect`. Subsequent reads from it will return its default value.
    mutating fn clearRect() {this._rect = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rect: Int32? = Nothing
  }

  struct FixedPoint: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fixedPoint: Int32 {
      get {return _fixedPoint ?? 0}
      set {_fixedPoint = newValue}
    }
    /// Returns true if `fixedPoint` has been explicitly set.
    var hasFixedPoint: Boolean {return this._fixedPoint != Nothing}
    /// Clears the value of `fixedPoint`. Subsequent reads from it will return its default value.
    mutating fn clearFixedPoint() {this._fixedPoint = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fixedPoint: Int32? = Nothing
  }

  struct FixedRect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fixedRect: Int32 {
      get {return _fixedRect ?? 0}
      set {_fixedRect = newValue}
    }
    /// Returns true if `fixedRect` has been explicitly set.
    var hasFixedRect: Boolean {return this._fixedRect != Nothing}
    /// Clears the value of `fixedRect`. Subsequent reads from it will return its default value.
    mutating fn clearFixedRect() {this._fixedRect = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fixedRect: Int32? = Nothing
  }

  struct Style: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var style: Int32 {
      get {return _style ?? 0}
      set {_style = newValue}
    }
    /// Returns true if `style` has been explicitly set.
    var hasStyle: Boolean {return this._style != Nothing}
    /// Clears the value of `style`. Subsequent reads from it will return its default value.
    mutating fn clearStyle() {this._style = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _style: Int32? = Nothing
  }

  struct StyleParameter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var styleParameter: Int32 {
      get {return _styleParameter ?? 0}
      set {_styleParameter = newValue}
    }
    /// Returns true if `styleParameter` has been explicitly set.
    var hasStyleParameter: Boolean {return this._styleParameter != Nothing}
    /// Clears the value of `styleParameter`. Subsequent reads from it will return its default value.
    mutating fn clearStyleParameter() {this._styleParameter = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _styleParameter: Int32? = Nothing
  }

  struct StyleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var styleField: Int32 {
      get {return _styleField ?? 0}
      set {_styleField = newValue}
    }
    /// Returns true if `styleField` has been explicitly set.
    var hasStyleField: Boolean {return this._styleField != Nothing}
    /// Clears the value of `styleField`. Subsequent reads from it will return its default value.
    mutating fn clearStyleField() {this._styleField = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _styleField: Int32? = Nothing
  }

  struct TimeScale: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeScale: Int32 {
      get {return _timeScale ?? 0}
      set {_timeScale = newValue}
    }
    /// Returns true if `timeScale` has been explicitly set.
    var hasTimeScale: Boolean {return this._timeScale != Nothing}
    /// Clears the value of `timeScale`. Subsequent reads from it will return its default value.
    mutating fn clearTimeScale() {this._timeScale = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timeScale: Int32? = Nothing
  }

  struct TimeBase: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeBase: Int32 {
      get {return _timeBase ?? 0}
      set {_timeBase = newValue}
    }
    /// Returns true if `timeBase` has been explicitly set.
    var hasTimeBase: Boolean {return this._timeBase != Nothing}
    /// Clears the value of `timeBase`. Subsequent reads from it will return its default value.
    mutating fn clearTimeBase() {this._timeBase = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timeBase: Int32? = Nothing
  }

  struct TimeRecord: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeRecord: Int32 {
      get {return _timeRecord ?? 0}
      set {_timeRecord = newValue}
    }
    /// Returns true if `timeRecord` has been explicitly set.
    var hasTimeRecord: Boolean {return this._timeRecord != Nothing}
    /// Clears the value of `timeRecord`. Subsequent reads from it will return its default value.
    mutating fn clearTimeRecord() {this._timeRecord = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timeRecord: Int32? = Nothing
  }

  struct serializedData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serializedData: Int32 {
      get {return _serializedData ?? 0}
      set {_serializedData = newValue}
    }
    /// Returns true if `serializedData` has been explicitly set.
    var hasSerializedData: Boolean {return this._serializedData != Nothing}
    /// Clears the value of `serializedData`. Subsequent reads from it will return its default value.
    mutating fn clearSerializedData() {this._serializedData = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _serializedData: Int32? = Nothing
  }

  struct jsonUTF8Data: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonUtf8Data: Int32 {
      get {return _jsonUtf8Data ?? 0}
      set {_jsonUtf8Data = newValue}
    }
    /// Returns true if `jsonUtf8Data` has been explicitly set.
    var hasJsonUtf8Data: Boolean {return this._jsonUtf8Data != Nothing}
    /// Clears the value of `jsonUtf8Data`. Subsequent reads from it will return its default value.
    mutating fn clearJsonUtf8Data() {this._jsonUtf8Data = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _jsonUtf8Data: Int32? = Nothing
  }

  struct jsonString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonString: Int32 {
      get {return _jsonString ?? 0}
      set {_jsonString = newValue}
    }
    /// Returns true if `jsonString` has been explicitly set.
    var hasJsonString: Boolean {return this._jsonString != Nothing}
    /// Clears the value of `jsonString`. Subsequent reads from it will return its default value.
    mutating fn clearJsonString() {this._jsonString = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _jsonString: Int32? = Nothing
  }

  struct Extension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `extension`: Int32 {
      get {return _extension ?? 0}
      set {_extension = newValue}
    }
    /// Returns true if ``extension`` has been explicitly set.
    var hasExtension: Boolean {return this._extension != Nothing}
    /// Clears the value of ``extension``. Subsequent reads from it will return its default value.
    mutating fn clearExtension() {this._extension = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extension: Int32? = Nothing
  }

  struct ExtensionsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensions: Int32 {
      get {return _extensions ?? 0}
      set {_extensions = newValue}
    }
    /// Returns true if `extensions` has been explicitly set.
    var hasExtensions: Boolean {return this._extensions != Nothing}
    /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
    mutating fn clearExtensions() {this._extensions = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extensions: Int32? = Nothing
  }

  init() {}
}

struct SwiftProtoTesting_Names_EnumNames: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StringEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aString // = 0

    init() {
      this = .aString
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aString
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aString: return 0
      }
    }

  }

  enum ProtocolEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aProtocol // = 0

    init() {
      this = .aProtocol
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aProtocol
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aProtocol: return 0
      }
    }

  }

  enum IntEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aInt // = 0

    init() {
      this = .aInt
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aInt
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aInt: return 0
      }
    }

  }

  enum DoubleEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aDouble // = 0

    init() {
      this = .aDouble
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aDouble
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aDouble: return 0
      }
    }

  }

  enum FloatEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aFloat // = 0

    init() {
      this = .aFloat
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aFloat
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aFloat: return 0
      }
    }

  }

  enum UIntEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aUint // = 0

    init() {
      this = .aUint
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aUint
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aUint: return 0
      }
    }

  }

  enum hashValueEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ahashValue // = 0

    init() {
      this = .ahashValue
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ahashValue
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ahashValue: return 0
      }
    }

  }

  enum descriptionEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adescription // = 0

    init() {
      this = .adescription
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adescription
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adescription: return 0
      }
    }

  }

  enum debugDescriptionEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adebugDescription // = 0

    init() {
      this = .adebugDescription
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adebugDescription
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adebugDescription: return 0
      }
    }

  }

  enum SwiftEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aSwift // = 0

    init() {
      this = .aSwift
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aSwift
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aSwift: return 0
      }
    }

  }

  enum UNRECOGNIZED: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aUnrecognized // = 0

    init() {
      this = .aUnrecognized
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aUnrecognized
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aUnrecognized: return 0
      }
    }

  }

  enum classEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aclass // = 0

    init() {
      this = .aclass
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aclass
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aclass: return 0
      }
    }

  }

  enum deinitEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adeinit // = 0

    init() {
      this = .adeinit
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adeinit
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adeinit: return 0
      }
    }

  }

  enum enumEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aenum // = 0

    init() {
      this = .aenum
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aenum
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aenum: return 0
      }
    }

  }

  enum extensionEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aextension // = 0

    init() {
      this = .aextension
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aextension
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aextension: return 0
      }
    }

  }

  enum funcEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afunc // = 0

    init() {
      this = .afunc
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afunc
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afunc: return 0
      }
    }

  }

  enum importEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aimport // = 0

    init() {
      this = .aimport
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aimport
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aimport: return 0
      }
    }

  }

  enum initEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ainit // = 0

    init() {
      this = .ainit
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ainit
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ainit: return 0
      }
    }

  }

  enum inoutEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ainout // = 0

    init() {
      this = .ainout
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ainout
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ainout: return 0
      }
    }

  }

  enum internalEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ainternal // = 0

    init() {
      this = .ainternal
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ainternal
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ainternal: return 0
      }
    }

  }

  enum immutableEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aimmutable // = 0

    init() {
      this = .aimmutable
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aimmutable
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aimmutable: return 0
      }
    }

  }

  enum operatorEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aoperator // = 0

    init() {
      this = .aoperator
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aoperator
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aoperator: return 0
      }
    }

  }

  enum privateEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aprivate // = 0

    init() {
      this = .aprivate
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aprivate
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aprivate: return 0
      }
    }

  }

  enum protocolEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aprotocol // = 0

    init() {
      this = .aprotocol
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aprotocol
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aprotocol: return 0
      }
    }

  }

  enum publicEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case apublic // = 0

    init() {
      this = .apublic
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .apublic
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .apublic: return 0
      }
    }

  }

  enum staticEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case astatic // = 0

    init() {
      this = .astatic
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .astatic
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .astatic: return 0
      }
    }

  }

  enum structEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case astruct // = 0

    init() {
      this = .astruct
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .astruct
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .astruct: return 0
      }
    }

  }

  enum subscriptEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asubscript // = 0

    init() {
      this = .asubscript
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asubscript
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asubscript: return 0
      }
    }

  }

  enum typealiasEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atypealias // = 0

    init() {
      this = .atypealias
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atypealias
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atypealias: return 0
      }
    }

  }

  enum varEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case avar // = 0

    init() {
      this = .avar
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .avar
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .avar: return 0
      }
    }

  }

  enum breakEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abreak // = 0

    init() {
      this = .abreak
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abreak
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abreak: return 0
      }
    }

  }

  enum caseEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case acase // = 0

    init() {
      this = .acase
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .acase
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .acase: return 0
      }
    }

  }

  enum continueEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case acontinue // = 0

    init() {
      this = .acontinue
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .acontinue
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .acontinue: return 0
      }
    }

  }

  enum defaultEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adefault // = 0

    init() {
      this = .adefault
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adefault
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adefault: return 0
      }
    }

  }

  enum deferEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adefer // = 0

    init() {
      this = .adefer
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adefer
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adefer: return 0
      }
    }

  }

  enum doEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ado // = 0

    init() {
      this = .ado
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ado
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ado: return 0
      }
    }

  }

  enum elseEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aelse // = 0

    init() {
      this = .aelse
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aelse
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aelse: return 0
      }
    }

  }

  enum fallthroughEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afallthrough // = 0

    init() {
      this = .afallthrough
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afallthrough
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afallthrough: return 0
      }
    }

  }

  enum forEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afor // = 0

    init() {
      this = .afor
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afor
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afor: return 0
      }
    }

  }

  enum guardEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aguard // = 0

    init() {
      this = .aguard
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aguard
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aguard: return 0
      }
    }

  }

  enum ifEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aif // = 0

    init() {
      this = .aif
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aif
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aif: return 0
      }
    }

  }

  enum inEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ain // = 0

    init() {
      this = .ain
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ain
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ain: return 0
      }
    }

  }

  enum repeatEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case arepeat // = 0

    init() {
      this = .arepeat
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .arepeat
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .arepeat: return 0
      }
    }

  }

  enum returnEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case areturn // = 0

    init() {
      this = .areturn
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .areturn
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .areturn: return 0
      }
    }

  }

  enum switchEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aswitch // = 0

    init() {
      this = .aswitch
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aswitch
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aswitch: return 0
      }
    }

  }

  enum whereEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case awhere // = 0

    init() {
      this = .awhere
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .awhere
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .awhere: return 0
      }
    }

  }

  enum whileEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case awhile // = 0

    init() {
      this = .awhile
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .awhile
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .awhile: return 0
      }
    }

  }

  enum asEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aas // = 0

    init() {
      this = .aas
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aas
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aas: return 0
      }
    }

  }

  enum catchEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case acatch // = 0

    init() {
      this = .acatch
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .acatch
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .acatch: return 0
      }
    }

  }

  enum dynamicTypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adynamicType // = 0

    init() {
      this = .adynamicType
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adynamicType
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adynamicType: return 0
      }
    }

  }

  enum falseEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afalse // = 0

    init() {
      this = .afalse
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afalse
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afalse: return 0
      }
    }

  }

  enum isEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ais // = 0

    init() {
      this = .ais
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ais
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ais: return 0
      }
    }

  }

  enum nilEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anil // = 0

    init() {
      this = .anil
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anil
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anil: return 0
      }
    }

  }

  enum rethrowsEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case arethrows // = 0

    init() {
      this = .arethrows
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .arethrows
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .arethrows: return 0
      }
    }

  }

  enum superEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asuper // = 0

    init() {
      this = .asuper
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asuper
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asuper: return 0
      }
    }

  }

  enum selfEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aself // = 0

    init() {
      this = .aself
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aself
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aself: return 0
      }
    }

  }

  enum throwEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case athrow // = 0

    init() {
      this = .athrow
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .athrow
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .athrow: return 0
      }
    }

  }

  enum throwsEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case athrows // = 0

    init() {
      this = .athrows
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .athrows
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .athrows: return 0
      }
    }

  }

  enum trueEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atrue // = 0

    init() {
      this = .atrue
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atrue
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atrue: return 0
      }
    }

  }

  enum tryEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atry // = 0

    init() {
      this = .atry
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atry
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atry: return 0
      }
    }

  }

  enum __COLUMN__Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a_Column__ // = 0

    init() {
      this = .a_Column__
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a_Column__
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a_Column__: return 0
      }
    }

  }

  enum __FILE__Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a_File__ // = 0

    init() {
      this = .a_File__
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a_File__
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a_File__: return 0
      }
    }

  }

  enum __FUNCTION__Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a_Function__ // = 0

    init() {
      this = .a_Function__
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a_Function__
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a_Function__: return 0
      }
    }

  }

  enum __LINE__Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a_Line__ // = 0

    init() {
      this = .a_Line__
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a_Line__
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a_Line__: return 0
      }
    }

  }

  enum _Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a_ // = 0

    init() {
      this = .a_
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a_
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a_: return 0
      }
    }

  }

  enum __Enum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case a__ // = 0

    init() {
      this = .a__
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .a__
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .a__: return 0
      }
    }

  }

  enum associativity: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aassociativity // = 0

    init() {
      this = .aassociativity
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aassociativity
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aassociativity: return 0
      }
    }

  }

  enum convenience: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aconvenience // = 0

    init() {
      this = .aconvenience
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aconvenience
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aconvenience: return 0
      }
    }

  }

  enum dynamic: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adynamic // = 0

    init() {
      this = .adynamic
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adynamic
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adynamic: return 0
      }
    }

  }

  enum didSet: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adidSet // = 0

    init() {
      this = .adidSet
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adidSet
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adidSet: return 0
      }
    }

  }

  enum final: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afinal // = 0

    init() {
      this = .afinal
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afinal
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afinal: return 0
      }
    }

  }

  enum get: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aget // = 0

    init() {
      this = .aget
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aget
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aget: return 0
      }
    }

  }

  enum infix: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ainfix // = 0

    init() {
      this = .ainfix
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ainfix
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ainfix: return 0
      }
    }

  }

  enum indirect: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aindirect // = 0

    init() {
      this = .aindirect
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aindirect
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aindirect: return 0
      }
    }

  }

  enum lazy: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case alazy // = 0

    init() {
      this = .alazy
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .alazy
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .alazy: return 0
      }
    }

  }

  enum left: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aleft // = 0

    init() {
      this = .aleft
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aleft
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aleft: return 0
      }
    }

  }

  enum mutating: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case amutating // = 0

    init() {
      this = .amutating
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .amutating
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .amutating: return 0
      }
    }

  }

  enum none: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anone // = 0

    init() {
      this = .anone
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anone
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anone: return 0
      }
    }

  }

  enum nonmutating: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anonmutating // = 0

    init() {
      this = .anonmutating
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anonmutating
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anonmutating: return 0
      }
    }

  }

  enum optional: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aoptional // = 0

    init() {
      this = .aoptional
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aoptional
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aoptional: return 0
      }
    }

  }

  enum override: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aoverride // = 0

    init() {
      this = .aoverride
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aoverride
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aoverride: return 0
      }
    }

  }

  enum postfix: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case apostfix // = 0

    init() {
      this = .apostfix
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .apostfix
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .apostfix: return 0
      }
    }

  }

  enum precedence: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aprecedence // = 0

    init() {
      this = .aprecedence
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aprecedence
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aprecedence: return 0
      }
    }

  }

  enum prefix: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aprefix // = 0

    init() {
      this = .aprefix
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aprefix
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aprefix: return 0
      }
    }

  }

  enum required: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case arequired // = 0

    init() {
      this = .arequired
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .arequired
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .arequired: return 0
      }
    }

  }

  enum right: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aright // = 0

    init() {
      this = .aright
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aright
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aright: return 0
      }
    }

  }

  enum set: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aset // = 0

    init() {
      this = .aset
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aset
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aset: return 0
      }
    }

  }

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aType // = 0

    init() {
      this = .aType
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aType
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aType: return 0
      }
    }

  }

  enum unowned: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aunowned // = 0

    init() {
      this = .aunowned
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aunowned
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aunowned: return 0
      }
    }

  }

  enum weak: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aweak // = 0

    init() {
      this = .aweak
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aweak
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aweak: return 0
      }
    }

  }

  enum willSet: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case awillSet // = 0

    init() {
      this = .awillSet
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .awillSet
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .awillSet: return 0
      }
    }

  }

  enum id: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aid // = 0

    init() {
      this = .aid
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aid
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aid: return 0
      }
    }

  }

  enum _cmd: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aCmd // = 0

    init() {
      this = .aCmd
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aCmd
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aCmd: return 0
      }
    }

  }

  enum out: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aout // = 0

    init() {
      this = .aout
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aout
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aout: return 0
      }
    }

  }

  enum bycopy: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abycopy // = 0

    init() {
      this = .abycopy
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abycopy
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abycopy: return 0
      }
    }

  }

  enum byref: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abyref // = 0

    init() {
      this = .abyref
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abyref
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abyref: return 0
      }
    }

  }

  enum oneway: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aoneway // = 0

    init() {
      this = .aoneway
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aoneway
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aoneway: return 0
      }
    }

  }

  enum and: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aand // = 0

    init() {
      this = .aand
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aand
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aand: return 0
      }
    }

  }

  enum and_eq: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aandEq // = 0

    init() {
      this = .aandEq
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aandEq
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aandEq: return 0
      }
    }

  }

  enum alignas: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aalignas // = 0

    init() {
      this = .aalignas
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aalignas
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aalignas: return 0
      }
    }

  }

  enum alignof: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aalignof // = 0

    init() {
      this = .aalignof
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aalignof
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aalignof: return 0
      }
    }

  }

  enum asm: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aasm // = 0

    init() {
      this = .aasm
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aasm
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aasm: return 0
      }
    }

  }

  enum auto: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aauto // = 0

    init() {
      this = .aauto
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aauto
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aauto: return 0
      }
    }

  }

  enum bitand: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abitand // = 0

    init() {
      this = .abitand
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abitand
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abitand: return 0
      }
    }

  }

  enum bitor: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abitor // = 0

    init() {
      this = .abitor
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abitor
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abitor: return 0
      }
    }

  }

  enum bool: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case abool // = 0

    init() {
      this = .abool
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .abool
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .abool: return 0
      }
    }

  }

  enum char: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case achar // = 0

    init() {
      this = .achar
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .achar
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .achar: return 0
      }
    }

  }

  enum char16_t: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case achar16T // = 0

    init() {
      this = .achar16T
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .achar16T
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .achar16T: return 0
      }
    }

  }

  enum char32_t: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case achar32T // = 0

    init() {
      this = .achar32T
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .achar32T
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .achar32T: return 0
      }
    }

  }

  enum compl: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case acompl // = 0

    init() {
      this = .acompl
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .acompl
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .acompl: return 0
      }
    }

  }

  enum const: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aconst // = 0

    init() {
      this = .aconst
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aconst
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aconst: return 0
      }
    }

  }

  enum constexpr: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aconstexpr // = 0

    init() {
      this = .aconstexpr
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aconstexpr
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aconstexpr: return 0
      }
    }

  }

  enum const_cast: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aconstCast // = 0

    init() {
      this = .aconstCast
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aconstCast
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aconstCast: return 0
      }
    }

  }

  enum decltype: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adecltype // = 0

    init() {
      this = .adecltype
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adecltype
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adecltype: return 0
      }
    }

  }

  enum deimmutablee: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adeimmutablee // = 0

    init() {
      this = .adeimmutablee
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adeimmutablee
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adeimmutablee: return 0
      }
    }

  }

  enum dynamic_cast: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adynamicCast // = 0

    init() {
      this = .adynamicCast
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adynamicCast
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adynamicCast: return 0
      }
    }

  }

  enum explicit: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aexplicit // = 0

    init() {
      this = .aexplicit
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aexplicit
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aexplicit: return 0
      }
    }

  }

  enum export: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aexport // = 0

    init() {
      this = .aexport
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aexport
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aexport: return 0
      }
    }

  }

  enum extern: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aextern // = 0

    init() {
      this = .aextern
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aextern
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aextern: return 0
      }
    }

  }

  enum friend: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afriend // = 0

    init() {
      this = .afriend
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afriend
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afriend: return 0
      }
    }

  }

  enum goto: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case agoto // = 0

    init() {
      this = .agoto
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .agoto
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .agoto: return 0
      }
    }

  }

  enum inline: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ainline // = 0

    init() {
      this = .ainline
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ainline
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ainline: return 0
      }
    }

  }

  enum long: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case along // = 0

    init() {
      this = .along
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .along
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .along: return 0
      }
    }

  }

  enum mutable: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case amutable // = 0

    init() {
      this = .amutable
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .amutable
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .amutable: return 0
      }
    }

  }

  enum namespace: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anamespace // = 0

    init() {
      this = .anamespace
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anamespace
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anamespace: return 0
      }
    }

  }

  enum new: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anew // = 0

    init() {
      this = .anew
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anew
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anew: return 0
      }
    }

  }

  enum noexcept: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anoexcept // = 0

    init() {
      this = .anoexcept
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anoexcept
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anoexcept: return 0
      }
    }

  }

  enum not: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anot // = 0

    init() {
      this = .anot
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anot
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anot: return 0
      }
    }

  }

  enum not_eq: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anotEq // = 0

    init() {
      this = .anotEq
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anotEq
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anotEq: return 0
      }
    }

  }

  enum nullptr: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case anullptr // = 0

    init() {
      this = .anullptr
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .anullptr
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .anullptr: return 0
      }
    }

  }

  enum or: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aor // = 0

    init() {
      this = .aor
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aor
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aor: return 0
      }
    }

  }

  enum or_eq: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aorEq // = 0

    init() {
      this = .aorEq
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aorEq
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aorEq: return 0
      }
    }

  }

  enum protected: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aprotected // = 0

    init() {
      this = .aprotected
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aprotected
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aprotected: return 0
      }
    }

  }

  enum register: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aregister // = 0

    init() {
      this = .aregister
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aregister
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aregister: return 0
      }
    }

  }

  enum reinterpret_cast: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case areinterpretCast // = 0

    init() {
      this = .areinterpretCast
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .areinterpretCast
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .areinterpretCast: return 0
      }
    }

  }

  enum short: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ashort // = 0

    init() {
      this = .ashort
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ashort
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ashort: return 0
      }
    }

  }

  enum signed: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asigned // = 0

    init() {
      this = .asigned
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asigned
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asigned: return 0
      }
    }

  }

  enum sizeof: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asizeof // = 0

    init() {
      this = .asizeof
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asizeof
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asizeof: return 0
      }
    }

  }

  enum static_assert: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case astaticAssert // = 0

    init() {
      this = .astaticAssert
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .astaticAssert
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .astaticAssert: return 0
      }
    }

  }

  enum static_cast: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case astaticCast // = 0

    init() {
      this = .astaticCast
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .astaticCast
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .astaticCast: return 0
      }
    }

  }

  enum template: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atemplate // = 0

    init() {
      this = .atemplate
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atemplate
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atemplate: return 0
      }
    }

  }

  enum this: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case athis // = 0

    init() {
      this = .athis
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .athis
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .athis: return 0
      }
    }

  }

  enum thread_local: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case athreadLocal // = 0

    init() {
      this = .athreadLocal
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .athreadLocal
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .athreadLocal: return 0
      }
    }

  }

  enum typedef: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atypedef // = 0

    init() {
      this = .atypedef
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atypedef
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atypedef: return 0
      }
    }

  }

  enum typeid: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atypeid // = 0

    init() {
      this = .atypeid
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atypeid
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atypeid: return 0
      }
    }

  }

  enum typename: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case atypename // = 0

    init() {
      this = .atypename
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .atypename
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .atypename: return 0
      }
    }

  }

  enum union: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aunion // = 0

    init() {
      this = .aunion
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aunion
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aunion: return 0
      }
    }

  }

  enum unsigned: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aunsigned // = 0

    init() {
      this = .aunsigned
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aunsigned
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aunsigned: return 0
      }
    }

  }

  enum using: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ausing // = 0

    init() {
      this = .ausing
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ausing
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ausing: return 0
      }
    }

  }

  enum virtual: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case avirtual // = 0

    init() {
      this = .avirtual
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .avirtual
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .avirtual: return 0
      }
    }

  }

  enum void: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case avoid // = 0

    init() {
      this = .avoid
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .avoid
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .avoid: return 0
      }
    }

  }

  enum volatile: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case avolatile // = 0

    init() {
      this = .avolatile
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .avolatile
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .avolatile: return 0
      }
    }

  }

  enum wchar_t: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case awcharT // = 0

    init() {
      this = .awcharT
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .awcharT
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .awcharT: return 0
      }
    }

  }

  enum xor: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case axor // = 0

    init() {
      this = .axor
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .axor
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .axor: return 0
      }
    }

  }

  enum xor_eq: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case axorEq // = 0

    init() {
      this = .axorEq
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .axorEq
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .axorEq: return 0
      }
    }

  }

  enum restrict: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case arestrict // = 0

    init() {
      this = .arestrict
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .arestrict
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .arestrict: return 0
      }
    }

  }

  enum Category: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aCategory // = 0

    init() {
      this = .aCategory
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aCategory
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aCategory: return 0
      }
    }

  }

  enum Ivar: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aIvar // = 0

    init() {
      this = .aIvar
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aIvar
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aIvar: return 0
      }
    }

  }

  enum Method: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aMethod // = 0

    init() {
      this = .aMethod
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aMethod
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aMethod: return 0
      }
    }

  }

  enum finalize: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case afinalize // = 0

    init() {
      this = .afinalize
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .afinalize
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .afinalize: return 0
      }
    }

  }

  enum hash: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case ahash // = 0

    init() {
      this = .ahash
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .ahash
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .ahash: return 0
      }
    }

  }

  enum dealloc: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adealloc // = 0

    init() {
      this = .adealloc
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adealloc
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adealloc: return 0
      }
    }

  }

  enum superclass: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asuperclass // = 0

    init() {
      this = .asuperclass
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asuperclass
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asuperclass: return 0
      }
    }

  }

  enum retain: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aretain // = 0

    init() {
      this = .aretain
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aretain
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aretain: return 0
      }
    }

  }

  enum release: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case arelease // = 0

    init() {
      this = .arelease
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .arelease
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .arelease: return 0
      }
    }

  }

  enum autorelease: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aautorelease // = 0

    init() {
      this = .aautorelease
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aautorelease
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aautorelease: return 0
      }
    }

  }

  enum retainCount: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aretainCount // = 0

    init() {
      this = .aretainCount
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aretainCount
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aretainCount: return 0
      }
    }

  }

  enum zone: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case azone // = 0

    init() {
      this = .azone
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .azone
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .azone: return 0
      }
    }

  }

  enum isProxy: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aisProxy // = 0

    init() {
      this = .aisProxy
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aisProxy
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aisProxy: return 0
      }
    }

  }

  enum copy: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case acopy // = 0

    init() {
      this = .acopy
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .acopy
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .acopy: return 0
      }
    }

  }

  enum mutableCopy: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case amutableCopy // = 0

    init() {
      this = .amutableCopy
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .amutableCopy
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .amutableCopy: return 0
      }
    }

  }

  enum classForCoder: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aclassForCoder // = 0

    init() {
      this = .aclassForCoder
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aclassForCoder
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aclassForCoder: return 0
      }
    }

  }

  enum clear: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aclear // = 0

    init() {
      this = .aclear
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aclear
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aclear: return 0
      }
    }

  }

  enum data: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adata // = 0

    init() {
      this = .adata
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adata
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adata: return 0
      }
    }

  }

  enum delimitedData: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adelimitedData // = 0

    init() {
      this = .adelimitedData
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adelimitedData
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adelimitedData: return 0
      }
    }

  }

  enum descriptor: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case adescriptor // = 0

    init() {
      this = .adescriptor
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .adescriptor
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .adescriptor: return 0
      }
    }

  }

  enum extensionRegistry: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aextensionRegistry // = 0

    init() {
      this = .aextensionRegistry
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aextensionRegistry
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aextensionRegistry: return 0
      }
    }

  }

  enum extensionsCurrentlySet: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aextensionsCurrentlySet // = 0

    init() {
      this = .aextensionsCurrentlySet
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aextensionsCurrentlySet
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aextensionsCurrentlySet: return 0
      }
    }

  }

  enum isInitializedEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aisInitialized // = 0

    init() {
      this = .aisInitialized
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aisInitialized
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aisInitialized: return 0
      }
    }

  }

  enum serializedSize: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aserializedSize // = 0

    init() {
      this = .aserializedSize
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aserializedSize
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aserializedSize: return 0
      }
    }

  }

  enum sortedExtensionsInUse: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case asortedExtensionsInUse // = 0

    init() {
      this = .asortedExtensionsInUse
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .asortedExtensionsInUse
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .asortedExtensionsInUse: return 0
      }
    }

  }

  enum unknownFieldsEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aunknownFields // = 0

    init() {
      this = .aunknownFields
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aunknownFields
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aunknownFields: return 0
      }
    }

  }

  enum Fixed: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aFixed // = 0

    init() {
      this = .aFixed
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aFixed
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aFixed: return 0
      }
    }

  }

  enum Fract: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aFract // = 0

    init() {
      this = .aFract
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aFract
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aFract: return 0
      }
    }

  }

  enum Size: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aSize // = 0

    init() {
      this = .aSize
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aSize
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aSize: return 0
      }
    }

  }

  enum LogicalAddress: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aLogicalAddress // = 0

    init() {
      this = .aLogicalAddress
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aLogicalAddress
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aLogicalAddress: return 0
      }
    }

  }

  enum PhysicalAddress: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aPhysicalAddress // = 0

    init() {
      this = .aPhysicalAddress
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aPhysicalAddress
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aPhysicalAddress: return 0
      }
    }

  }

  enum ByteCount: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aByteCount // = 0

    init() {
      this = .aByteCount
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aByteCount
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aByteCount: return 0
      }
    }

  }

  enum ByteOffset: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aByteOffset // = 0

    init() {
      this = .aByteOffset
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aByteOffset
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aByteOffset: return 0
      }
    }

  }

  enum Duration: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aDuration // = 0

    init() {
      this = .aDuration
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aDuration
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aDuration: return 0
      }
    }

  }

  enum AbsoluteTime: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aAbsoluteTime // = 0

    init() {
      this = .aAbsoluteTime
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aAbsoluteTime
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aAbsoluteTime: return 0
      }
    }

  }

  enum OptionBits: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aOptionBits // = 0

    init() {
      this = .aOptionBits
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aOptionBits
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aOptionBits: return 0
      }
    }

  }

  enum ItemCount: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aItemCount // = 0

    init() {
      this = .aItemCount
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aItemCount
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aItemCount: return 0
      }
    }

  }

  enum PBVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aPbversion // = 0

    init() {
      this = .aPbversion
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aPbversion
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aPbversion: return 0
      }
    }

  }

  enum ScriptCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aScriptCode // = 0

    init() {
      this = .aScriptCode
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aScriptCode
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aScriptCode: return 0
      }
    }

  }

  enum LangCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aLangCode // = 0

    init() {
      this = .aLangCode
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aLangCode
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aLangCode: return 0
      }
    }

  }

  enum RegionCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aRegionCode // = 0

    init() {
      this = .aRegionCode
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aRegionCode
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aRegionCode: return 0
      }
    }

  }

  enum OSType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aOstype // = 0

    init() {
      this = .aOstype
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aOstype
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aOstype: return 0
      }
    }

  }

  enum ProcessSerialNumber: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aProcessSerialNumber // = 0

    init() {
      this = .aProcessSerialNumber
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aProcessSerialNumber
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aProcessSerialNumber: return 0
      }
    }

  }

  enum Point: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aPoint // = 0

    init() {
      this = .aPoint
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aPoint
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aPoint: return 0
      }
    }

  }

  enum Rect: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aRect // = 0

    init() {
      this = .aRect
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aRect
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aRect: return 0
      }
    }

  }

  enum FixedPoint: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aFixedPoint // = 0

    init() {
      this = .aFixedPoint
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aFixedPoint
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aFixedPoint: return 0
      }
    }

  }

  enum FixedRect: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aFixedRect // = 0

    init() {
      this = .aFixedRect
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aFixedRect
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aFixedRect: return 0
      }
    }

  }

  enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aStyle // = 0

    init() {
      this = .aStyle
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aStyle
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aStyle: return 0
      }
    }

  }

  enum StyleParameter: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aStyleParameter // = 0

    init() {
      this = .aStyleParameter
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aStyleParameter
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aStyleParameter: return 0
      }
    }

  }

  enum StyleField: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aStyleField // = 0

    init() {
      this = .aStyleField
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aStyleField
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aStyleField: return 0
      }
    }

  }

  enum TimeScale: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aTimeScale // = 0

    init() {
      this = .aTimeScale
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aTimeScale
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aTimeScale: return 0
      }
    }

  }

  enum TimeBase: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aTimeBase // = 0

    init() {
      this = .aTimeBase
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aTimeBase
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aTimeBase: return 0
      }
    }

  }

  enum TimeRecord: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aTimeRecord // = 0

    init() {
      this = .aTimeRecord
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aTimeRecord
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aTimeRecord: return 0
      }
    }

  }

  enum Extension: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aExtension // = 0

    init() {
      this = .aExtension
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aExtension
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aExtension: return 0
      }
    }

  }

  enum ExtensionsEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer
    case aExtensions // = 0

    init() {
      this = .aExtensions
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .aExtensions
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .aExtensions: return 0
      }
    }

  }

  init() {}
}

struct SwiftProtoTesting_Names_FieldNamingInitials: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Lowers: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var http: Int32 {
      get {return _storage._http ?? 0}
      set {_uniqueStorage()._http = newValue}
    }
    /// Returns true if `http` has been explicitly set.
    var hasHTTP: Boolean {return _storage._http != Nothing}
    /// Clears the value of `http`. Subsequent reads from it will return its default value.
    mutating fn clearHTTP() {_uniqueStorage()._http = Nothing}

    var httpRequest: Int32 {
      get {return _storage._httpRequest ?? 0}
      set {_uniqueStorage()._httpRequest = newValue}
    }
    /// Returns true if `httpRequest` has been explicitly set.
    var hasHTTPRequest: Boolean {return _storage._httpRequest != Nothing}
    /// Clears the value of `httpRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPRequest() {_uniqueStorage()._httpRequest = Nothing}

    var theHTTPRequest: Int32 {
      get {return _storage._theHTTPRequest ?? 0}
      set {_uniqueStorage()._theHTTPRequest = newValue}
    }
    /// Returns true if `theHTTPRequest` has been explicitly set.
    var hasTheHTTPRequest: Boolean {return _storage._theHTTPRequest != Nothing}
    /// Clears the value of `theHTTPRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPRequest() {_uniqueStorage()._theHTTPRequest = Nothing}

    var theHTTP: Int32 {
      get {return _storage._theHTTP ?? 0}
      set {_uniqueStorage()._theHTTP = newValue}
    }
    /// Returns true if `theHTTP` has been explicitly set.
    var hasTheHTTP: Boolean {return _storage._theHTTP != Nothing}
    /// Clears the value of `theHTTP`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTP() {_uniqueStorage()._theHTTP = Nothing}

    var https: Int32 {
      get {return _storage._https ?? 0}
      set {_uniqueStorage()._https = newValue}
    }
    /// Returns true if `https` has been explicitly set.
    var hasHTTPS: Boolean {return _storage._https != Nothing}
    /// Clears the value of `https`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPS() {_uniqueStorage()._https = Nothing}

    var httpsRequest: Int32 {
      get {return _storage._httpsRequest ?? 0}
      set {_uniqueStorage()._httpsRequest = newValue}
    }
    /// Returns true if `httpsRequest` has been explicitly set.
    var hasHTTPSRequest: Boolean {return _storage._httpsRequest != Nothing}
    /// Clears the value of `httpsRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPSRequest() {_uniqueStorage()._httpsRequest = Nothing}

    var theHTTPSRequest: Int32 {
      get {return _storage._theHTTPSRequest ?? 0}
      set {_uniqueStorage()._theHTTPSRequest = newValue}
    }
    /// Returns true if `theHTTPSRequest` has been explicitly set.
    var hasTheHTTPSRequest: Boolean {return _storage._theHTTPSRequest != Nothing}
    /// Clears the value of `theHTTPSRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPSRequest() {_uniqueStorage()._theHTTPSRequest = Nothing}

    var theHTTPS: Int32 {
      get {return _storage._theHTTPS ?? 0}
      set {_uniqueStorage()._theHTTPS = newValue}
    }
    /// Returns true if `theHTTPS` has been explicitly set.
    var hasTheHTTPS: Boolean {return _storage._theHTTPS != Nothing}
    /// Clears the value of `theHTTPS`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPS() {_uniqueStorage()._theHTTPS = Nothing}

    var url: Int32 {
      get {return _storage._url ?? 0}
      set {_uniqueStorage()._url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Boolean {return _storage._url != Nothing}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating fn clearURL() {_uniqueStorage()._url = Nothing}

    var urlValue: Int32 {
      get {return _storage._urlValue ?? 0}
      set {_uniqueStorage()._urlValue = newValue}
    }
    /// Returns true if `urlValue` has been explicitly set.
    var hasURLValue: Boolean {return _storage._urlValue != Nothing}
    /// Clears the value of `urlValue`. Subsequent reads from it will return its default value.
    mutating fn clearURLValue() {_uniqueStorage()._urlValue = Nothing}

    var theURLValue: Int32 {
      get {return _storage._theURLValue ?? 0}
      set {_uniqueStorage()._theURLValue = newValue}
    }
    /// Returns true if `theURLValue` has been explicitly set.
    var hasTheURLValue: Boolean {return _storage._theURLValue != Nothing}
    /// Clears the value of `theURLValue`. Subsequent reads from it will return its default value.
    mutating fn clearTheURLValue() {_uniqueStorage()._theURLValue = Nothing}

    var theURL: Int32 {
      get {return _storage._theURL ?? 0}
      set {_uniqueStorage()._theURL = newValue}
    }
    /// Returns true if `theURL` has been explicitly set.
    var hasTheURL: Boolean {return _storage._theURL != Nothing}
    /// Clears the value of `theURL`. Subsequent reads from it will return its default value.
    mutating fn clearTheURL() {_uniqueStorage()._theURL = Nothing}

    var aBC: Int32 {
      get {return _storage._aBC ?? 0}
      set {_uniqueStorage()._aBC = newValue}
    }
    /// Returns true if `aBC` has been explicitly set.
    var hasABC: Boolean {return _storage._aBC != Nothing}
    /// Clears the value of `aBC`. Subsequent reads from it will return its default value.
    mutating fn clearABC() {_uniqueStorage()._aBC = Nothing}

    var id: Int32 {
      get {return _storage._id ?? 0}
      set {_uniqueStorage()._id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Boolean {return _storage._id != Nothing}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating fn clearID() {_uniqueStorage()._id = Nothing}

    var idNumber: Int32 {
      get {return _storage._idNumber ?? 0}
      set {_uniqueStorage()._idNumber = newValue}
    }
    /// Returns true if `idNumber` has been explicitly set.
    var hasIDNumber: Boolean {return _storage._idNumber != Nothing}
    /// Clears the value of `idNumber`. Subsequent reads from it will return its default value.
    mutating fn clearIDNumber() {_uniqueStorage()._idNumber = Nothing}

    var theIDNumber: Int32 {
      get {return _storage._theIDNumber ?? 0}
      set {_uniqueStorage()._theIDNumber = newValue}
    }
    /// Returns true if `theIDNumber` has been explicitly set.
    var hasTheIDNumber: Boolean {return _storage._theIDNumber != Nothing}
    /// Clears the value of `theIDNumber`. Subsequent reads from it will return its default value.
    mutating fn clearTheIDNumber() {_uniqueStorage()._theIDNumber = Nothing}

    var requestID: Int32 {
      get {return _storage._requestID ?? 0}
      set {_uniqueStorage()._requestID = newValue}
    }
    /// Returns true if `requestID` has been explicitly set.
    var hasRequestID: Boolean {return _storage._requestID != Nothing}
    /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
    mutating fn clearRequestID() {_uniqueStorage()._requestID = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Uppers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var http: Int32 {
      get {return _http ?? 0}
      set {_http = newValue}
    }
    /// Returns true if `http` has been explicitly set.
    var hasHTTP: Boolean {return this._http != Nothing}
    /// Clears the value of `http`. Subsequent reads from it will return its default value.
    mutating fn clearHTTP() {this._http = Nothing}

    var httpRequest: Int32 {
      get {return _httpRequest ?? 0}
      set {_httpRequest = newValue}
    }
    /// Returns true if `httpRequest` has been explicitly set.
    var hasHTTPRequest: Boolean {return this._httpRequest != Nothing}
    /// Clears the value of `httpRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPRequest() {this._httpRequest = Nothing}

    var theHTTPRequest: Int32 {
      get {return _theHTTPRequest ?? 0}
      set {_theHTTPRequest = newValue}
    }
    /// Returns true if `theHTTPRequest` has been explicitly set.
    var hasTheHTTPRequest: Boolean {return this._theHTTPRequest != Nothing}
    /// Clears the value of `theHTTPRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPRequest() {this._theHTTPRequest = Nothing}

    var theHTTP: Int32 {
      get {return _theHTTP ?? 0}
      set {_theHTTP = newValue}
    }
    /// Returns true if `theHTTP` has been explicitly set.
    var hasTheHTTP: Boolean {return this._theHTTP != Nothing}
    /// Clears the value of `theHTTP`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTP() {this._theHTTP = Nothing}

    var https: Int32 {
      get {return _https ?? 0}
      set {_https = newValue}
    }
    /// Returns true if `https` has been explicitly set.
    var hasHTTPS: Boolean {return this._https != Nothing}
    /// Clears the value of `https`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPS() {this._https = Nothing}

    var httpsRequest: Int32 {
      get {return _httpsRequest ?? 0}
      set {_httpsRequest = newValue}
    }
    /// Returns true if `httpsRequest` has been explicitly set.
    var hasHTTPSRequest: Boolean {return this._httpsRequest != Nothing}
    /// Clears the value of `httpsRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPSRequest() {this._httpsRequest = Nothing}

    var theHTTPSRequest: Int32 {
      get {return _theHTTPSRequest ?? 0}
      set {_theHTTPSRequest = newValue}
    }
    /// Returns true if `theHTTPSRequest` has been explicitly set.
    var hasTheHTTPSRequest: Boolean {return this._theHTTPSRequest != Nothing}
    /// Clears the value of `theHTTPSRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPSRequest() {this._theHTTPSRequest = Nothing}

    var theHTTPS: Int32 {
      get {return _theHTTPS ?? 0}
      set {_theHTTPS = newValue}
    }
    /// Returns true if `theHTTPS` has been explicitly set.
    var hasTheHTTPS: Boolean {return this._theHTTPS != Nothing}
    /// Clears the value of `theHTTPS`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPS() {this._theHTTPS = Nothing}

    var url: Int32 {
      get {return _url ?? 0}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Boolean {return this._url != Nothing}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating fn clearURL() {this._url = Nothing}

    var urlValue: Int32 {
      get {return _urlValue ?? 0}
      set {_urlValue = newValue}
    }
    /// Returns true if `urlValue` has been explicitly set.
    var hasURLValue: Boolean {return this._urlValue != Nothing}
    /// Clears the value of `urlValue`. Subsequent reads from it will return its default value.
    mutating fn clearURLValue() {this._urlValue = Nothing}

    var theURLValue: Int32 {
      get {return _theURLValue ?? 0}
      set {_theURLValue = newValue}
    }
    /// Returns true if `theURLValue` has been explicitly set.
    var hasTheURLValue: Boolean {return this._theURLValue != Nothing}
    /// Clears the value of `theURLValue`. Subsequent reads from it will return its default value.
    mutating fn clearTheURLValue() {this._theURLValue = Nothing}

    var theURL: Int32 {
      get {return _theURL ?? 0}
      set {_theURL = newValue}
    }
    /// Returns true if `theURL` has been explicitly set.
    var hasTheURL: Boolean {return this._theURL != Nothing}
    /// Clears the value of `theURL`. Subsequent reads from it will return its default value.
    mutating fn clearTheURL() {this._theURL = Nothing}

    var id: Int32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Boolean {return this._id != Nothing}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating fn clearID() {this._id = Nothing}

    var idNumber: Int32 {
      get {return _idNumber ?? 0}
      set {_idNumber = newValue}
    }
    /// Returns true if `idNumber` has been explicitly set.
    var hasIDNumber: Boolean {return this._idNumber != Nothing}
    /// Clears the value of `idNumber`. Subsequent reads from it will return its default value.
    mutating fn clearIDNumber() {this._idNumber = Nothing}

    var theIDNumber: Int32 {
      get {return _theIDNumber ?? 0}
      set {_theIDNumber = newValue}
    }
    /// Returns true if `theIDNumber` has been explicitly set.
    var hasTheIDNumber: Boolean {return this._theIDNumber != Nothing}
    /// Clears the value of `theIDNumber`. Subsequent reads from it will return its default value.
    mutating fn clearTheIDNumber() {this._theIDNumber = Nothing}

    var requestID: Int32 {
      get {return _requestID ?? 0}
      set {_requestID = newValue}
    }
    /// Returns true if `requestID` has been explicitly set.
    var hasRequestID: Boolean {return this._requestID != Nothing}
    /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
    mutating fn clearRequestID() {this._requestID = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _http: Int32? = Nothing
    fileprivate var _httpRequest: Int32? = Nothing
    fileprivate var _theHTTPRequest: Int32? = Nothing
    fileprivate var _theHTTP: Int32? = Nothing
    fileprivate var _https: Int32? = Nothing
    fileprivate var _httpsRequest: Int32? = Nothing
    fileprivate var _theHTTPSRequest: Int32? = Nothing
    fileprivate var _theHTTPS: Int32? = Nothing
    fileprivate var _url: Int32? = Nothing
    fileprivate var _urlValue: Int32? = Nothing
    fileprivate var _theURLValue: Int32? = Nothing
    fileprivate var _theURL: Int32? = Nothing
    fileprivate var _id: Int32? = Nothing
    fileprivate var _idNumber: Int32? = Nothing
    fileprivate var _theIDNumber: Int32? = Nothing
    fileprivate var _requestID: Int32? = Nothing
  }

  struct WordCase: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var http: Int32 {
      get {return _http ?? 0}
      set {_http = newValue}
    }
    /// Returns true if `http` has been explicitly set.
    var hasHTTP: Boolean {return this._http != Nothing}
    /// Clears the value of `http`. Subsequent reads from it will return its default value.
    mutating fn clearHTTP() {this._http = Nothing}

    var httpRequest: Int32 {
      get {return _httpRequest ?? 0}
      set {_httpRequest = newValue}
    }
    /// Returns true if `httpRequest` has been explicitly set.
    var hasHTTPRequest: Boolean {return this._httpRequest != Nothing}
    /// Clears the value of `httpRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPRequest() {this._httpRequest = Nothing}

    var theHTTPRequest: Int32 {
      get {return _theHTTPRequest ?? 0}
      set {_theHTTPRequest = newValue}
    }
    /// Returns true if `theHTTPRequest` has been explicitly set.
    var hasTheHTTPRequest: Boolean {return this._theHTTPRequest != Nothing}
    /// Clears the value of `theHTTPRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPRequest() {this._theHTTPRequest = Nothing}

    var theHTTP: Int32 {
      get {return _theHTTP ?? 0}
      set {_theHTTP = newValue}
    }
    /// Returns true if `theHTTP` has been explicitly set.
    var hasTheHTTP: Boolean {return this._theHTTP != Nothing}
    /// Clears the value of `theHTTP`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTP() {this._theHTTP = Nothing}

    var https: Int32 {
      get {return _https ?? 0}
      set {_https = newValue}
    }
    /// Returns true if `https` has been explicitly set.
    var hasHTTPS: Boolean {return this._https != Nothing}
    /// Clears the value of `https`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPS() {this._https = Nothing}

    var httpsRequest: Int32 {
      get {return _httpsRequest ?? 0}
      set {_httpsRequest = newValue}
    }
    /// Returns true if `httpsRequest` has been explicitly set.
    var hasHTTPSRequest: Boolean {return this._httpsRequest != Nothing}
    /// Clears the value of `httpsRequest`. Subsequent reads from it will return its default value.
    mutating fn clearHTTPSRequest() {this._httpsRequest = Nothing}

    var theHTTPSRequest: Int32 {
      get {return _theHTTPSRequest ?? 0}
      set {_theHTTPSRequest = newValue}
    }
    /// Returns true if `theHTTPSRequest` has been explicitly set.
    var hasTheHTTPSRequest: Boolean {return this._theHTTPSRequest != Nothing}
    /// Clears the value of `theHTTPSRequest`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPSRequest() {this._theHTTPSRequest = Nothing}

    var theHTTPS: Int32 {
      get {return _theHTTPS ?? 0}
      set {_theHTTPS = newValue}
    }
    /// Returns true if `theHTTPS` has been explicitly set.
    var hasTheHTTPS: Boolean {return this._theHTTPS != Nothing}
    /// Clears the value of `theHTTPS`. Subsequent reads from it will return its default value.
    mutating fn clearTheHTTPS() {this._theHTTPS = Nothing}

    var url: Int32 {
      get {return _url ?? 0}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Boolean {return this._url != Nothing}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating fn clearURL() {this._url = Nothing}

    var urlValue: Int32 {
      get {return _urlValue ?? 0}
      set {_urlValue = newValue}
    }
    /// Returns true if `urlValue` has been explicitly set.
    var hasURLValue: Boolean {return this._urlValue != Nothing}
    /// Clears the value of `urlValue`. Subsequent reads from it will return its default value.
    mutating fn clearURLValue() {this._urlValue = Nothing}

    var theURLValue: Int32 {
      get {return _theURLValue ?? 0}
      set {_theURLValue = newValue}
    }
    /// Returns true if `theURLValue` has been explicitly set.
    var hasTheURLValue: Boolean {return this._theURLValue != Nothing}
    /// Clears the value of `theURLValue`. Subsequent reads from it will return its default value.
    mutating fn clearTheURLValue() {this._theURLValue = Nothing}

    var theURL: Int32 {
      get {return _theURL ?? 0}
      set {_theURL = newValue}
    }
    /// Returns true if `theURL` has been explicitly set.
    var hasTheURL: Boolean {return this._theURL != Nothing}
    /// Clears the value of `theURL`. Subsequent reads from it will return its default value.
    mutating fn clearTheURL() {this._theURL = Nothing}

    var id: Int32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Boolean {return this._id != Nothing}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating fn clearID() {this._id = Nothing}

    var idNumber: Int32 {
      get {return _idNumber ?? 0}
      set {_idNumber = newValue}
    }
    /// Returns true if `idNumber` has been explicitly set.
    var hasIDNumber: Boolean {return this._idNumber != Nothing}
    /// Clears the value of `idNumber`. Subsequent reads from it will return its default value.
    mutating fn clearIDNumber() {this._idNumber = Nothing}

    var theIDNumber: Int32 {
      get {return _theIDNumber ?? 0}
      set {_theIDNumber = newValue}
    }
    /// Returns true if `theIDNumber` has been explicitly set.
    var hasTheIDNumber: Boolean {return this._theIDNumber != Nothing}
    /// Clears the value of `theIDNumber`. Subsequent reads from it will return its default value.
    mutating fn clearTheIDNumber() {this._theIDNumber = Nothing}

    var requestID: Int32 {
      get {return _requestID ?? 0}
      set {_requestID = newValue}
    }
    /// Returns true if `requestID` has been explicitly set.
    var hasRequestID: Boolean {return this._requestID != Nothing}
    /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
    mutating fn clearRequestID() {this._requestID = Nothing}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _http: Int32? = Nothing
    fileprivate var _httpRequest: Int32? = Nothing
    fileprivate var _theHTTPRequest: Int32? = Nothing
    fileprivate var _theHTTP: Int32? = Nothing
    fileprivate var _https: Int32? = Nothing
    fileprivate var _httpsRequest: Int32? = Nothing
    fileprivate var _theHTTPSRequest: Int32? = Nothing
    fileprivate var _theHTTPS: Int32? = Nothing
    fileprivate var _url: Int32? = Nothing
    fileprivate var _urlValue: Int32? = Nothing
    fileprivate var _theURLValue: Int32? = Nothing
    fileprivate var _theURL: Int32? = Nothing
    fileprivate var _id: Int32? = Nothing
    fileprivate var _idNumber: Int32? = Nothing
    fileprivate var _theIDNumber: Int32? = Nothing
    fileprivate var _requestID: Int32? = Nothing
  }

  init() {}
}

struct SwiftProtoTesting_Names_ExtensionNamingInitials: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct SwiftProtoTesting_Names_Lowers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SwiftProtoTesting_Names_Uppers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SwiftProtoTesting_Names_WordCase: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SwiftProtoTesting_Names_ExtensionNamingInitialsLowers: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct SwiftProtoTesting_Names_ExtensionNamingInitialsUppers: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct SwiftProtoTesting_Names_ValidIdentifiers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var _1Field: Int32 {
    get {return __1Field ?? 0}
    set {__1Field = newValue}
  }
  /// Returns true if `_1Field` has been explicitly set.
  var has_1Field: Boolean {return this.__1Field != Nothing}
  /// Clears the value of `_1Field`. Subsequent reads from it will return its default value.
  mutating fn clear_1Field() {this.__1Field = Nothing}

  var field: Int32 {
    get {return _field ?? 0}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  var hasField: Boolean {return this._field != Nothing}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  mutating fn clearField() {this._field = Nothing}

  var _3Field3: Int32 {
    get {return __3Field3 ?? 0}
    set {__3Field3 = newValue}
  }
  /// Returns true if `_3Field3` has been explicitly set.
  var has_3Field3: Boolean {return this.__3Field3 != Nothing}
  /// Clears the value of `_3Field3`. Subsequent reads from it will return its default value.
  mutating fn clear_3Field3() {this.__3Field3 = Nothing}

  var _2Of: SwiftProtoTesting_Names_ValidIdentifiers.OneOf__2Of? = Nothing

  var _4: Int32 {
    get {
      if case ._4(immutable v)? = _2Of {return v}
      return 0
    }
    set {_2Of = ._4(newValue)}
  }

  var _5Field: Int32 {
    get {
      if case ._5Field(immutable v)? = _2Of {return v}
      return 0
    }
    set {_2Of = ._5Field(newValue)}
  }

  var enumField: SwiftProtoTesting_Names_ValidIdentifiers.TestEnum {
    get {return _enumField ?? .testEnum0}
    set {_enumField = newValue}
  }
  /// Returns true if `enumField` has been explicitly set.
  var hasEnumField: Boolean {return this._enumField != Nothing}
  /// Clears the value of `enumField`. Subsequent reads from it will return its default value.
  mutating fn clearEnumField() {this._enumField = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf__2Of: Equatable, Sendable {
    case _4(Int32)
    case _5Field(Int32)

  }

  enum TestEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Integer

    /// Won't prefix strip
    case testEnum0 // = 0

    /// Will prefix strip
    case first // = 1

    /// Leading underscore & number, keeps that.
    case _2 // = 2

    /// Leading underscore & number, keeps that.
    case _3Value // = 3

    init() {
      this = .testEnum0
    }

    init?(rawValue: Integer) {
      switch rawValue {
      case 0: this = .testEnum0
      case 1: this = .first
      case 2: this = ._2
      case 3: this = ._3Value
      default: return Nothing
      }
    }

    var rawValue: Integer {
      switch this {
      case .testEnum0: return 0
      case .first: return 1
      case ._2: return 2
      case ._3Value: return 3
      }
    }

  }

  init() {}

  fileprivate var __1Field: Int32? = Nothing
  fileprivate var _field: Int32? = Nothing
  fileprivate var __3Field3: Int32? = Nothing
  fileprivate var _enumField: SwiftProtoTesting_Names_ValidIdentifiers.TestEnum? = Nothing
}

/// For issue #1084 - If the generated code compiles, things are good.
///
/// This gets special handling because of the generated setter.
struct SwiftProtoTesting_Names_SpecialNames1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newValue: SwiftProtoTesting_Names_SpecialNames1.OneOf_NewValue? = Nothing

  var str: String {
    get {
      if case .str(immutable v)? = newValue {return v}
      return String()
    }
    set {this.newValue = .str(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_NewValue: Equatable, Sendable {
    case str(String)

  }

  init() {}
}

/// No special handling needed in the generator.
struct SwiftProtoTesting_Names_SpecialNames2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newValue: String {
    get {return _newValue ?? String()}
    set {_newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Boolean {return this._newValue != Nothing}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating fn clearNewValue() {this._newValue = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newValue: String? = Nothing
}

/// No special handling needed in the generator.
struct SwiftProtoTesting_Names_SpecialNames3: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newValue: OneOf_NewValue? {
    get {return _storage._newValue}
    set {_uniqueStorage()._newValue = newValue}
  }

  var str: String {
    get {
      if case .str(immutable v)? = _storage._newValue {return v}
      return String()
    }
    set {_uniqueStorage()._newValue = .str(newValue)}
  }

  var forcesStorage: SwiftProtoTesting_Names_SpecialNames3 {
    get {return _storage._forcesStorage ?? SwiftProtoTesting_Names_SpecialNames3()}
    set {_uniqueStorage()._forcesStorage = newValue}
  }
  /// Returns true if `forcesStorage` has been explicitly set.
  var hasForcesStorage: Boolean {return _storage._forcesStorage != Nothing}
  /// Clears the value of `forcesStorage`. Subsequent reads from it will return its default value.
  mutating fn clearForcesStorage() {_uniqueStorage()._forcesStorage = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_NewValue: Equatable, Sendable {
    case str(String)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// No special handling needed in the generator.
struct SwiftProtoTesting_Names_SpecialNames4: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newValue: String {
    get {return _storage._newValue ?? String()}
    set {_uniqueStorage()._newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Boolean {return _storage._newValue != Nothing}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating fn clearNewValue() {_uniqueStorage()._newValue = Nothing}

  var forcesStorage: SwiftProtoTesting_Names_SpecialNames4 {
    get {return _storage._forcesStorage ?? SwiftProtoTesting_Names_SpecialNames4()}
    set {_uniqueStorage()._forcesStorage = newValue}
  }
  /// Returns true if `forcesStorage` has been explicitly set.
  var hasForcesStorage: Boolean {return _storage._forcesStorage != Nothing}
  /// Clears the value of `forcesStorage`. Subsequent reads from it will return its default value.
  mutating fn clearForcesStorage() {_uniqueStorage()._forcesStorage = Nothing}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Extension support defined in unittest_swift_naming.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtoTesting_Names_ExtensionNamingInitials {

  var SwiftProtoTesting_Names_Lowers_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http)
  }

  var SwiftProtoTesting_Names_Lowers_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.http_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.http_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.http_request)
  }

  var SwiftProtoTesting_Names_Lowers_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_http_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_http_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http_request)
  }

  var SwiftProtoTesting_Names_Lowers_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_http)
  }

  var SwiftProtoTesting_Names_Lowers_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https)
  }

  var SwiftProtoTesting_Names_Lowers_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.https_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.https_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.https_request)
  }

  var SwiftProtoTesting_Names_Lowers_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_https_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_https_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https_request)
  }

  var SwiftProtoTesting_Names_Lowers_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_https)
  }

  var SwiftProtoTesting_Names_Lowers_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url)
  }

  var SwiftProtoTesting_Names_Lowers_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.url_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.url_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.url_value)
  }

  var SwiftProtoTesting_Names_Lowers_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_url_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_url_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url_value)
  }

  var SwiftProtoTesting_Names_Lowers_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_url)
  }

  var SwiftProtoTesting_Names_Lowers_aBC: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.a_b_c) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.a_b_c, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.a_b_c`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_aBC: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.a_b_c)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.a_b_c`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_aBC() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.a_b_c)
  }

  var SwiftProtoTesting_Names_Lowers_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id)
  }

  var SwiftProtoTesting_Names_Lowers_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.id_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.id_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.id_number)
  }

  var SwiftProtoTesting_Names_Lowers_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_id_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_id_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.the_id_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_id_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.the_id_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.the_id_number)
  }

  var SwiftProtoTesting_Names_Lowers_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.request_id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.request_id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Lowers.Extensions.request_id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Lowers_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.request_id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Lowers.Extensions.request_id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Lowers_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Lowers.Extensions.request_id)
  }

  var SwiftProtoTesting_Names_Uppers_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTP`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTP`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP)
  }

  var SwiftProtoTesting_Names_Uppers_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request)
  }

  var SwiftProtoTesting_Names_Uppers_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request)
  }

  var SwiftProtoTesting_Names_Uppers_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP)
  }

  var SwiftProtoTesting_Names_Uppers_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTPS`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTPS`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS)
  }

  var SwiftProtoTesting_Names_Uppers_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request)
  }

  var SwiftProtoTesting_Names_Uppers_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request)
  }

  var SwiftProtoTesting_Names_Uppers_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS)
  }

  var SwiftProtoTesting_Names_Uppers_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.URL`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.URL`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL)
  }

  var SwiftProtoTesting_Names_Uppers_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.URL_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.URL_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.URL_value)
  }

  var SwiftProtoTesting_Names_Uppers_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value)
  }

  var SwiftProtoTesting_Names_Uppers_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_URL`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_URL`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_URL)
  }

  var SwiftProtoTesting_Names_Uppers_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.ID`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.ID`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID)
  }

  var SwiftProtoTesting_Names_Uppers_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.ID_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.ID_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.ID_number)
  }

  var SwiftProtoTesting_Names_Uppers_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number)
  }

  var SwiftProtoTesting_Names_Uppers_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.request_ID) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.request_ID, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Uppers.Extensions.request_ID`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_Uppers_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.request_ID)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Uppers.Extensions.request_ID`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_Uppers_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Uppers.Extensions.request_ID)
  }

  var SwiftProtoTesting_Names_WordCase_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.Http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.Http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Http)
  }

  var SwiftProtoTesting_Names_WordCase_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest)
  }

  var SwiftProtoTesting_Names_WordCase_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest)
  }

  var SwiftProtoTesting_Names_WordCase_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttp) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttp, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttp`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttp)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttp`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttp)
  }

  var SwiftProtoTesting_Names_WordCase_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.Https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.Https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Https)
  }

  var SwiftProtoTesting_Names_WordCase_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest)
  }

  var SwiftProtoTesting_Names_WordCase_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest)
  }

  var SwiftProtoTesting_Names_WordCase_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttps) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttps, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttps`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttps)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheHttps`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheHttps)
  }

  var SwiftProtoTesting_Names_WordCase_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.Url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.Url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Url)
  }

  var SwiftProtoTesting_Names_WordCase_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.UrlValue) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.UrlValue, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.UrlValue`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.UrlValue)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.UrlValue`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.UrlValue)
  }

  var SwiftProtoTesting_Names_WordCase_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue)
  }

  var SwiftProtoTesting_Names_WordCase_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrl) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrl, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheUrl`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrl)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheUrl`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheUrl)
  }

  var SwiftProtoTesting_Names_WordCase_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.Id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.Id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.Id)
  }

  var SwiftProtoTesting_Names_WordCase_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.IdNumber) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.IdNumber, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.IdNumber`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.IdNumber)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.IdNumber`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.IdNumber)
  }

  var SwiftProtoTesting_Names_WordCase_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber)
  }

  var SwiftProtoTesting_Names_WordCase_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.RequestId) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.RequestId, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_WordCase.Extensions.RequestId`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_WordCase_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.RequestId)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_WordCase.Extensions.RequestId`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_WordCase_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_WordCase.Extensions.RequestId)
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsLowers {

  var SwiftProtoTesting_Names_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http)
  }

  var SwiftProtoTesting_Names_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_http_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_http_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_http_request)
  }

  var SwiftProtoTesting_Names_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_http_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_http_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http_request)
  }

  var SwiftProtoTesting_Names_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_http)
  }

  var SwiftProtoTesting_Names_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https)
  }

  var SwiftProtoTesting_Names_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_https_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_https_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_https_request)
  }

  var SwiftProtoTesting_Names_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_https_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_https_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https_request)
  }

  var SwiftProtoTesting_Names_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_https)
  }

  var SwiftProtoTesting_Names_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url)
  }

  var SwiftProtoTesting_Names_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_url_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_url_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_url_value)
  }

  var SwiftProtoTesting_Names_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_url_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_url_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url_value)
  }

  var SwiftProtoTesting_Names_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_url)
  }

  var SwiftProtoTesting_Names_aBC: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_a_b_c) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_a_b_c, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_a_b_c`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_aBC: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_a_b_c)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_a_b_c`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_aBC() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_a_b_c)
  }

  var SwiftProtoTesting_Names_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id)
  }

  var SwiftProtoTesting_Names_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_id_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_id_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_id_number)
  }

  var SwiftProtoTesting_Names_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_id_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_id_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_id_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_id_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_id_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_id_number)
  }

  var SwiftProtoTesting_Names_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_request_id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_request_id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_id)
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsUppers {

  var SwiftProtoTesting_Names_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HTTP`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HTTP`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP)
  }

  var SwiftProtoTesting_Names_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HTTP_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HTTP_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTP_request)
  }

  var SwiftProtoTesting_Names_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_HTTP_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_HTTP_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP_request)
  }

  var SwiftProtoTesting_Names_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_HTTP`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_HTTP`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTP)
  }

  var SwiftProtoTesting_Names_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HTTPS`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HTTPS`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS)
  }

  var SwiftProtoTesting_Names_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HTTPS_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HTTPS_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HTTPS_request)
  }

  var SwiftProtoTesting_Names_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS_request) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS_request, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_HTTPS_request`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS_request)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_HTTPS_request`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS_request)
  }

  var SwiftProtoTesting_Names_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_HTTPS`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_HTTPS`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_HTTPS)
  }

  var SwiftProtoTesting_Names_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_URL`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_URL`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL)
  }

  var SwiftProtoTesting_Names_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_URL_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_URL_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_URL_value)
  }

  var SwiftProtoTesting_Names_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL_value) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL_value, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_URL_value`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL_value)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_URL_value`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL_value)
  }

  var SwiftProtoTesting_Names_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_URL`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_URL`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_URL)
  }

  var SwiftProtoTesting_Names_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_ID`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_ID`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID)
  }

  var SwiftProtoTesting_Names_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_ID_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_ID_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_ID_number)
  }

  var SwiftProtoTesting_Names_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_ID_number) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_ID_number, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_the_ID_number`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_ID_number)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_the_ID_number`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_the_ID_number)
  }

  var SwiftProtoTesting_Names_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_ID) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_ID, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_request_ID`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_ID)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_request_ID`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_request_ID)
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase {

  var SwiftProtoTesting_Names_http: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Http) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Http, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_Http`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_http: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Http)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_Http`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_http() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Http)
  }

  var SwiftProtoTesting_Names_httpRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HttpRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HttpRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpRequest)
  }

  var SwiftProtoTesting_Names_theHTTPRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheHttpRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheHttpRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpRequest)
  }

  var SwiftProtoTesting_Names_theHTTP: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttp) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttp, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheHttp`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTP: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttp)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheHttp`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTP() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttp)
  }

  var SwiftProtoTesting_Names_https: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Https) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Https, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_Https`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_https: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Https)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_Https`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_https() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Https)
  }

  var SwiftProtoTesting_Names_httpsRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpsRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpsRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_HttpsRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_httpsRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpsRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_HttpsRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_httpsRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_HttpsRequest)
  }

  var SwiftProtoTesting_Names_theHTTPSRequest: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpsRequest) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpsRequest, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheHttpsRequest`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPSRequest: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpsRequest)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheHttpsRequest`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPSRequest() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttpsRequest)
  }

  var SwiftProtoTesting_Names_theHTTPS: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttps) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttps, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheHttps`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theHTTPS: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttps)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheHttps`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theHTTPS() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheHttps)
  }

  var SwiftProtoTesting_Names_url: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Url) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Url, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_Url`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_url: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Url)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_Url`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_url() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Url)
  }

  var SwiftProtoTesting_Names_urlValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_UrlValue) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_UrlValue, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_UrlValue`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_urlValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_UrlValue)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_UrlValue`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_urlValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_UrlValue)
  }

  var SwiftProtoTesting_Names_theURLValue: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrlValue) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrlValue, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheUrlValue`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURLValue: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrlValue)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheUrlValue`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURLValue() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrlValue)
  }

  var SwiftProtoTesting_Names_theURL: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrl) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrl, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheUrl`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theURL: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrl)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheUrl`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theURL() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheUrl)
  }

  var SwiftProtoTesting_Names_id: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Id) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Id, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_Id`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_id: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Id)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_Id`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_id() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_Id)
  }

  var SwiftProtoTesting_Names_idNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_IdNumber) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_IdNumber, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_IdNumber`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_idNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_IdNumber)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_IdNumber`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_idNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_IdNumber)
  }

  var SwiftProtoTesting_Names_theIDNumber: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheIdNumber) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheIdNumber, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_TheIdNumber`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_theIDNumber: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheIdNumber)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_TheIdNumber`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_theIDNumber() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_TheIdNumber)
  }

  var SwiftProtoTesting_Names_requestID: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_Extensions_RequestId) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_Extensions_RequestId, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_Extensions_RequestId`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_requestID: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_Extensions_RequestId)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_Extensions_RequestId`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_requestID() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_Extensions_RequestId)
  }
}

extension SwiftProtoTesting_Names_Foo {

  var SwiftProtoTesting_Names_FieldNames_foo1: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_FieldNames.Extensions.foo1) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_FieldNames.Extensions.foo1, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_FieldNames.Extensions.foo1`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_FieldNames_foo1: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_FieldNames.Extensions.foo1)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_FieldNames.Extensions.foo1`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_FieldNames_foo1() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_FieldNames.Extensions.foo1)
  }

  var SwiftProtoTesting_Names_MessageNames_foo2: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo2) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo2, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_MessageNames.Extensions.foo2`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_MessageNames_foo2: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo2)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_MessageNames.Extensions.foo2`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_MessageNames_foo2() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo2)
  }

  var SwiftProtoTesting_Names_MessageNames_foo4: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo4) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo4, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_MessageNames.Extensions.foo4`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_MessageNames_foo4: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo4)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_MessageNames.Extensions.foo4`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_MessageNames_foo4() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.Extensions.foo4)
  }

  var SwiftProtoTesting_Names_MessageNames_StringMessage_foo3: Int32 {
    get {return getExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3) ?? 0}
    set {setExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3, value: newValue)}
  }
  /// Returns true if extension `SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3`
  /// has been explicitly set.
  var hasSwiftProtoTesting_Names_MessageNames_StringMessage_foo3: Boolean {
    return hasExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3)
  }
  /// Clears the value of extension `SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3`.
  /// Subsequent reads from it will return its default value.
  mutating fn clearSwiftProtoTesting_Names_MessageNames_StringMessage_foo3() {
    clearExtensionValue(ext: SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3)
  }

}

// MARK: - File's ExtensionMap: SwiftProtoTesting_Names_UnittestSwiftNaming_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
immutable SwiftProtoTesting_Names_UnittestSwiftNaming_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  SwiftProtoTesting_Names_Extensions_http,
  SwiftProtoTesting_Names_Extensions_http_request,
  SwiftProtoTesting_Names_Extensions_the_http_request,
  SwiftProtoTesting_Names_Extensions_the_http,
  SwiftProtoTesting_Names_Extensions_https,
  SwiftProtoTesting_Names_Extensions_https_request,
  SwiftProtoTesting_Names_Extensions_the_https_request,
  SwiftProtoTesting_Names_Extensions_the_https,
  SwiftProtoTesting_Names_Extensions_url,
  SwiftProtoTesting_Names_Extensions_url_value,
  SwiftProtoTesting_Names_Extensions_the_url_value,
  SwiftProtoTesting_Names_Extensions_the_url,
  SwiftProtoTesting_Names_Extensions_a_b_c,
  SwiftProtoTesting_Names_Extensions_id,
  SwiftProtoTesting_Names_Extensions_id_number,
  SwiftProtoTesting_Names_Extensions_the_id_number,
  SwiftProtoTesting_Names_Extensions_request_id,
  SwiftProtoTesting_Names_Extensions_HTTP,
  SwiftProtoTesting_Names_Extensions_HTTP_request,
  SwiftProtoTesting_Names_Extensions_the_HTTP_request,
  SwiftProtoTesting_Names_Extensions_the_HTTP,
  SwiftProtoTesting_Names_Extensions_HTTPS,
  SwiftProtoTesting_Names_Extensions_HTTPS_request,
  SwiftProtoTesting_Names_Extensions_the_HTTPS_request,
  SwiftProtoTesting_Names_Extensions_the_HTTPS,
  SwiftProtoTesting_Names_Extensions_URL,
  SwiftProtoTesting_Names_Extensions_URL_value,
  SwiftProtoTesting_Names_Extensions_the_URL_value,
  SwiftProtoTesting_Names_Extensions_the_URL,
  SwiftProtoTesting_Names_Extensions_ID,
  SwiftProtoTesting_Names_Extensions_ID_number,
  SwiftProtoTesting_Names_Extensions_the_ID_number,
  SwiftProtoTesting_Names_Extensions_request_ID,
  SwiftProtoTesting_Names_Extensions_Http,
  SwiftProtoTesting_Names_Extensions_HttpRequest,
  SwiftProtoTesting_Names_Extensions_TheHttpRequest,
  SwiftProtoTesting_Names_Extensions_TheHttp,
  SwiftProtoTesting_Names_Extensions_Https,
  SwiftProtoTesting_Names_Extensions_HttpsRequest,
  SwiftProtoTesting_Names_Extensions_TheHttpsRequest,
  SwiftProtoTesting_Names_Extensions_TheHttps,
  SwiftProtoTesting_Names_Extensions_Url,
  SwiftProtoTesting_Names_Extensions_UrlValue,
  SwiftProtoTesting_Names_Extensions_TheUrlValue,
  SwiftProtoTesting_Names_Extensions_TheUrl,
  SwiftProtoTesting_Names_Extensions_Id,
  SwiftProtoTesting_Names_Extensions_IdNumber,
  SwiftProtoTesting_Names_Extensions_TheIdNumber,
  SwiftProtoTesting_Names_Extensions_RequestId,
  SwiftProtoTesting_Names_FieldNames.Extensions.foo1,
  SwiftProtoTesting_Names_MessageNames.Extensions.foo2,
  SwiftProtoTesting_Names_MessageNames.Extensions.foo4,
  SwiftProtoTesting_Names_MessageNames.StringMessage.Extensions.foo3,
  SwiftProtoTesting_Names_Lowers.Extensions.http,
  SwiftProtoTesting_Names_Lowers.Extensions.http_request,
  SwiftProtoTesting_Names_Lowers.Extensions.the_http_request,
  SwiftProtoTesting_Names_Lowers.Extensions.the_http,
  SwiftProtoTesting_Names_Lowers.Extensions.https,
  SwiftProtoTesting_Names_Lowers.Extensions.https_request,
  SwiftProtoTesting_Names_Lowers.Extensions.the_https_request,
  SwiftProtoTesting_Names_Lowers.Extensions.the_https,
  SwiftProtoTesting_Names_Lowers.Extensions.url,
  SwiftProtoTesting_Names_Lowers.Extensions.url_value,
  SwiftProtoTesting_Names_Lowers.Extensions.the_url_value,
  SwiftProtoTesting_Names_Lowers.Extensions.the_url,
  SwiftProtoTesting_Names_Lowers.Extensions.a_b_c,
  SwiftProtoTesting_Names_Lowers.Extensions.id,
  SwiftProtoTesting_Names_Lowers.Extensions.id_number,
  SwiftProtoTesting_Names_Lowers.Extensions.the_id_number,
  SwiftProtoTesting_Names_Lowers.Extensions.request_id,
  SwiftProtoTesting_Names_Uppers.Extensions.HTTP,
  SwiftProtoTesting_Names_Uppers.Extensions.HTTP_request,
  SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP_request,
  SwiftProtoTesting_Names_Uppers.Extensions.the_HTTP,
  SwiftProtoTesting_Names_Uppers.Extensions.HTTPS,
  SwiftProtoTesting_Names_Uppers.Extensions.HTTPS_request,
  SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS_request,
  SwiftProtoTesting_Names_Uppers.Extensions.the_HTTPS,
  SwiftProtoTesting_Names_Uppers.Extensions.URL,
  SwiftProtoTesting_Names_Uppers.Extensions.URL_value,
  SwiftProtoTesting_Names_Uppers.Extensions.the_URL_value,
  SwiftProtoTesting_Names_Uppers.Extensions.the_URL,
  SwiftProtoTesting_Names_Uppers.Extensions.ID,
  SwiftProtoTesting_Names_Uppers.Extensions.ID_number,
  SwiftProtoTesting_Names_Uppers.Extensions.the_ID_number,
  SwiftProtoTesting_Names_Uppers.Extensions.request_ID,
  SwiftProtoTesting_Names_WordCase.Extensions.Http,
  SwiftProtoTesting_Names_WordCase.Extensions.HttpRequest,
  SwiftProtoTesting_Names_WordCase.Extensions.TheHttpRequest,
  SwiftProtoTesting_Names_WordCase.Extensions.TheHttp,
  SwiftProtoTesting_Names_WordCase.Extensions.Https,
  SwiftProtoTesting_Names_WordCase.Extensions.HttpsRequest,
  SwiftProtoTesting_Names_WordCase.Extensions.TheHttpsRequest,
  SwiftProtoTesting_Names_WordCase.Extensions.TheHttps,
  SwiftProtoTesting_Names_WordCase.Extensions.Url,
  SwiftProtoTesting_Names_WordCase.Extensions.UrlValue,
  SwiftProtoTesting_Names_WordCase.Extensions.TheUrlValue,
  SwiftProtoTesting_Names_WordCase.Extensions.TheUrl,
  SwiftProtoTesting_Names_WordCase.Extensions.Id,
  SwiftProtoTesting_Names_WordCase.Extensions.IdNumber,
  SwiftProtoTesting_Names_WordCase.Extensions.TheIdNumber,
  SwiftProtoTesting_Names_WordCase.Extensions.RequestId
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

immutable SwiftProtoTesting_Names_Extensions_http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 1,
  fieldName: "swift_proto_testing.names.http"
)

immutable SwiftProtoTesting_Names_Extensions_http_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 2,
  fieldName: "swift_proto_testing.names.http_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_http_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 3,
  fieldName: "swift_proto_testing.names.the_http_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 4,
  fieldName: "swift_proto_testing.names.the_http"
)

immutable SwiftProtoTesting_Names_Extensions_https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 11,
  fieldName: "swift_proto_testing.names.https"
)

immutable SwiftProtoTesting_Names_Extensions_https_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 12,
  fieldName: "swift_proto_testing.names.https_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_https_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 13,
  fieldName: "swift_proto_testing.names.the_https_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 14,
  fieldName: "swift_proto_testing.names.the_https"
)

immutable SwiftProtoTesting_Names_Extensions_url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 21,
  fieldName: "swift_proto_testing.names.url"
)

immutable SwiftProtoTesting_Names_Extensions_url_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 22,
  fieldName: "swift_proto_testing.names.url_value"
)

immutable SwiftProtoTesting_Names_Extensions_the_url_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 23,
  fieldName: "swift_proto_testing.names.the_url_value"
)

immutable SwiftProtoTesting_Names_Extensions_the_url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 24,
  fieldName: "swift_proto_testing.names.the_url"
)

immutable SwiftProtoTesting_Names_Extensions_a_b_c = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 31,
  fieldName: "swift_proto_testing.names.a_b_c"
)

immutable SwiftProtoTesting_Names_Extensions_id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 41,
  fieldName: "swift_proto_testing.names.id"
)

immutable SwiftProtoTesting_Names_Extensions_id_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 42,
  fieldName: "swift_proto_testing.names.id_number"
)

immutable SwiftProtoTesting_Names_Extensions_the_id_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 43,
  fieldName: "swift_proto_testing.names.the_id_number"
)

immutable SwiftProtoTesting_Names_Extensions_request_id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsLowers>(
  _protobuf_fieldNumber: 44,
  fieldName: "swift_proto_testing.names.request_id"
)

immutable SwiftProtoTesting_Names_Extensions_HTTP = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 1,
  fieldName: "swift_proto_testing.names.HTTP"
)

immutable SwiftProtoTesting_Names_Extensions_HTTP_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 2,
  fieldName: "swift_proto_testing.names.HTTP_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_HTTP_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 3,
  fieldName: "swift_proto_testing.names.the_HTTP_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_HTTP = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 4,
  fieldName: "swift_proto_testing.names.the_HTTP"
)

immutable SwiftProtoTesting_Names_Extensions_HTTPS = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 11,
  fieldName: "swift_proto_testing.names.HTTPS"
)

immutable SwiftProtoTesting_Names_Extensions_HTTPS_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 12,
  fieldName: "swift_proto_testing.names.HTTPS_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_HTTPS_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 13,
  fieldName: "swift_proto_testing.names.the_HTTPS_request"
)

immutable SwiftProtoTesting_Names_Extensions_the_HTTPS = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 14,
  fieldName: "swift_proto_testing.names.the_HTTPS"
)

immutable SwiftProtoTesting_Names_Extensions_URL = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 21,
  fieldName: "swift_proto_testing.names.URL"
)

immutable SwiftProtoTesting_Names_Extensions_URL_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 22,
  fieldName: "swift_proto_testing.names.URL_value"
)

immutable SwiftProtoTesting_Names_Extensions_the_URL_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 23,
  fieldName: "swift_proto_testing.names.the_URL_value"
)

immutable SwiftProtoTesting_Names_Extensions_the_URL = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 24,
  fieldName: "swift_proto_testing.names.the_URL"
)

immutable SwiftProtoTesting_Names_Extensions_ID = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 41,
  fieldName: "swift_proto_testing.names.ID"
)

immutable SwiftProtoTesting_Names_Extensions_ID_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 42,
  fieldName: "swift_proto_testing.names.ID_number"
)

immutable SwiftProtoTesting_Names_Extensions_the_ID_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 43,
  fieldName: "swift_proto_testing.names.the_ID_number"
)

immutable SwiftProtoTesting_Names_Extensions_request_ID = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsUppers>(
  _protobuf_fieldNumber: 44,
  fieldName: "swift_proto_testing.names.request_ID"
)

immutable SwiftProtoTesting_Names_Extensions_Http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 1,
  fieldName: "swift_proto_testing.names.Http"
)

immutable SwiftProtoTesting_Names_Extensions_HttpRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 2,
  fieldName: "swift_proto_testing.names.HttpRequest"
)

immutable SwiftProtoTesting_Names_Extensions_TheHttpRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 3,
  fieldName: "swift_proto_testing.names.TheHttpRequest"
)

immutable SwiftProtoTesting_Names_Extensions_TheHttp = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 4,
  fieldName: "swift_proto_testing.names.TheHttp"
)

immutable SwiftProtoTesting_Names_Extensions_Https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 11,
  fieldName: "swift_proto_testing.names.Https"
)

immutable SwiftProtoTesting_Names_Extensions_HttpsRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 12,
  fieldName: "swift_proto_testing.names.HttpsRequest"
)

immutable SwiftProtoTesting_Names_Extensions_TheHttpsRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 13,
  fieldName: "swift_proto_testing.names.TheHttpsRequest"
)

immutable SwiftProtoTesting_Names_Extensions_TheHttps = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 14,
  fieldName: "swift_proto_testing.names.TheHttps"
)

immutable SwiftProtoTesting_Names_Extensions_Url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 21,
  fieldName: "swift_proto_testing.names.Url"
)

immutable SwiftProtoTesting_Names_Extensions_UrlValue = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 22,
  fieldName: "swift_proto_testing.names.UrlValue"
)

immutable SwiftProtoTesting_Names_Extensions_TheUrlValue = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 23,
  fieldName: "swift_proto_testing.names.TheUrlValue"
)

immutable SwiftProtoTesting_Names_Extensions_TheUrl = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 24,
  fieldName: "swift_proto_testing.names.TheUrl"
)

immutable SwiftProtoTesting_Names_Extensions_Id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 41,
  fieldName: "swift_proto_testing.names.Id"
)

immutable SwiftProtoTesting_Names_Extensions_IdNumber = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 42,
  fieldName: "swift_proto_testing.names.IdNumber"
)

immutable SwiftProtoTesting_Names_Extensions_TheIdNumber = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 43,
  fieldName: "swift_proto_testing.names.TheIdNumber"
)

immutable SwiftProtoTesting_Names_Extensions_RequestId = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase>(
  _protobuf_fieldNumber: 44,
  fieldName: "swift_proto_testing.names.RequestId"
)

extension SwiftProtoTesting_Names_FieldNames {
  enum Extensions {
    static immutable foo1 = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_Foo>(
      _protobuf_fieldNumber: 1,
      fieldName: "swift_proto_testing.names.FieldNames.foo1"
    )
  }
}

extension SwiftProtoTesting_Names_MessageNames {
  enum Extensions {
    static immutable foo2 = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_Foo>(
      _protobuf_fieldNumber: 2,
      fieldName: "swift_proto_testing.names.MessageNames.foo2"
    )

    static immutable foo4 = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_Foo>(
      _protobuf_fieldNumber: 4,
      fieldName: "swift_proto_testing.names.MessageNames.foo4"
    )
  }
}

extension SwiftProtoTesting_Names_MessageNames.StringMessage {
  enum Extensions {
    static immutable foo3 = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_Foo>(
      _protobuf_fieldNumber: 3,
      fieldName: "swift_proto_testing.names.MessageNames.String.foo3"
    )
  }
}

extension SwiftProtoTesting_Names_Lowers {
  enum Extensions {
    static immutable http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 1,
      fieldName: "swift_proto_testing.names.Lowers.http"
    )

    static immutable http_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 2,
      fieldName: "swift_proto_testing.names.Lowers.http_request"
    )

    static immutable the_http_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 3,
      fieldName: "swift_proto_testing.names.Lowers.the_http_request"
    )

    static immutable the_http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 4,
      fieldName: "swift_proto_testing.names.Lowers.the_http"
    )

    static immutable https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 11,
      fieldName: "swift_proto_testing.names.Lowers.https"
    )

    static immutable https_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 12,
      fieldName: "swift_proto_testing.names.Lowers.https_request"
    )

    static immutable the_https_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 13,
      fieldName: "swift_proto_testing.names.Lowers.the_https_request"
    )

    static immutable the_https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 14,
      fieldName: "swift_proto_testing.names.Lowers.the_https"
    )

    static immutable url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 21,
      fieldName: "swift_proto_testing.names.Lowers.url"
    )

    static immutable url_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 22,
      fieldName: "swift_proto_testing.names.Lowers.url_value"
    )

    static immutable the_url_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 23,
      fieldName: "swift_proto_testing.names.Lowers.the_url_value"
    )

    static immutable the_url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 24,
      fieldName: "swift_proto_testing.names.Lowers.the_url"
    )

    static immutable a_b_c = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 31,
      fieldName: "swift_proto_testing.names.Lowers.a_b_c"
    )

    static immutable id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 41,
      fieldName: "swift_proto_testing.names.Lowers.id"
    )

    static immutable id_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 42,
      fieldName: "swift_proto_testing.names.Lowers.id_number"
    )

    static immutable the_id_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 43,
      fieldName: "swift_proto_testing.names.Lowers.the_id_number"
    )

    static immutable request_id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 44,
      fieldName: "swift_proto_testing.names.Lowers.request_id"
    )
  }
}

extension SwiftProtoTesting_Names_Uppers {
  enum Extensions {
    static immutable HTTP = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 101,
      fieldName: "swift_proto_testing.names.Uppers.HTTP"
    )

    static immutable HTTP_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 102,
      fieldName: "swift_proto_testing.names.Uppers.HTTP_request"
    )

    static immutable the_HTTP_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 103,
      fieldName: "swift_proto_testing.names.Uppers.the_HTTP_request"
    )

    static immutable the_HTTP = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 104,
      fieldName: "swift_proto_testing.names.Uppers.the_HTTP"
    )

    static immutable HTTPS = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 111,
      fieldName: "swift_proto_testing.names.Uppers.HTTPS"
    )

    static immutable HTTPS_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 112,
      fieldName: "swift_proto_testing.names.Uppers.HTTPS_request"
    )

    static immutable the_HTTPS_request = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 113,
      fieldName: "swift_proto_testing.names.Uppers.the_HTTPS_request"
    )

    static immutable the_HTTPS = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 114,
      fieldName: "swift_proto_testing.names.Uppers.the_HTTPS"
    )

    static immutable URL = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 121,
      fieldName: "swift_proto_testing.names.Uppers.URL"
    )

    static immutable URL_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 122,
      fieldName: "swift_proto_testing.names.Uppers.URL_value"
    )

    static immutable the_URL_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 123,
      fieldName: "swift_proto_testing.names.Uppers.the_URL_value"
    )

    static immutable the_URL = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 124,
      fieldName: "swift_proto_testing.names.Uppers.the_URL"
    )

    static immutable ID = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 141,
      fieldName: "swift_proto_testing.names.Uppers.ID"
    )

    static immutable ID_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 142,
      fieldName: "swift_proto_testing.names.Uppers.ID_number"
    )

    static immutable the_ID_number = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 143,
      fieldName: "swift_proto_testing.names.Uppers.the_ID_number"
    )

    static immutable request_ID = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 144,
      fieldName: "swift_proto_testing.names.Uppers.request_ID"
    )
  }
}

extension SwiftProtoTesting_Names_WordCase {
  enum Extensions {
    static immutable Http = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 201,
      fieldName: "swift_proto_testing.names.WordCase.Http"
    )

    static immutable HttpRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 202,
      fieldName: "swift_proto_testing.names.WordCase.HttpRequest"
    )

    static immutable TheHttpRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 203,
      fieldName: "swift_proto_testing.names.WordCase.TheHttpRequest"
    )

    static immutable TheHttp = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 204,
      fieldName: "swift_proto_testing.names.WordCase.TheHttp"
    )

    static immutable Https = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 211,
      fieldName: "swift_proto_testing.names.WordCase.Https"
    )

    static immutable HttpsRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 212,
      fieldName: "swift_proto_testing.names.WordCase.HttpsRequest"
    )

    static immutable TheHttpsRequest = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 213,
      fieldName: "swift_proto_testing.names.WordCase.TheHttpsRequest"
    )

    static immutable TheHttps = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 214,
      fieldName: "swift_proto_testing.names.WordCase.TheHttps"
    )

    static immutable Url = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 221,
      fieldName: "swift_proto_testing.names.WordCase.Url"
    )

    static immutable UrlValue = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 222,
      fieldName: "swift_proto_testing.names.WordCase.UrlValue"
    )

    static immutable TheUrlValue = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 223,
      fieldName: "swift_proto_testing.names.WordCase.TheUrlValue"
    )

    static immutable TheUrl = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 224,
      fieldName: "swift_proto_testing.names.WordCase.TheUrl"
    )

    static immutable Id = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 241,
      fieldName: "swift_proto_testing.names.WordCase.Id"
    )

    static immutable IdNumber = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 242,
      fieldName: "swift_proto_testing.names.WordCase.IdNumber"
    )

    static immutable TheIdNumber = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 243,
      fieldName: "swift_proto_testing.names.WordCase.TheIdNumber"
    )

    static immutable RequestId = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufInt32>, SwiftProtoTesting_Names_ExtensionNamingInitials>(
      _protobuf_fieldNumber: 244,
      fieldName: "swift_proto_testing.names.WordCase.RequestId"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate immutable _protobuf_package = "swift_proto_testing.names"

extension SwiftProtoTesting_Names_EnumFieldNames: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "A"),
    1: .same(proto: "String"),
    2: .same(proto: "Integer"),
    3: .same(proto: "Double"),
    4: .same(proto: "Float"),
    5: .same(proto: "UInt"),
    6: .same(proto: "hashValue"),
    7: .same(proto: "description"),
    8: .same(proto: "debugDescription"),
    9: .same(proto: "Swift"),
    10: .same(proto: "UNRECOGNIZED"),
    11: .same(proto: "class"),
    12: .same(proto: "deinit"),
    13: .same(proto: "enum"),
    14: .same(proto: "extension"),
    15: .same(proto: "fn"),
    16: .same(proto: "import"),
    17: .same(proto: "init"),
    18: .same(proto: "inout"),
    19: .same(proto: "internal"),
    20: .same(proto: "immutable"),
    21: .same(proto: "operator"),
    22: .same(proto: "private"),
    23: .same(proto: "protocol"),
    24: .same(proto: "public"),
    25: .same(proto: "static"),
    26: .same(proto: "struct"),
    27: .same(proto: "subscript"),
    28: .same(proto: "typealias"),
    29: .same(proto: "var"),
    30: .same(proto: "break"),
    31: .same(proto: "case"),
    32: .same(proto: "continue"),
    33: .same(proto: "default"),
    34: .same(proto: "defer"),
    35: .same(proto: "do"),
    36: .same(proto: "else"),
    37: .same(proto: "fallthrough"),
    38: .same(proto: "for"),
    39: .same(proto: "guard"),
    40: .same(proto: "if"),
    41: .same(proto: "in"),
    42: .same(proto: "repeat"),
    43: .same(proto: "return"),
    44: .same(proto: "switch"),
    45: .same(proto: "where"),
    46: .same(proto: "while"),
    47: .same(proto: "as"),
    48: .same(proto: "catch"),
    49: .same(proto: "dynamicType"),
    50: .same(proto: "false"),
    51: .same(proto: "is"),
    52: .same(proto: "Nothing"),
    53: .same(proto: "rethrows"),
    54: .same(proto: "super"),
    55: .same(proto: "this"),
    57: .same(proto: "throw"),
    58: .same(proto: "throws"),
    59: .same(proto: "true"),
    60: .same(proto: "try"),
    61: .same(proto: "__COLUMN__"),
    62: .same(proto: "__FILE__"),
    63: .same(proto: "__FUNCTION__"),
    64: .same(proto: "__LINE__"),
    65: .same(proto: "_"),
    66: .same(proto: "associativity"),
    67: .same(proto: "convenience"),
    68: .same(proto: "dynamic"),
    69: .same(proto: "didSet"),
    70: .same(proto: "final"),
    71: .same(proto: "get"),
    72: .same(proto: "infix"),
    73: .same(proto: "indirect"),
    74: .same(proto: "lazy"),
    75: .same(proto: "left"),
    76: .same(proto: "mutating"),
    77: .same(proto: "none"),
    78: .same(proto: "nonmutating"),
    79: .same(proto: "optional"),
    80: .same(proto: "override"),
    81: .same(proto: "postfix"),
    82: .same(proto: "precedence"),
    83: .same(proto: "prefix"),
    85: .same(proto: "required"),
    86: .same(proto: "right"),
    87: .same(proto: "set"),
    88: .same(proto: "Type"),
    89: .same(proto: "unowned"),
    90: .same(proto: "weak"),
    91: .same(proto: "willSet"),
    93: .same(proto: "_cmd"),
    96: .same(proto: "out"),
    98: .same(proto: "bycopy"),
    99: .same(proto: "byref"),
    100: .same(proto: "oneway"),
    102: .same(proto: "and"),
    103: .same(proto: "and_eq"),
    104: .same(proto: "alignas"),
    105: .same(proto: "alignof"),
    106: .same(proto: "asm"),
    107: .same(proto: "auto"),
    108: .same(proto: "bitand"),
    109: .same(proto: "bitor"),
    110: .same(proto: "bool"),
    114: .same(proto: "char"),
    115: .same(proto: "char16_t"),
    116: .same(proto: "char32_t"),
    118: .same(proto: "compl"),
    119: .same(proto: "const"),
    120: .same(proto: "constexpr"),
    121: .same(proto: "const_cast"),
    123: .same(proto: "decltype"),
    125: .same(proto: "deimmutablee"),
    127: .same(proto: "dynamic_cast"),
    130: .same(proto: "explicit"),
    131: .same(proto: "export"),
    132: .same(proto: "extern"),
    136: .same(proto: "friend"),
    137: .same(proto: "goto"),
    139: .same(proto: "inline"),
    141: .same(proto: "long"),
    142: .same(proto: "mutable"),
    143: .same(proto: "namespace"),
    144: .same(proto: "new"),
    145: .same(proto: "noexcept"),
    146: .same(proto: "not"),
    147: .same(proto: "not_eq"),
    148: .same(proto: "nullptr"),
    150: .same(proto: "or"),
    151: .same(proto: "or_eq"),
    153: .same(proto: "protected"),
    155: .same(proto: "register"),
    156: .same(proto: "reinterpret_cast"),
    158: .same(proto: "short"),
    159: .same(proto: "signed"),
    160: .same(proto: "sizeof"),
    162: .same(proto: "static_assert"),
    163: .same(proto: "static_cast"),
    166: .same(proto: "template"),
    167: .same(proto: "this"),
    168: .same(proto: "thread_local"),
    172: .same(proto: "typedef"),
    173: .same(proto: "typeid"),
    174: .same(proto: "typename"),
    175: .same(proto: "union"),
    176: .same(proto: "unsigned"),
    177: .same(proto: "using"),
    178: .same(proto: "virtual"),
    179: .same(proto: "void"),
    180: .same(proto: "volatile"),
    181: .same(proto: "wchar_t"),
    183: .same(proto: "xor"),
    184: .same(proto: "xor_eq"),
    185: .same(proto: "restrict"),
    186: .same(proto: "Category"),
    187: .same(proto: "Ivar"),
    188: .same(proto: "Method"),
    192: .same(proto: "finalize"),
    193: .same(proto: "hash"),
    194: .same(proto: "dealloc"),
    197: .same(proto: "superclass"),
    198: .same(proto: "retain"),
    199: .same(proto: "release"),
    200: .same(proto: "autorelease"),
    201: .same(proto: "retainCount"),
    202: .same(proto: "zone"),
    203: .same(proto: "isProxy"),
    204: .same(proto: "copy"),
    205: .same(proto: "mutableCopy"),
    206: .same(proto: "classForCoder"),
    207: .same(proto: "clear"),
    208: .same(proto: "data"),
    209: .same(proto: "delimitedData"),
    210: .same(proto: "descriptor"),
    211: .same(proto: "extensionRegistry"),
    212: .same(proto: "extensionsCurrentlySet"),
    213: .same(proto: "isInitialized"),
    214: .same(proto: "serializedSize"),
    215: .same(proto: "sortedExtensionsInUse"),
    216: .same(proto: "unknownFields"),
    217: .same(proto: "Fixed"),
    218: .same(proto: "Fract"),
    219: .same(proto: "Size"),
    220: .same(proto: "LogicalAddress"),
    221: .same(proto: "PhysicalAddress"),
    222: .same(proto: "ByteCount"),
    223: .same(proto: "ByteOffset"),
    224: .same(proto: "Duration"),
    225: .same(proto: "AbsoluteTime"),
    226: .same(proto: "OptionBits"),
    227: .same(proto: "ItemCount"),
    228: .same(proto: "PBVersion"),
    229: .same(proto: "ScriptCode"),
    230: .same(proto: "LangCode"),
    231: .same(proto: "RegionCode"),
    232: .same(proto: "OSType"),
    233: .same(proto: "ProcessSerialNumber"),
    234: .same(proto: "Point"),
    235: .same(proto: "Rect"),
    236: .same(proto: "FixedPoint"),
    237: .same(proto: "FixedRect"),
    238: .same(proto: "Style"),
    239: .same(proto: "StyleParameter"),
    240: .same(proto: "StyleField"),
    241: .same(proto: "TimeScale"),
    242: .same(proto: "TimeBase"),
    243: .same(proto: "TimeRecord"),
    244: .same(proto: "Extensions"),
  ]
}

extension SwiftProtoTesting_Names_EnumFieldNames2: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AA"),
    1065: .same(proto: "__"),
  ]
}

extension SwiftProtoTesting_Names_Foo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".Foo"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Boolean {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      if (1 <= fieldNumber && fieldNumber < 5001) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: SwiftProtoTesting_Names_Foo.this, fieldNumber: fieldNumber)
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1, end: 5001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_Foo, rhs: SwiftProtoTesting_Names_Foo) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_FieldNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".FieldNames"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "String"),
    2: .same(proto: "Integer"),
    3: .same(proto: "Double"),
    4: .same(proto: "Float"),
    5: .same(proto: "UInt"),
    6: .same(proto: "hashValue"),
    7: .same(proto: "description"),
    8: .same(proto: "debugDescription"),
    9: .same(proto: "Swift"),
    10: .same(proto: "UNRECOGNIZED"),
    11: .same(proto: "class"),
    12: .same(proto: "deinit"),
    13: .same(proto: "enum"),
    15: .same(proto: "fn"),
    16: .same(proto: "import"),
    17: .same(proto: "init"),
    18: .same(proto: "inout"),
    19: .same(proto: "internal"),
    20: .same(proto: "immutable"),
    21: .same(proto: "operator"),
    22: .same(proto: "private"),
    23: .same(proto: "protocol"),
    24: .same(proto: "public"),
    25: .same(proto: "static"),
    26: .same(proto: "struct"),
    27: .same(proto: "subscript"),
    28: .same(proto: "typealias"),
    29: .same(proto: "var"),
    30: .same(proto: "break"),
    31: .same(proto: "case"),
    32: .same(proto: "continue"),
    33: .same(proto: "default"),
    34: .same(proto: "defer"),
    35: .same(proto: "do"),
    36: .same(proto: "else"),
    37: .same(proto: "fallthrough"),
    38: .same(proto: "for"),
    39: .same(proto: "guard"),
    40: .same(proto: "if"),
    41: .same(proto: "in"),
    42: .same(proto: "repeat"),
    43: .same(proto: "return"),
    44: .same(proto: "switch"),
    45: .same(proto: "where"),
    46: .same(proto: "while"),
    47: .same(proto: "as"),
    48: .same(proto: "catch"),
    49: .same(proto: "dynamicType"),
    50: .same(proto: "false"),
    51: .same(proto: "is"),
    52: .same(proto: "Nothing"),
    53: .same(proto: "rethrows"),
    54: .same(proto: "super"),
    55: .same(proto: "this"),
    57: .same(proto: "throw"),
    58: .same(proto: "throws"),
    59: .same(proto: "true"),
    60: .same(proto: "try"),
    61: .standard(proto: "__COLUMN__"),
    62: .standard(proto: "__FILE__"),
    63: .standard(proto: "__FUNCTION__"),
    64: .standard(proto: "__LINE__"),
    65: .standard(proto: "_"),
    66: .same(proto: "associativity"),
    67: .same(proto: "convenience"),
    68: .same(proto: "dynamic"),
    69: .same(proto: "didSet"),
    70: .same(proto: "final"),
    71: .same(proto: "get"),
    72: .same(proto: "infix"),
    73: .same(proto: "indirect"),
    74: .same(proto: "lazy"),
    75: .same(proto: "left"),
    76: .same(proto: "mutating"),
    77: .same(proto: "none"),
    78: .same(proto: "nonmutating"),
    79: .same(proto: "optional"),
    80: .same(proto: "override"),
    81: .same(proto: "postfix"),
    82: .same(proto: "precedence"),
    83: .same(proto: "prefix"),
    85: .same(proto: "required"),
    86: .same(proto: "right"),
    87: .same(proto: "set"),
    88: .same(proto: "Type"),
    89: .same(proto: "unowned"),
    90: .same(proto: "weak"),
    91: .same(proto: "willSet"),
    92: .same(proto: "id"),
    93: .standard(proto: "_cmd"),
    96: .same(proto: "out"),
    98: .same(proto: "bycopy"),
    99: .same(proto: "byref"),
    100: .same(proto: "oneway"),
    102: .same(proto: "and"),
    103: .standard(proto: "and_eq"),
    104: .same(proto: "alignas"),
    105: .same(proto: "alignof"),
    106: .same(proto: "asm"),
    107: .same(proto: "auto"),
    108: .same(proto: "bitand"),
    109: .same(proto: "bitor"),
    110: .same(proto: "bool"),
    114: .same(proto: "char"),
    115: .standard(proto: "char16_t"),
    116: .standard(proto: "char32_t"),
    118: .same(proto: "compl"),
    119: .same(proto: "const"),
    120: .same(proto: "constexpr"),
    121: .standard(proto: "const_cast"),
    123: .same(proto: "decltype"),
    125: .same(proto: "deimmutablee"),
    127: .standard(proto: "dynamic_cast"),
    130: .same(proto: "explicit"),
    131: .same(proto: "export"),
    132: .same(proto: "extern"),
    136: .same(proto: "friend"),
    137: .same(proto: "goto"),
    139: .same(proto: "inline"),
    141: .same(proto: "long"),
    142: .same(proto: "mutable"),
    143: .same(proto: "namespace"),
    144: .same(proto: "new"),
    145: .same(proto: "noexcept"),
    146: .same(proto: "not"),
    147: .standard(proto: "not_eq"),
    148: .same(proto: "nullptr"),
    150: .same(proto: "or"),
    151: .standard(proto: "or_eq"),
    153: .same(proto: "protected"),
    155: .same(proto: "register"),
    156: .standard(proto: "reinterpret_cast"),
    158: .same(proto: "short"),
    159: .same(proto: "signed"),
    160: .same(proto: "sizeof"),
    162: .standard(proto: "static_assert"),
    163: .standard(proto: "static_cast"),
    166: .same(proto: "template"),
    167: .same(proto: "this"),
    168: .standard(proto: "thread_local"),
    172: .same(proto: "typedef"),
    173: .same(proto: "typeid"),
    174: .same(proto: "typename"),
    175: .same(proto: "union"),
    176: .same(proto: "unsigned"),
    177: .same(proto: "using"),
    178: .same(proto: "virtual"),
    179: .same(proto: "void"),
    180: .same(proto: "volatile"),
    181: .standard(proto: "wchar_t"),
    183: .same(proto: "xor"),
    184: .standard(proto: "xor_eq"),
    185: .same(proto: "restrict"),
    186: .same(proto: "Category"),
    187: .same(proto: "Ivar"),
    188: .same(proto: "Method"),
    192: .same(proto: "finalize"),
    193: .same(proto: "hash"),
    194: .same(proto: "dealloc"),
    197: .same(proto: "superclass"),
    198: .same(proto: "retain"),
    199: .same(proto: "release"),
    200: .same(proto: "autorelease"),
    201: .same(proto: "retainCount"),
    202: .same(proto: "zone"),
    203: .same(proto: "isProxy"),
    204: .same(proto: "copy"),
    205: .same(proto: "mutableCopy"),
    206: .same(proto: "classForCoder"),
    207: .same(proto: "clear"),
    208: .same(proto: "data"),
    209: .same(proto: "delimitedData"),
    210: .same(proto: "descriptor"),
    211: .same(proto: "extensionRegistry"),
    212: .same(proto: "extensionsCurrentlySet"),
    213: .same(proto: "isInitialized"),
    214: .same(proto: "serializedSize"),
    215: .same(proto: "sortedExtensionsInUse"),
    216: .same(proto: "unknownFields"),
    217: .same(proto: "Fixed"),
    218: .same(proto: "Fract"),
    219: .same(proto: "Size"),
    220: .same(proto: "LogicalAddress"),
    221: .same(proto: "PhysicalAddress"),
    222: .same(proto: "ByteCount"),
    223: .same(proto: "ByteOffset"),
    224: .same(proto: "Duration"),
    225: .same(proto: "AbsoluteTime"),
    226: .same(proto: "OptionBits"),
    227: .same(proto: "ItemCount"),
    228: .same(proto: "PBVersion"),
    229: .same(proto: "ScriptCode"),
    230: .same(proto: "LangCode"),
    231: .same(proto: "RegionCode"),
    232: .same(proto: "OSType"),
    233: .same(proto: "ProcessSerialNumber"),
    234: .same(proto: "Point"),
    235: .same(proto: "Rect"),
    236: .same(proto: "FixedPoint"),
    237: .same(proto: "FixedRect"),
    238: .same(proto: "Style"),
    239: .same(proto: "StyleParameter"),
    240: .same(proto: "StyleField"),
    241: .same(proto: "TimeScale"),
    242: .same(proto: "TimeBase"),
    243: .same(proto: "TimeRecord"),
    244: .unique(proto: "json_should_be_overridden", json: "json_was_overridden"),
    245: .same(proto: "Any"),
    246: .same(proto: "Int32"),
    247: .same(proto: "Int64"),
    250: .same(proto: "UInt32"),
    251: .same(proto: "UInt64"),
    252: .same(proto: "associatedtype"),
    253: .same(proto: "fileprivate"),
    254: .same(proto: "open"),
    255: .same(proto: "serializedData"),
    256: .same(proto: "hasSerializedData"),
    257: .same(proto: "clearSerializedData"),
    258: .same(proto: "jsonUTF8Data"),
    259: .same(proto: "jsonString"),
    260: .same(proto: "Extension"),
    261: .same(proto: "Extensions"),
  ]

  fileprivate class _StorageClass {
    var _string: Int32? = Nothing
    var _int: Int32? = Nothing
    var _double: Int32? = Nothing
    var _float: Int32? = Nothing
    var _uint: Int32? = Nothing
    var _hashValue_p: Int32? = Nothing
    var _description_p: Int32? = Nothing
    var _debugDescription_p: Int32? = Nothing
    var _swift: Int32? = Nothing
    var _unrecognized: Int32? = Nothing
    var _class: Int32? = Nothing
    var _deinit: Int32? = Nothing
    var _enum: Int32? = Nothing
    var _func: Int32? = Nothing
    var _import: Int32? = Nothing
    var _init_p: Int32? = Nothing
    var _inout: Int32? = Nothing
    var _internal: Int32? = Nothing
    var _immutable: Int32? = Nothing
    var _operator: Int32? = Nothing
    var _private: Int32? = Nothing
    var _protocol: Int32? = Nothing
    var _public: Int32? = Nothing
    var _static: Int32? = Nothing
    var _struct: Int32? = Nothing
    var _subscript: Int32? = Nothing
    var _typealias: Int32? = Nothing
    var _var: Int32? = Nothing
    var _break: Int32? = Nothing
    var _case: Int32? = Nothing
    var _continue: Int32? = Nothing
    var _default: Int32? = Nothing
    var _defer: Int32? = Nothing
    var _do: Int32? = Nothing
    var _else: Int32? = Nothing
    var _fallthrough: Int32? = Nothing
    var _for: Int32? = Nothing
    var _guard: Int32? = Nothing
    var _if: Int32? = Nothing
    var _in: Int32? = Nothing
    var _repeat: Int32? = Nothing
    var _return: Int32? = Nothing
    var _switch: Int32? = Nothing
    var _where: Int32? = Nothing
    var _while: Int32? = Nothing
    var _as: Int32? = Nothing
    var _catch: Int32? = Nothing
    var _dynamicType_p: Int32? = Nothing
    var _false: Int32? = Nothing
    var _is: Int32? = Nothing
    var _nil: Int32? = Nothing
    var _rethrows: Int32? = Nothing
    var _super: Int32? = Nothing
    var _self_p: Int32? = Nothing
    var _throw: Int32? = Nothing
    var _throws: Int32? = Nothing
    var _true: Int32? = Nothing
    var _try: Int32? = Nothing
    var __Column__: Int32? = Nothing
    var __File__: Int32? = Nothing
    var __Function__: Int32? = Nothing
    var __Line__: Int32? = Nothing
    var ____: Int32? = Nothing
    var _associativity: Int32? = Nothing
    var _convenience: Int32? = Nothing
    var _dynamic: Int32? = Nothing
    var _didSet: Int32? = Nothing
    var _final: Int32? = Nothing
    var _get: Int32? = Nothing
    var _infix: Int32? = Nothing
    var _indirect: Int32? = Nothing
    var _lazy: Int32? = Nothing
    var _left: Int32? = Nothing
    var _mutating: Int32? = Nothing
    var _none: Int32? = Nothing
    var _nonmutating: Int32? = Nothing
    var _optional: Int32? = Nothing
    var _override: Int32? = Nothing
    var _postfix: Int32? = Nothing
    var _precedence: Int32? = Nothing
    var _prefix: Int32? = Nothing
    var _required: Int32? = Nothing
    var _right: Int32? = Nothing
    var _set: Int32? = Nothing
    var _type: Int32? = Nothing
    var _unowned: Int32? = Nothing
    var _weak: Int32? = Nothing
    var _willSet: Int32? = Nothing
    var _id: Int32? = Nothing
    var _cmd: Int32? = Nothing
    var _out: Int32? = Nothing
    var _bycopy: Int32? = Nothing
    var _byref: Int32? = Nothing
    var _oneway: Int32? = Nothing
    var _and: Int32? = Nothing
    var _andEq: Int32? = Nothing
    var _alignas: Int32? = Nothing
    var _alignof: Int32? = Nothing
    var _asm: Int32? = Nothing
    var _auto: Int32? = Nothing
    var _bitand: Int32? = Nothing
    var _bitor: Int32? = Nothing
    var _bool: Int32? = Nothing
    var _char: Int32? = Nothing
    var _char16T: Int32? = Nothing
    var _char32T: Int32? = Nothing
    var _compl: Int32? = Nothing
    var _const: Int32? = Nothing
    var _constexpr: Int32? = Nothing
    var _constCast: Int32? = Nothing
    var _decltype: Int32? = Nothing
    var _deimmutablee: Int32? = Nothing
    var _dynamicCast: Int32? = Nothing
    var _explicit: Int32? = Nothing
    var _export: Int32? = Nothing
    var _extern: Int32? = Nothing
    var _friend: Int32? = Nothing
    var _goto: Int32? = Nothing
    var _inline: Int32? = Nothing
    var _long: Int32? = Nothing
    var _mutable: Int32? = Nothing
    var _namespace: Int32? = Nothing
    var _new: Int32? = Nothing
    var _noexcept: Int32? = Nothing
    var _not: Int32? = Nothing
    var _notEq: Int32? = Nothing
    var _nullptr: Int32? = Nothing
    var _or: Int32? = Nothing
    var _orEq: Int32? = Nothing
    var _protected: Int32? = Nothing
    var _register: Int32? = Nothing
    var _reinterpretCast: Int32? = Nothing
    var _short: Int32? = Nothing
    var _signed: Int32? = Nothing
    var _sizeof: Int32? = Nothing
    var _staticAssert: Int32? = Nothing
    var _staticCast: Int32? = Nothing
    var _template: Int32? = Nothing
    var _this: Int32? = Nothing
    var _threadLocal: Int32? = Nothing
    var _typedef: Int32? = Nothing
    var _typeid: Int32? = Nothing
    var _typename: Int32? = Nothing
    var _union: Int32? = Nothing
    var _unsigned: Int32? = Nothing
    var _using: Int32? = Nothing
    var _virtual: Int32? = Nothing
    var _void: Int32? = Nothing
    var _volatile: Int32? = Nothing
    var _wcharT: Int32? = Nothing
    var _xor: Int32? = Nothing
    var _xorEq: Int32? = Nothing
    var _restrict: Int32? = Nothing
    var _category: Int32? = Nothing
    var _ivar: Int32? = Nothing
    var _method: Int32? = Nothing
    var _finalize: Int32? = Nothing
    var _hash: Int32? = Nothing
    var _dealloc: Int32? = Nothing
    var _superclass: Int32? = Nothing
    var _retain: Int32? = Nothing
    var _release: Int32? = Nothing
    var _autorelease: Int32? = Nothing
    var _retainCount: Int32? = Nothing
    var _zone: Int32? = Nothing
    var _isProxy: Int32? = Nothing
    var _copy: Int32? = Nothing
    var _mutableCopy: Int32? = Nothing
    var _classForCoder: Int32? = Nothing
    var _clear: Int32? = Nothing
    var _data: Int32? = Nothing
    var _delimitedData: Int32? = Nothing
    var _descriptor: Int32? = Nothing
    var _extensionRegistry: Int32? = Nothing
    var _extensionsCurrentlySet: Int32? = Nothing
    var _isInitialized_p: Int32? = Nothing
    var _serializedSize: Int32? = Nothing
    var _sortedExtensionsInUse: Int32? = Nothing
    var _unknownFields_p: Int32? = Nothing
    var _fixed: Int32? = Nothing
    var _fract: Int32? = Nothing
    var _size: Int32? = Nothing
    var _logicalAddress: Int32? = Nothing
    var _physicalAddress: Int32? = Nothing
    var _byteCount: Int32? = Nothing
    var _byteOffset: Int32? = Nothing
    var _duration: Int32? = Nothing
    var _absoluteTime: Int32? = Nothing
    var _optionBits: Int32? = Nothing
    var _itemCount: Int32? = Nothing
    var _pbversion: Int32? = Nothing
    var _scriptCode: Int32? = Nothing
    var _langCode: Int32? = Nothing
    var _regionCode: Int32? = Nothing
    var _ostype: Int32? = Nothing
    var _processSerialNumber: Int32? = Nothing
    var _point: Int32? = Nothing
    var _rect: Int32? = Nothing
    var _fixedPoint: Int32? = Nothing
    var _fixedRect: Int32? = Nothing
    var _style: Int32? = Nothing
    var _styleParameter: Int32? = Nothing
    var _styleField: Int32? = Nothing
    var _timeScale: Int32? = Nothing
    var _timeBase: Int32? = Nothing
    var _timeRecord: Int32? = Nothing
    var _jsonShouldBeOverridden: Int32? = Nothing
    var _any: Int32? = Nothing
    var _int32: Int32? = Nothing
    var _int64: Int32? = Nothing
    var _uint32: Int32? = Nothing
    var _uint64: Int32? = Nothing
    var _associatedtype: Int32? = Nothing
    var _fileprivate: Int32? = Nothing
    var _open: Int32? = Nothing
    var _serializedData: Int32? = Nothing
    var _hasSerializedData_p: Int32? = Nothing
    var _clearSerializedData_p: Int32? = Nothing
    var _jsonUtf8Data: Int32? = Nothing
    var _jsonString: Int32? = Nothing
    var _extension: Int32? = Nothing
    var _extensions: Int32? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _string = source._string
      _int = source._int
      _double = source._double
      _float = source._float
      _uint = source._uint
      _hashValue_p = source._hashValue_p
      _description_p = source._description_p
      _debugDescription_p = source._debugDescription_p
      _swift = source._swift
      _unrecognized = source._unrecognized
      _class = source._class
      _deinit = source._deinit
      _enum = source._enum
      _func = source._func
      _import = source._import
      _init_p = source._init_p
      _inout = source._inout
      _internal = source._internal
      _immutable = source._immutable
      _operator = source._operator
      _private = source._private
      _protocol = source._protocol
      _public = source._public
      _static = source._static
      _struct = source._struct
      _subscript = source._subscript
      _typealias = source._typealias
      _var = source._var
      _break = source._break
      _case = source._case
      _continue = source._continue
      _default = source._default
      _defer = source._defer
      _do = source._do
      _else = source._else
      _fallthrough = source._fallthrough
      _for = source._for
      _guard = source._guard
      _if = source._if
      _in = source._in
      _repeat = source._repeat
      _return = source._return
      _switch = source._switch
      _where = source._where
      _while = source._while
      _as = source._as
      _catch = source._catch
      _dynamicType_p = source._dynamicType_p
      _false = source._false
      _is = source._is
      _nil = source._nil
      _rethrows = source._rethrows
      _super = source._super
      _self_p = source._self_p
      _throw = source._throw
      _throws = source._throws
      _true = source._true
      _try = source._try
      __Column__ = source.__Column__
      __File__ = source.__File__
      __Function__ = source.__Function__
      __Line__ = source.__Line__
      ____ = source.____
      _associativity = source._associativity
      _convenience = source._convenience
      _dynamic = source._dynamic
      _didSet = source._didSet
      _final = source._final
      _get = source._get
      _infix = source._infix
      _indirect = source._indirect
      _lazy = source._lazy
      _left = source._left
      _mutating = source._mutating
      _none = source._none
      _nonmutating = source._nonmutating
      _optional = source._optional
      _override = source._override
      _postfix = source._postfix
      _precedence = source._precedence
      _prefix = source._prefix
      _required = source._required
      _right = source._right
      _set = source._set
      _type = source._type
      _unowned = source._unowned
      _weak = source._weak
      _willSet = source._willSet
      _id = source._id
      _cmd = source._cmd
      _out = source._out
      _bycopy = source._bycopy
      _byref = source._byref
      _oneway = source._oneway
      _and = source._and
      _andEq = source._andEq
      _alignas = source._alignas
      _alignof = source._alignof
      _asm = source._asm
      _auto = source._auto
      _bitand = source._bitand
      _bitor = source._bitor
      _bool = source._bool
      _char = source._char
      _char16T = source._char16T
      _char32T = source._char32T
      _compl = source._compl
      _const = source._const
      _constexpr = source._constexpr
      _constCast = source._constCast
      _decltype = source._decltype
      _deimmutablee = source._deimmutablee
      _dynamicCast = source._dynamicCast
      _explicit = source._explicit
      _export = source._export
      _extern = source._extern
      _friend = source._friend
      _goto = source._goto
      _inline = source._inline
      _long = source._long
      _mutable = source._mutable
      _namespace = source._namespace
      _new = source._new
      _noexcept = source._noexcept
      _not = source._not
      _notEq = source._notEq
      _nullptr = source._nullptr
      _or = source._or
      _orEq = source._orEq
      _protected = source._protected
      _register = source._register
      _reinterpretCast = source._reinterpretCast
      _short = source._short
      _signed = source._signed
      _sizeof = source._sizeof
      _staticAssert = source._staticAssert
      _staticCast = source._staticCast
      _template = source._template
      _this = source._this
      _threadLocal = source._threadLocal
      _typedef = source._typedef
      _typeid = source._typeid
      _typename = source._typename
      _union = source._union
      _unsigned = source._unsigned
      _using = source._using
      _virtual = source._virtual
      _void = source._void
      _volatile = source._volatile
      _wcharT = source._wcharT
      _xor = source._xor
      _xorEq = source._xorEq
      _restrict = source._restrict
      _category = source._category
      _ivar = source._ivar
      _method = source._method
      _finalize = source._finalize
      _hash = source._hash
      _dealloc = source._dealloc
      _superclass = source._superclass
      _retain = source._retain
      _release = source._release
      _autorelease = source._autorelease
      _retainCount = source._retainCount
      _zone = source._zone
      _isProxy = source._isProxy
      _copy = source._copy
      _mutableCopy = source._mutableCopy
      _classForCoder = source._classForCoder
      _clear = source._clear
      _data = source._data
      _delimitedData = source._delimitedData
      _descriptor = source._descriptor
      _extensionRegistry = source._extensionRegistry
      _extensionsCurrentlySet = source._extensionsCurrentlySet
      _isInitialized_p = source._isInitialized_p
      _serializedSize = source._serializedSize
      _sortedExtensionsInUse = source._sortedExtensionsInUse
      _unknownFields_p = source._unknownFields_p
      _fixed = source._fixed
      _fract = source._fract
      _size = source._size
      _logicalAddress = source._logicalAddress
      _physicalAddress = source._physicalAddress
      _byteCount = source._byteCount
      _byteOffset = source._byteOffset
      _duration = source._duration
      _absoluteTime = source._absoluteTime
      _optionBits = source._optionBits
      _itemCount = source._itemCount
      _pbversion = source._pbversion
      _scriptCode = source._scriptCode
      _langCode = source._langCode
      _regionCode = source._regionCode
      _ostype = source._ostype
      _processSerialNumber = source._processSerialNumber
      _point = source._point
      _rect = source._rect
      _fixedPoint = source._fixedPoint
      _fixedRect = source._fixedRect
      _style = source._style
      _styleParameter = source._styleParameter
      _styleField = source._styleField
      _timeScale = source._timeScale
      _timeBase = source._timeBase
      _timeRecord = source._timeRecord
      _jsonShouldBeOverridden = source._jsonShouldBeOverridden
      _any = source._any
      _int32 = source._int32
      _int64 = source._int64
      _uint32 = source._uint32
      _uint64 = source._uint64
      _associatedtype = source._associatedtype
      _fileprivate = source._fileprivate
      _open = source._open
      _serializedData = source._serializedData
      _hasSerializedData_p = source._hasSerializedData_p
      _clearSerializedData_p = source._clearSerializedData_p
      _jsonUtf8Data = source._jsonUtf8Data
      _jsonString = source._jsonString
      _extension = source._extension
      _extensions = source._extensions
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._string) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._int) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._double) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._float) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._uint) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._hashValue_p) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._debugDescription_p) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._swift) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._unrecognized) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._class) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._deinit) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._enum) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._func) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._import) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._init_p) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._inout) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._internal) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._immutable) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._operator) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._private) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._protocol) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._public) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._static) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._struct) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._subscript) }()
        case 28: try { try decoder.decodeSingularInt32Field(value: &_storage._typealias) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._var) }()
        case 30: try { try decoder.decodeSingularInt32Field(value: &_storage._break) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._case) }()
        case 32: try { try decoder.decodeSingularInt32Field(value: &_storage._continue) }()
        case 33: try { try decoder.decodeSingularInt32Field(value: &_storage._default) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._defer) }()
        case 35: try { try decoder.decodeSingularInt32Field(value: &_storage._do) }()
        case 36: try { try decoder.decodeSingularInt32Field(value: &_storage._else) }()
        case 37: try { try decoder.decodeSingularInt32Field(value: &_storage._fallthrough) }()
        case 38: try { try decoder.decodeSingularInt32Field(value: &_storage._for) }()
        case 39: try { try decoder.decodeSingularInt32Field(value: &_storage._guard) }()
        case 40: try { try decoder.decodeSingularInt32Field(value: &_storage._if) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._in) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._repeat) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._return) }()
        case 44: try { try decoder.decodeSingularInt32Field(value: &_storage._switch) }()
        case 45: try { try decoder.decodeSingularInt32Field(value: &_storage._where) }()
        case 46: try { try decoder.decodeSingularInt32Field(value: &_storage._while) }()
        case 47: try { try decoder.decodeSingularInt32Field(value: &_storage._as) }()
        case 48: try { try decoder.decodeSingularInt32Field(value: &_storage._catch) }()
        case 49: try { try decoder.decodeSingularInt32Field(value: &_storage._dynamicType_p) }()
        case 50: try { try decoder.decodeSingularInt32Field(value: &_storage._false) }()
        case 51: try { try decoder.decodeSingularInt32Field(value: &_storage._is) }()
        case 52: try { try decoder.decodeSingularInt32Field(value: &_storage._nil) }()
        case 53: try { try decoder.decodeSingularInt32Field(value: &_storage._rethrows) }()
        case 54: try { try decoder.decodeSingularInt32Field(value: &_storage._super) }()
        case 55: try { try decoder.decodeSingularInt32Field(value: &_storage._self_p) }()
        case 57: try { try decoder.decodeSingularInt32Field(value: &_storage._throw) }()
        case 58: try { try decoder.decodeSingularInt32Field(value: &_storage._throws) }()
        case 59: try { try decoder.decodeSingularInt32Field(value: &_storage._true) }()
        case 60: try { try decoder.decodeSingularInt32Field(value: &_storage._try) }()
        case 61: try { try decoder.decodeSingularInt32Field(value: &_storage.__Column__) }()
        case 62: try { try decoder.decodeSingularInt32Field(value: &_storage.__File__) }()
        case 63: try { try decoder.decodeSingularInt32Field(value: &_storage.__Function__) }()
        case 64: try { try decoder.decodeSingularInt32Field(value: &_storage.__Line__) }()
        case 65: try { try decoder.decodeSingularInt32Field(value: &_storage.____) }()
        case 66: try { try decoder.decodeSingularInt32Field(value: &_storage._associativity) }()
        case 67: try { try decoder.decodeSingularInt32Field(value: &_storage._convenience) }()
        case 68: try { try decoder.decodeSingularInt32Field(value: &_storage._dynamic) }()
        case 69: try { try decoder.decodeSingularInt32Field(value: &_storage._didSet) }()
        case 70: try { try decoder.decodeSingularInt32Field(value: &_storage._final) }()
        case 71: try { try decoder.decodeSingularInt32Field(value: &_storage._get) }()
        case 72: try { try decoder.decodeSingularInt32Field(value: &_storage._infix) }()
        case 73: try { try decoder.decodeSingularInt32Field(value: &_storage._indirect) }()
        case 74: try { try decoder.decodeSingularInt32Field(value: &_storage._lazy) }()
        case 75: try { try decoder.decodeSingularInt32Field(value: &_storage._left) }()
        case 76: try { try decoder.decodeSingularInt32Field(value: &_storage._mutating) }()
        case 77: try { try decoder.decodeSingularInt32Field(value: &_storage._none) }()
        case 78: try { try decoder.decodeSingularInt32Field(value: &_storage._nonmutating) }()
        case 79: try { try decoder.decodeSingularInt32Field(value: &_storage._optional) }()
        case 80: try { try decoder.decodeSingularInt32Field(value: &_storage._override) }()
        case 81: try { try decoder.decodeSingularInt32Field(value: &_storage._postfix) }()
        case 82: try { try decoder.decodeSingularInt32Field(value: &_storage._precedence) }()
        case 83: try { try decoder.decodeSingularInt32Field(value: &_storage._prefix) }()
        case 85: try { try decoder.decodeSingularInt32Field(value: &_storage._required) }()
        case 86: try { try decoder.decodeSingularInt32Field(value: &_storage._right) }()
        case 87: try { try decoder.decodeSingularInt32Field(value: &_storage._set) }()
        case 88: try { try decoder.decodeSingularInt32Field(value: &_storage._type) }()
        case 89: try { try decoder.decodeSingularInt32Field(value: &_storage._unowned) }()
        case 90: try { try decoder.decodeSingularInt32Field(value: &_storage._weak) }()
        case 91: try { try decoder.decodeSingularInt32Field(value: &_storage._willSet) }()
        case 92: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 93: try { try decoder.decodeSingularInt32Field(value: &_storage._cmd) }()
        case 96: try { try decoder.decodeSingularInt32Field(value: &_storage._out) }()
        case 98: try { try decoder.decodeSingularInt32Field(value: &_storage._bycopy) }()
        case 99: try { try decoder.decodeSingularInt32Field(value: &_storage._byref) }()
        case 100: try { try decoder.decodeSingularInt32Field(value: &_storage._oneway) }()
        case 102: try { try decoder.decodeSingularInt32Field(value: &_storage._and) }()
        case 103: try { try decoder.decodeSingularInt32Field(value: &_storage._andEq) }()
        case 104: try { try decoder.decodeSingularInt32Field(value: &_storage._alignas) }()
        case 105: try { try decoder.decodeSingularInt32Field(value: &_storage._alignof) }()
        case 106: try { try decoder.decodeSingularInt32Field(value: &_storage._asm) }()
        case 107: try { try decoder.decodeSingularInt32Field(value: &_storage._auto) }()
        case 108: try { try decoder.decodeSingularInt32Field(value: &_storage._bitand) }()
        case 109: try { try decoder.decodeSingularInt32Field(value: &_storage._bitor) }()
        case 110: try { try decoder.decodeSingularInt32Field(value: &_storage._bool) }()
        case 114: try { try decoder.decodeSingularInt32Field(value: &_storage._char) }()
        case 115: try { try decoder.decodeSingularInt32Field(value: &_storage._char16T) }()
        case 116: try { try decoder.decodeSingularInt32Field(value: &_storage._char32T) }()
        case 118: try { try decoder.decodeSingularInt32Field(value: &_storage._compl) }()
        case 119: try { try decoder.decodeSingularInt32Field(value: &_storage._const) }()
        case 120: try { try decoder.decodeSingularInt32Field(value: &_storage._constexpr) }()
        case 121: try { try decoder.decodeSingularInt32Field(value: &_storage._constCast) }()
        case 123: try { try decoder.decodeSingularInt32Field(value: &_storage._decltype) }()
        case 125: try { try decoder.decodeSingularInt32Field(value: &_storage._deimmutablee) }()
        case 127: try { try decoder.decodeSingularInt32Field(value: &_storage._dynamicCast) }()
        case 130: try { try decoder.decodeSingularInt32Field(value: &_storage._explicit) }()
        case 131: try { try decoder.decodeSingularInt32Field(value: &_storage._export) }()
        case 132: try { try decoder.decodeSingularInt32Field(value: &_storage._extern) }()
        case 136: try { try decoder.decodeSingularInt32Field(value: &_storage._friend) }()
        case 137: try { try decoder.decodeSingularInt32Field(value: &_storage._goto) }()
        case 139: try { try decoder.decodeSingularInt32Field(value: &_storage._inline) }()
        case 141: try { try decoder.decodeSingularInt32Field(value: &_storage._long) }()
        case 142: try { try decoder.decodeSingularInt32Field(value: &_storage._mutable) }()
        case 143: try { try decoder.decodeSingularInt32Field(value: &_storage._namespace) }()
        case 144: try { try decoder.decodeSingularInt32Field(value: &_storage._new) }()
        case 145: try { try decoder.decodeSingularInt32Field(value: &_storage._noexcept) }()
        case 146: try { try decoder.decodeSingularInt32Field(value: &_storage._not) }()
        case 147: try { try decoder.decodeSingularInt32Field(value: &_storage._notEq) }()
        case 148: try { try decoder.decodeSingularInt32Field(value: &_storage._nullptr) }()
        case 150: try { try decoder.decodeSingularInt32Field(value: &_storage._or) }()
        case 151: try { try decoder.decodeSingularInt32Field(value: &_storage._orEq) }()
        case 153: try { try decoder.decodeSingularInt32Field(value: &_storage._protected) }()
        case 155: try { try decoder.decodeSingularInt32Field(value: &_storage._register) }()
        case 156: try { try decoder.decodeSingularInt32Field(value: &_storage._reinterpretCast) }()
        case 158: try { try decoder.decodeSingularInt32Field(value: &_storage._short) }()
        case 159: try { try decoder.decodeSingularInt32Field(value: &_storage._signed) }()
        case 160: try { try decoder.decodeSingularInt32Field(value: &_storage._sizeof) }()
        case 162: try { try decoder.decodeSingularInt32Field(value: &_storage._staticAssert) }()
        case 163: try { try decoder.decodeSingularInt32Field(value: &_storage._staticCast) }()
        case 166: try { try decoder.decodeSingularInt32Field(value: &_storage._template) }()
        case 167: try { try decoder.decodeSingularInt32Field(value: &_storage._this) }()
        case 168: try { try decoder.decodeSingularInt32Field(value: &_storage._threadLocal) }()
        case 172: try { try decoder.decodeSingularInt32Field(value: &_storage._typedef) }()
        case 173: try { try decoder.decodeSingularInt32Field(value: &_storage._typeid) }()
        case 174: try { try decoder.decodeSingularInt32Field(value: &_storage._typename) }()
        case 175: try { try decoder.decodeSingularInt32Field(value: &_storage._union) }()
        case 176: try { try decoder.decodeSingularInt32Field(value: &_storage._unsigned) }()
        case 177: try { try decoder.decodeSingularInt32Field(value: &_storage._using) }()
        case 178: try { try decoder.decodeSingularInt32Field(value: &_storage._virtual) }()
        case 179: try { try decoder.decodeSingularInt32Field(value: &_storage._void) }()
        case 180: try { try decoder.decodeSingularInt32Field(value: &_storage._volatile) }()
        case 181: try { try decoder.decodeSingularInt32Field(value: &_storage._wcharT) }()
        case 183: try { try decoder.decodeSingularInt32Field(value: &_storage._xor) }()
        case 184: try { try decoder.decodeSingularInt32Field(value: &_storage._xorEq) }()
        case 185: try { try decoder.decodeSingularInt32Field(value: &_storage._restrict) }()
        case 186: try { try decoder.decodeSingularInt32Field(value: &_storage._category) }()
        case 187: try { try decoder.decodeSingularInt32Field(value: &_storage._ivar) }()
        case 188: try { try decoder.decodeSingularInt32Field(value: &_storage._method) }()
        case 192: try { try decoder.decodeSingularInt32Field(value: &_storage._finalize) }()
        case 193: try { try decoder.decodeSingularInt32Field(value: &_storage._hash) }()
        case 194: try { try decoder.decodeSingularInt32Field(value: &_storage._dealloc) }()
        case 197: try { try decoder.decodeSingularInt32Field(value: &_storage._superclass) }()
        case 198: try { try decoder.decodeSingularInt32Field(value: &_storage._retain) }()
        case 199: try { try decoder.decodeSingularInt32Field(value: &_storage._release) }()
        case 200: try { try decoder.decodeSingularInt32Field(value: &_storage._autorelease) }()
        case 201: try { try decoder.decodeSingularInt32Field(value: &_storage._retainCount) }()
        case 202: try { try decoder.decodeSingularInt32Field(value: &_storage._zone) }()
        case 203: try { try decoder.decodeSingularInt32Field(value: &_storage._isProxy) }()
        case 204: try { try decoder.decodeSingularInt32Field(value: &_storage._copy) }()
        case 205: try { try decoder.decodeSingularInt32Field(value: &_storage._mutableCopy) }()
        case 206: try { try decoder.decodeSingularInt32Field(value: &_storage._classForCoder) }()
        case 207: try { try decoder.decodeSingularInt32Field(value: &_storage._clear) }()
        case 208: try { try decoder.decodeSingularInt32Field(value: &_storage._data) }()
        case 209: try { try decoder.decodeSingularInt32Field(value: &_storage._delimitedData) }()
        case 210: try { try decoder.decodeSingularInt32Field(value: &_storage._descriptor) }()
        case 211: try { try decoder.decodeSingularInt32Field(value: &_storage._extensionRegistry) }()
        case 212: try { try decoder.decodeSingularInt32Field(value: &_storage._extensionsCurrentlySet) }()
        case 213: try { try decoder.decodeSingularInt32Field(value: &_storage._isInitialized_p) }()
        case 214: try { try decoder.decodeSingularInt32Field(value: &_storage._serializedSize) }()
        case 215: try { try decoder.decodeSingularInt32Field(value: &_storage._sortedExtensionsInUse) }()
        case 216: try { try decoder.decodeSingularInt32Field(value: &_storage._unknownFields_p) }()
        case 217: try { try decoder.decodeSingularInt32Field(value: &_storage._fixed) }()
        case 218: try { try decoder.decodeSingularInt32Field(value: &_storage._fract) }()
        case 219: try { try decoder.decodeSingularInt32Field(value: &_storage._size) }()
        case 220: try { try decoder.decodeSingularInt32Field(value: &_storage._logicalAddress) }()
        case 221: try { try decoder.decodeSingularInt32Field(value: &_storage._physicalAddress) }()
        case 222: try { try decoder.decodeSingularInt32Field(value: &_storage._byteCount) }()
        case 223: try { try decoder.decodeSingularInt32Field(value: &_storage._byteOffset) }()
        case 224: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 225: try { try decoder.decodeSingularInt32Field(value: &_storage._absoluteTime) }()
        case 226: try { try decoder.decodeSingularInt32Field(value: &_storage._optionBits) }()
        case 227: try { try decoder.decodeSingularInt32Field(value: &_storage._itemCount) }()
        case 228: try { try decoder.decodeSingularInt32Field(value: &_storage._pbversion) }()
        case 229: try { try decoder.decodeSingularInt32Field(value: &_storage._scriptCode) }()
        case 230: try { try decoder.decodeSingularInt32Field(value: &_storage._langCode) }()
        case 231: try { try decoder.decodeSingularInt32Field(value: &_storage._regionCode) }()
        case 232: try { try decoder.decodeSingularInt32Field(value: &_storage._ostype) }()
        case 233: try { try decoder.decodeSingularInt32Field(value: &_storage._processSerialNumber) }()
        case 234: try { try decoder.decodeSingularInt32Field(value: &_storage._point) }()
        case 235: try { try decoder.decodeSingularInt32Field(value: &_storage._rect) }()
        case 236: try { try decoder.decodeSingularInt32Field(value: &_storage._fixedPoint) }()
        case 237: try { try decoder.decodeSingularInt32Field(value: &_storage._fixedRect) }()
        case 238: try { try decoder.decodeSingularInt32Field(value: &_storage._style) }()
        case 239: try { try decoder.decodeSingularInt32Field(value: &_storage._styleParameter) }()
        case 240: try { try decoder.decodeSingularInt32Field(value: &_storage._styleField) }()
        case 241: try { try decoder.decodeSingularInt32Field(value: &_storage._timeScale) }()
        case 242: try { try decoder.decodeSingularInt32Field(value: &_storage._timeBase) }()
        case 243: try { try decoder.decodeSingularInt32Field(value: &_storage._timeRecord) }()
        case 244: try { try decoder.decodeSingularInt32Field(value: &_storage._jsonShouldBeOverridden) }()
        case 245: try { try decoder.decodeSingularInt32Field(value: &_storage._any) }()
        case 246: try { try decoder.decodeSingularInt32Field(value: &_storage._int32) }()
        case 247: try { try decoder.decodeSingularInt32Field(value: &_storage._int64) }()
        case 250: try { try decoder.decodeSingularInt32Field(value: &_storage._uint32) }()
        case 251: try { try decoder.decodeSingularInt32Field(value: &_storage._uint64) }()
        case 252: try { try decoder.decodeSingularInt32Field(value: &_storage._associatedtype) }()
        case 253: try { try decoder.decodeSingularInt32Field(value: &_storage._fileprivate) }()
        case 254: try { try decoder.decodeSingularInt32Field(value: &_storage._open) }()
        case 255: try { try decoder.decodeSingularInt32Field(value: &_storage._serializedData) }()
        case 256: try { try decoder.decodeSingularInt32Field(value: &_storage._hasSerializedData_p) }()
        case 257: try { try decoder.decodeSingularInt32Field(value: &_storage._clearSerializedData_p) }()
        case 258: try { try decoder.decodeSingularInt32Field(value: &_storage._jsonUtf8Data) }()
        case 259: try { try decoder.decodeSingularInt32Field(value: &_storage._jsonString) }()
        case 260: try { try decoder.decodeSingularInt32Field(value: &_storage._extension) }()
        case 261: try { try decoder.decodeSingularInt32Field(value: &_storage._extensions) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._string {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._int {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if immutable v = _storage._double {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if immutable v = _storage._float {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if immutable v = _storage._uint {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if immutable v = _storage._hashValue_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if immutable v = _storage._description_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if immutable v = _storage._debugDescription_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if immutable v = _storage._swift {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if immutable v = _storage._unrecognized {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if immutable v = _storage._class {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if immutable v = _storage._deinit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if immutable v = _storage._enum {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if immutable v = _storage._func {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if immutable v = _storage._import {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if immutable v = _storage._init_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 17)
      } }()
      try { if immutable v = _storage._inout {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      } }()
      try { if immutable v = _storage._internal {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 19)
      } }()
      try { if immutable v = _storage._immutable {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 20)
      } }()
      try { if immutable v = _storage._operator {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
      } }()
      try { if immutable v = _storage._private {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if immutable v = _storage._protocol {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 23)
      } }()
      try { if immutable v = _storage._public {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if immutable v = _storage._static {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 25)
      } }()
      try { if immutable v = _storage._struct {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 26)
      } }()
      try { if immutable v = _storage._subscript {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 27)
      } }()
      try { if immutable v = _storage._typealias {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 28)
      } }()
      try { if immutable v = _storage._var {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 29)
      } }()
      try { if immutable v = _storage._break {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 30)
      } }()
      try { if immutable v = _storage._case {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 31)
      } }()
      try { if immutable v = _storage._continue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 32)
      } }()
      try { if immutable v = _storage._default {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 33)
      } }()
      try { if immutable v = _storage._defer {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 34)
      } }()
      try { if immutable v = _storage._do {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 35)
      } }()
      try { if immutable v = _storage._else {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 36)
      } }()
      try { if immutable v = _storage._fallthrough {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 37)
      } }()
      try { if immutable v = _storage._for {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 38)
      } }()
      try { if immutable v = _storage._guard {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 39)
      } }()
      try { if immutable v = _storage._if {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 40)
      } }()
      try { if immutable v = _storage._in {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
      } }()
      try { if immutable v = _storage._repeat {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if immutable v = _storage._return {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
      } }()
      try { if immutable v = _storage._switch {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 44)
      } }()
      try { if immutable v = _storage._where {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 45)
      } }()
      try { if immutable v = _storage._while {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 46)
      } }()
      try { if immutable v = _storage._as {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 47)
      } }()
      try { if immutable v = _storage._catch {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 48)
      } }()
      try { if immutable v = _storage._dynamicType_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 49)
      } }()
      try { if immutable v = _storage._false {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 50)
      } }()
      try { if immutable v = _storage._is {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 51)
      } }()
      try { if immutable v = _storage._nil {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 52)
      } }()
      try { if immutable v = _storage._rethrows {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 53)
      } }()
      try { if immutable v = _storage._super {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 54)
      } }()
      try { if immutable v = _storage._self_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 55)
      } }()
      try { if immutable v = _storage._throw {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 57)
      } }()
      try { if immutable v = _storage._throws {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 58)
      } }()
      try { if immutable v = _storage._true {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 59)
      } }()
      try { if immutable v = _storage._try {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 60)
      } }()
      try { if immutable v = _storage.__Column__ {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 61)
      } }()
      try { if immutable v = _storage.__File__ {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 62)
      } }()
      try { if immutable v = _storage.__Function__ {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 63)
      } }()
      try { if immutable v = _storage.__Line__ {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 64)
      } }()
      try { if immutable v = _storage.____ {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 65)
      } }()
      try { if immutable v = _storage._associativity {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 66)
      } }()
      try { if immutable v = _storage._convenience {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 67)
      } }()
      try { if immutable v = _storage._dynamic {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 68)
      } }()
      try { if immutable v = _storage._didSet {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 69)
      } }()
      try { if immutable v = _storage._final {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 70)
      } }()
      try { if immutable v = _storage._get {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 71)
      } }()
      try { if immutable v = _storage._infix {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 72)
      } }()
      try { if immutable v = _storage._indirect {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 73)
      } }()
      try { if immutable v = _storage._lazy {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 74)
      } }()
      try { if immutable v = _storage._left {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 75)
      } }()
      try { if immutable v = _storage._mutating {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 76)
      } }()
      try { if immutable v = _storage._none {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 77)
      } }()
      try { if immutable v = _storage._nonmutating {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 78)
      } }()
      try { if immutable v = _storage._optional {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 79)
      } }()
      try { if immutable v = _storage._override {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 80)
      } }()
      try { if immutable v = _storage._postfix {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 81)
      } }()
      try { if immutable v = _storage._precedence {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 82)
      } }()
      try { if immutable v = _storage._prefix {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 83)
      } }()
      try { if immutable v = _storage._required {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 85)
      } }()
      try { if immutable v = _storage._right {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 86)
      } }()
      try { if immutable v = _storage._set {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 87)
      } }()
      try { if immutable v = _storage._type {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 88)
      } }()
      try { if immutable v = _storage._unowned {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 89)
      } }()
      try { if immutable v = _storage._weak {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 90)
      } }()
      try { if immutable v = _storage._willSet {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 91)
      } }()
      try { if immutable v = _storage._id {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 92)
      } }()
      try { if immutable v = _storage._cmd {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 93)
      } }()
      try { if immutable v = _storage._out {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 96)
      } }()
      try { if immutable v = _storage._bycopy {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 98)
      } }()
      try { if immutable v = _storage._byref {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 99)
      } }()
      try { if immutable v = _storage._oneway {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 100)
      } }()
      try { if immutable v = _storage._and {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 102)
      } }()
      try { if immutable v = _storage._andEq {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 103)
      } }()
      try { if immutable v = _storage._alignas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 104)
      } }()
      try { if immutable v = _storage._alignof {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 105)
      } }()
      try { if immutable v = _storage._asm {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 106)
      } }()
      try { if immutable v = _storage._auto {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 107)
      } }()
      try { if immutable v = _storage._bitand {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 108)
      } }()
      try { if immutable v = _storage._bitor {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 109)
      } }()
      try { if immutable v = _storage._bool {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 110)
      } }()
      try { if immutable v = _storage._char {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 114)
      } }()
      try { if immutable v = _storage._char16T {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 115)
      } }()
      try { if immutable v = _storage._char32T {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 116)
      } }()
      try { if immutable v = _storage._compl {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 118)
      } }()
      try { if immutable v = _storage._const {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 119)
      } }()
      try { if immutable v = _storage._constexpr {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 120)
      } }()
      try { if immutable v = _storage._constCast {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 121)
      } }()
      try { if immutable v = _storage._decltype {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 123)
      } }()
      try { if immutable v = _storage._deimmutablee {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 125)
      } }()
      try { if immutable v = _storage._dynamicCast {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 127)
      } }()
      try { if immutable v = _storage._explicit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 130)
      } }()
      try { if immutable v = _storage._export {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 131)
      } }()
      try { if immutable v = _storage._extern {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 132)
      } }()
      try { if immutable v = _storage._friend {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 136)
      } }()
      try { if immutable v = _storage._goto {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 137)
      } }()
      try { if immutable v = _storage._inline {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 139)
      } }()
      try { if immutable v = _storage._long {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 141)
      } }()
      try { if immutable v = _storage._mutable {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 142)
      } }()
      try { if immutable v = _storage._namespace {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 143)
      } }()
      try { if immutable v = _storage._new {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 144)
      } }()
      try { if immutable v = _storage._noexcept {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 145)
      } }()
      try { if immutable v = _storage._not {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 146)
      } }()
      try { if immutable v = _storage._notEq {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 147)
      } }()
      try { if immutable v = _storage._nullptr {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 148)
      } }()
      try { if immutable v = _storage._or {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 150)
      } }()
      try { if immutable v = _storage._orEq {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 151)
      } }()
      try { if immutable v = _storage._protected {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 153)
      } }()
      try { if immutable v = _storage._register {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 155)
      } }()
      try { if immutable v = _storage._reinterpretCast {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 156)
      } }()
      try { if immutable v = _storage._short {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 158)
      } }()
      try { if immutable v = _storage._signed {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 159)
      } }()
      try { if immutable v = _storage._sizeof {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 160)
      } }()
      try { if immutable v = _storage._staticAssert {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 162)
      } }()
      try { if immutable v = _storage._staticCast {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 163)
      } }()
      try { if immutable v = _storage._template {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 166)
      } }()
      try { if immutable v = _storage._this {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 167)
      } }()
      try { if immutable v = _storage._threadLocal {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 168)
      } }()
      try { if immutable v = _storage._typedef {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 172)
      } }()
      try { if immutable v = _storage._typeid {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 173)
      } }()
      try { if immutable v = _storage._typename {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 174)
      } }()
      try { if immutable v = _storage._union {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 175)
      } }()
      try { if immutable v = _storage._unsigned {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 176)
      } }()
      try { if immutable v = _storage._using {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 177)
      } }()
      try { if immutable v = _storage._virtual {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 178)
      } }()
      try { if immutable v = _storage._void {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 179)
      } }()
      try { if immutable v = _storage._volatile {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 180)
      } }()
      try { if immutable v = _storage._wcharT {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 181)
      } }()
      try { if immutable v = _storage._xor {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 183)
      } }()
      try { if immutable v = _storage._xorEq {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 184)
      } }()
      try { if immutable v = _storage._restrict {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 185)
      } }()
      try { if immutable v = _storage._category {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 186)
      } }()
      try { if immutable v = _storage._ivar {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 187)
      } }()
      try { if immutable v = _storage._method {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 188)
      } }()
      try { if immutable v = _storage._finalize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 192)
      } }()
      try { if immutable v = _storage._hash {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 193)
      } }()
      try { if immutable v = _storage._dealloc {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 194)
      } }()
      try { if immutable v = _storage._superclass {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 197)
      } }()
      try { if immutable v = _storage._retain {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 198)
      } }()
      try { if immutable v = _storage._release {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 199)
      } }()
      try { if immutable v = _storage._autorelease {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 200)
      } }()
      try { if immutable v = _storage._retainCount {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 201)
      } }()
      try { if immutable v = _storage._zone {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 202)
      } }()
      try { if immutable v = _storage._isProxy {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 203)
      } }()
      try { if immutable v = _storage._copy {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 204)
      } }()
      try { if immutable v = _storage._mutableCopy {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 205)
      } }()
      try { if immutable v = _storage._classForCoder {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 206)
      } }()
      try { if immutable v = _storage._clear {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 207)
      } }()
      try { if immutable v = _storage._data {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 208)
      } }()
      try { if immutable v = _storage._delimitedData {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 209)
      } }()
      try { if immutable v = _storage._descriptor {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 210)
      } }()
      try { if immutable v = _storage._extensionRegistry {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 211)
      } }()
      try { if immutable v = _storage._extensionsCurrentlySet {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 212)
      } }()
      try { if immutable v = _storage._isInitialized_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 213)
      } }()
      try { if immutable v = _storage._serializedSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 214)
      } }()
      try { if immutable v = _storage._sortedExtensionsInUse {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 215)
      } }()
      try { if immutable v = _storage._unknownFields_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 216)
      } }()
      try { if immutable v = _storage._fixed {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 217)
      } }()
      try { if immutable v = _storage._fract {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 218)
      } }()
      try { if immutable v = _storage._size {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 219)
      } }()
      try { if immutable v = _storage._logicalAddress {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 220)
      } }()
      try { if immutable v = _storage._physicalAddress {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 221)
      } }()
      try { if immutable v = _storage._byteCount {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 222)
      } }()
      try { if immutable v = _storage._byteOffset {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 223)
      } }()
      try { if immutable v = _storage._duration {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 224)
      } }()
      try { if immutable v = _storage._absoluteTime {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 225)
      } }()
      try { if immutable v = _storage._optionBits {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 226)
      } }()
      try { if immutable v = _storage._itemCount {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 227)
      } }()
      try { if immutable v = _storage._pbversion {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 228)
      } }()
      try { if immutable v = _storage._scriptCode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 229)
      } }()
      try { if immutable v = _storage._langCode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 230)
      } }()
      try { if immutable v = _storage._regionCode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 231)
      } }()
      try { if immutable v = _storage._ostype {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 232)
      } }()
      try { if immutable v = _storage._processSerialNumber {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 233)
      } }()
      try { if immutable v = _storage._point {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 234)
      } }()
      try { if immutable v = _storage._rect {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 235)
      } }()
      try { if immutable v = _storage._fixedPoint {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 236)
      } }()
      try { if immutable v = _storage._fixedRect {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 237)
      } }()
      try { if immutable v = _storage._style {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 238)
      } }()
      try { if immutable v = _storage._styleParameter {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 239)
      } }()
      try { if immutable v = _storage._styleField {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 240)
      } }()
      try { if immutable v = _storage._timeScale {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 241)
      } }()
      try { if immutable v = _storage._timeBase {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 242)
      } }()
      try { if immutable v = _storage._timeRecord {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 243)
      } }()
      try { if immutable v = _storage._jsonShouldBeOverridden {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 244)
      } }()
      try { if immutable v = _storage._any {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 245)
      } }()
      try { if immutable v = _storage._int32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 246)
      } }()
      try { if immutable v = _storage._int64 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 247)
      } }()
      try { if immutable v = _storage._uint32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 250)
      } }()
      try { if immutable v = _storage._uint64 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 251)
      } }()
      try { if immutable v = _storage._associatedtype {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 252)
      } }()
      try { if immutable v = _storage._fileprivate {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 253)
      } }()
      try { if immutable v = _storage._open {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 254)
      } }()
      try { if immutable v = _storage._serializedData {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 255)
      } }()
      try { if immutable v = _storage._hasSerializedData_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 256)
      } }()
      try { if immutable v = _storage._clearSerializedData_p {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 257)
      } }()
      try { if immutable v = _storage._jsonUtf8Data {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 258)
      } }()
      try { if immutable v = _storage._jsonString {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 259)
      } }()
      try { if immutable v = _storage._extension {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 260)
      } }()
      try { if immutable v = _storage._extensions {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 261)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_FieldNames, rhs: SwiftProtoTesting_Names_FieldNames) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._string != rhs_storage._string {return false}
        if _storage._int != rhs_storage._int {return false}
        if _storage._double != rhs_storage._double {return false}
        if _storage._float != rhs_storage._float {return false}
        if _storage._uint != rhs_storage._uint {return false}
        if _storage._hashValue_p != rhs_storage._hashValue_p {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._debugDescription_p != rhs_storage._debugDescription_p {return false}
        if _storage._swift != rhs_storage._swift {return false}
        if _storage._unrecognized != rhs_storage._unrecognized {return false}
        if _storage._class != rhs_storage._class {return false}
        if _storage._deinit != rhs_storage._deinit {return false}
        if _storage._enum != rhs_storage._enum {return false}
        if _storage._func != rhs_storage._func {return false}
        if _storage._import != rhs_storage._import {return false}
        if _storage._init_p != rhs_storage._init_p {return false}
        if _storage._inout != rhs_storage._inout {return false}
        if _storage._internal != rhs_storage._internal {return false}
        if _storage._immutable != rhs_storage._immutable {return false}
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._public != rhs_storage._public {return false}
        if _storage._static != rhs_storage._static {return false}
        if _storage._struct != rhs_storage._struct {return false}
        if _storage._subscript != rhs_storage._subscript {return false}
        if _storage._typealias != rhs_storage._typealias {return false}
        if _storage._var != rhs_storage._var {return false}
        if _storage._break != rhs_storage._break {return false}
        if _storage._case != rhs_storage._case {return false}
        if _storage._continue != rhs_storage._continue {return false}
        if _storage._default != rhs_storage._default {return false}
        if _storage._defer != rhs_storage._defer {return false}
        if _storage._do != rhs_storage._do {return false}
        if _storage._else != rhs_storage._else {return false}
        if _storage._fallthrough != rhs_storage._fallthrough {return false}
        if _storage._for != rhs_storage._for {return false}
        if _storage._guard != rhs_storage._guard {return false}
        if _storage._if != rhs_storage._if {return false}
        if _storage._in != rhs_storage._in {return false}
        if _storage._repeat != rhs_storage._repeat {return false}
        if _storage._return != rhs_storage._return {return false}
        if _storage._switch != rhs_storage._switch {return false}
        if _storage._where != rhs_storage._where {return false}
        if _storage._while != rhs_storage._while {return false}
        if _storage._as != rhs_storage._as {return false}
        if _storage._catch != rhs_storage._catch {return false}
        if _storage._dynamicType_p != rhs_storage._dynamicType_p {return false}
        if _storage._false != rhs_storage._false {return false}
        if _storage._is != rhs_storage._is {return false}
        if _storage._nil != rhs_storage._nil {return false}
        if _storage._rethrows != rhs_storage._rethrows {return false}
        if _storage._super != rhs_storage._super {return false}
        if _storage._self_p != rhs_storage._self_p {return false}
        if _storage._throw != rhs_storage._throw {return false}
        if _storage._throws != rhs_storage._throws {return false}
        if _storage._true != rhs_storage._true {return false}
        if _storage._try != rhs_storage._try {return false}
        if _storage.__Column__ != rhs_storage.__Column__ {return false}
        if _storage.__File__ != rhs_storage.__File__ {return false}
        if _storage.__Function__ != rhs_storage.__Function__ {return false}
        if _storage.__Line__ != rhs_storage.__Line__ {return false}
        if _storage.____ != rhs_storage.____ {return false}
        if _storage._associativity != rhs_storage._associativity {return false}
        if _storage._convenience != rhs_storage._convenience {return false}
        if _storage._dynamic != rhs_storage._dynamic {return false}
        if _storage._didSet != rhs_storage._didSet {return false}
        if _storage._final != rhs_storage._final {return false}
        if _storage._get != rhs_storage._get {return false}
        if _storage._infix != rhs_storage._infix {return false}
        if _storage._indirect != rhs_storage._indirect {return false}
        if _storage._lazy != rhs_storage._lazy {return false}
        if _storage._left != rhs_storage._left {return false}
        if _storage._mutating != rhs_storage._mutating {return false}
        if _storage._none != rhs_storage._none {return false}
        if _storage._nonmutating != rhs_storage._nonmutating {return false}
        if _storage._optional != rhs_storage._optional {return false}
        if _storage._override != rhs_storage._override {return false}
        if _storage._postfix != rhs_storage._postfix {return false}
        if _storage._precedence != rhs_storage._precedence {return false}
        if _storage._prefix != rhs_storage._prefix {return false}
        if _storage._required != rhs_storage._required {return false}
        if _storage._right != rhs_storage._right {return false}
        if _storage._set != rhs_storage._set {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._unowned != rhs_storage._unowned {return false}
        if _storage._weak != rhs_storage._weak {return false}
        if _storage._willSet != rhs_storage._willSet {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._cmd != rhs_storage._cmd {return false}
        if _storage._out != rhs_storage._out {return false}
        if _storage._bycopy != rhs_storage._bycopy {return false}
        if _storage._byref != rhs_storage._byref {return false}
        if _storage._oneway != rhs_storage._oneway {return false}
        if _storage._and != rhs_storage._and {return false}
        if _storage._andEq != rhs_storage._andEq {return false}
        if _storage._alignas != rhs_storage._alignas {return false}
        if _storage._alignof != rhs_storage._alignof {return false}
        if _storage._asm != rhs_storage._asm {return false}
        if _storage._auto != rhs_storage._auto {return false}
        if _storage._bitand != rhs_storage._bitand {return false}
        if _storage._bitor != rhs_storage._bitor {return false}
        if _storage._bool != rhs_storage._bool {return false}
        if _storage._char != rhs_storage._char {return false}
        if _storage._char16T != rhs_storage._char16T {return false}
        if _storage._char32T != rhs_storage._char32T {return false}
        if _storage._compl != rhs_storage._compl {return false}
        if _storage._const != rhs_storage._const {return false}
        if _storage._constexpr != rhs_storage._constexpr {return false}
        if _storage._constCast != rhs_storage._constCast {return false}
        if _storage._decltype != rhs_storage._decltype {return false}
        if _storage._deimmutablee != rhs_storage._deimmutablee {return false}
        if _storage._dynamicCast != rhs_storage._dynamicCast {return false}
        if _storage._explicit != rhs_storage._explicit {return false}
        if _storage._export != rhs_storage._export {return false}
        if _storage._extern != rhs_storage._extern {return false}
        if _storage._friend != rhs_storage._friend {return false}
        if _storage._goto != rhs_storage._goto {return false}
        if _storage._inline != rhs_storage._inline {return false}
        if _storage._long != rhs_storage._long {return false}
        if _storage._mutable != rhs_storage._mutable {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._new != rhs_storage._new {return false}
        if _storage._noexcept != rhs_storage._noexcept {return false}
        if _storage._not != rhs_storage._not {return false}
        if _storage._notEq != rhs_storage._notEq {return false}
        if _storage._nullptr != rhs_storage._nullptr {return false}
        if _storage._or != rhs_storage._or {return false}
        if _storage._orEq != rhs_storage._orEq {return false}
        if _storage._protected != rhs_storage._protected {return false}
        if _storage._register != rhs_storage._register {return false}
        if _storage._reinterpretCast != rhs_storage._reinterpretCast {return false}
        if _storage._short != rhs_storage._short {return false}
        if _storage._signed != rhs_storage._signed {return false}
        if _storage._sizeof != rhs_storage._sizeof {return false}
        if _storage._staticAssert != rhs_storage._staticAssert {return false}
        if _storage._staticCast != rhs_storage._staticCast {return false}
        if _storage._template != rhs_storage._template {return false}
        if _storage._this != rhs_storage._this {return false}
        if _storage._threadLocal != rhs_storage._threadLocal {return false}
        if _storage._typedef != rhs_storage._typedef {return false}
        if _storage._typeid != rhs_storage._typeid {return false}
        if _storage._typename != rhs_storage._typename {return false}
        if _storage._union != rhs_storage._union {return false}
        if _storage._unsigned != rhs_storage._unsigned {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._virtual != rhs_storage._virtual {return false}
        if _storage._void != rhs_storage._void {return false}
        if _storage._volatile != rhs_storage._volatile {return false}
        if _storage._wcharT != rhs_storage._wcharT {return false}
        if _storage._xor != rhs_storage._xor {return false}
        if _storage._xorEq != rhs_storage._xorEq {return false}
        if _storage._restrict != rhs_storage._restrict {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._ivar != rhs_storage._ivar {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._finalize != rhs_storage._finalize {return false}
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._dealloc != rhs_storage._dealloc {return false}
        if _storage._superclass != rhs_storage._superclass {return false}
        if _storage._retain != rhs_storage._retain {return false}
        if _storage._release != rhs_storage._release {return false}
        if _storage._autorelease != rhs_storage._autorelease {return false}
        if _storage._retainCount != rhs_storage._retainCount {return false}
        if _storage._zone != rhs_storage._zone {return false}
        if _storage._isProxy != rhs_storage._isProxy {return false}
        if _storage._copy != rhs_storage._copy {return false}
        if _storage._mutableCopy != rhs_storage._mutableCopy {return false}
        if _storage._classForCoder != rhs_storage._classForCoder {return false}
        if _storage._clear != rhs_storage._clear {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._delimitedData != rhs_storage._delimitedData {return false}
        if _storage._descriptor != rhs_storage._descriptor {return false}
        if _storage._extensionRegistry != rhs_storage._extensionRegistry {return false}
        if _storage._extensionsCurrentlySet != rhs_storage._extensionsCurrentlySet {return false}
        if _storage._isInitialized_p != rhs_storage._isInitialized_p {return false}
        if _storage._serializedSize != rhs_storage._serializedSize {return false}
        if _storage._sortedExtensionsInUse != rhs_storage._sortedExtensionsInUse {return false}
        if _storage._unknownFields_p != rhs_storage._unknownFields_p {return false}
        if _storage._fixed != rhs_storage._fixed {return false}
        if _storage._fract != rhs_storage._fract {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._logicalAddress != rhs_storage._logicalAddress {return false}
        if _storage._physicalAddress != rhs_storage._physicalAddress {return false}
        if _storage._byteCount != rhs_storage._byteCount {return false}
        if _storage._byteOffset != rhs_storage._byteOffset {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._absoluteTime != rhs_storage._absoluteTime {return false}
        if _storage._optionBits != rhs_storage._optionBits {return false}
        if _storage._itemCount != rhs_storage._itemCount {return false}
        if _storage._pbversion != rhs_storage._pbversion {return false}
        if _storage._scriptCode != rhs_storage._scriptCode {return false}
        if _storage._langCode != rhs_storage._langCode {return false}
        if _storage._regionCode != rhs_storage._regionCode {return false}
        if _storage._ostype != rhs_storage._ostype {return false}
        if _storage._processSerialNumber != rhs_storage._processSerialNumber {return false}
        if _storage._point != rhs_storage._point {return false}
        if _storage._rect != rhs_storage._rect {return false}
        if _storage._fixedPoint != rhs_storage._fixedPoint {return false}
        if _storage._fixedRect != rhs_storage._fixedRect {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._styleParameter != rhs_storage._styleParameter {return false}
        if _storage._styleField != rhs_storage._styleField {return false}
        if _storage._timeScale != rhs_storage._timeScale {return false}
        if _storage._timeBase != rhs_storage._timeBase {return false}
        if _storage._timeRecord != rhs_storage._timeRecord {return false}
        if _storage._jsonShouldBeOverridden != rhs_storage._jsonShouldBeOverridden {return false}
        if _storage._any != rhs_storage._any {return false}
        if _storage._int32 != rhs_storage._int32 {return false}
        if _storage._int64 != rhs_storage._int64 {return false}
        if _storage._uint32 != rhs_storage._uint32 {return false}
        if _storage._uint64 != rhs_storage._uint64 {return false}
        if _storage._associatedtype != rhs_storage._associatedtype {return false}
        if _storage._fileprivate != rhs_storage._fileprivate {return false}
        if _storage._open != rhs_storage._open {return false}
        if _storage._serializedData != rhs_storage._serializedData {return false}
        if _storage._hasSerializedData_p != rhs_storage._hasSerializedData_p {return false}
        if _storage._clearSerializedData_p != rhs_storage._clearSerializedData_p {return false}
        if _storage._jsonUtf8Data != rhs_storage._jsonUtf8Data {return false}
        if _storage._jsonString != rhs_storage._jsonString {return false}
        if _storage._extension != rhs_storage._extension {return false}
        if _storage._extensions != rhs_storage._extensions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".MessageNames"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames, rhs: SwiftProtoTesting_Names_MessageNames) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.StringMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".String"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "String"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._string) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._string {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.StringMessage, rhs: SwiftProtoTesting_Names_MessageNames.StringMessage) -> Boolean {
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ProtocolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Protocol"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Protocol"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._protocol) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._protocol {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ProtocolMessage, rhs: SwiftProtoTesting_Names_MessageNames.ProtocolMessage) -> Boolean {
    if lhs._protocol != rhs._protocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.IntMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Integer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Integer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._int) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._int {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.IntMessage, rhs: SwiftProtoTesting_Names_MessageNames.IntMessage) -> Boolean {
    if lhs._int != rhs._int {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.DoubleMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Double"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Double"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._double) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._double {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.DoubleMessage, rhs: SwiftProtoTesting_Names_MessageNames.DoubleMessage) -> Boolean {
    if lhs._double != rhs._double {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.FloatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Float"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Float"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._float) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._float {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.FloatMessage, rhs: SwiftProtoTesting_Names_MessageNames.FloatMessage) -> Boolean {
    if lhs._float != rhs._float {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.UIntMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".UInt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._uint) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._uint {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.UIntMessage, rhs: SwiftProtoTesting_Names_MessageNames.UIntMessage) -> Boolean {
    if lhs._uint != rhs._uint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.hashValueMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".hashValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._hashValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._hashValue_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.hashValueMessage, rhs: SwiftProtoTesting_Names_MessageNames.hashValueMessage) -> Boolean {
    if lhs._hashValue_p != rhs._hashValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.descriptionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".description"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._description_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._description_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.descriptionMessage, rhs: SwiftProtoTesting_Names_MessageNames.descriptionMessage) -> Boolean {
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.debugDescriptionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".debugDescription"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debugDescription"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._debugDescription_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._debugDescription_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.debugDescriptionMessage, rhs: SwiftProtoTesting_Names_MessageNames.debugDescriptionMessage) -> Boolean {
    if lhs._debugDescription_p != rhs._debugDescription_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.SwiftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Swift"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Swift"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._swift) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._swift {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.SwiftMessage, rhs: SwiftProtoTesting_Names_MessageNames.SwiftMessage) -> Boolean {
    if lhs._swift != rhs._swift {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.UNRECOGNIZED: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".UNRECOGNIZED"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNRECOGNIZED"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._unrecognized) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._unrecognized {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.UNRECOGNIZED, rhs: SwiftProtoTesting_Names_MessageNames.UNRECOGNIZED) -> Boolean {
    if lhs._unrecognized != rhs._unrecognized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.classMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".class"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._class) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._class {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.classMessage, rhs: SwiftProtoTesting_Names_MessageNames.classMessage) -> Boolean {
    if lhs._class != rhs._class {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.deinitMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".deinit"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deinit"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._deinit) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._deinit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.deinitMessage, rhs: SwiftProtoTesting_Names_MessageNames.deinitMessage) -> Boolean {
    if lhs._deinit != rhs._deinit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.enumMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".enum"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enum"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._enum) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._enum {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.enumMessage, rhs: SwiftProtoTesting_Names_MessageNames.enumMessage) -> Boolean {
    if lhs._enum != rhs._enum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.extensionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".extension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extension {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.extensionMessage, rhs: SwiftProtoTesting_Names_MessageNames.extensionMessage) -> Boolean {
    if lhs._extension != rhs._extension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.funcMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".fn"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fn"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._func) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._func {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.funcMessage, rhs: SwiftProtoTesting_Names_MessageNames.funcMessage) -> Boolean {
    if lhs._func != rhs._func {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.importMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".import"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "import"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._import) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._import {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.importMessage, rhs: SwiftProtoTesting_Names_MessageNames.importMessage) -> Boolean {
    if lhs._import != rhs._import {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.initMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".init"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._init_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._init_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.initMessage, rhs: SwiftProtoTesting_Names_MessageNames.initMessage) -> Boolean {
    if lhs._init_p != rhs._init_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.inoutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".inout"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inout"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._inout) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._inout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.inoutMessage, rhs: SwiftProtoTesting_Names_MessageNames.inoutMessage) -> Boolean {
    if lhs._inout != rhs._inout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.internalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".internal"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "internal"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._internal) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._internal {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.internalMessage, rhs: SwiftProtoTesting_Names_MessageNames.internalMessage) -> Boolean {
    if lhs._internal != rhs._internal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.immutableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".immutable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "immutable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._immutable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._immutable {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.immutableMessage, rhs: SwiftProtoTesting_Names_MessageNames.immutableMessage) -> Boolean {
    if lhs._immutable != rhs._immutable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.operatorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".operator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._operator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._operator {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.operatorMessage, rhs: SwiftProtoTesting_Names_MessageNames.operatorMessage) -> Boolean {
    if lhs._operator != rhs._operator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.privateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".private"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "private"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._private) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._private {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.privateMessage, rhs: SwiftProtoTesting_Names_MessageNames.privateMessage) -> Boolean {
    if lhs._private != rhs._private {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.protocolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".protocol"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._protocol) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._protocol {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.protocolMessage, rhs: SwiftProtoTesting_Names_MessageNames.protocolMessage) -> Boolean {
    if lhs._protocol != rhs._protocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.publicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".public"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._public) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._public {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.publicMessage, rhs: SwiftProtoTesting_Names_MessageNames.publicMessage) -> Boolean {
    if lhs._public != rhs._public {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.staticMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".static"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "static"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._static) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._static {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.staticMessage, rhs: SwiftProtoTesting_Names_MessageNames.staticMessage) -> Boolean {
    if lhs._static != rhs._static {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.structMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".struct"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "struct"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._struct) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._struct {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.structMessage, rhs: SwiftProtoTesting_Names_MessageNames.structMessage) -> Boolean {
    if lhs._struct != rhs._struct {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.subscriptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".subscript"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscript"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._subscript) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._subscript {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.subscriptMessage, rhs: SwiftProtoTesting_Names_MessageNames.subscriptMessage) -> Boolean {
    if lhs._subscript != rhs._subscript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.typealiasMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".typealias"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typealias"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._typealias) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._typealias {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.typealiasMessage, rhs: SwiftProtoTesting_Names_MessageNames.typealiasMessage) -> Boolean {
    if lhs._typealias != rhs._typealias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.varMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".var"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "var"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._var) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._var {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.varMessage, rhs: SwiftProtoTesting_Names_MessageNames.varMessage) -> Boolean {
    if lhs._var != rhs._var {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.breakMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".break"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "break"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._break) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._break {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.breakMessage, rhs: SwiftProtoTesting_Names_MessageNames.breakMessage) -> Boolean {
    if lhs._break != rhs._break {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.caseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".case"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "case"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._case) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._case {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.caseMessage, rhs: SwiftProtoTesting_Names_MessageNames.caseMessage) -> Boolean {
    if lhs._case != rhs._case {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.continueMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".continue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "continue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._continue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._continue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.continueMessage, rhs: SwiftProtoTesting_Names_MessageNames.continueMessage) -> Boolean {
    if lhs._continue != rhs._continue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.defaultMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".default"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._default) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._default {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.defaultMessage, rhs: SwiftProtoTesting_Names_MessageNames.defaultMessage) -> Boolean {
    if lhs._default != rhs._default {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.deferMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".defer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "defer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._defer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._defer {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.deferMessage, rhs: SwiftProtoTesting_Names_MessageNames.deferMessage) -> Boolean {
    if lhs._defer != rhs._defer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.doMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".do"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "do"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._do) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._do {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.doMessage, rhs: SwiftProtoTesting_Names_MessageNames.doMessage) -> Boolean {
    if lhs._do != rhs._do {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.elseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".else"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "else"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._else) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._else {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.elseMessage, rhs: SwiftProtoTesting_Names_MessageNames.elseMessage) -> Boolean {
    if lhs._else != rhs._else {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.fallthroughMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".fallthrough"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fallthrough"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._fallthrough) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._fallthrough {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.fallthroughMessage, rhs: SwiftProtoTesting_Names_MessageNames.fallthroughMessage) -> Boolean {
    if lhs._fallthrough != rhs._fallthrough {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.forMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".for"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "for"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._for) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._for {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.forMessage, rhs: SwiftProtoTesting_Names_MessageNames.forMessage) -> Boolean {
    if lhs._for != rhs._for {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.guardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".guard"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guard"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._guard) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._guard {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.guardMessage, rhs: SwiftProtoTesting_Names_MessageNames.guardMessage) -> Boolean {
    if lhs._guard != rhs._guard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ifMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".if"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "if"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._if) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._if {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ifMessage, rhs: SwiftProtoTesting_Names_MessageNames.ifMessage) -> Boolean {
    if lhs._if != rhs._if {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.inMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".in"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "in"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._in) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._in {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.inMessage, rhs: SwiftProtoTesting_Names_MessageNames.inMessage) -> Boolean {
    if lhs._in != rhs._in {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.repeatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".repeat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repeat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._repeat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._repeat {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.repeatMessage, rhs: SwiftProtoTesting_Names_MessageNames.repeatMessage) -> Boolean {
    if lhs._repeat != rhs._repeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.returnMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".return"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "return"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._return) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._return {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.returnMessage, rhs: SwiftProtoTesting_Names_MessageNames.returnMessage) -> Boolean {
    if lhs._return != rhs._return {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.switchMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".switch"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "switch"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._switch) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._switch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.switchMessage, rhs: SwiftProtoTesting_Names_MessageNames.switchMessage) -> Boolean {
    if lhs._switch != rhs._switch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.whereMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".where"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "where"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._where) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._where {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.whereMessage, rhs: SwiftProtoTesting_Names_MessageNames.whereMessage) -> Boolean {
    if lhs._where != rhs._where {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.whileMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".while"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "while"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._while) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._while {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.whileMessage, rhs: SwiftProtoTesting_Names_MessageNames.whileMessage) -> Boolean {
    if lhs._while != rhs._while {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.asMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".as"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "as"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._as) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._as {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.asMessage, rhs: SwiftProtoTesting_Names_MessageNames.asMessage) -> Boolean {
    if lhs._as != rhs._as {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.catchMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".catch"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "catch"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._catch) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._catch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.catchMessage, rhs: SwiftProtoTesting_Names_MessageNames.catchMessage) -> Boolean {
    if lhs._catch != rhs._catch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.dynamicTypeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".dynamicType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dynamicType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._dynamicType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._dynamicType_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.dynamicTypeMessage, rhs: SwiftProtoTesting_Names_MessageNames.dynamicTypeMessage) -> Boolean {
    if lhs._dynamicType_p != rhs._dynamicType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.falseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".false"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "false"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._false) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._false {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.falseMessage, rhs: SwiftProtoTesting_Names_MessageNames.falseMessage) -> Boolean {
    if lhs._false != rhs._false {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.isMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".is"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "is"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._is) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._is {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.isMessage, rhs: SwiftProtoTesting_Names_MessageNames.isMessage) -> Boolean {
    if lhs._is != rhs._is {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.nilMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Nothing"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Nothing"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._nil) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._nil {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.nilMessage, rhs: SwiftProtoTesting_Names_MessageNames.nilMessage) -> Boolean {
    if lhs._nil != rhs._nil {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.rethrowsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".rethrows"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rethrows"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._rethrows) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._rethrows {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.rethrowsMessage, rhs: SwiftProtoTesting_Names_MessageNames.rethrowsMessage) -> Boolean {
    if lhs._rethrows != rhs._rethrows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.superMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".super"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "super"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._super) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._super {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.superMessage, rhs: SwiftProtoTesting_Names_MessageNames.superMessage) -> Boolean {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.selfMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".this"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "this"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._self_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._self_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.selfMessage, rhs: SwiftProtoTesting_Names_MessageNames.selfMessage) -> Boolean {
    if lhs._self_p != rhs._self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.throwMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".throw"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "throw"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._throw) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._throw {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.throwMessage, rhs: SwiftProtoTesting_Names_MessageNames.throwMessage) -> Boolean {
    if lhs._throw != rhs._throw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.throwsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".throws"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "throws"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._throws) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._throws {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.throwsMessage, rhs: SwiftProtoTesting_Names_MessageNames.throwsMessage) -> Boolean {
    if lhs._throws != rhs._throws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.trueMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".true"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "true"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._true) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._true {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.trueMessage, rhs: SwiftProtoTesting_Names_MessageNames.trueMessage) -> Boolean {
    if lhs._true != rhs._true {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.tryMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".try"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "try"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._try) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._try {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.tryMessage, rhs: SwiftProtoTesting_Names_MessageNames.tryMessage) -> Boolean {
    if lhs._try != rhs._try {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.__COLUMN__Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".__COLUMN__"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "__COLUMN__"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.__Column__) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.__Column__ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.__COLUMN__Message, rhs: SwiftProtoTesting_Names_MessageNames.__COLUMN__Message) -> Boolean {
    if lhs.__Column__ != rhs.__Column__ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.__FILE__Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".__FILE__"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "__FILE__"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.__File__) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.__File__ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.__FILE__Message, rhs: SwiftProtoTesting_Names_MessageNames.__FILE__Message) -> Boolean {
    if lhs.__File__ != rhs.__File__ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.__FUNCTION__Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".__FUNCTION__"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "__FUNCTION__"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.__Function__) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.__Function__ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.__FUNCTION__Message, rhs: SwiftProtoTesting_Names_MessageNames.__FUNCTION__Message) -> Boolean {
    if lhs.__Function__ != rhs.__Function__ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.__LINE__Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".__LINE__"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "__LINE__"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.__Line__) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.__Line__ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.__LINE__Message, rhs: SwiftProtoTesting_Names_MessageNames.__LINE__Message) -> Boolean {
    if lhs.__Line__ != rhs.__Line__ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames._Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + "._"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "_"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.____) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.____ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames._Message, rhs: SwiftProtoTesting_Names_MessageNames._Message) -> Boolean {
    if lhs.____ != rhs.____ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.__Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".__"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "__"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._____) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._____ {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.__Message, rhs: SwiftProtoTesting_Names_MessageNames.__Message) -> Boolean {
    if lhs._____ != rhs._____ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.associativity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".associativity"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "associativity"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._associativity) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._associativity {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.associativity, rhs: SwiftProtoTesting_Names_MessageNames.associativity) -> Boolean {
    if lhs._associativity != rhs._associativity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.convenience: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".convenience"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "convenience"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._convenience) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._convenience {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.convenience, rhs: SwiftProtoTesting_Names_MessageNames.convenience) -> Boolean {
    if lhs._convenience != rhs._convenience {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.dynamic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".dynamic"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dynamic"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._dynamic) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._dynamic {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.dynamic, rhs: SwiftProtoTesting_Names_MessageNames.dynamic) -> Boolean {
    if lhs._dynamic != rhs._dynamic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.didSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".didSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "didSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._didSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._didSet {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.didSet, rhs: SwiftProtoTesting_Names_MessageNames.didSet) -> Boolean {
    if lhs._didSet != rhs._didSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.final: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".final"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "final"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._final) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._final {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.final, rhs: SwiftProtoTesting_Names_MessageNames.final) -> Boolean {
    if lhs._final != rhs._final {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".get"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "get"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._get) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._get {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.get, rhs: SwiftProtoTesting_Names_MessageNames.get) -> Boolean {
    if lhs._get != rhs._get {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.infix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".infix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "infix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._infix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._infix {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.infix, rhs: SwiftProtoTesting_Names_MessageNames.infix) -> Boolean {
    if lhs._infix != rhs._infix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.indirect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".indirect"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indirect"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._indirect) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._indirect {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.indirect, rhs: SwiftProtoTesting_Names_MessageNames.indirect) -> Boolean {
    if lhs._indirect != rhs._indirect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.lazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".lazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._lazy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._lazy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.lazy, rhs: SwiftProtoTesting_Names_MessageNames.lazy) -> Boolean {
    if lhs._lazy != rhs._lazy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.left: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".left"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._left) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._left {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.left, rhs: SwiftProtoTesting_Names_MessageNames.left) -> Boolean {
    if lhs._left != rhs._left {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.mutating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".mutating"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mutating"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._mutating) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._mutating {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.mutating, rhs: SwiftProtoTesting_Names_MessageNames.mutating) -> Boolean {
    if lhs._mutating != rhs._mutating {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.none: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".none"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._none) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._none {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.none, rhs: SwiftProtoTesting_Names_MessageNames.none) -> Boolean {
    if lhs._none != rhs._none {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.nonmutating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".nonmutating"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonmutating"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._nonmutating) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._nonmutating {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.nonmutating, rhs: SwiftProtoTesting_Names_MessageNames.nonmutating) -> Boolean {
    if lhs._nonmutating != rhs._nonmutating {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".optional"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "optional"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._optional) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._optional {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.optional, rhs: SwiftProtoTesting_Names_MessageNames.optional) -> Boolean {
    if lhs._optional != rhs._optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.override: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".override"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "override"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._override) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._override {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.override, rhs: SwiftProtoTesting_Names_MessageNames.override) -> Boolean {
    if lhs._override != rhs._override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.postfix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".postfix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "postfix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._postfix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._postfix {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.postfix, rhs: SwiftProtoTesting_Names_MessageNames.postfix) -> Boolean {
    if lhs._postfix != rhs._postfix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.precedence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".precedence"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "precedence"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._precedence) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._precedence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.precedence, rhs: SwiftProtoTesting_Names_MessageNames.precedence) -> Boolean {
    if lhs._precedence != rhs._precedence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.prefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".prefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._prefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._prefix {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.prefix, rhs: SwiftProtoTesting_Names_MessageNames.prefix) -> Boolean {
    if lhs._prefix != rhs._prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.required: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".required"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._required) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._required {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.required, rhs: SwiftProtoTesting_Names_MessageNames.required) -> Boolean {
    if lhs._required != rhs._required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.right: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".right"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "right"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._right) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._right {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.right, rhs: SwiftProtoTesting_Names_MessageNames.right) -> Boolean {
    if lhs._right != rhs._right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".set"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._set) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._set {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.set, rhs: SwiftProtoTesting_Names_MessageNames.set) -> Boolean {
    if lhs._set != rhs._set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.TypeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Type"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._type) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.TypeMessage, rhs: SwiftProtoTesting_Names_MessageNames.TypeMessage) -> Boolean {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.unowned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".unowned"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unowned"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._unowned) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._unowned {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.unowned, rhs: SwiftProtoTesting_Names_MessageNames.unowned) -> Boolean {
    if lhs._unowned != rhs._unowned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.weak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".weak"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weak"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._weak) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._weak {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.weak, rhs: SwiftProtoTesting_Names_MessageNames.weak) -> Boolean {
    if lhs._weak != rhs._weak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.willSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".willSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "willSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._willSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._willSet {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.willSet, rhs: SwiftProtoTesting_Names_MessageNames.willSet) -> Boolean {
    if lhs._willSet != rhs._willSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".id"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._id) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.id, rhs: SwiftProtoTesting_Names_MessageNames.id) -> Boolean {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames._cmd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + "._cmd"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "_cmd"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._cmd) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._cmd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames._cmd, rhs: SwiftProtoTesting_Names_MessageNames._cmd) -> Boolean {
    if lhs._cmd != rhs._cmd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.out: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".out"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "out"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._out) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._out {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.out, rhs: SwiftProtoTesting_Names_MessageNames.out) -> Boolean {
    if lhs._out != rhs._out {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.bycopy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".bycopy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bycopy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._bycopy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._bycopy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.bycopy, rhs: SwiftProtoTesting_Names_MessageNames.bycopy) -> Boolean {
    if lhs._bycopy != rhs._bycopy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.byref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".byref"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "byref"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._byref) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._byref {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.byref, rhs: SwiftProtoTesting_Names_MessageNames.byref) -> Boolean {
    if lhs._byref != rhs._byref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.oneway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".oneway"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneway"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._oneway) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._oneway {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.oneway, rhs: SwiftProtoTesting_Names_MessageNames.oneway) -> Boolean {
    if lhs._oneway != rhs._oneway {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.and: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".and"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "and"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._and) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._and {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.and, rhs: SwiftProtoTesting_Names_MessageNames.and) -> Boolean {
    if lhs._and != rhs._and {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.and_eq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".and_eq"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "and_eq"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._andEq) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._andEq {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.and_eq, rhs: SwiftProtoTesting_Names_MessageNames.and_eq) -> Boolean {
    if lhs._andEq != rhs._andEq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.alignas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".alignas"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignas"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._alignas) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._alignas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.alignas, rhs: SwiftProtoTesting_Names_MessageNames.alignas) -> Boolean {
    if lhs._alignas != rhs._alignas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.alignof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".alignof"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignof"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._alignof) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._alignof {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.alignof, rhs: SwiftProtoTesting_Names_MessageNames.alignof) -> Boolean {
    if lhs._alignof != rhs._alignof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.asm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".asm"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asm"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._asm) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._asm {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.asm, rhs: SwiftProtoTesting_Names_MessageNames.asm) -> Boolean {
    if lhs._asm != rhs._asm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.auto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".auto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._auto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._auto {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.auto, rhs: SwiftProtoTesting_Names_MessageNames.auto) -> Boolean {
    if lhs._auto != rhs._auto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.bitand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".bitand"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitand"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._bitand) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._bitand {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.bitand, rhs: SwiftProtoTesting_Names_MessageNames.bitand) -> Boolean {
    if lhs._bitand != rhs._bitand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.bitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".bitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._bitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._bitor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.bitor, rhs: SwiftProtoTesting_Names_MessageNames.bitor) -> Boolean {
    if lhs._bitor != rhs._bitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.bool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".bool"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bool"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._bool) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._bool {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.bool, rhs: SwiftProtoTesting_Names_MessageNames.bool) -> Boolean {
    if lhs._bool != rhs._bool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.char: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".char"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "char"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._char) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._char {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.char, rhs: SwiftProtoTesting_Names_MessageNames.char) -> Boolean {
    if lhs._char != rhs._char {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.char16_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".char16_t"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char16_t"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._char16T) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._char16T {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.char16_t, rhs: SwiftProtoTesting_Names_MessageNames.char16_t) -> Boolean {
    if lhs._char16T != rhs._char16T {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.char32_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".char32_t"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char32_t"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._char32T) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._char32T {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.char32_t, rhs: SwiftProtoTesting_Names_MessageNames.char32_t) -> Boolean {
    if lhs._char32T != rhs._char32T {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.compl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".compl"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compl"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._compl) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._compl {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.compl, rhs: SwiftProtoTesting_Names_MessageNames.compl) -> Boolean {
    if lhs._compl != rhs._compl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.const: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".const"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._const) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._const {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.const, rhs: SwiftProtoTesting_Names_MessageNames.const) -> Boolean {
    if lhs._const != rhs._const {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.constexpr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".constexpr"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constexpr"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._constexpr) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._constexpr {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.constexpr, rhs: SwiftProtoTesting_Names_MessageNames.constexpr) -> Boolean {
    if lhs._constexpr != rhs._constexpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.const_cast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".const_cast"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "const_cast"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._constCast) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._constCast {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.const_cast, rhs: SwiftProtoTesting_Names_MessageNames.const_cast) -> Boolean {
    if lhs._constCast != rhs._constCast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.decltype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".decltype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decltype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._decltype) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._decltype {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.decltype, rhs: SwiftProtoTesting_Names_MessageNames.decltype) -> Boolean {
    if lhs._decltype != rhs._decltype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.deimmutablee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".deimmutablee"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deimmutablee"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._deimmutablee) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._deimmutablee {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.deimmutablee, rhs: SwiftProtoTesting_Names_MessageNames.deimmutablee) -> Boolean {
    if lhs._deimmutablee != rhs._deimmutablee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.dynamic_cast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".dynamic_cast"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dynamic_cast"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._dynamicCast) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._dynamicCast {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.dynamic_cast, rhs: SwiftProtoTesting_Names_MessageNames.dynamic_cast) -> Boolean {
    if lhs._dynamicCast != rhs._dynamicCast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.explicit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".explicit"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "explicit"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._explicit) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._explicit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.explicit, rhs: SwiftProtoTesting_Names_MessageNames.explicit) -> Boolean {
    if lhs._explicit != rhs._explicit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".export"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "export"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._export) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._export {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.export, rhs: SwiftProtoTesting_Names_MessageNames.export) -> Boolean {
    if lhs._export != rhs._export {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.extern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".extern"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extern"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extern) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extern {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.extern, rhs: SwiftProtoTesting_Names_MessageNames.extern) -> Boolean {
    if lhs._extern != rhs._extern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".friend"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friend"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._friend) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._friend {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.friend, rhs: SwiftProtoTesting_Names_MessageNames.friend) -> Boolean {
    if lhs._friend != rhs._friend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.goto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".goto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._goto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._goto {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.goto, rhs: SwiftProtoTesting_Names_MessageNames.goto) -> Boolean {
    if lhs._goto != rhs._goto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.inline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".inline"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inline"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._inline) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._inline {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.inline, rhs: SwiftProtoTesting_Names_MessageNames.inline) -> Boolean {
    if lhs._inline != rhs._inline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.long: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".long"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "long"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._long) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._long {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.long, rhs: SwiftProtoTesting_Names_MessageNames.long) -> Boolean {
    if lhs._long != rhs._long {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.mutable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".mutable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mutable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._mutable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._mutable {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.mutable, rhs: SwiftProtoTesting_Names_MessageNames.mutable) -> Boolean {
    if lhs._mutable != rhs._mutable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".namespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._namespace) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._namespace {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.namespace, rhs: SwiftProtoTesting_Names_MessageNames.namespace) -> Boolean {
    if lhs._namespace != rhs._namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.new: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".new"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "new"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._new) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._new {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.new, rhs: SwiftProtoTesting_Names_MessageNames.new) -> Boolean {
    if lhs._new != rhs._new {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.noexcept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".noexcept"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noexcept"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._noexcept) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._noexcept {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.noexcept, rhs: SwiftProtoTesting_Names_MessageNames.noexcept) -> Boolean {
    if lhs._noexcept != rhs._noexcept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.not: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".not"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "not"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._not) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._not {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.not, rhs: SwiftProtoTesting_Names_MessageNames.not) -> Boolean {
    if lhs._not != rhs._not {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.not_eq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".not_eq"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "not_eq"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._notEq) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._notEq {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.not_eq, rhs: SwiftProtoTesting_Names_MessageNames.not_eq) -> Boolean {
    if lhs._notEq != rhs._notEq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.nullptr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".nullptr"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nullptr"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._nullptr) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._nullptr {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.nullptr, rhs: SwiftProtoTesting_Names_MessageNames.nullptr) -> Boolean {
    if lhs._nullptr != rhs._nullptr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.or: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".or"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "or"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._or) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._or {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.or, rhs: SwiftProtoTesting_Names_MessageNames.or) -> Boolean {
    if lhs._or != rhs._or {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.or_eq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".or_eq"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "or_eq"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._orEq) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._orEq {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.or_eq, rhs: SwiftProtoTesting_Names_MessageNames.or_eq) -> Boolean {
    if lhs._orEq != rhs._orEq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.protected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".protected"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protected"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._protected) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._protected {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.protected, rhs: SwiftProtoTesting_Names_MessageNames.protected) -> Boolean {
    if lhs._protected != rhs._protected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.register: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".register"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "register"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._register) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._register {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.register, rhs: SwiftProtoTesting_Names_MessageNames.register) -> Boolean {
    if lhs._register != rhs._register {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.reinterpret_cast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".reinterpret_cast"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reinterpret_cast"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._reinterpretCast) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._reinterpretCast {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.reinterpret_cast, rhs: SwiftProtoTesting_Names_MessageNames.reinterpret_cast) -> Boolean {
    if lhs._reinterpretCast != rhs._reinterpretCast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.short: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".short"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "short"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._short) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._short {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.short, rhs: SwiftProtoTesting_Names_MessageNames.short) -> Boolean {
    if lhs._short != rhs._short {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.signed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".signed"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signed"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._signed) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._signed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.signed, rhs: SwiftProtoTesting_Names_MessageNames.signed) -> Boolean {
    if lhs._signed != rhs._signed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.sizeof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".sizeof"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sizeof"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._sizeof) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._sizeof {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.sizeof, rhs: SwiftProtoTesting_Names_MessageNames.sizeof) -> Boolean {
    if lhs._sizeof != rhs._sizeof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.static_assert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".static_assert"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "static_assert"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._staticAssert) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._staticAssert {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.static_assert, rhs: SwiftProtoTesting_Names_MessageNames.static_assert) -> Boolean {
    if lhs._staticAssert != rhs._staticAssert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.static_cast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".static_cast"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "static_cast"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._staticCast) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._staticCast {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.static_cast, rhs: SwiftProtoTesting_Names_MessageNames.static_cast) -> Boolean {
    if lhs._staticCast != rhs._staticCast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.template: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".template"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "template"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._template) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._template {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.template, rhs: SwiftProtoTesting_Names_MessageNames.template) -> Boolean {
    if lhs._template != rhs._template {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.this: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".this"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "this"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._this) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._this {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.this, rhs: SwiftProtoTesting_Names_MessageNames.this) -> Boolean {
    if lhs._this != rhs._this {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.thread_local: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".thread_local"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "thread_local"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._threadLocal) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._threadLocal {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.thread_local, rhs: SwiftProtoTesting_Names_MessageNames.thread_local) -> Boolean {
    if lhs._threadLocal != rhs._threadLocal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.typedef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".typedef"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typedef"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._typedef) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._typedef {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.typedef, rhs: SwiftProtoTesting_Names_MessageNames.typedef) -> Boolean {
    if lhs._typedef != rhs._typedef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.typeid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".typeid"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeid"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._typeid) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._typeid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.typeid, rhs: SwiftProtoTesting_Names_MessageNames.typeid) -> Boolean {
    if lhs._typeid != rhs._typeid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.typename: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".typename"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typename"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._typename) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._typename {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.typename, rhs: SwiftProtoTesting_Names_MessageNames.typename) -> Boolean {
    if lhs._typename != rhs._typename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".union"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "union"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._union) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._union {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.union, rhs: SwiftProtoTesting_Names_MessageNames.union) -> Boolean {
    if lhs._union != rhs._union {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.unsigned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".unsigned"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unsigned"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._unsigned) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._unsigned {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.unsigned, rhs: SwiftProtoTesting_Names_MessageNames.unsigned) -> Boolean {
    if lhs._unsigned != rhs._unsigned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.using: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".using"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "using"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._using) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._using {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.using, rhs: SwiftProtoTesting_Names_MessageNames.using) -> Boolean {
    if lhs._using != rhs._using {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.virtual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".virtual"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "virtual"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._virtual) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._virtual {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.virtual, rhs: SwiftProtoTesting_Names_MessageNames.virtual) -> Boolean {
    if lhs._virtual != rhs._virtual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.void: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".void"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "void"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._void) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._void {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.void, rhs: SwiftProtoTesting_Names_MessageNames.void) -> Boolean {
    if lhs._void != rhs._void {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.volatile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".volatile"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volatile"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._volatile) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._volatile {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.volatile, rhs: SwiftProtoTesting_Names_MessageNames.volatile) -> Boolean {
    if lhs._volatile != rhs._volatile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.wchar_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".wchar_t"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wchar_t"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._wcharT) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._wcharT {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.wchar_t, rhs: SwiftProtoTesting_Names_MessageNames.wchar_t) -> Boolean {
    if lhs._wcharT != rhs._wcharT {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.xor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".xor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "xor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._xor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._xor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.xor, rhs: SwiftProtoTesting_Names_MessageNames.xor) -> Boolean {
    if lhs._xor != rhs._xor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.xor_eq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".xor_eq"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "xor_eq"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._xorEq) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._xorEq {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.xor_eq, rhs: SwiftProtoTesting_Names_MessageNames.xor_eq) -> Boolean {
    if lhs._xorEq != rhs._xorEq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.restrict: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".restrict"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "restrict"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._restrict) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._restrict {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.restrict, rhs: SwiftProtoTesting_Names_MessageNames.restrict) -> Boolean {
    if lhs._restrict != rhs._restrict {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Category"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Category"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._category) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._category {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Category, rhs: SwiftProtoTesting_Names_MessageNames.Category) -> Boolean {
    if lhs._category != rhs._category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Ivar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Ivar"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Ivar"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._ivar) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._ivar {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Ivar, rhs: SwiftProtoTesting_Names_MessageNames.Ivar) -> Boolean {
    if lhs._ivar != rhs._ivar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Method: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Method"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Method"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._method) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._method {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Method, rhs: SwiftProtoTesting_Names_MessageNames.Method) -> Boolean {
    if lhs._method != rhs._method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.finalize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".finalize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finalize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._finalize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._finalize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.finalize, rhs: SwiftProtoTesting_Names_MessageNames.finalize) -> Boolean {
    if lhs._finalize != rhs._finalize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".hash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._hash) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._hash {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.hash, rhs: SwiftProtoTesting_Names_MessageNames.hash) -> Boolean {
    if lhs._hash != rhs._hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.dealloc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".dealloc"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dealloc"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._dealloc) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._dealloc {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.dealloc, rhs: SwiftProtoTesting_Names_MessageNames.dealloc) -> Boolean {
    if lhs._dealloc != rhs._dealloc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.superclass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".superclass"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "superclass"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._superclass) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._superclass {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.superclass, rhs: SwiftProtoTesting_Names_MessageNames.superclass) -> Boolean {
    if lhs._superclass != rhs._superclass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.retain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".retain"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retain"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._retain) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._retain {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.retain, rhs: SwiftProtoTesting_Names_MessageNames.retain) -> Boolean {
    if lhs._retain != rhs._retain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.release: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".release"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "release"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._release) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._release {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.release, rhs: SwiftProtoTesting_Names_MessageNames.release) -> Boolean {
    if lhs._release != rhs._release {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.autorelease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".autorelease"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "autorelease"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._autorelease) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._autorelease {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.autorelease, rhs: SwiftProtoTesting_Names_MessageNames.autorelease) -> Boolean {
    if lhs._autorelease != rhs._autorelease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.retainCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".retainCount"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retainCount"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._retainCount) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._retainCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.retainCount, rhs: SwiftProtoTesting_Names_MessageNames.retainCount) -> Boolean {
    if lhs._retainCount != rhs._retainCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.zone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".zone"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zone"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._zone) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._zone {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.zone, rhs: SwiftProtoTesting_Names_MessageNames.zone) -> Boolean {
    if lhs._zone != rhs._zone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.isProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".isProxy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isProxy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._isProxy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._isProxy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.isProxy, rhs: SwiftProtoTesting_Names_MessageNames.isProxy) -> Boolean {
    if lhs._isProxy != rhs._isProxy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.copy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".copy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._copy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._copy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.copy, rhs: SwiftProtoTesting_Names_MessageNames.copy) -> Boolean {
    if lhs._copy != rhs._copy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.mutableCopy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".mutableCopy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mutableCopy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._mutableCopy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._mutableCopy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.mutableCopy, rhs: SwiftProtoTesting_Names_MessageNames.mutableCopy) -> Boolean {
    if lhs._mutableCopy != rhs._mutableCopy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.classForCoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".classForCoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "classForCoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._classForCoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._classForCoder {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.classForCoder, rhs: SwiftProtoTesting_Names_MessageNames.classForCoder) -> Boolean {
    if lhs._classForCoder != rhs._classForCoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.clear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".clear"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clear"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._clear) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._clear {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.clear, rhs: SwiftProtoTesting_Names_MessageNames.clear) -> Boolean {
    if lhs._clear != rhs._clear {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".data"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._data) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._data {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.data, rhs: SwiftProtoTesting_Names_MessageNames.data) -> Boolean {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.delimitedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".delimitedData"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delimitedData"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._delimitedData) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._delimitedData {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.delimitedData, rhs: SwiftProtoTesting_Names_MessageNames.delimitedData) -> Boolean {
    if lhs._delimitedData != rhs._delimitedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.descriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".descriptor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._descriptor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._descriptor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.descriptor, rhs: SwiftProtoTesting_Names_MessageNames.descriptor) -> Boolean {
    if lhs._descriptor != rhs._descriptor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.extensionRegistry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".extensionRegistry"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extensionRegistry"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extensionRegistry) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extensionRegistry {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.extensionRegistry, rhs: SwiftProtoTesting_Names_MessageNames.extensionRegistry) -> Boolean {
    if lhs._extensionRegistry != rhs._extensionRegistry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.extensionsCurrentlySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".extensionsCurrentlySet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extensionsCurrentlySet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extensionsCurrentlySet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extensionsCurrentlySet {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.extensionsCurrentlySet, rhs: SwiftProtoTesting_Names_MessageNames.extensionsCurrentlySet) -> Boolean {
    if lhs._extensionsCurrentlySet != rhs._extensionsCurrentlySet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.isInitializedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".isInitialized"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isInitialized"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._isInitialized_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._isInitialized_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.isInitializedMessage, rhs: SwiftProtoTesting_Names_MessageNames.isInitializedMessage) -> Boolean {
    if lhs._isInitialized_p != rhs._isInitialized_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.serializedSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".serializedSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serializedSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._serializedSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._serializedSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.serializedSize, rhs: SwiftProtoTesting_Names_MessageNames.serializedSize) -> Boolean {
    if lhs._serializedSize != rhs._serializedSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.sortedExtensionsInUse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".sortedExtensionsInUse"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sortedExtensionsInUse"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._sortedExtensionsInUse) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._sortedExtensionsInUse {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.sortedExtensionsInUse, rhs: SwiftProtoTesting_Names_MessageNames.sortedExtensionsInUse) -> Boolean {
    if lhs._sortedExtensionsInUse != rhs._sortedExtensionsInUse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.unknownFieldsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".unknownFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknownFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._unknownFields_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._unknownFields_p {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.unknownFieldsMessage, rhs: SwiftProtoTesting_Names_MessageNames.unknownFieldsMessage) -> Boolean {
    if lhs._unknownFields_p != rhs._unknownFields_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Fixed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Fixed"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Fixed"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._fixed) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._fixed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Fixed, rhs: SwiftProtoTesting_Names_MessageNames.Fixed) -> Boolean {
    if lhs._fixed != rhs._fixed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Fract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Fract"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Fract"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._fract) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._fract {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Fract, rhs: SwiftProtoTesting_Names_MessageNames.Fract) -> Boolean {
    if lhs._fract != rhs._fract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Size"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Size"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._size) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._size {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Size, rhs: SwiftProtoTesting_Names_MessageNames.Size) -> Boolean {
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.LogicalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".LogicalAddress"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LogicalAddress"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._logicalAddress) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._logicalAddress {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.LogicalAddress, rhs: SwiftProtoTesting_Names_MessageNames.LogicalAddress) -> Boolean {
    if lhs._logicalAddress != rhs._logicalAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.PhysicalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".PhysicalAddress"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PhysicalAddress"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._physicalAddress) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._physicalAddress {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.PhysicalAddress, rhs: SwiftProtoTesting_Names_MessageNames.PhysicalAddress) -> Boolean {
    if lhs._physicalAddress != rhs._physicalAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ByteCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".ByteCount"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ByteCount"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._byteCount) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._byteCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ByteCount, rhs: SwiftProtoTesting_Names_MessageNames.ByteCount) -> Boolean {
    if lhs._byteCount != rhs._byteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ByteOffset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".ByteOffset"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ByteOffset"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._byteOffset) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._byteOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ByteOffset, rhs: SwiftProtoTesting_Names_MessageNames.ByteOffset) -> Boolean {
    if lhs._byteOffset != rhs._byteOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Duration"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Duration"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._duration) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._duration {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Duration, rhs: SwiftProtoTesting_Names_MessageNames.Duration) -> Boolean {
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.AbsoluteTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".AbsoluteTime"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AbsoluteTime"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._absoluteTime) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._absoluteTime {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.AbsoluteTime, rhs: SwiftProtoTesting_Names_MessageNames.AbsoluteTime) -> Boolean {
    if lhs._absoluteTime != rhs._absoluteTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.OptionBits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".OptionBits"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionBits"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._optionBits) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._optionBits {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.OptionBits, rhs: SwiftProtoTesting_Names_MessageNames.OptionBits) -> Boolean {
    if lhs._optionBits != rhs._optionBits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ItemCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".ItemCount"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ItemCount"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._itemCount) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._itemCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ItemCount, rhs: SwiftProtoTesting_Names_MessageNames.ItemCount) -> Boolean {
    if lhs._itemCount != rhs._itemCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.PBVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".PBVersion"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PBVersion"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._pbversion) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._pbversion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.PBVersion, rhs: SwiftProtoTesting_Names_MessageNames.PBVersion) -> Boolean {
    if lhs._pbversion != rhs._pbversion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ScriptCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".ScriptCode"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ScriptCode"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._scriptCode) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._scriptCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ScriptCode, rhs: SwiftProtoTesting_Names_MessageNames.ScriptCode) -> Boolean {
    if lhs._scriptCode != rhs._scriptCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.LangCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".LangCode"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LangCode"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._langCode) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._langCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.LangCode, rhs: SwiftProtoTesting_Names_MessageNames.LangCode) -> Boolean {
    if lhs._langCode != rhs._langCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.RegionCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".RegionCode"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RegionCode"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._regionCode) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._regionCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.RegionCode, rhs: SwiftProtoTesting_Names_MessageNames.RegionCode) -> Boolean {
    if lhs._regionCode != rhs._regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.OSType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".OSType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OSType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._ostype) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._ostype {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.OSType, rhs: SwiftProtoTesting_Names_MessageNames.OSType) -> Boolean {
    if lhs._ostype != rhs._ostype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ProcessSerialNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".ProcessSerialNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProcessSerialNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._processSerialNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._processSerialNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ProcessSerialNumber, rhs: SwiftProtoTesting_Names_MessageNames.ProcessSerialNumber) -> Boolean {
    if lhs._processSerialNumber != rhs._processSerialNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Point"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Point"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._point) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._point {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Point, rhs: SwiftProtoTesting_Names_MessageNames.Point) -> Boolean {
    if lhs._point != rhs._point {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Rect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Rect"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Rect"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._rect) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._rect {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Rect, rhs: SwiftProtoTesting_Names_MessageNames.Rect) -> Boolean {
    if lhs._rect != rhs._rect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.FixedPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".FixedPoint"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FixedPoint"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._fixedPoint) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._fixedPoint {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.FixedPoint, rhs: SwiftProtoTesting_Names_MessageNames.FixedPoint) -> Boolean {
    if lhs._fixedPoint != rhs._fixedPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.FixedRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".FixedRect"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FixedRect"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._fixedRect) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._fixedRect {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.FixedRect, rhs: SwiftProtoTesting_Names_MessageNames.FixedRect) -> Boolean {
    if lhs._fixedRect != rhs._fixedRect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Style"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Style"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._style) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._style {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Style, rhs: SwiftProtoTesting_Names_MessageNames.Style) -> Boolean {
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.StyleParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".StyleParameter"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StyleParameter"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._styleParameter) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._styleParameter {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.StyleParameter, rhs: SwiftProtoTesting_Names_MessageNames.StyleParameter) -> Boolean {
    if lhs._styleParameter != rhs._styleParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.StyleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".StyleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StyleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._styleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._styleField {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.StyleField, rhs: SwiftProtoTesting_Names_MessageNames.StyleField) -> Boolean {
    if lhs._styleField != rhs._styleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.TimeScale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".TimeScale"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TimeScale"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._timeScale) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._timeScale {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.TimeScale, rhs: SwiftProtoTesting_Names_MessageNames.TimeScale) -> Boolean {
    if lhs._timeScale != rhs._timeScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.TimeBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".TimeBase"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TimeBase"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._timeBase) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._timeBase {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.TimeBase, rhs: SwiftProtoTesting_Names_MessageNames.TimeBase) -> Boolean {
    if lhs._timeBase != rhs._timeBase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.TimeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".TimeRecord"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TimeRecord"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._timeRecord) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._timeRecord {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.TimeRecord, rhs: SwiftProtoTesting_Names_MessageNames.TimeRecord) -> Boolean {
    if lhs._timeRecord != rhs._timeRecord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.serializedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".serializedData"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serializedData"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._serializedData) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._serializedData {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.serializedData, rhs: SwiftProtoTesting_Names_MessageNames.serializedData) -> Boolean {
    if lhs._serializedData != rhs._serializedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.jsonUTF8Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".jsonUTF8Data"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonUTF8Data"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._jsonUtf8Data) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._jsonUtf8Data {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.jsonUTF8Data, rhs: SwiftProtoTesting_Names_MessageNames.jsonUTF8Data) -> Boolean {
    if lhs._jsonUtf8Data != rhs._jsonUtf8Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.jsonString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".jsonString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._jsonString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._jsonString {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.jsonString, rhs: SwiftProtoTesting_Names_MessageNames.jsonString) -> Boolean {
    if lhs._jsonString != rhs._jsonString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.Extension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Extension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Extension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extension {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.Extension, rhs: SwiftProtoTesting_Names_MessageNames.Extension) -> Boolean {
    if lhs._extension != rhs._extension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_MessageNames.ExtensionsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_MessageNames.protoMessageName + ".Extensions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Extensions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._extensions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._extensions {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_MessageNames.ExtensionsMessage, rhs: SwiftProtoTesting_Names_MessageNames.ExtensionsMessage) -> Boolean {
    if lhs._extensions != rhs._extensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_EnumNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".EnumNames"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_EnumNames, rhs: SwiftProtoTesting_Names_EnumNames) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_EnumNames.StringEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aString"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ProtocolEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aProtocol"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.IntEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aInt"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.DoubleEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aDouble"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.FloatEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aFloat"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.UIntEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aUInt"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.hashValueEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ahashValue"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.descriptionEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adescription"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.debugDescriptionEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adebugDescription"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.SwiftEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aSwift"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.UNRECOGNIZED: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aUNRECOGNIZED"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.classEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aclass"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.deinitEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adeinit"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.enumEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aenum"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.extensionEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aextension"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.funcEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afunc"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.importEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aimport"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.initEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ainit"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.inoutEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ainout"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.internalEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ainternal"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.immutableEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aimmutable"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.operatorEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aoperator"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.privateEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aprivate"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.protocolEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aprotocol"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.publicEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "apublic"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.staticEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "astatic"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.structEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "astruct"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.subscriptEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asubscript"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.typealiasEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atypealias"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.varEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "avar"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.breakEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abreak"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.caseEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "acase"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.continueEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "acontinue"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.defaultEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adefault"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.deferEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adefer"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.doEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ado"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.elseEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aelse"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.fallthroughEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afallthrough"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.forEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afor"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.guardEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aguard"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ifEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aif"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.inEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ain"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.repeatEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "arepeat"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.returnEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "areturn"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.switchEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aswitch"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.whereEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "awhere"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.whileEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "awhile"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.asEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aas"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.catchEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "acatch"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.dynamicTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adynamicType"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.falseEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afalse"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.isEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ais"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.nilEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anil"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.rethrowsEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "arethrows"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.superEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asuper"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.selfEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aself"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.throwEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "athrow"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.throwsEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "athrows"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.trueEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atrue"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.tryEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atry"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.__COLUMN__Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a__COLUMN__"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.__FILE__Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a__FILE__"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.__FUNCTION__Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a__FUNCTION__"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.__LINE__Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a__LINE__"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames._Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a_"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.__Enum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a__"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.associativity: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aassociativity"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.convenience: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aconvenience"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.dynamic: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adynamic"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.didSet: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adidSet"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.final: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afinal"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.get: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aget"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.infix: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ainfix"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.indirect: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aindirect"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.lazy: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "alazy"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.left: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aleft"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.mutating: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "amutating"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.none: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anone"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.nonmutating: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anonmutating"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.optional: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aoptional"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.override: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aoverride"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.postfix: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "apostfix"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.precedence: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aprecedence"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.prefix: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aprefix"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.required: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "arequired"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.right: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aright"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.set: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aset"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aType"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.unowned: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aunowned"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.weak: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aweak"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.willSet: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "awillSet"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.id: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aid"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames._cmd: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a_cmd"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.out: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aout"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.bycopy: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abycopy"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.byref: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abyref"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.oneway: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aoneway"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.and: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aand"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.and_eq: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aand_eq"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.alignas: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aalignas"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.alignof: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aalignof"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.asm: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aasm"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.auto: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aauto"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.bitand: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abitand"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.bitor: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abitor"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.bool: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "abool"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.char: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "achar"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.char16_t: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "achar16_t"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.char32_t: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "achar32_t"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.compl: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "acompl"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.const: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aconst"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.constexpr: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aconstexpr"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.const_cast: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aconst_cast"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.decltype: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adecltype"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.deimmutablee: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adeimmutablee"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.dynamic_cast: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adynamic_cast"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.explicit: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aexplicit"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.export: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aexport"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.extern: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aextern"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.friend: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afriend"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.goto: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "agoto"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.inline: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ainline"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.long: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "along"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.mutable: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "amutable"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.namespace: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anamespace"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.new: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anew"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.noexcept: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anoexcept"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.not: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anot"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.not_eq: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anot_eq"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.nullptr: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "anullptr"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.or: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aor"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.or_eq: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aor_eq"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.protected: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aprotected"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.register: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aregister"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.reinterpret_cast: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "areinterpret_cast"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.short: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ashort"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.signed: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asigned"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.sizeof: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asizeof"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.static_assert: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "astatic_assert"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.static_cast: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "astatic_cast"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.template: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atemplate"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.this: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "athis"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.thread_local: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "athread_local"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.typedef: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atypedef"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.typeid: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atypeid"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.typename: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "atypename"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.union: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aunion"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.unsigned: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aunsigned"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.using: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ausing"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.virtual: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "avirtual"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.void: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "avoid"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.volatile: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "avolatile"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.wchar_t: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "awchar_t"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.xor: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "axor"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.xor_eq: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "axor_eq"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.restrict: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "arestrict"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Category: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aCategory"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Ivar: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aIvar"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Method: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aMethod"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.finalize: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "afinalize"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.hash: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ahash"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.dealloc: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adealloc"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.superclass: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asuperclass"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.retain: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aretain"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.release: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "arelease"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.autorelease: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aautorelease"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.retainCount: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aretainCount"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.zone: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "azone"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.isProxy: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aisProxy"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.copy: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "acopy"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.mutableCopy: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "amutableCopy"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.classForCoder: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aclassForCoder"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.clear: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aclear"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.data: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adata"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.delimitedData: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adelimitedData"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.descriptor: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "adescriptor"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.extensionRegistry: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aextensionRegistry"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.extensionsCurrentlySet: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aextensionsCurrentlySet"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.isInitializedEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aisInitialized"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.serializedSize: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aserializedSize"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.sortedExtensionsInUse: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "asortedExtensionsInUse"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.unknownFieldsEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aunknownFields"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Fixed: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aFixed"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Fract: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aFract"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Size: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aSize"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.LogicalAddress: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aLogicalAddress"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.PhysicalAddress: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aPhysicalAddress"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ByteCount: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aByteCount"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ByteOffset: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aByteOffset"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Duration: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aDuration"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.AbsoluteTime: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aAbsoluteTime"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.OptionBits: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aOptionBits"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ItemCount: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aItemCount"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.PBVersion: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aPBVersion"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ScriptCode: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aScriptCode"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.LangCode: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aLangCode"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.RegionCode: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aRegionCode"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.OSType: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aOSType"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ProcessSerialNumber: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aProcessSerialNumber"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Point: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aPoint"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Rect: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aRect"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.FixedPoint: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aFixedPoint"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.FixedRect: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aFixedRect"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Style: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aStyle"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.StyleParameter: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aStyleParameter"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.StyleField: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aStyleField"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.TimeScale: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aTimeScale"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.TimeBase: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aTimeBase"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.TimeRecord: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aTimeRecord"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.Extension: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aExtension"),
  ]
}

extension SwiftProtoTesting_Names_EnumNames.ExtensionsEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "aExtensions"),
  ]
}

extension SwiftProtoTesting_Names_FieldNamingInitials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".FieldNamingInitials"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_FieldNamingInitials, rhs: SwiftProtoTesting_Names_FieldNamingInitials) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_FieldNamingInitials.Lowers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_FieldNamingInitials.protoMessageName + ".Lowers"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "http"),
    2: .standard(proto: "http_request"),
    3: .standard(proto: "the_http_request"),
    4: .standard(proto: "the_http"),
    11: .same(proto: "https"),
    12: .standard(proto: "https_request"),
    13: .standard(proto: "the_https_request"),
    14: .standard(proto: "the_https"),
    21: .same(proto: "url"),
    22: .standard(proto: "url_value"),
    23: .standard(proto: "the_url_value"),
    24: .standard(proto: "the_url"),
    31: .standard(proto: "a_b_c"),
    41: .same(proto: "id"),
    42: .standard(proto: "id_number"),
    43: .standard(proto: "the_id_number"),
    44: .standard(proto: "request_id"),
  ]

  fileprivate class _StorageClass {
    var _http: Int32? = Nothing
    var _httpRequest: Int32? = Nothing
    var _theHTTPRequest: Int32? = Nothing
    var _theHTTP: Int32? = Nothing
    var _https: Int32? = Nothing
    var _httpsRequest: Int32? = Nothing
    var _theHTTPSRequest: Int32? = Nothing
    var _theHTTPS: Int32? = Nothing
    var _url: Int32? = Nothing
    var _urlValue: Int32? = Nothing
    var _theURLValue: Int32? = Nothing
    var _theURL: Int32? = Nothing
    var _aBC: Int32? = Nothing
    var _id: Int32? = Nothing
    var _idNumber: Int32? = Nothing
    var _theIDNumber: Int32? = Nothing
    var _requestID: Int32? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _http = source._http
      _httpRequest = source._httpRequest
      _theHTTPRequest = source._theHTTPRequest
      _theHTTP = source._theHTTP
      _https = source._https
      _httpsRequest = source._httpsRequest
      _theHTTPSRequest = source._theHTTPSRequest
      _theHTTPS = source._theHTTPS
      _url = source._url
      _urlValue = source._urlValue
      _theURLValue = source._theURLValue
      _theURL = source._theURL
      _aBC = source._aBC
      _id = source._id
      _idNumber = source._idNumber
      _theIDNumber = source._theIDNumber
      _requestID = source._requestID
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._http) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._httpRequest) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._theHTTPRequest) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._theHTTP) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._https) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._httpsRequest) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._theHTTPSRequest) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._theHTTPS) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._url) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._urlValue) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._theURLValue) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._theURL) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._aBC) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._idNumber) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._theIDNumber) }()
        case 44: try { try decoder.decodeSingularInt32Field(value: &_storage._requestID) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._http {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._httpRequest {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if immutable v = _storage._theHTTPRequest {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if immutable v = _storage._theHTTP {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if immutable v = _storage._https {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if immutable v = _storage._httpsRequest {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if immutable v = _storage._theHTTPSRequest {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if immutable v = _storage._theHTTPS {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if immutable v = _storage._url {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
      } }()
      try { if immutable v = _storage._urlValue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if immutable v = _storage._theURLValue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 23)
      } }()
      try { if immutable v = _storage._theURL {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if immutable v = _storage._aBC {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 31)
      } }()
      try { if immutable v = _storage._id {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
      } }()
      try { if immutable v = _storage._idNumber {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if immutable v = _storage._theIDNumber {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
      } }()
      try { if immutable v = _storage._requestID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 44)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_FieldNamingInitials.Lowers, rhs: SwiftProtoTesting_Names_FieldNamingInitials.Lowers) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._http != rhs_storage._http {return false}
        if _storage._httpRequest != rhs_storage._httpRequest {return false}
        if _storage._theHTTPRequest != rhs_storage._theHTTPRequest {return false}
        if _storage._theHTTP != rhs_storage._theHTTP {return false}
        if _storage._https != rhs_storage._https {return false}
        if _storage._httpsRequest != rhs_storage._httpsRequest {return false}
        if _storage._theHTTPSRequest != rhs_storage._theHTTPSRequest {return false}
        if _storage._theHTTPS != rhs_storage._theHTTPS {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._urlValue != rhs_storage._urlValue {return false}
        if _storage._theURLValue != rhs_storage._theURLValue {return false}
        if _storage._theURL != rhs_storage._theURL {return false}
        if _storage._aBC != rhs_storage._aBC {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._idNumber != rhs_storage._idNumber {return false}
        if _storage._theIDNumber != rhs_storage._theIDNumber {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_FieldNamingInitials.Uppers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_FieldNamingInitials.protoMessageName + ".Uppers"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HTTP"),
    2: .standard(proto: "HTTP_request"),
    3: .standard(proto: "the_HTTP_request"),
    4: .standard(proto: "the_HTTP"),
    11: .same(proto: "HTTPS"),
    12: .standard(proto: "HTTPS_request"),
    13: .standard(proto: "the_HTTPS_request"),
    14: .standard(proto: "the_HTTPS"),
    21: .same(proto: "URL"),
    22: .standard(proto: "URL_value"),
    23: .standard(proto: "the_URL_value"),
    24: .standard(proto: "the_URL"),
    41: .same(proto: "ID"),
    42: .standard(proto: "ID_number"),
    43: .standard(proto: "the_ID_number"),
    44: .standard(proto: "request_ID"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._http) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &this._httpRequest) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPRequest) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &this._theHTTP) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &this._https) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &this._httpsRequest) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPSRequest) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPS) }()
      case 21: try { try decoder.decodeSingularInt32Field(value: &this._url) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &this._urlValue) }()
      case 23: try { try decoder.decodeSingularInt32Field(value: &this._theURLValue) }()
      case 24: try { try decoder.decodeSingularInt32Field(value: &this._theURL) }()
      case 41: try { try decoder.decodeSingularInt32Field(value: &this._id) }()
      case 42: try { try decoder.decodeSingularInt32Field(value: &this._idNumber) }()
      case 43: try { try decoder.decodeSingularInt32Field(value: &this._theIDNumber) }()
      case 44: try { try decoder.decodeSingularInt32Field(value: &this._requestID) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._http {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._httpRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._theHTTPRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if immutable v = this._theHTTP {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if immutable v = this._https {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if immutable v = this._httpsRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try { if immutable v = this._theHTTPSRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
    } }()
    try { if immutable v = this._theHTTPS {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if immutable v = this._url {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
    } }()
    try { if immutable v = this._urlValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
    } }()
    try { if immutable v = this._theURLValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 23)
    } }()
    try { if immutable v = this._theURL {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
    } }()
    try { if immutable v = this._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
    } }()
    try { if immutable v = this._idNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
    } }()
    try { if immutable v = this._theIDNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
    } }()
    try { if immutable v = this._requestID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 44)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_FieldNamingInitials.Uppers, rhs: SwiftProtoTesting_Names_FieldNamingInitials.Uppers) -> Boolean {
    if lhs._http != rhs._http {return false}
    if lhs._httpRequest != rhs._httpRequest {return false}
    if lhs._theHTTPRequest != rhs._theHTTPRequest {return false}
    if lhs._theHTTP != rhs._theHTTP {return false}
    if lhs._https != rhs._https {return false}
    if lhs._httpsRequest != rhs._httpsRequest {return false}
    if lhs._theHTTPSRequest != rhs._theHTTPSRequest {return false}
    if lhs._theHTTPS != rhs._theHTTPS {return false}
    if lhs._url != rhs._url {return false}
    if lhs._urlValue != rhs._urlValue {return false}
    if lhs._theURLValue != rhs._theURLValue {return false}
    if lhs._theURL != rhs._theURL {return false}
    if lhs._id != rhs._id {return false}
    if lhs._idNumber != rhs._idNumber {return false}
    if lhs._theIDNumber != rhs._theIDNumber {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_FieldNamingInitials.WordCase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Names_FieldNamingInitials.protoMessageName + ".WordCase"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Http"),
    2: .same(proto: "HttpRequest"),
    3: .same(proto: "TheHttpRequest"),
    4: .same(proto: "TheHttp"),
    11: .same(proto: "Https"),
    12: .same(proto: "HttpsRequest"),
    13: .same(proto: "TheHttpsRequest"),
    14: .same(proto: "TheHttps"),
    21: .same(proto: "Url"),
    22: .same(proto: "UrlValue"),
    23: .same(proto: "TheUrlValue"),
    24: .same(proto: "TheUrl"),
    41: .same(proto: "Id"),
    42: .same(proto: "IdNumber"),
    43: .same(proto: "TheIdNumber"),
    44: .same(proto: "RequestId"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this._http) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &this._httpRequest) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPRequest) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &this._theHTTP) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &this._https) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &this._httpsRequest) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPSRequest) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &this._theHTTPS) }()
      case 21: try { try decoder.decodeSingularInt32Field(value: &this._url) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &this._urlValue) }()
      case 23: try { try decoder.decodeSingularInt32Field(value: &this._theURLValue) }()
      case 24: try { try decoder.decodeSingularInt32Field(value: &this._theURL) }()
      case 41: try { try decoder.decodeSingularInt32Field(value: &this._id) }()
      case 42: try { try decoder.decodeSingularInt32Field(value: &this._idNumber) }()
      case 43: try { try decoder.decodeSingularInt32Field(value: &this._theIDNumber) }()
      case 44: try { try decoder.decodeSingularInt32Field(value: &this._requestID) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._http {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._httpRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this._theHTTPRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if immutable v = this._theHTTP {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if immutable v = this._https {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if immutable v = this._httpsRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try { if immutable v = this._theHTTPSRequest {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
    } }()
    try { if immutable v = this._theHTTPS {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if immutable v = this._url {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 21)
    } }()
    try { if immutable v = this._urlValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
    } }()
    try { if immutable v = this._theURLValue {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 23)
    } }()
    try { if immutable v = this._theURL {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
    } }()
    try { if immutable v = this._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
    } }()
    try { if immutable v = this._idNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
    } }()
    try { if immutable v = this._theIDNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
    } }()
    try { if immutable v = this._requestID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 44)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_FieldNamingInitials.WordCase, rhs: SwiftProtoTesting_Names_FieldNamingInitials.WordCase) -> Boolean {
    if lhs._http != rhs._http {return false}
    if lhs._httpRequest != rhs._httpRequest {return false}
    if lhs._theHTTPRequest != rhs._theHTTPRequest {return false}
    if lhs._theHTTP != rhs._theHTTP {return false}
    if lhs._https != rhs._https {return false}
    if lhs._httpsRequest != rhs._httpsRequest {return false}
    if lhs._theHTTPSRequest != rhs._theHTTPSRequest {return false}
    if lhs._theHTTPS != rhs._theHTTPS {return false}
    if lhs._url != rhs._url {return false}
    if lhs._urlValue != rhs._urlValue {return false}
    if lhs._theURLValue != rhs._theURLValue {return false}
    if lhs._theURL != rhs._theURL {return false}
    if lhs._id != rhs._id {return false}
    if lhs._idNumber != rhs._idNumber {return false}
    if lhs._theIDNumber != rhs._theIDNumber {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".ExtensionNamingInitials"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Boolean {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      if (1 <= fieldNumber && fieldNumber < 1001) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: SwiftProtoTesting_Names_ExtensionNamingInitials.this, fieldNumber: fieldNumber)
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1, end: 1001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_ExtensionNamingInitials, rhs: SwiftProtoTesting_Names_ExtensionNamingInitials) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_Lowers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".Lowers"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_Lowers, rhs: SwiftProtoTesting_Names_Lowers) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_Uppers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".Uppers"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_Uppers, rhs: SwiftProtoTesting_Names_Uppers) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_WordCase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".WordCase"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_WordCase, rhs: SwiftProtoTesting_Names_WordCase) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsLowers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".ExtensionNamingInitialsLowers"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Boolean {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      if (1 <= fieldNumber && fieldNumber < 1001) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: SwiftProtoTesting_Names_ExtensionNamingInitialsLowers.this, fieldNumber: fieldNumber)
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1, end: 1001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_ExtensionNamingInitialsLowers, rhs: SwiftProtoTesting_Names_ExtensionNamingInitialsLowers) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsUppers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".ExtensionNamingInitialsUppers"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Boolean {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      if (1 <= fieldNumber && fieldNumber < 1001) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: SwiftProtoTesting_Names_ExtensionNamingInitialsUppers.this, fieldNumber: fieldNumber)
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1, end: 1001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_ExtensionNamingInitialsUppers, rhs: SwiftProtoTesting_Names_ExtensionNamingInitialsUppers) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".ExtensionNamingInitialsWordCase"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Boolean {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      if (1 <= fieldNumber && fieldNumber < 1001) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase.this, fieldNumber: fieldNumber)
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1, end: 1001)
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase, rhs: SwiftProtoTesting_Names_ExtensionNamingInitialsWordCase) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ValidIdentifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".ValidIdentifiers"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "_1field"),
    2: .standard(proto: "_field"),
    3: .standard(proto: "_3field_3"),
    4: .standard(proto: "_4"),
    5: .standard(proto: "_5field"),
    6: .standard(proto: "enum_field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.__1Field) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &this._field) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &this.__3Field3) }()
      case 4: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if immutable v = v {
          if this._2Of != Nothing {try decoder.handleConflictingOneOf()}
          this._2Of = ._4(v)
        }
      }()
      case 5: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if immutable v = v {
          if this._2Of != Nothing {try decoder.handleConflictingOneOf()}
          this._2Of = ._5Field(v)
        }
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &this._enumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this.__1Field {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if immutable v = this._field {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if immutable v = this.__3Field3 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    switch this._2Of {
    case ._4?: try {
      guard case ._4(immutable v)? = this._2Of else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }()
    case ._5Field?: try {
      guard case ._5Field(immutable v)? = this._2Of else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }()
    case Nothing: break
    }
    try { if immutable v = this._enumField {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_ValidIdentifiers, rhs: SwiftProtoTesting_Names_ValidIdentifiers) -> Boolean {
    if lhs.__1Field != rhs.__1Field {return false}
    if lhs._field != rhs._field {return false}
    if lhs.__3Field3 != rhs.__3Field3 {return false}
    if lhs._2Of != rhs._2Of {return false}
    if lhs._enumField != rhs._enumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_ValidIdentifiers.TestEnum: SwiftProtobuf._ProtoNameProviding {
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_ENUM_0"),
    1: .same(proto: "TEST_ENUM_FIRST"),
    2: .same(proto: "_2"),
    3: .same(proto: "_3_VALUE"),
  ]
}

extension SwiftProtoTesting_Names_SpecialNames1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".SpecialNames1"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "str"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if immutable v = v {
          if this.newValue != Nothing {try decoder.handleConflictingOneOf()}
          this.newValue = .str(v)
        }
      }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .str(immutable v)? = this.newValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_SpecialNames1, rhs: SwiftProtoTesting_Names_SpecialNames1) -> Boolean {
    if lhs.newValue != rhs.newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_SpecialNames2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".SpecialNames2"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &this._newValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if immutable v = this._newValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_SpecialNames2, rhs: SwiftProtoTesting_Names_SpecialNames2) -> Boolean {
    if lhs._newValue != rhs._newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_SpecialNames3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".SpecialNames3"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "str"),
    2: .standard(proto: "forces_storage"),
  ]

  fileprivate class _StorageClass {
    var _newValue: SwiftProtoTesting_Names_SpecialNames3.OneOf_NewValue?
    var _forcesStorage: SwiftProtoTesting_Names_SpecialNames3? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _newValue = source._newValue
      _forcesStorage = source._forcesStorage
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if immutable v = v {
            if _storage._newValue != Nothing {try decoder.handleConflictingOneOf()}
            _storage._newValue = .str(v)
          }
        }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._forcesStorage) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if case .str(immutable v)? = _storage._newValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._forcesStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_SpecialNames3, rhs: SwiftProtoTesting_Names_SpecialNames3) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._newValue != rhs_storage._newValue {return false}
        if _storage._forcesStorage != rhs_storage._forcesStorage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Names_SpecialNames4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".SpecialNames4"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_value"),
    2: .standard(proto: "forces_storage"),
  ]

  fileprivate class _StorageClass {
    var _newValue: String? = Nothing
    var _forcesStorage: SwiftProtoTesting_Names_SpecialNames4? = Nothing

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) immutable defaultInstance = _StorageClass()
    #else
      static immutable defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _newValue = source._newValue
      _forcesStorage = source._forcesStorage
    }
  }

  fileprivate mutating fn _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while immutable fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._newValue) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._forcesStorage) }()
        default: break
        }
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if immutable v = _storage._newValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if immutable v = _storage._forcesStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Names_SpecialNames4, rhs: SwiftProtoTesting_Names_SpecialNames4) -> Boolean {
    if lhs._storage !== rhs._storage {
      immutable storagesAreEqual: Boolean = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        immutable _storage = _args.0
        immutable rhs_storage = _args.1
        if _storage._newValue != rhs_storage._newValue {return false}
        if _storage._forcesStorage != rhs_storage._forcesStorage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
