// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: generated_swift_names_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// See Makefile for the logic that generates this
/// Protoc errors imply this file is being generated incorrectly
/// Swift compile errors are probably bugs in protoc-gen-swift

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct adjusted: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var adjusted: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct aggregateValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var aggregateValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct allCases: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var allCases: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct allowAlias: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var allowAlias: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct alwaysPrintEnumsAsInts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alwaysPrintEnumsAsInts: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct alwaysPrintInt64sAsNumbers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alwaysPrintInt64SAsNumbers: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct annotation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var annotation: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct any: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var any: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AnyExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var anyExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AnyMessageExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var anyMessageExtension: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AnyMessageStorage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var anyMessageStorage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AnyUnpackError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var anyUnpackError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Api: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var api: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct appended: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appended: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct appendUIntHex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appendUintHex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct appendUnknown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appendUnknown: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct areAllInitialized: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var areAllInitialized: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Array: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var array: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct arrayDepth: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var arrayDepth: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct arrayLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var arrayLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct arraySeparator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var arraySeparator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct asMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `as`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct asciiOpenCurlyBracket: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asciiOpenCurlyBracket: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct asciiZero: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asciiZero: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct async: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var async: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AsyncIterator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asyncIterator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AsyncIteratorProtocol: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asyncIteratorProtocol: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AsyncMessageSequence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var asyncMessageSequence: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct available: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var available: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct b: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var b: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Base: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var base: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct base64Values: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var base64Values: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct baseAddress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var baseAddress: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BaseType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var baseType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct begin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var begin: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct binary: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binary: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryDecoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryDecoding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryDecodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryDecodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryDecodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryDecodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryDelimited: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryDelimited: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingMessageSetSizeVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingMessageSetSizeVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingMessageSetVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingMessageSetVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingSizeVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingSizeVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryEncodingVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryEncodingVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct binaryOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct binaryProtobufDelimitedMessages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryProtobufDelimitedMessages: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BinaryStreamDecoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryStreamDecoding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct binaryStreamDecodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var binaryStreamDecodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct bitPattern: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bitPattern: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct body: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var body: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BoolMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bool: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct booleanLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var booleanLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BooleanLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var booleanLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct boolValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var boolValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct buffer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var buffer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct bytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct bytesInGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytesInGroup: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct bytesNeeded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytesNeeded: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct bytesRead: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytesRead: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BytesValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytesValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct c: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var c: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct capitalizeNext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var capitalizeNext: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct cardinality: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cardinality: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CaseIterable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var caseIterable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ccEnableArenas: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ccEnableArenas: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ccGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ccGenericServices: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Character: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var character: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct chars: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var chars: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct chunk: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var chunk: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct classMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `class`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearAggregateValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearAggregateValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearAllowAlias: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearAllowAlias_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearBegin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearBegin_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearCcEnableArenas: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearCcEnableArenas_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearCcGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearCcGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearClientStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearClientStreaming_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearCsharpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearCsharpNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearCtype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearCtype_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDebugRedact: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDebugRedact_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDefaultValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDefaultValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDeprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDeprecated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDeprecatedLegacyJsonFieldConflicts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDeprecatedLegacyJsonFieldConflicts_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDeprecationWarning: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDeprecationWarning_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearDoubleValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearDoubleValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEditionDeprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEditionDeprecated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEditionIntroduced: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEditionIntroduced_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEditionRemoved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEditionRemoved_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEnd: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEnd_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearEnumType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearEnumType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearExtendee: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearExtendee_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearExtensionValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearExtensionValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearFeatureSupport: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearFeatureSupport_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearFieldPresence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearFieldPresence_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearFixedFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearFixedFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearFullName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearFullName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearGoPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearGoPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearIdempotencyLevel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearIdempotencyLevel_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearIdentifierValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearIdentifierValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearInputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearInputType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearIsExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearIsExtension_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaGenerateEqualsAndHash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaGenerateEqualsAndHash_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaMultipleFiles: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaMultipleFiles_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaOuterClassname: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaOuterClassname_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJavaStringCheckUtf8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJavaStringCheckUtf8_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJsonFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJsonFormat_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJsonName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJsonName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearJstype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearJstype_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearLabel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearLabel_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearLazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearLazy_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearLeadingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearLeadingComments_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearMapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearMapEntry_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearMaximumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearMaximumEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearMessageEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearMessageEncoding_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearMessageSetWireFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearMessageSetWireFormat_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearMinimumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearMinimumEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearNamePart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearNamePart_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearNegativeIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearNegativeIntValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearNoStandardDescriptorAccessor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearNoStandardDescriptorAccessor_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearNumber_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearObjcClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearObjcClassPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearOneofIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearOneofIndex_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearOptimizeFor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearOptimizeFor_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearOptions_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearOutputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearOutputType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearOverridableFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearOverridableFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPacked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPacked_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPhpClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPhpClassPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPhpMetadataNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPhpMetadataNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPhpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPhpNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPositiveIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPositiveIntValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearProto3Optional: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearProto3Optional_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearPyGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearPyGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearRepeated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearRepeated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearRepeatedFieldEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearRepeatedFieldEncoding_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearReserved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearReserved_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearRetention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearRetention_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearRubyPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearRubyPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSemantic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSemantic_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearServerStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearServerStreaming_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSourceCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSourceCodeInfo_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSourceContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSourceContext_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSourceFile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSourceFile_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearStart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearStart_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearStringValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearStringValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSwiftPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSwiftPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearSyntax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearSyntax_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearTrailingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearTrailingComments_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearTypeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearTypeName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearUnverifiedLazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearUnverifiedLazy_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearUtf8Validation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearUtf8Validation_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearVerification: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearVerification_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clearWeak: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearWeak_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct clientStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clientStreaming: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct code: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct codePoint: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var codePoint: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct codeUnits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var codeUnits: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Collection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var collection: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct com: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var com: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct comma: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var comma: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct consumedBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var consumedBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct contentsOf: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentsOf: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ContiguousBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contiguousBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct copy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var copy: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct count: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var count: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct countVarintsInBuffer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var countVarintsInBuffer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct csharpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var csharpNamespace: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ctype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ctype: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct customCodable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var customCodable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CustomDebugStringConvertible: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var customDebugStringConvertible: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CustomStringConvertible: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var customStringConvertible: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct d: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var d: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct dataResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataResult: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct date: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var date: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct daySec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var daySec: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct daysSinceEpoch: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var daysSinceEpoch: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct debugDescriptionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var debugDescription_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct debugRedact: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var debugRedact: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct declaration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var declaration: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decoded: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodedFromJSONNull: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodedFromJsonnull: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeExtensionFieldsAsMessageSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeExtensionFieldsAsMessageSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeJSON: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeJson: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeMapField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeMapField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeMessageMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeMessage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeated: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedBoolField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedBoolField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedBytesField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedBytesField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedDoubleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedDoubleField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedEnumField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedEnumField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedFixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedFixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedFloatField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedFloatField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedGroupField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedGroupField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedInt32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedInt64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedSFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedSfixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedSFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedSfixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedSInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedSint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedSInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedSint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedStringField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedStringField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedUInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedUint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeRepeatedUInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeRepeatedUint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingular: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingular: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularBoolField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularBoolField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularBytesField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularBytesField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularDoubleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularDoubleField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularEnumField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularEnumField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularFixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularFixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularFloatField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularFloatField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularGroupField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularGroupField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularInt32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularInt64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularSFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularSfixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularSFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularSfixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularSInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularSint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularSInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularSint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularStringField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularStringField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularUInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularUint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeSingularUInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeSingularUint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct decodeTextFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var decodeTextFormat: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct defaultAnyTypeURLPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var defaultAnyTypeUrlprefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct defaults: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var defaults: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct defaultValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var defaultValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct dependency: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dependency: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct deprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deprecated: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct deprecatedLegacyJsonFieldConflicts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deprecatedLegacyJsonFieldConflicts: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct deprecationWarning: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deprecationWarning: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct descriptionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var description_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var descriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Dictionary: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dictionary: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct dictionaryLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dictionaryLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digit: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digit0: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digit0: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digit1: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digit1: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digitCount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digitCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digits: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct digitValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digitValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct discardableResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var discardableResult: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct discardUnknownFields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var discardUnknownFields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DoubleMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var double: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct doubleValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var doubleValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Duration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var duration: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct E: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var e: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct edition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var edition: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EditionDefault: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var editionDefault: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct editionDefaults: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var editionDefaults: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct editionDeprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var editionDeprecated: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct editionIntroduced: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var editionIntroduced: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct editionRemoved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var editionRemoved: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Element: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct elements: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var elements: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct emitExtensionFieldName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var emitExtensionFieldName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct emitFieldName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var emitFieldName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct emitFieldNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var emitFieldNumber: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Empty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var empty: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct emptyData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var emptyData: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encodeAsBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encodeAsBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encoded: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encodedJSONString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encodedJsonstring: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encodedSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encodedSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encodeField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encodeField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct encoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct end: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var end: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct endArray: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endArray: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct endMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct endObject: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endObject: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct endRegularField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endRegularField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct enumMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `enum`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EnumDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EnumOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EnumReservedRange: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumReservedRange: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct enumType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct enumvalue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumvalue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EnumValueDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumValueDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EnumValueOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enumValueOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EquatableMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var equatable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var error: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExpressibleByArrayLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var expressibleByArrayLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExpressibleByDictionaryLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var expressibleByDictionaryLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ext: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extendedGraphemeClusterLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extendedGraphemeClusterLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtendedGraphemeClusterLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extendedGraphemeClusterLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extendee: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extendee: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtensibleMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensibleMessage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extensionMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `extension`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extensionFieldNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionFieldNumber: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtensionFieldValueSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionFieldValueSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtensionMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extensionRange: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionRange: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ExtensionRangeOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensionRangeOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extensions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extensions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct extras: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extras: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct F: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var f: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct falseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `false`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct features: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var features: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FeatureSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FeatureSetDefaults: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureSetDefaults: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FeatureSetEditionDefault: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureSetEditionDefault: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct featureSupport: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureSupport: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldData: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FieldDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FieldMask: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldMask: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldNameCount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldNameCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldNum: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldNum: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldNumber: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldNumberForProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldNumberForProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FieldOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldPresence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldPresence: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FieldTag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldTag: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fieldType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fieldType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct file: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var file: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FileDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fileDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FileDescriptorSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fileDescriptorSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fileName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fileName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FileOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fileOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct filter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var filter: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct final: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var final: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct finiteOnly: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var finiteOnly: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct first: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var first: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct firstItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var firstItem: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fixedFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fixedFeatures: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FloatMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var float: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct floatLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var floatLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FloatLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var floatLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FloatValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var floatValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct forMessageName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forMessageName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct formUnion: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var formUnion: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct forReadingFrom: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forReadingFrom: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct forTypeURL: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forTypeURL: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ForwardParser: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forwardParser: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct forWritingInto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forWritingInto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct from: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var from: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fromAscii2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromAscii2: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fromAscii4: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromAscii4: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fromByteOffset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromByteOffset: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fromHexDigit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromHexDigit: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct fullName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fullName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct funcMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `fn`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct function: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var function: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct G: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var g: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GeneratedCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var generatedCodeInfo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct get: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var get: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct getExtensionValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var getExtensionValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct googleapis: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleapis: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Any: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufAny: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Api: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufApi: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_BoolValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufBoolValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_BytesValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufBytesValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_DescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_DoubleValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufDoubleValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Duration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufDuration: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Edition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEdition: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Empty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEmpty: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Enum: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnum: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_EnumDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnumDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_EnumOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnumOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_EnumValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnumValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_EnumValueDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnumValueDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_EnumValueOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufEnumValueOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_ExtensionRangeOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufExtensionRangeOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FeatureSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFeatureSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FeatureSetDefaults: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFeatureSetDefaults: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FieldDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFieldDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FieldMask: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFieldMask: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FieldOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFieldOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FileDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFileDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FileDescriptorSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFileDescriptorSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FileOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFileOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_FloatValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufFloatValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_GeneratedCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufGeneratedCodeInfo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Int32Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufInt32Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Int64Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufInt64Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_ListValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufListValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_MessageOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufMessageOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Method: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufMethod: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_MethodDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufMethodDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_MethodOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufMethodOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Mixin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufMixin: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_NullValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufNullValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_OneofDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufOneofDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_OneofOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufOneofOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Option: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufOption: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_ServiceDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufServiceDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_ServiceOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufServiceOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_SourceCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufSourceCodeInfo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_SourceContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufSourceContext: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_StringValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufStringValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Struct: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufStruct: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Syntax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufSyntax: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Timestamp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufTimestamp: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Type: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_UInt32Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufUint32Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_UInt64Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufUint64Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_UninterpretedOption: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufUninterpretedOption: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Google_Protobuf_Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var googleProtobufValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct goPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var goPackage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct group: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var group: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct groupFieldNumberStack: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupFieldNumberStack: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct groupSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hadOneofValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hadOneofValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct handleConflictingOneOf: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var handleConflictingOneOf: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasAggregateValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasAggregateValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasAllowAlias: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasAllowAlias_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasBegin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasBegin_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasCcEnableArenas: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasCcEnableArenas_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasCcGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasCcGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasClientStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasClientStreaming_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasCsharpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasCsharpNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasCtype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasCtype_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDebugRedact: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDebugRedact_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDefaultValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDefaultValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDeprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDeprecated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDeprecatedLegacyJsonFieldConflicts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDeprecatedLegacyJsonFieldConflicts_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDeprecationWarning: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDeprecationWarning_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasDoubleValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasDoubleValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEditionDeprecated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEditionDeprecated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEditionIntroduced: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEditionIntroduced_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEditionRemoved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEditionRemoved_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEnd: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEnd_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasEnumType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasEnumType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasExtendee: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasExtendee_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasExtensionValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasExtensionValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasFeatureSupport: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasFeatureSupport_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasFieldPresence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasFieldPresence_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasFixedFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasFixedFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasFullName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasFullName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasGoPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasGoPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct HashableMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hashable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasher: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasher: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct HashVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hashVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasIdempotencyLevel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasIdempotencyLevel_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasIdentifierValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasIdentifierValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasInputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasInputType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasIsExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasIsExtension_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaGenerateEqualsAndHash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaGenerateEqualsAndHash_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaMultipleFiles: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaMultipleFiles_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaOuterClassname: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaOuterClassname_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJavaStringCheckUtf8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJavaStringCheckUtf8_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJsonFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJsonFormat_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJsonName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJsonName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasJstype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasJstype_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasLabel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasLabel_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasLazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasLazy_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasLeadingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasLeadingComments_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasMapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasMapEntry_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasMaximumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasMaximumEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasMessageEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasMessageEncoding_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasMessageSetWireFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasMessageSetWireFormat_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasMinimumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasMinimumEdition_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasNamePart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasNamePart_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasNegativeIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasNegativeIntValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasNoStandardDescriptorAccessor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasNoStandardDescriptorAccessor_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasNumber_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasObjcClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasObjcClassPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasOneofIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasOneofIndex_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasOptimizeFor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasOptimizeFor_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasOptions_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasOutputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasOutputType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasOverridableFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasOverridableFeatures_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPacked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPacked_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPhpClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPhpClassPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPhpMetadataNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPhpMetadataNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPhpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPhpNamespace_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPositiveIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPositiveIntValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasProto3Optional: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasProto3Optional_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasPyGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasPyGenericServices_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasRepeated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasRepeated_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasRepeatedFieldEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasRepeatedFieldEncoding_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasReserved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasReserved_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasRetention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasRetention_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasRubyPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasRubyPackage_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSemantic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSemantic_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasServerStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasServerStreaming_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSourceCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSourceCodeInfo_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSourceContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSourceContext_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSourceFile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSourceFile_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasStart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasStart_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasStringValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasStringValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSwiftPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSwiftPrefix_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasSyntax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasSyntax_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasTrailingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasTrailingComments_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasType_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasTypeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasTypeName_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasUnverifiedLazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasUnverifiedLazy_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasUtf8Validation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasUtf8Validation_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasValue_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasVerification: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasVerification_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hasWeak: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hasWeak_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct hour: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hour: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct i: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var i: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct idempotencyLevel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var idempotencyLevel: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct identifierValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifierValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ifMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `if`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ignoreUnknownExtensionFields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ignoreUnknownExtensionFields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ignoreUnknownFields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ignoreUnknownFields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct index: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct initMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var init_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct inoutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `inout`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct inputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inputType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct insert: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var insert: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct IntMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Int32Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Int32Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int32Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Int64Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Int64Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int64Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Int8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var int8: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct integerLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var integerLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct IntegerLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var integerLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct intern: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var intern: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Internal: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `internal`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct InternalState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var internalState: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct into: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var into: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ints: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ints: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isA: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isA: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isEqual: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isEqual: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isEqualTo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isEqualTo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isExtension: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isInitializedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isInitialized_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct isNegative: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isNegative: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct itemTagsEncodedSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemTagsEncodedSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct iterator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iterator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaGenerateEqualsAndHash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaGenerateEqualsAndHash: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaGenericServices: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaMultipleFiles: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaMultipleFiles: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaOuterClassname: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaOuterClassname: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaPackage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct javaStringCheckUtf8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var javaStringCheckUtf8: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsondecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONDecodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsondecodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONDecodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsondecodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonEncoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonEncoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONEncodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonencodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONEncodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonencodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONEncodingVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonencodingVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonFormat: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONMapEncodingVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonmapEncodingVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonPath: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonPath: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonPaths: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonPaths: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JSONScanner: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonscanner: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonString: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonText: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonText: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonUTF8Bytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonUtf8Bytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jsonUTF8Data: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonUtf8Data: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct jstype: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jstype: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct k: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var k: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct kChunkSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kChunkSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Key: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct keyField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keyField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct keyFieldOpt: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keyFieldOpt: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct KeyType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keyType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct kind: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct l: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var l: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct label: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var label: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct lazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lazy: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct leadingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var leadingComments: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct leadingDetachedComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var leadingDetachedComments: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct length: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var length: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct lessThan: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lessThan: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct immutableMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `immutable`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct lhs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lhs: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct line: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var line: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct list: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var list: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct listOfMessages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var listOfMessages: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct listValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var listValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct littleEndian: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var littleEndian: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct load: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var load: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct localHasher: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var localHasher: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct location: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var location: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct M: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var m: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct major: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var major: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct makeAsyncIterator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var makeAsyncIterator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct makeIterator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var makeIterator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct malformedLength: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var malformedLength: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapEntry: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MapKeyType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapKeyType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mapToMessages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapToMessages: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MapValueType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapValueType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mapVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct maximumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var maximumEdition: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mdayStart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mdayStart: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct merge: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var merge: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct messageDepthLimit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageDepthLimit: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct messageEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageEncoding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MessageExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageExtension: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MessageImplementationBase: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageImplementationBase: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MessageOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MessageSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct messageSetWireFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageSetWireFormat: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct messageSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct messageType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Method: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var method: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MethodDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var methodDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MethodOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var methodOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct methods: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var methods: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct min: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var min: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct minimumEdition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var minimumEdition: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct minor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var minor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Mixin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mixin: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mixins: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mixins: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct modifier: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var modifier: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct modify: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var modify: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct month: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var month: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct msgExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var msgExtension: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct mutating: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mutating: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct n: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var n: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct name: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NameDescription: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nameDescription: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NameMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nameMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NamePart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var namePart: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct names: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var names: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nanos: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nanos: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct negativeIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var negativeIntValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nestedType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nestedType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct newL: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var newL: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct newList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var newList: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct newValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var newValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct next: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var next: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nextByte: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nextByte: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nextFieldNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nextFieldNumber: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nextVarInt: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nextVarInt: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nilMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `Nothing`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nilLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nilLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct noBytesAvailable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var noBytesAvailable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct noStandardDescriptorAccessor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var noStandardDescriptorAccessor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct nullValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nullValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct number: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var number: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct numberValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var numberValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct objcClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var objcClassPrefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct of: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var of: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct oneofDecl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneofDecl: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OneofDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneofDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct oneofIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneofIndex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OneofOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneofOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct oneofs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneofs: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OneOf_Kind: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oneOfKind: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct optimizeFor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optimizeFor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptimizeMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optimizeMode: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Option: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var option: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionalEnumExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionalEnumExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionalExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionalExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionalGroupExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionalGroupExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionalMessageExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionalMessageExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionRetention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionRetention: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var options: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct OptionTargetType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var optionTargetType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct other: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var other: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct others: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var others: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct out: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var out: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct outputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var outputType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct overridableFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var overridableFeatures: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct p: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct package: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var package: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct packed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var packed: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PackedEnumExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var packedEnumExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PackedExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var packedExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct padding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var padding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct parent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parent: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct parse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parse: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct partial: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var partial: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct path: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct paths: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var paths: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct payload: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var payload: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct payloadSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var payloadSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct phpClassPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var phpClassPrefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct phpMetadataNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var phpMetadataNamespace: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct phpNamespace: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var phpNamespace: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct pos: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pos: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct positiveIntValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var positiveIntValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct prefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct preserveProtoFieldNames: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var preserveProtoFieldNames: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct preTraverse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var preTraverse: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct printUnknownFields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var printUnknownFields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct proto2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var proto2: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct proto3DefaultValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var proto3DefaultValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct proto3Optional: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var proto3Optional: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufAPIVersionCheck: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufApiversionCheck: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufAPIVersion_2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufApiversion2: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufBool: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufBool: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufDouble: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufDouble: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufEnumMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufEnumMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobufExtension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufExtension: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufFixed32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufFixed32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufFixed64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufFixed64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufFloat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufFloat: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufInt32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufInt32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufInt64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufMessageMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufMessageMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufSFixed32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufSfixed32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufSFixed64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufSfixed64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufSInt32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufSint32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufSInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufSint64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufString: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufUInt32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufUint32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtobufUInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufUint64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_extensionFieldValues: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufExtensionFieldValues: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_fieldNumber: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufFieldNumber: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_generated_isEqualTo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufGeneratedIsEqualTo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_nameMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufNameMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_newField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufNewField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protobuf_package: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protobufPackage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protocolMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `protocol`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protoFieldName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protoFieldName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protoMessageNameMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protoMessageName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProtoNameProviding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protoNameProviding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct protoPaths: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var protoPaths: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct publicMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `public`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct publicDependency: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicDependency: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putBoolValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putBoolValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putBytesValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putBytesValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putDoubleValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putDoubleValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putEnumValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putEnumValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putFixedUInt32: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putFixedUint32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putFixedUInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putFixedUint64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putFloatValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putFloatValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putInt64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putStringValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putStringValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putUInt64: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putUint64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putUInt64Hex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putUint64Hex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putVarInt: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putVarInt: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct putZigZagVarInt: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var putZigZagVarInt: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct pyGenericServices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pyGenericServices: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct R: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var r: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct rawChars: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawChars: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RawRepresentable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawRepresentable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RawValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct read4HexDigits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var read4HexDigits: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct readBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var readBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct register: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var register: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct repeated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeated: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RepeatedEnumExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeatedEnumExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RepeatedExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeatedExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct repeatedFieldEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeatedFieldEncoding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RepeatedGroupExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeatedGroupExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RepeatedMessageExtensionField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeatedMessageExtensionField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct repeating: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repeating: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct requestStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var requestStreaming: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct requestTypeURL: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var requestTypeURL: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct requiredSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var requiredSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct responseStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var responseStreaming: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct responseTypeURL: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var responseTypeURL: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct result: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var result: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct retention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var retention: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct rethrowsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `rethrows`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct returnMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `return`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ReturnType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var returnType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct revision: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var revision: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct rhs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rhs: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct root: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var root: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct rubyPackage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rubyPackage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct s: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var s: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sawBackslash: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sawBackslash: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sawSection4Characters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sawSection4Characters: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sawSection5Characters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sawSection5Characters: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct scan: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scan: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct scanner: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scanner: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct seconds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var seconds: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct selfMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var self_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct semantic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var semantic: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SendableMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sendable: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct separator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var separator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct serialize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serialize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct serializedBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serializedBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct serializedData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serializedData: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct serializedSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serializedSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct serverStreaming: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serverStreaming: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct service: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var service: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ServiceDescriptorProto: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serviceDescriptorProto: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ServiceOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serviceOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct set: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var set: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct setExtensionValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var setExtensionValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct shift: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var shift: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SimpleExtensionMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var simpleExtensionMap: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct size: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var size: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sizer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sizer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct source: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sourceCodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceCodeInfo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sourceContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceContext: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sourceEncoding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceEncoding: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct sourceFile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceFile: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SourceLocation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceLocation: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct span: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var span: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct split: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var split: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var start: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startArray: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startArray: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startArrayObject: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startArrayObject: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startIndex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startObject: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startObject: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct startRegularField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startRegularField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct state: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var state: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct staticMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `static`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StaticString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var staticString: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct storage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var storage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StringMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var string: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct stringLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stringLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StringLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stringLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct stringResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stringResult: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct stringValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stringValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct structMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `struct`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct structValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var structValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct subDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var subDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct subscriptMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `subscript`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct subVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var subVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SwiftMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var swift: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct swiftPrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var swiftPrefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SwiftProtobufContiguousBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var swiftProtobufContiguousBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SwiftProtobufError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var swiftProtobufError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct syntax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var syntax: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct T: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var t: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct tag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tag: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct targets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var targets: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct terminator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var terminator: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct testDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var testDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct text: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct textDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TextFormatDecoder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatDecoder: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TextFormatDecodingError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatDecodingError: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TextFormatDecodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatDecodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TextFormatEncodingOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatEncodingOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TextFormatEncodingVisitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatEncodingVisitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct textFormatString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var textFormatString: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct throwOrIgnore: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var throwOrIgnore: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct throwsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `throws`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct timeInterval: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeInterval: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct timeIntervalSince1970: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeIntervalSince1970: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct timeIntervalSinceReferenceDate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeIntervalSinceReferenceDate: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Timestamp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timestamp: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct tooLarge: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tooLarge: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct total: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var total: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct totalArrayDepth: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var totalArrayDepth: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct totalSize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var totalSize: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct trailingComments: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var trailingComments: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct traverseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var traverse: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct trueMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `true`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct tryMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `try`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct type: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typealiasMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `typealias`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TypeEnum: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeEnum: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeName: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typePrefix: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typePrefix: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typeStart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeStart: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typeUnknown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeUnknown: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct typeURL: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var typeURL: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UInt32Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint32: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UInt32Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint32Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UInt64Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint64: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UInt64Value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint64Value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UInt8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uint8: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unchecked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unchecked: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unicodeScalarLiteral: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unicodeScalarLiteral: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnicodeScalarLiteralType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unicodeScalarLiteralType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unicodeScalars: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unicodeScalars: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnicodeScalarView: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unicodeScalarView: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct uninterpretedOption: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uninterpretedOption: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct union: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var union: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct uniqueStorage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uniqueStorage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unknown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknown: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unknownFieldsMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields_p: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnknownStorage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownStorage: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unpackTo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unpackTo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnsafeBufferPointer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsafeBufferPointer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnsafeMutablePointer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsafeMutablePointer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnsafeMutableRawBufferPointer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsafeMutableRawBufferPointer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnsafeRawBufferPointer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsafeRawBufferPointer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UnsafeRawPointer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unsafeRawPointer: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct unverifiedLazy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unverifiedLazy: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct updatedOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var updatedOptions: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct url: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct useDeterministicOrdering: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var useDeterministicOrdering: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct utf8: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var utf8: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct utf8Ptr: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var utf8Ptr: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct utf8ToDouble: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var utf8ToDouble: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct utf8Validation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var utf8Validation: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UTF8View: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var utf8View: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct v: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var v: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct value: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct valueField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var valueField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct values: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var values: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ValueType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var valueType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct varMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `var`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct verification: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var verification: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct VerificationState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var verificationState: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Version: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var version: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct versionString: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var versionString: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitExtensionFields: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitExtensionFields: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitExtensionFieldsAsMessageSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitExtensionFieldsAsMessageSet: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitMapField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitMapField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPacked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPacked: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedBoolField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedBoolField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedDoubleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedDoubleField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedEnumField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedEnumField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedFixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedFixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedFloatField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedFloatField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedInt32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedInt64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedSFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedSfixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedSFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedSfixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedSInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedSint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedSInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedSint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedUInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedUint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitPackedUInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitPackedUint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeated: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedBoolField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedBoolField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedBytesField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedBytesField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedDoubleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedDoubleField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedEnumField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedEnumField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedFixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedFixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedFloatField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedFloatField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedGroupField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedGroupField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedInt32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedInt64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedSFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedSfixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedSFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedSfixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedSInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedSint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedSInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedSint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedStringField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedStringField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedUInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedUint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitRepeatedUInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitRepeatedUint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingular: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingular: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularBoolField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularBoolField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularBytesField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularBytesField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularDoubleField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularDoubleField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularEnumField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularEnumField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularFixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularFixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularFloatField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularFloatField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularGroupField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularGroupField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularInt32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularInt64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularMessageField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularMessageField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularSFixed32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularSfixed32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularSFixed64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularSfixed64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularSInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularSint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularSInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularSint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularStringField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularStringField: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularUInt32Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularUint32Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitSingularUInt64Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitSingularUint64Field: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct visitUnknown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var visitUnknown: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct wasDecoded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wasDecoded: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct weak: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var weak: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct weakDependency: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var weakDependency: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct whereMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `where`: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct wireFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wireFormat: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct with: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var with: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct withUnsafeBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var withUnsafeBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct withUnsafeMutableBytes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var withUnsafeMutableBytes: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct work: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var work: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Wrapped: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wrapped: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct WrappedType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wrappedType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct wrappedValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wrappedValue: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct written: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var written: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct yday: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var yday: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate immutable _protobuf_package = "swift_proto_testing.generated"

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = _protobuf_package + ".GeneratedSwiftReservedMessages"
  static immutable _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != Nothing {}
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages) -> Boolean {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.adjusted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".adjusted"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adjusted"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.adjusted) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.adjusted != 0 {
      try visitor.visitSingularInt32Field(value: this.adjusted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.adjusted, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.adjusted) -> Boolean {
    if lhs.adjusted != rhs.adjusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.aggregateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".aggregateValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aggregateValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.aggregateValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.aggregateValue != 0 {
      try visitor.visitSingularInt32Field(value: this.aggregateValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.aggregateValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.aggregateValue) -> Boolean {
    if lhs.aggregateValue != rhs.aggregateValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allCases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".allCases"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allCases"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.allCases) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.allCases != 0 {
      try visitor.visitSingularInt32Field(value: this.allCases, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allCases, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allCases) -> Boolean {
    if lhs.allCases != rhs.allCases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allowAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".allowAlias"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowAlias"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.allowAlias) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.allowAlias != 0 {
      try visitor.visitSingularInt32Field(value: this.allowAlias, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allowAlias, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.allowAlias) -> Boolean {
    if lhs.allowAlias != rhs.allowAlias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintEnumsAsInts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".alwaysPrintEnumsAsInts"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alwaysPrintEnumsAsInts"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.alwaysPrintEnumsAsInts) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.alwaysPrintEnumsAsInts != 0 {
      try visitor.visitSingularInt32Field(value: this.alwaysPrintEnumsAsInts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintEnumsAsInts, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintEnumsAsInts) -> Boolean {
    if lhs.alwaysPrintEnumsAsInts != rhs.alwaysPrintEnumsAsInts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintInt64sAsNumbers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".alwaysPrintInt64sAsNumbers"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alwaysPrintInt64sAsNumbers"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.alwaysPrintInt64SAsNumbers) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.alwaysPrintInt64SAsNumbers != 0 {
      try visitor.visitSingularInt32Field(value: this.alwaysPrintInt64SAsNumbers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintInt64sAsNumbers, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.alwaysPrintInt64sAsNumbers) -> Boolean {
    if lhs.alwaysPrintInt64SAsNumbers != rhs.alwaysPrintInt64SAsNumbers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".annotation"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.annotation) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.annotation != 0 {
      try visitor.visitSingularInt32Field(value: this.annotation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.annotation, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.annotation) -> Boolean {
    if lhs.annotation != rhs.annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.any: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".any"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "any"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.any) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.any != 0 {
      try visitor.visitSingularInt32Field(value: this.any, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.any, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.any) -> Boolean {
    if lhs.any != rhs.any {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AnyExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AnyExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.anyExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.anyExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.anyExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyExtensionField) -> Boolean {
    if lhs.anyExtensionField != rhs.anyExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AnyMessageExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AnyMessageExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.anyMessageExtension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.anyMessageExtension != 0 {
      try visitor.visitSingularInt32Field(value: this.anyMessageExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageExtension) -> Boolean {
    if lhs.anyMessageExtension != rhs.anyMessageExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AnyMessageStorage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AnyMessageStorage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.anyMessageStorage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.anyMessageStorage != 0 {
      try visitor.visitSingularInt32Field(value: this.anyMessageStorage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageStorage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyMessageStorage) -> Boolean {
    if lhs.anyMessageStorage != rhs.anyMessageStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyUnpackError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AnyUnpackError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AnyUnpackError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.anyUnpackError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.anyUnpackError != 0 {
      try visitor.visitSingularInt32Field(value: this.anyUnpackError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyUnpackError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AnyUnpackError) -> Boolean {
    if lhs.anyUnpackError != rhs.anyUnpackError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Api: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Api"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Api"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.api) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.api != 0 {
      try visitor.visitSingularInt32Field(value: this.api, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Api, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Api) -> Boolean {
    if lhs.api != rhs.api {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appended: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".appended"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appended"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.appended) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.appended != 0 {
      try visitor.visitSingularInt32Field(value: this.appended, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appended, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appended) -> Boolean {
    if lhs.appended != rhs.appended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUIntHex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".appendUIntHex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appendUIntHex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.appendUintHex) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.appendUintHex != 0 {
      try visitor.visitSingularInt32Field(value: this.appendUintHex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUIntHex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUIntHex) -> Boolean {
    if lhs.appendUintHex != rhs.appendUintHex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUnknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".appendUnknown"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appendUnknown"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.appendUnknown) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.appendUnknown != 0 {
      try visitor.visitSingularInt32Field(value: this.appendUnknown, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUnknown, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.appendUnknown) -> Boolean {
    if lhs.appendUnknown != rhs.appendUnknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.areAllInitialized: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".areAllInitialized"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "areAllInitialized"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.areAllInitialized) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.areAllInitialized != 0 {
      try visitor.visitSingularInt32Field(value: this.areAllInitialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.areAllInitialized, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.areAllInitialized) -> Boolean {
    if lhs.areAllInitialized != rhs.areAllInitialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Array"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Array"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.array) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.array != 0 {
      try visitor.visitSingularInt32Field(value: this.array, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Array, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Array) -> Boolean {
    if lhs.array != rhs.array {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayDepth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".arrayDepth"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arrayDepth"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.arrayDepth) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.arrayDepth != 0 {
      try visitor.visitSingularInt32Field(value: this.arrayDepth, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayDepth, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayDepth) -> Boolean {
    if lhs.arrayDepth != rhs.arrayDepth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".arrayLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arrayLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.arrayLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.arrayLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.arrayLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arrayLiteral) -> Boolean {
    if lhs.arrayLiteral != rhs.arrayLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arraySeparator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".arraySeparator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arraySeparator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.arraySeparator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.arraySeparator != 0 {
      try visitor.visitSingularInt32Field(value: this.arraySeparator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arraySeparator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.arraySeparator) -> Boolean {
    if lhs.arraySeparator != rhs.arraySeparator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".as"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "as"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`as`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`as` != 0 {
      try visitor.visitSingularInt32Field(value: this.`as`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asMessage) -> Boolean {
    if lhs.`as` != rhs.`as` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiOpenCurlyBracket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".asciiOpenCurlyBracket"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asciiOpenCurlyBracket"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.asciiOpenCurlyBracket) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.asciiOpenCurlyBracket != 0 {
      try visitor.visitSingularInt32Field(value: this.asciiOpenCurlyBracket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiOpenCurlyBracket, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiOpenCurlyBracket) -> Boolean {
    if lhs.asciiOpenCurlyBracket != rhs.asciiOpenCurlyBracket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiZero: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".asciiZero"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asciiZero"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.asciiZero) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.asciiZero != 0 {
      try visitor.visitSingularInt32Field(value: this.asciiZero, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiZero, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.asciiZero) -> Boolean {
    if lhs.asciiZero != rhs.asciiZero {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.async: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".async"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "async"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.async) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.async != 0 {
      try visitor.visitSingularInt32Field(value: this.async, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.async, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.async) -> Boolean {
    if lhs.async != rhs.async {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIterator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AsyncIterator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AsyncIterator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.asyncIterator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.asyncIterator != 0 {
      try visitor.visitSingularInt32Field(value: this.asyncIterator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIterator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIterator) -> Boolean {
    if lhs.asyncIterator != rhs.asyncIterator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIteratorProtocol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AsyncIteratorProtocol"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AsyncIteratorProtocol"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.asyncIteratorProtocol) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.asyncIteratorProtocol != 0 {
      try visitor.visitSingularInt32Field(value: this.asyncIteratorProtocol, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIteratorProtocol, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncIteratorProtocol) -> Boolean {
    if lhs.asyncIteratorProtocol != rhs.asyncIteratorProtocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncMessageSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".AsyncMessageSequence"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AsyncMessageSequence"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.asyncMessageSequence) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.asyncMessageSequence != 0 {
      try visitor.visitSingularInt32Field(value: this.asyncMessageSequence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncMessageSequence, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.AsyncMessageSequence) -> Boolean {
    if lhs.asyncMessageSequence != rhs.asyncMessageSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.available: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".available"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "available"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.available) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.available != 0 {
      try visitor.visitSingularInt32Field(value: this.available, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.available, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.available) -> Boolean {
    if lhs.available != rhs.available {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.b: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".b"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "b"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.b) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.b != 0 {
      try visitor.visitSingularInt32Field(value: this.b, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.b, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.b) -> Boolean {
    if lhs.b != rhs.b {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Base: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Base"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Base"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.base) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.base != 0 {
      try visitor.visitSingularInt32Field(value: this.base, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Base, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Base) -> Boolean {
    if lhs.base != rhs.base {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.base64Values: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".base64Values"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base64Values"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.base64Values) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.base64Values != 0 {
      try visitor.visitSingularInt32Field(value: this.base64Values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.base64Values, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.base64Values) -> Boolean {
    if lhs.base64Values != rhs.base64Values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.baseAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".baseAddress"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baseAddress"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.baseAddress) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.baseAddress != 0 {
      try visitor.visitSingularInt32Field(value: this.baseAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.baseAddress, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.baseAddress) -> Boolean {
    if lhs.baseAddress != rhs.baseAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BaseType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BaseType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BaseType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.baseType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.baseType != 0 {
      try visitor.visitSingularInt32Field(value: this.baseType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BaseType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BaseType) -> Boolean {
    if lhs.baseType != rhs.baseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.begin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".begin"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.begin) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.begin != 0 {
      try visitor.visitSingularInt32Field(value: this.begin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.begin, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.begin) -> Boolean {
    if lhs.begin != rhs.begin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".binary"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binary"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binary) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binary != 0 {
      try visitor.visitSingularInt32Field(value: this.binary, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binary, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binary) -> Boolean {
    if lhs.binary != rhs.binary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoder) -> Boolean {
    if lhs.binaryDecoder != rhs.binaryDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryDecoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryDecoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryDecoding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryDecoding != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryDecoding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecoding) -> Boolean {
    if lhs.binaryDecoding != rhs.binaryDecoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryDecodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryDecodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryDecodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryDecodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryDecodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingError) -> Boolean {
    if lhs.binaryDecodingError != rhs.binaryDecodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryDecodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryDecodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryDecodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryDecodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryDecodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDecodingOptions) -> Boolean {
    if lhs.binaryDecodingOptions != rhs.binaryDecodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDelimited: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryDelimited"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryDelimited"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryDelimited) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryDelimited != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryDelimited, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDelimited, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryDelimited) -> Boolean {
    if lhs.binaryDelimited != rhs.binaryDelimited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncoder != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncoder) -> Boolean {
    if lhs.binaryEncoder != rhs.binaryEncoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingError) -> Boolean {
    if lhs.binaryEncodingError != rhs.binaryEncodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetSizeVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingMessageSetSizeVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingMessageSetSizeVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingMessageSetSizeVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingMessageSetSizeVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingMessageSetSizeVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetSizeVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetSizeVisitor) -> Boolean {
    if lhs.binaryEncodingMessageSetSizeVisitor != rhs.binaryEncodingMessageSetSizeVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingMessageSetVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingMessageSetVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingMessageSetVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingMessageSetVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingMessageSetVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingMessageSetVisitor) -> Boolean {
    if lhs.binaryEncodingMessageSetVisitor != rhs.binaryEncodingMessageSetVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingOptions) -> Boolean {
    if lhs.binaryEncodingOptions != rhs.binaryEncodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingSizeVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingSizeVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingSizeVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingSizeVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingSizeVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingSizeVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingSizeVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingSizeVisitor) -> Boolean {
    if lhs.binaryEncodingSizeVisitor != rhs.binaryEncodingSizeVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryEncodingVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryEncodingVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryEncodingVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryEncodingVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryEncodingVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryEncodingVisitor) -> Boolean {
    if lhs.binaryEncodingVisitor != rhs.binaryEncodingVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".binaryOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binaryOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryOptions) -> Boolean {
    if lhs.binaryOptions != rhs.binaryOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryProtobufDelimitedMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".binaryProtobufDelimitedMessages"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binaryProtobufDelimitedMessages"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryProtobufDelimitedMessages) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryProtobufDelimitedMessages != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryProtobufDelimitedMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryProtobufDelimitedMessages, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryProtobufDelimitedMessages) -> Boolean {
    if lhs.binaryProtobufDelimitedMessages != rhs.binaryProtobufDelimitedMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryStreamDecoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BinaryStreamDecoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BinaryStreamDecoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryStreamDecoding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryStreamDecoding != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryStreamDecoding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryStreamDecoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BinaryStreamDecoding) -> Boolean {
    if lhs.binaryStreamDecoding != rhs.binaryStreamDecoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryStreamDecodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".binaryStreamDecodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binaryStreamDecodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.binaryStreamDecodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.binaryStreamDecodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.binaryStreamDecodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryStreamDecodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.binaryStreamDecodingError) -> Boolean {
    if lhs.binaryStreamDecodingError != rhs.binaryStreamDecodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bitPattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".bitPattern"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitPattern"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bitPattern) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bitPattern != 0 {
      try visitor.visitSingularInt32Field(value: this.bitPattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bitPattern, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bitPattern) -> Boolean {
    if lhs.bitPattern != rhs.bitPattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.body: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".body"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.body) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.body != 0 {
      try visitor.visitSingularInt32Field(value: this.body, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.body, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.body) -> Boolean {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BoolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Boolean"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Boolean"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bool) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bool != 0 {
      try visitor.visitSingularInt32Field(value: this.bool, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BoolMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BoolMessage) -> Boolean {
    if lhs.bool != rhs.bool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.booleanLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".booleanLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "booleanLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.booleanLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.booleanLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.booleanLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.booleanLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.booleanLiteral) -> Boolean {
    if lhs.booleanLiteral != rhs.booleanLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BooleanLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BooleanLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BooleanLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.booleanLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.booleanLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.booleanLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BooleanLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BooleanLiteralType) -> Boolean {
    if lhs.booleanLiteralType != rhs.booleanLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.boolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".boolValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "boolValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.boolValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.boolValue != 0 {
      try visitor.visitSingularInt32Field(value: this.boolValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.boolValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.boolValue) -> Boolean {
    if lhs.boolValue != rhs.boolValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.buffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".buffer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buffer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.buffer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.buffer != 0 {
      try visitor.visitSingularInt32Field(value: this.buffer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.buffer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.buffer) -> Boolean {
    if lhs.buffer != rhs.buffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".bytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bytes != 0 {
      try visitor.visitSingularInt32Field(value: this.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytes) -> Boolean {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesInGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".bytesInGroup"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesInGroup"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bytesInGroup) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bytesInGroup != 0 {
      try visitor.visitSingularInt32Field(value: this.bytesInGroup, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesInGroup, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesInGroup) -> Boolean {
    if lhs.bytesInGroup != rhs.bytesInGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesNeeded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".bytesNeeded"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesNeeded"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bytesNeeded) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bytesNeeded != 0 {
      try visitor.visitSingularInt32Field(value: this.bytesNeeded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesNeeded, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesNeeded) -> Boolean {
    if lhs.bytesNeeded != rhs.bytesNeeded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".bytesRead"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesRead"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bytesRead) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bytesRead != 0 {
      try visitor.visitSingularInt32Field(value: this.bytesRead, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesRead, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.bytesRead) -> Boolean {
    if lhs.bytesRead != rhs.bytesRead {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BytesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".BytesValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BytesValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.bytesValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.bytesValue != 0 {
      try visitor.visitSingularInt32Field(value: this.bytesValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BytesValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.BytesValue) -> Boolean {
    if lhs.bytesValue != rhs.bytesValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.c: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".c"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "c"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.c) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.c != 0 {
      try visitor.visitSingularInt32Field(value: this.c, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.c, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.c) -> Boolean {
    if lhs.c != rhs.c {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.capitalizeNext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".capitalizeNext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capitalizeNext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.capitalizeNext) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.capitalizeNext != 0 {
      try visitor.visitSingularInt32Field(value: this.capitalizeNext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.capitalizeNext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.capitalizeNext) -> Boolean {
    if lhs.capitalizeNext != rhs.capitalizeNext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.cardinality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".cardinality"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cardinality"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.cardinality) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.cardinality != 0 {
      try visitor.visitSingularInt32Field(value: this.cardinality, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.cardinality, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.cardinality) -> Boolean {
    if lhs.cardinality != rhs.cardinality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CaseIterable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".CaseIterable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CaseIterable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.caseIterable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.caseIterable != 0 {
      try visitor.visitSingularInt32Field(value: this.caseIterable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CaseIterable, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CaseIterable) -> Boolean {
    if lhs.caseIterable != rhs.caseIterable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccEnableArenas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ccEnableArenas"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ccEnableArenas"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ccEnableArenas) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ccEnableArenas != 0 {
      try visitor.visitSingularInt32Field(value: this.ccEnableArenas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccEnableArenas, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccEnableArenas) -> Boolean {
    if lhs.ccEnableArenas != rhs.ccEnableArenas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ccGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ccGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ccGenericServices) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ccGenericServices != 0 {
      try visitor.visitSingularInt32Field(value: this.ccGenericServices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ccGenericServices) -> Boolean {
    if lhs.ccGenericServices != rhs.ccGenericServices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Character: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Character"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Character"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.character) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.character != 0 {
      try visitor.visitSingularInt32Field(value: this.character, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Character, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Character) -> Boolean {
    if lhs.character != rhs.character {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".chars"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chars"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.chars) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.chars != 0 {
      try visitor.visitSingularInt32Field(value: this.chars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chars, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chars) -> Boolean {
    if lhs.chars != rhs.chars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".chunk"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunk"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.chunk) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.chunk != 0 {
      try visitor.visitSingularInt32Field(value: this.chunk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chunk, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.chunk) -> Boolean {
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.classMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".class"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`class`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`class` != 0 {
      try visitor.visitSingularInt32Field(value: this.`class`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.classMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.classMessage) -> Boolean {
    if lhs.`class` != rhs.`class` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAggregateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearAggregateValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearAggregateValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearAggregateValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearAggregateValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearAggregateValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAggregateValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAggregateValue) -> Boolean {
    if lhs.clearAggregateValue_p != rhs.clearAggregateValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAllowAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearAllowAlias"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearAllowAlias"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearAllowAlias_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearAllowAlias_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearAllowAlias_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAllowAlias, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearAllowAlias) -> Boolean {
    if lhs.clearAllowAlias_p != rhs.clearAllowAlias_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearBegin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearBegin"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearBegin"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearBegin_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearBegin_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearBegin_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearBegin, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearBegin) -> Boolean {
    if lhs.clearBegin_p != rhs.clearBegin_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcEnableArenas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearCcEnableArenas"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearCcEnableArenas"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearCcEnableArenas_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearCcEnableArenas_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearCcEnableArenas_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcEnableArenas, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcEnableArenas) -> Boolean {
    if lhs.clearCcEnableArenas_p != rhs.clearCcEnableArenas_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearCcGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearCcGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearCcGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearCcGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearCcGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCcGenericServices) -> Boolean {
    if lhs.clearCcGenericServices_p != rhs.clearCcGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearClientStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearClientStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearClientStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearClientStreaming_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearClientStreaming_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearClientStreaming_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearClientStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearClientStreaming) -> Boolean {
    if lhs.clearClientStreaming_p != rhs.clearClientStreaming_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCsharpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearCsharpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearCsharpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearCsharpNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearCsharpNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearCsharpNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCsharpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCsharpNamespace) -> Boolean {
    if lhs.clearCsharpNamespace_p != rhs.clearCsharpNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCtype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearCtype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearCtype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearCtype_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearCtype_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearCtype_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCtype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearCtype) -> Boolean {
    if lhs.clearCtype_p != rhs.clearCtype_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDebugRedact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDebugRedact"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDebugRedact"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDebugRedact_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDebugRedact_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDebugRedact_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDebugRedact, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDebugRedact) -> Boolean {
    if lhs.clearDebugRedact_p != rhs.clearDebugRedact_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDefaultValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDefaultValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDefaultValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDefaultValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDefaultValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDefaultValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDefaultValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDefaultValue) -> Boolean {
    if lhs.clearDefaultValue_p != rhs.clearDefaultValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDeprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDeprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDeprecated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDeprecated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDeprecated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecated) -> Boolean {
    if lhs.clearDeprecated_p != rhs.clearDeprecated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecatedLegacyJsonFieldConflicts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDeprecatedLegacyJsonFieldConflicts"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDeprecatedLegacyJsonFieldConflicts"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDeprecatedLegacyJsonFieldConflicts_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDeprecatedLegacyJsonFieldConflicts_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDeprecatedLegacyJsonFieldConflicts_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecatedLegacyJsonFieldConflicts, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecatedLegacyJsonFieldConflicts) -> Boolean {
    if lhs.clearDeprecatedLegacyJsonFieldConflicts_p != rhs.clearDeprecatedLegacyJsonFieldConflicts_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecationWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDeprecationWarning"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDeprecationWarning"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDeprecationWarning_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDeprecationWarning_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDeprecationWarning_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecationWarning, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDeprecationWarning) -> Boolean {
    if lhs.clearDeprecationWarning_p != rhs.clearDeprecationWarning_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDoubleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearDoubleValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearDoubleValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearDoubleValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearDoubleValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearDoubleValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDoubleValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearDoubleValue) -> Boolean {
    if lhs.clearDoubleValue_p != rhs.clearDoubleValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEdition) -> Boolean {
    if lhs.clearEdition_p != rhs.clearEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionDeprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEditionDeprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEditionDeprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEditionDeprecated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEditionDeprecated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEditionDeprecated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionDeprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionDeprecated) -> Boolean {
    if lhs.clearEditionDeprecated_p != rhs.clearEditionDeprecated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionIntroduced: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEditionIntroduced"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEditionIntroduced"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEditionIntroduced_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEditionIntroduced_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEditionIntroduced_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionIntroduced, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionIntroduced) -> Boolean {
    if lhs.clearEditionIntroduced_p != rhs.clearEditionIntroduced_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEditionRemoved"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEditionRemoved"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEditionRemoved_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEditionRemoved_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEditionRemoved_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionRemoved, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEditionRemoved) -> Boolean {
    if lhs.clearEditionRemoved_p != rhs.clearEditionRemoved_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEnd"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEnd"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEnd_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEnd_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEnd_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnd, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnd) -> Boolean {
    if lhs.clearEnd_p != rhs.clearEnd_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnumType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearEnumType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearEnumType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearEnumType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearEnumType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearEnumType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnumType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearEnumType) -> Boolean {
    if lhs.clearEnumType_p != rhs.clearEnumType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtendee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearExtendee"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearExtendee"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearExtendee_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearExtendee_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearExtendee_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtendee, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtendee) -> Boolean {
    if lhs.clearExtendee_p != rhs.clearExtendee_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtensionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearExtensionValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearExtensionValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearExtensionValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearExtensionValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearExtensionValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtensionValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearExtensionValue) -> Boolean {
    if lhs.clearExtensionValue_p != rhs.clearExtensionValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatures) -> Boolean {
    if lhs.clearFeatures_p != rhs.clearFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatureSupport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearFeatureSupport"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearFeatureSupport"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearFeatureSupport_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearFeatureSupport_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearFeatureSupport_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatureSupport, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFeatureSupport) -> Boolean {
    if lhs.clearFeatureSupport_p != rhs.clearFeatureSupport_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFieldPresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearFieldPresence"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearFieldPresence"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearFieldPresence_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearFieldPresence_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearFieldPresence_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFieldPresence, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFieldPresence) -> Boolean {
    if lhs.clearFieldPresence_p != rhs.clearFieldPresence_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFixedFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearFixedFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearFixedFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearFixedFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearFixedFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearFixedFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFixedFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFixedFeatures) -> Boolean {
    if lhs.clearFixedFeatures_p != rhs.clearFixedFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFullName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearFullName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearFullName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearFullName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearFullName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearFullName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFullName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearFullName) -> Boolean {
    if lhs.clearFullName_p != rhs.clearFullName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearGoPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearGoPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearGoPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearGoPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearGoPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearGoPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearGoPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearGoPackage) -> Boolean {
    if lhs.clearGoPackage_p != rhs.clearGoPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdempotencyLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearIdempotencyLevel"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearIdempotencyLevel"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearIdempotencyLevel_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearIdempotencyLevel_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearIdempotencyLevel_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdempotencyLevel, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdempotencyLevel) -> Boolean {
    if lhs.clearIdempotencyLevel_p != rhs.clearIdempotencyLevel_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdentifierValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearIdentifierValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearIdentifierValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearIdentifierValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearIdentifierValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearIdentifierValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdentifierValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIdentifierValue) -> Boolean {
    if lhs.clearIdentifierValue_p != rhs.clearIdentifierValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearInputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearInputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearInputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearInputType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearInputType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearInputType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearInputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearInputType) -> Boolean {
    if lhs.clearInputType_p != rhs.clearInputType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIsExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearIsExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearIsExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearIsExtension_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearIsExtension_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearIsExtension_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIsExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearIsExtension) -> Boolean {
    if lhs.clearIsExtension_p != rhs.clearIsExtension_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenerateEqualsAndHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaGenerateEqualsAndHash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaGenerateEqualsAndHash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaGenerateEqualsAndHash_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaGenerateEqualsAndHash_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaGenerateEqualsAndHash_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenerateEqualsAndHash, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenerateEqualsAndHash) -> Boolean {
    if lhs.clearJavaGenerateEqualsAndHash_p != rhs.clearJavaGenerateEqualsAndHash_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaGenericServices) -> Boolean {
    if lhs.clearJavaGenericServices_p != rhs.clearJavaGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaMultipleFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaMultipleFiles"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaMultipleFiles"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaMultipleFiles_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaMultipleFiles_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaMultipleFiles_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaMultipleFiles, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaMultipleFiles) -> Boolean {
    if lhs.clearJavaMultipleFiles_p != rhs.clearJavaMultipleFiles_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaOuterClassname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaOuterClassname"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaOuterClassname"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaOuterClassname_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaOuterClassname_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaOuterClassname_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaOuterClassname, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaOuterClassname) -> Boolean {
    if lhs.clearJavaOuterClassname_p != rhs.clearJavaOuterClassname_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaPackage) -> Boolean {
    if lhs.clearJavaPackage_p != rhs.clearJavaPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaStringCheckUtf8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJavaStringCheckUtf8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJavaStringCheckUtf8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJavaStringCheckUtf8_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJavaStringCheckUtf8_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJavaStringCheckUtf8_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaStringCheckUtf8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJavaStringCheckUtf8) -> Boolean {
    if lhs.clearJavaStringCheckUtf8_p != rhs.clearJavaStringCheckUtf8_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJsonFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJsonFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJsonFormat_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJsonFormat_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJsonFormat_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonFormat) -> Boolean {
    if lhs.clearJsonFormat_p != rhs.clearJsonFormat_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJsonName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJsonName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJsonName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJsonName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJsonName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJsonName) -> Boolean {
    if lhs.clearJsonName_p != rhs.clearJsonName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJstype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearJstype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearJstype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearJstype_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearJstype_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearJstype_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJstype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearJstype) -> Boolean {
    if lhs.clearJstype_p != rhs.clearJstype_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearLabel"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearLabel"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearLabel_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearLabel_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearLabel_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLabel, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLabel) -> Boolean {
    if lhs.clearLabel_p != rhs.clearLabel_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearLazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearLazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearLazy_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearLazy_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearLazy_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLazy) -> Boolean {
    if lhs.clearLazy_p != rhs.clearLazy_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLeadingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearLeadingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearLeadingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearLeadingComments_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearLeadingComments_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearLeadingComments_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLeadingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearLeadingComments) -> Boolean {
    if lhs.clearLeadingComments_p != rhs.clearLeadingComments_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearMapEntry"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearMapEntry"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearMapEntry_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearMapEntry_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearMapEntry_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMapEntry, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMapEntry) -> Boolean {
    if lhs.clearMapEntry_p != rhs.clearMapEntry_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMaximumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearMaximumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearMaximumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearMaximumEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearMaximumEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearMaximumEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMaximumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMaximumEdition) -> Boolean {
    if lhs.clearMaximumEdition_p != rhs.clearMaximumEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearMessageEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearMessageEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearMessageEncoding_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearMessageEncoding_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearMessageEncoding_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageEncoding) -> Boolean {
    if lhs.clearMessageEncoding_p != rhs.clearMessageEncoding_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageSetWireFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearMessageSetWireFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearMessageSetWireFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearMessageSetWireFormat_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearMessageSetWireFormat_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearMessageSetWireFormat_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageSetWireFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMessageSetWireFormat) -> Boolean {
    if lhs.clearMessageSetWireFormat_p != rhs.clearMessageSetWireFormat_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMinimumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearMinimumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearMinimumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearMinimumEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearMinimumEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearMinimumEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMinimumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearMinimumEdition) -> Boolean {
    if lhs.clearMinimumEdition_p != rhs.clearMinimumEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearName) -> Boolean {
    if lhs.clearName_p != rhs.clearName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNamePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearNamePart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearNamePart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearNamePart_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearNamePart_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearNamePart_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNamePart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNamePart) -> Boolean {
    if lhs.clearNamePart_p != rhs.clearNamePart_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNegativeIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearNegativeIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearNegativeIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearNegativeIntValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearNegativeIntValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearNegativeIntValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNegativeIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNegativeIntValue) -> Boolean {
    if lhs.clearNegativeIntValue_p != rhs.clearNegativeIntValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNoStandardDescriptorAccessor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearNoStandardDescriptorAccessor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearNoStandardDescriptorAccessor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearNoStandardDescriptorAccessor_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearNoStandardDescriptorAccessor_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearNoStandardDescriptorAccessor_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNoStandardDescriptorAccessor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNoStandardDescriptorAccessor) -> Boolean {
    if lhs.clearNoStandardDescriptorAccessor_p != rhs.clearNoStandardDescriptorAccessor_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearNumber_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearNumber_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearNumber_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearNumber) -> Boolean {
    if lhs.clearNumber_p != rhs.clearNumber_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearObjcClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearObjcClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearObjcClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearObjcClassPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearObjcClassPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearObjcClassPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearObjcClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearObjcClassPrefix) -> Boolean {
    if lhs.clearObjcClassPrefix_p != rhs.clearObjcClassPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOneofIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearOneofIndex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearOneofIndex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearOneofIndex_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearOneofIndex_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearOneofIndex_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOneofIndex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOneofIndex) -> Boolean {
    if lhs.clearOneofIndex_p != rhs.clearOneofIndex_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptimizeFor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearOptimizeFor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearOptimizeFor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearOptimizeFor_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearOptimizeFor_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearOptimizeFor_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptimizeFor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptimizeFor) -> Boolean {
    if lhs.clearOptimizeFor_p != rhs.clearOptimizeFor_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearOptions_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearOptions_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearOptions_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOptions) -> Boolean {
    if lhs.clearOptions_p != rhs.clearOptions_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOutputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearOutputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearOutputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearOutputType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearOutputType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearOutputType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOutputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOutputType) -> Boolean {
    if lhs.clearOutputType_p != rhs.clearOutputType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOverridableFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearOverridableFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearOverridableFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearOverridableFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearOverridableFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearOverridableFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOverridableFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearOverridableFeatures) -> Boolean {
    if lhs.clearOverridableFeatures_p != rhs.clearOverridableFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPackage) -> Boolean {
    if lhs.clearPackage_p != rhs.clearPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPacked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPacked"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPacked"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPacked_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPacked_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPacked_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPacked, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPacked) -> Boolean {
    if lhs.clearPacked_p != rhs.clearPacked_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPhpClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPhpClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPhpClassPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPhpClassPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPhpClassPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpClassPrefix) -> Boolean {
    if lhs.clearPhpClassPrefix_p != rhs.clearPhpClassPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpMetadataNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPhpMetadataNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPhpMetadataNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPhpMetadataNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPhpMetadataNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPhpMetadataNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpMetadataNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpMetadataNamespace) -> Boolean {
    if lhs.clearPhpMetadataNamespace_p != rhs.clearPhpMetadataNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPhpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPhpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPhpNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPhpNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPhpNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPhpNamespace) -> Boolean {
    if lhs.clearPhpNamespace_p != rhs.clearPhpNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPositiveIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPositiveIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPositiveIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPositiveIntValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPositiveIntValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPositiveIntValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPositiveIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPositiveIntValue) -> Boolean {
    if lhs.clearPositiveIntValue_p != rhs.clearPositiveIntValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearProto3Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearProto3Optional"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearProto3Optional"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearProto3Optional_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearProto3Optional_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearProto3Optional_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearProto3Optional, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearProto3Optional) -> Boolean {
    if lhs.clearProto3Optional_p != rhs.clearProto3Optional_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPyGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearPyGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearPyGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearPyGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearPyGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearPyGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPyGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearPyGenericServices) -> Boolean {
    if lhs.clearPyGenericServices_p != rhs.clearPyGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearRepeated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearRepeated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearRepeated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearRepeated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearRepeated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeated) -> Boolean {
    if lhs.clearRepeated_p != rhs.clearRepeated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeatedFieldEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearRepeatedFieldEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearRepeatedFieldEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearRepeatedFieldEncoding_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearRepeatedFieldEncoding_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearRepeatedFieldEncoding_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeatedFieldEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRepeatedFieldEncoding) -> Boolean {
    if lhs.clearRepeatedFieldEncoding_p != rhs.clearRepeatedFieldEncoding_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearReserved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearReserved"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearReserved"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearReserved_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearReserved_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearReserved_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearReserved, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearReserved) -> Boolean {
    if lhs.clearReserved_p != rhs.clearReserved_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRetention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearRetention"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearRetention"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearRetention_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearRetention_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearRetention_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRetention, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRetention) -> Boolean {
    if lhs.clearRetention_p != rhs.clearRetention_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRubyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearRubyPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearRubyPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearRubyPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearRubyPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearRubyPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRubyPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearRubyPackage) -> Boolean {
    if lhs.clearRubyPackage_p != rhs.clearRubyPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSemantic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSemantic"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSemantic"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSemantic_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSemantic_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSemantic_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSemantic, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSemantic) -> Boolean {
    if lhs.clearSemantic_p != rhs.clearSemantic_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearServerStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearServerStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearServerStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearServerStreaming_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearServerStreaming_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearServerStreaming_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearServerStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearServerStreaming) -> Boolean {
    if lhs.clearServerStreaming_p != rhs.clearServerStreaming_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSourceCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSourceCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSourceCodeInfo_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSourceCodeInfo_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSourceCodeInfo_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceCodeInfo) -> Boolean {
    if lhs.clearSourceCodeInfo_p != rhs.clearSourceCodeInfo_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSourceContext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSourceContext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSourceContext_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSourceContext_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSourceContext_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceContext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceContext) -> Boolean {
    if lhs.clearSourceContext_p != rhs.clearSourceContext_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSourceFile"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSourceFile"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSourceFile_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSourceFile_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSourceFile_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceFile, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSourceFile) -> Boolean {
    if lhs.clearSourceFile_p != rhs.clearSourceFile_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearStart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearStart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearStart_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearStart_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearStart_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStart) -> Boolean {
    if lhs.clearStart_p != rhs.clearStart_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearStringValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearStringValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearStringValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearStringValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearStringValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStringValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearStringValue) -> Boolean {
    if lhs.clearStringValue_p != rhs.clearStringValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSwiftPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSwiftPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSwiftPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSwiftPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSwiftPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSwiftPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSwiftPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSwiftPrefix) -> Boolean {
    if lhs.clearSwiftPrefix_p != rhs.clearSwiftPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSyntax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearSyntax"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearSyntax"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearSyntax_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearSyntax_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearSyntax_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSyntax, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearSyntax) -> Boolean {
    if lhs.clearSyntax_p != rhs.clearSyntax_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTrailingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearTrailingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearTrailingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearTrailingComments_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearTrailingComments_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearTrailingComments_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTrailingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTrailingComments) -> Boolean {
    if lhs.clearTrailingComments_p != rhs.clearTrailingComments_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearType) -> Boolean {
    if lhs.clearType_p != rhs.clearType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTypeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearTypeName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearTypeName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearTypeName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearTypeName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearTypeName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTypeName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearTypeName) -> Boolean {
    if lhs.clearTypeName_p != rhs.clearTypeName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUnverifiedLazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearUnverifiedLazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearUnverifiedLazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearUnverifiedLazy_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearUnverifiedLazy_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearUnverifiedLazy_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUnverifiedLazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUnverifiedLazy) -> Boolean {
    if lhs.clearUnverifiedLazy_p != rhs.clearUnverifiedLazy_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUtf8Validation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearUtf8Validation"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearUtf8Validation"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearUtf8Validation_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearUtf8Validation_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearUtf8Validation_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUtf8Validation, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearUtf8Validation) -> Boolean {
    if lhs.clearUtf8Validation_p != rhs.clearUtf8Validation_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearValue) -> Boolean {
    if lhs.clearValue_p != rhs.clearValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearVerification"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearVerification"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearVerification_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearVerification_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearVerification_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearVerification, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearVerification) -> Boolean {
    if lhs.clearVerification_p != rhs.clearVerification_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearWeak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clearWeak"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clearWeak"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clearWeak_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clearWeak_p != 0 {
      try visitor.visitSingularInt32Field(value: this.clearWeak_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearWeak, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clearWeak) -> Boolean {
    if lhs.clearWeak_p != rhs.clearWeak_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clientStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".clientStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.clientStreaming) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.clientStreaming != 0 {
      try visitor.visitSingularInt32Field(value: this.clientStreaming, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clientStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.clientStreaming) -> Boolean {
    if lhs.clientStreaming != rhs.clientStreaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.code: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".code"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.code) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.code != 0 {
      try visitor.visitSingularInt32Field(value: this.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.code, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.code) -> Boolean {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".codePoint"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codePoint"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.codePoint) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.codePoint != 0 {
      try visitor.visitSingularInt32Field(value: this.codePoint, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePoint, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePoint) -> Boolean {
    if lhs.codePoint != rhs.codePoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codeUnits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".codeUnits"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeUnits"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.codeUnits) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.codeUnits != 0 {
      try visitor.visitSingularInt32Field(value: this.codeUnits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codeUnits, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codeUnits) -> Boolean {
    if lhs.codeUnits != rhs.codeUnits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Collection"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Collection"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.collection) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.collection != 0 {
      try visitor.visitSingularInt32Field(value: this.collection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Collection, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Collection) -> Boolean {
    if lhs.collection != rhs.collection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.com: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".com"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "com"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.com) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.com != 0 {
      try visitor.visitSingularInt32Field(value: this.com, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.com, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.com) -> Boolean {
    if lhs.com != rhs.com {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.comma: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".comma"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comma"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.comma) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.comma != 0 {
      try visitor.visitSingularInt32Field(value: this.comma, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.comma, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.comma) -> Boolean {
    if lhs.comma != rhs.comma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.consumedBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".consumedBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consumedBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.consumedBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.consumedBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.consumedBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.consumedBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.consumedBytes) -> Boolean {
    if lhs.consumedBytes != rhs.consumedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.contentsOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".contentsOf"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentsOf"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.contentsOf) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.contentsOf != 0 {
      try visitor.visitSingularInt32Field(value: this.contentsOf, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.contentsOf, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.contentsOf) -> Boolean {
    if lhs.contentsOf != rhs.contentsOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ContiguousBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ContiguousBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ContiguousBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.contiguousBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.contiguousBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.contiguousBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ContiguousBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ContiguousBytes) -> Boolean {
    if lhs.contiguousBytes != rhs.contiguousBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.copy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".copy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.copy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.copy != 0 {
      try visitor.visitSingularInt32Field(value: this.copy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.copy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.copy) -> Boolean {
    if lhs.copy != rhs.copy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".count"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.count) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.count != 0 {
      try visitor.visitSingularInt32Field(value: this.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.count, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.count) -> Boolean {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.countVarintsInBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".countVarintsInBuffer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countVarintsInBuffer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.countVarintsInBuffer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.countVarintsInBuffer != 0 {
      try visitor.visitSingularInt32Field(value: this.countVarintsInBuffer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.countVarintsInBuffer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.countVarintsInBuffer) -> Boolean {
    if lhs.countVarintsInBuffer != rhs.countVarintsInBuffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.csharpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".csharpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "csharpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.csharpNamespace) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.csharpNamespace != 0 {
      try visitor.visitSingularInt32Field(value: this.csharpNamespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.csharpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.csharpNamespace) -> Boolean {
    if lhs.csharpNamespace != rhs.csharpNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ctype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ctype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ctype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ctype) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ctype != 0 {
      try visitor.visitSingularInt32Field(value: this.ctype, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ctype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ctype) -> Boolean {
    if lhs.ctype != rhs.ctype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.customCodable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".customCodable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "customCodable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.customCodable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.customCodable != 0 {
      try visitor.visitSingularInt32Field(value: this.customCodable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.customCodable, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.customCodable) -> Boolean {
    if lhs.customCodable != rhs.customCodable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomDebugStringConvertible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".CustomDebugStringConvertible"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CustomDebugStringConvertible"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.customDebugStringConvertible) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.customDebugStringConvertible != 0 {
      try visitor.visitSingularInt32Field(value: this.customDebugStringConvertible, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomDebugStringConvertible, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomDebugStringConvertible) -> Boolean {
    if lhs.customDebugStringConvertible != rhs.customDebugStringConvertible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomStringConvertible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".CustomStringConvertible"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CustomStringConvertible"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.customStringConvertible) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.customStringConvertible != 0 {
      try visitor.visitSingularInt32Field(value: this.customStringConvertible, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomStringConvertible, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.CustomStringConvertible) -> Boolean {
    if lhs.customStringConvertible != rhs.customStringConvertible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.d: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".d"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "d"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.d) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.d != 0 {
      try visitor.visitSingularInt32Field(value: this.d, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.d, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.d) -> Boolean {
    if lhs.d != rhs.d {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Data"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Data"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.data) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.data != 0 {
      try visitor.visitSingularInt32Field(value: this.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DataMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DataMessage) -> Boolean {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dataResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".dataResult"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataResult"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.dataResult) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.dataResult != 0 {
      try visitor.visitSingularInt32Field(value: this.dataResult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dataResult, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dataResult) -> Boolean {
    if lhs.dataResult != rhs.dataResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".date"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.date) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.date != 0 {
      try visitor.visitSingularInt32Field(value: this.date, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.date, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.date) -> Boolean {
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daySec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".daySec"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "daySec"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.daySec) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.daySec != 0 {
      try visitor.visitSingularInt32Field(value: this.daySec, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daySec, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daySec) -> Boolean {
    if lhs.daySec != rhs.daySec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daysSinceEpoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".daysSinceEpoch"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "daysSinceEpoch"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.daysSinceEpoch) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.daysSinceEpoch != 0 {
      try visitor.visitSingularInt32Field(value: this.daysSinceEpoch, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daysSinceEpoch, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.daysSinceEpoch) -> Boolean {
    if lhs.daysSinceEpoch != rhs.daysSinceEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugDescriptionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".debugDescription"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debugDescription"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.debugDescription_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.debugDescription_p != 0 {
      try visitor.visitSingularInt32Field(value: this.debugDescription_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugDescriptionMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugDescriptionMessage) -> Boolean {
    if lhs.debugDescription_p != rhs.debugDescription_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugRedact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".debugRedact"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debugRedact"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.debugRedact) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.debugRedact != 0 {
      try visitor.visitSingularInt32Field(value: this.debugRedact, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugRedact, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.debugRedact) -> Boolean {
    if lhs.debugRedact != rhs.debugRedact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.declaration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".declaration"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "declaration"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.declaration) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.declaration != 0 {
      try visitor.visitSingularInt32Field(value: this.declaration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.declaration, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.declaration) -> Boolean {
    if lhs.declaration != rhs.declaration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decoded"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decoded"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decoded) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decoded != 0 {
      try visitor.visitSingularInt32Field(value: this.decoded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoded, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoded) -> Boolean {
    if lhs.decoded != rhs.decoded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodedFromJSONNull: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodedFromJSONNull"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodedFromJSONNull"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodedFromJsonnull) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodedFromJsonnull != 0 {
      try visitor.visitSingularInt32Field(value: this.decodedFromJsonnull, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodedFromJSONNull, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodedFromJSONNull) -> Boolean {
    if lhs.decodedFromJsonnull != rhs.decodedFromJsonnull {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionField) -> Boolean {
    if lhs.decodeExtensionField != rhs.decodeExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionFieldsAsMessageSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeExtensionFieldsAsMessageSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeExtensionFieldsAsMessageSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeExtensionFieldsAsMessageSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeExtensionFieldsAsMessageSet != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeExtensionFieldsAsMessageSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionFieldsAsMessageSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeExtensionFieldsAsMessageSet) -> Boolean {
    if lhs.decodeExtensionFieldsAsMessageSet != rhs.decodeExtensionFieldsAsMessageSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeJSON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeJSON"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeJSON"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeJson) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeJson != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeJson, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeJSON, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeJSON) -> Boolean {
    if lhs.decodeJson != rhs.decodeJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMapField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeMapField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeMapField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeMapField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeMapField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeMapField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMapField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMapField) -> Boolean {
    if lhs.decodeMapField != rhs.decodeMapField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMessageMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeMessage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeMessage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeMessage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeMessage != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMessageMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeMessageMessage) -> Boolean {
    if lhs.decodeMessage != rhs.decodeMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decoder != 0 {
      try visitor.visitSingularInt32Field(value: this.decoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decoder) -> Boolean {
    if lhs.decoder != rhs.decoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeated) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeated != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeated) -> Boolean {
    if lhs.decodeRepeated != rhs.decodeRepeated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBoolField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedBoolField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedBoolField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedBoolField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedBoolField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedBoolField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBoolField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBoolField) -> Boolean {
    if lhs.decodeRepeatedBoolField != rhs.decodeRepeatedBoolField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBytesField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedBytesField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedBytesField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedBytesField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedBytesField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedBytesField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBytesField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedBytesField) -> Boolean {
    if lhs.decodeRepeatedBytesField != rhs.decodeRepeatedBytesField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedDoubleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedDoubleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedDoubleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedDoubleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedDoubleField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedDoubleField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedDoubleField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedDoubleField) -> Boolean {
    if lhs.decodeRepeatedDoubleField != rhs.decodeRepeatedDoubleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedEnumField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedEnumField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedEnumField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedEnumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedEnumField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedEnumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedEnumField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedEnumField) -> Boolean {
    if lhs.decodeRepeatedEnumField != rhs.decodeRepeatedEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedFixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedFixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedFixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed32Field) -> Boolean {
    if lhs.decodeRepeatedFixed32Field != rhs.decodeRepeatedFixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedFixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedFixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedFixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFixed64Field) -> Boolean {
    if lhs.decodeRepeatedFixed64Field != rhs.decodeRepeatedFixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFloatField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedFloatField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedFloatField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedFloatField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedFloatField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedFloatField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFloatField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedFloatField) -> Boolean {
    if lhs.decodeRepeatedFloatField != rhs.decodeRepeatedFloatField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedGroupField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedGroupField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedGroupField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedGroupField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedGroupField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedGroupField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedGroupField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedGroupField) -> Boolean {
    if lhs.decodeRepeatedGroupField != rhs.decodeRepeatedGroupField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedInt32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedInt32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedInt32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt32Field) -> Boolean {
    if lhs.decodeRepeatedInt32Field != rhs.decodeRepeatedInt32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedInt64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedInt64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedInt64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedInt64Field) -> Boolean {
    if lhs.decodeRepeatedInt64Field != rhs.decodeRepeatedInt64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedMessageField) -> Boolean {
    if lhs.decodeRepeatedMessageField != rhs.decodeRepeatedMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedSFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedSFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedSfixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedSfixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedSfixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed32Field) -> Boolean {
    if lhs.decodeRepeatedSfixed32Field != rhs.decodeRepeatedSfixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedSFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedSFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedSfixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedSfixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedSfixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSFixed64Field) -> Boolean {
    if lhs.decodeRepeatedSfixed64Field != rhs.decodeRepeatedSfixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedSInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedSInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedSint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedSint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedSint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt32Field) -> Boolean {
    if lhs.decodeRepeatedSint32Field != rhs.decodeRepeatedSint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedSInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedSInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedSint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedSint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedSint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedSInt64Field) -> Boolean {
    if lhs.decodeRepeatedSint64Field != rhs.decodeRepeatedSint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedStringField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedStringField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedStringField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedStringField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedStringField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedStringField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedStringField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedStringField) -> Boolean {
    if lhs.decodeRepeatedStringField != rhs.decodeRepeatedStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedUInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedUInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedUint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedUint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedUint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt32Field) -> Boolean {
    if lhs.decodeRepeatedUint32Field != rhs.decodeRepeatedUint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeRepeatedUInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeRepeatedUInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeRepeatedUint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeRepeatedUint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeRepeatedUint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeRepeatedUInt64Field) -> Boolean {
    if lhs.decodeRepeatedUint64Field != rhs.decodeRepeatedUint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingular: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingular"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingular"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingular) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingular != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingular, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingular, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingular) -> Boolean {
    if lhs.decodeSingular != rhs.decodeSingular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBoolField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularBoolField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularBoolField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularBoolField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularBoolField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularBoolField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBoolField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBoolField) -> Boolean {
    if lhs.decodeSingularBoolField != rhs.decodeSingularBoolField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBytesField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularBytesField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularBytesField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularBytesField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularBytesField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularBytesField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBytesField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularBytesField) -> Boolean {
    if lhs.decodeSingularBytesField != rhs.decodeSingularBytesField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularDoubleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularDoubleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularDoubleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularDoubleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularDoubleField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularDoubleField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularDoubleField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularDoubleField) -> Boolean {
    if lhs.decodeSingularDoubleField != rhs.decodeSingularDoubleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularEnumField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularEnumField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularEnumField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularEnumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularEnumField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularEnumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularEnumField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularEnumField) -> Boolean {
    if lhs.decodeSingularEnumField != rhs.decodeSingularEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularFixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularFixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularFixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed32Field) -> Boolean {
    if lhs.decodeSingularFixed32Field != rhs.decodeSingularFixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularFixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularFixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularFixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFixed64Field) -> Boolean {
    if lhs.decodeSingularFixed64Field != rhs.decodeSingularFixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFloatField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularFloatField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularFloatField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularFloatField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularFloatField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularFloatField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFloatField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularFloatField) -> Boolean {
    if lhs.decodeSingularFloatField != rhs.decodeSingularFloatField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularGroupField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularGroupField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularGroupField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularGroupField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularGroupField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularGroupField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularGroupField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularGroupField) -> Boolean {
    if lhs.decodeSingularGroupField != rhs.decodeSingularGroupField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularInt32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularInt32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularInt32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt32Field) -> Boolean {
    if lhs.decodeSingularInt32Field != rhs.decodeSingularInt32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularInt64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularInt64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularInt64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularInt64Field) -> Boolean {
    if lhs.decodeSingularInt64Field != rhs.decodeSingularInt64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularMessageField) -> Boolean {
    if lhs.decodeSingularMessageField != rhs.decodeSingularMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularSFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularSFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularSfixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularSfixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularSfixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed32Field) -> Boolean {
    if lhs.decodeSingularSfixed32Field != rhs.decodeSingularSfixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularSFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularSFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularSfixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularSfixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularSfixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSFixed64Field) -> Boolean {
    if lhs.decodeSingularSfixed64Field != rhs.decodeSingularSfixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularSInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularSInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularSint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularSint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularSint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt32Field) -> Boolean {
    if lhs.decodeSingularSint32Field != rhs.decodeSingularSint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularSInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularSInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularSint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularSint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularSint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularSInt64Field) -> Boolean {
    if lhs.decodeSingularSint64Field != rhs.decodeSingularSint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularStringField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularStringField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularStringField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularStringField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularStringField != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularStringField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularStringField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularStringField) -> Boolean {
    if lhs.decodeSingularStringField != rhs.decodeSingularStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularUInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularUInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularUint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularUint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularUint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt32Field) -> Boolean {
    if lhs.decodeSingularUint32Field != rhs.decodeSingularUint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeSingularUInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeSingularUInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeSingularUint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeSingularUint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeSingularUint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeSingularUInt64Field) -> Boolean {
    if lhs.decodeSingularUint64Field != rhs.decodeSingularUint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeTextFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".decodeTextFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decodeTextFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.decodeTextFormat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.decodeTextFormat != 0 {
      try visitor.visitSingularInt32Field(value: this.decodeTextFormat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeTextFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.decodeTextFormat) -> Boolean {
    if lhs.decodeTextFormat != rhs.decodeTextFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultAnyTypeURLPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".defaultAnyTypeURLPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "defaultAnyTypeURLPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.defaultAnyTypeUrlprefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.defaultAnyTypeUrlprefix != 0 {
      try visitor.visitSingularInt32Field(value: this.defaultAnyTypeUrlprefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultAnyTypeURLPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultAnyTypeURLPrefix) -> Boolean {
    if lhs.defaultAnyTypeUrlprefix != rhs.defaultAnyTypeUrlprefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".defaults"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "defaults"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.defaults) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.defaults != 0 {
      try visitor.visitSingularInt32Field(value: this.defaults, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaults, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaults) -> Boolean {
    if lhs.defaults != rhs.defaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".defaultValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "defaultValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.defaultValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.defaultValue != 0 {
      try visitor.visitSingularInt32Field(value: this.defaultValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.defaultValue) -> Boolean {
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".dependency"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dependency"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.dependency) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.dependency != 0 {
      try visitor.visitSingularInt32Field(value: this.dependency, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dependency, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dependency) -> Boolean {
    if lhs.dependency != rhs.dependency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".deprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.deprecated) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.deprecated != 0 {
      try visitor.visitSingularInt32Field(value: this.deprecated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecated) -> Boolean {
    if lhs.deprecated != rhs.deprecated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecatedLegacyJsonFieldConflicts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".deprecatedLegacyJsonFieldConflicts"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deprecatedLegacyJsonFieldConflicts"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.deprecatedLegacyJsonFieldConflicts) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.deprecatedLegacyJsonFieldConflicts != 0 {
      try visitor.visitSingularInt32Field(value: this.deprecatedLegacyJsonFieldConflicts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecatedLegacyJsonFieldConflicts, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecatedLegacyJsonFieldConflicts) -> Boolean {
    if lhs.deprecatedLegacyJsonFieldConflicts != rhs.deprecatedLegacyJsonFieldConflicts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecationWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".deprecationWarning"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deprecationWarning"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.deprecationWarning) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.deprecationWarning != 0 {
      try visitor.visitSingularInt32Field(value: this.deprecationWarning, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecationWarning, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.deprecationWarning) -> Boolean {
    if lhs.deprecationWarning != rhs.deprecationWarning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.descriptionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".description"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.description_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.description_p != 0 {
      try visitor.visitSingularInt32Field(value: this.description_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.descriptionMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.descriptionMessage) -> Boolean {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".DescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.descriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.descriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.descriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DescriptorProto) -> Boolean {
    if lhs.descriptorProto != rhs.descriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Dictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Dictionary"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Dictionary"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.dictionary) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.dictionary != 0 {
      try visitor.visitSingularInt32Field(value: this.dictionary, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Dictionary, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Dictionary) -> Boolean {
    if lhs.dictionary != rhs.dictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dictionaryLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".dictionaryLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dictionaryLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.dictionaryLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.dictionaryLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.dictionaryLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dictionaryLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.dictionaryLiteral) -> Boolean {
    if lhs.dictionaryLiteral != rhs.dictionaryLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digit"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digit"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digit) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digit != 0 {
      try visitor.visitSingularInt32Field(value: this.digit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit) -> Boolean {
    if lhs.digit != rhs.digit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digit0"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digit0"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digit0) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digit0 != 0 {
      try visitor.visitSingularInt32Field(value: this.digit0, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit0, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit0) -> Boolean {
    if lhs.digit0 != rhs.digit0 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digit1"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digit1"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digit1) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digit1 != 0 {
      try visitor.visitSingularInt32Field(value: this.digit1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit1, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digit1) -> Boolean {
    if lhs.digit1 != rhs.digit1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digitCount"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digitCount"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digitCount) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digitCount != 0 {
      try visitor.visitSingularInt32Field(value: this.digitCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitCount, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitCount) -> Boolean {
    if lhs.digitCount != rhs.digitCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digits"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digits"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digits) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digits != 0 {
      try visitor.visitSingularInt32Field(value: this.digits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digits, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digits) -> Boolean {
    if lhs.digits != rhs.digits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".digitValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digitValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.digitValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.digitValue != 0 {
      try visitor.visitSingularInt32Field(value: this.digitValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.digitValue) -> Boolean {
    if lhs.digitValue != rhs.digitValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardableResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".discardableResult"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "discardableResult"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.discardableResult) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.discardableResult != 0 {
      try visitor.visitSingularInt32Field(value: this.discardableResult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardableResult, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardableResult) -> Boolean {
    if lhs.discardableResult != rhs.discardableResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardUnknownFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".discardUnknownFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "discardUnknownFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.discardUnknownFields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.discardUnknownFields != 0 {
      try visitor.visitSingularInt32Field(value: this.discardUnknownFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardUnknownFields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.discardUnknownFields) -> Boolean {
    if lhs.discardUnknownFields != rhs.discardUnknownFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DoubleMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Double"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Double"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.double) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.double != 0 {
      try visitor.visitSingularInt32Field(value: this.double, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DoubleMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.DoubleMessage) -> Boolean {
    if lhs.double != rhs.double {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.doubleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".doubleValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doubleValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.doubleValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.doubleValue != 0 {
      try visitor.visitSingularInt32Field(value: this.doubleValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.doubleValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.doubleValue) -> Boolean {
    if lhs.doubleValue != rhs.doubleValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Duration"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Duration"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.duration) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.duration != 0 {
      try visitor.visitSingularInt32Field(value: this.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Duration, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Duration) -> Boolean {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.E: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".E"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "E"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.e) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.e != 0 {
      try visitor.visitSingularInt32Field(value: this.e, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.E, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.E) -> Boolean {
    if lhs.e != rhs.e {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.edition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".edition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "edition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.edition) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.edition != 0 {
      try visitor.visitSingularInt32Field(value: this.edition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.edition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.edition) -> Boolean {
    if lhs.edition != rhs.edition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EditionDefault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EditionDefault"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EditionDefault"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.editionDefault) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.editionDefault != 0 {
      try visitor.visitSingularInt32Field(value: this.editionDefault, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EditionDefault, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EditionDefault) -> Boolean {
    if lhs.editionDefault != rhs.editionDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDefaults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".editionDefaults"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editionDefaults"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.editionDefaults) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.editionDefaults != 0 {
      try visitor.visitSingularInt32Field(value: this.editionDefaults, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDefaults, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDefaults) -> Boolean {
    if lhs.editionDefaults != rhs.editionDefaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDeprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".editionDeprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editionDeprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.editionDeprecated) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.editionDeprecated != 0 {
      try visitor.visitSingularInt32Field(value: this.editionDeprecated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDeprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionDeprecated) -> Boolean {
    if lhs.editionDeprecated != rhs.editionDeprecated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionIntroduced: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".editionIntroduced"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editionIntroduced"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.editionIntroduced) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.editionIntroduced != 0 {
      try visitor.visitSingularInt32Field(value: this.editionIntroduced, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionIntroduced, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionIntroduced) -> Boolean {
    if lhs.editionIntroduced != rhs.editionIntroduced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".editionRemoved"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editionRemoved"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.editionRemoved) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.editionRemoved != 0 {
      try visitor.visitSingularInt32Field(value: this.editionRemoved, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionRemoved, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.editionRemoved) -> Boolean {
    if lhs.editionRemoved != rhs.editionRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Element"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Element"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.element) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.element != 0 {
      try visitor.visitSingularInt32Field(value: this.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Element, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Element) -> Boolean {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.elements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".elements"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.elements) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.elements != 0 {
      try visitor.visitSingularInt32Field(value: this.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.elements, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.elements) -> Boolean {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitExtensionFieldName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".emitExtensionFieldName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emitExtensionFieldName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.emitExtensionFieldName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.emitExtensionFieldName != 0 {
      try visitor.visitSingularInt32Field(value: this.emitExtensionFieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitExtensionFieldName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitExtensionFieldName) -> Boolean {
    if lhs.emitExtensionFieldName != rhs.emitExtensionFieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".emitFieldName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emitFieldName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.emitFieldName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.emitFieldName != 0 {
      try visitor.visitSingularInt32Field(value: this.emitFieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldName) -> Boolean {
    if lhs.emitFieldName != rhs.emitFieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".emitFieldNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emitFieldNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.emitFieldNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.emitFieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: this.emitFieldNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emitFieldNumber) -> Boolean {
    if lhs.emitFieldNumber != rhs.emitFieldNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Empty"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Empty"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.empty) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.empty != 0 {
      try visitor.visitSingularInt32Field(value: this.empty, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Empty, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Empty) -> Boolean {
    if lhs.empty != rhs.empty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emptyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".emptyData"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emptyData"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.emptyData) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.emptyData != 0 {
      try visitor.visitSingularInt32Field(value: this.emptyData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emptyData, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.emptyData) -> Boolean {
    if lhs.emptyData != rhs.emptyData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeAsBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encodeAsBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodeAsBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encodeAsBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encodeAsBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.encodeAsBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeAsBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeAsBytes) -> Boolean {
    if lhs.encodeAsBytes != rhs.encodeAsBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encoded"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoded"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encoded) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encoded != 0 {
      try visitor.visitSingularInt32Field(value: this.encoded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoded, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoded) -> Boolean {
    if lhs.encoded != rhs.encoded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedJSONString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encodedJSONString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodedJSONString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encodedJsonstring) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encodedJsonstring != 0 {
      try visitor.visitSingularInt32Field(value: this.encodedJsonstring, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedJSONString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedJSONString) -> Boolean {
    if lhs.encodedJsonstring != rhs.encodedJsonstring {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encodedSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodedSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encodedSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encodedSize != 0 {
      try visitor.visitSingularInt32Field(value: this.encodedSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodedSize) -> Boolean {
    if lhs.encodedSize != rhs.encodedSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encodeField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodeField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encodeField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encodeField != 0 {
      try visitor.visitSingularInt32Field(value: this.encodeField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encodeField) -> Boolean {
    if lhs.encodeField != rhs.encodeField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".encoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.encoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.encoder != 0 {
      try visitor.visitSingularInt32Field(value: this.encoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.encoder) -> Boolean {
    if lhs.encoder != rhs.encoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.end: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".end"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "end"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.end) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.end != 0 {
      try visitor.visitSingularInt32Field(value: this.end, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.end, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.end) -> Boolean {
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".endArray"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endArray"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.endArray) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.endArray != 0 {
      try visitor.visitSingularInt32Field(value: this.endArray, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endArray, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endArray) -> Boolean {
    if lhs.endArray != rhs.endArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".endMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.endMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.endMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.endMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endMessageField) -> Boolean {
    if lhs.endMessageField != rhs.endMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".endObject"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endObject"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.endObject) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.endObject != 0 {
      try visitor.visitSingularInt32Field(value: this.endObject, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endObject, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endObject) -> Boolean {
    if lhs.endObject != rhs.endObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endRegularField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".endRegularField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endRegularField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.endRegularField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.endRegularField != 0 {
      try visitor.visitSingularInt32Field(value: this.endRegularField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endRegularField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.endRegularField) -> Boolean {
    if lhs.endRegularField != rhs.endRegularField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".enum"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enum"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`enum`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`enum` != 0 {
      try visitor.visitSingularInt32Field(value: this.`enum`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumMessage) -> Boolean {
    if lhs.`enum` != rhs.`enum` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EnumDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EnumDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.enumDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumDescriptorProto) -> Boolean {
    if lhs.enumDescriptorProto != rhs.enumDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EnumOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EnumOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.enumOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumOptions) -> Boolean {
    if lhs.enumOptions != rhs.enumOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumReservedRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EnumReservedRange"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EnumReservedRange"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumReservedRange) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumReservedRange != 0 {
      try visitor.visitSingularInt32Field(value: this.enumReservedRange, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumReservedRange, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumReservedRange) -> Boolean {
    if lhs.enumReservedRange != rhs.enumReservedRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".enumType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enumType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumType != 0 {
      try visitor.visitSingularInt32Field(value: this.enumType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumType) -> Boolean {
    if lhs.enumType != rhs.enumType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumvalue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".enumvalue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enumvalue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumvalue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumvalue != 0 {
      try visitor.visitSingularInt32Field(value: this.enumvalue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumvalue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.enumvalue) -> Boolean {
    if lhs.enumvalue != rhs.enumvalue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EnumValueDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EnumValueDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumValueDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumValueDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.enumValueDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueDescriptorProto) -> Boolean {
    if lhs.enumValueDescriptorProto != rhs.enumValueDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".EnumValueOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EnumValueOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.enumValueOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.enumValueOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.enumValueOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EnumValueOptions) -> Boolean {
    if lhs.enumValueOptions != rhs.enumValueOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EquatableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Equatable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Equatable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.equatable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.equatable != 0 {
      try visitor.visitSingularInt32Field(value: this.equatable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EquatableMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.EquatableMessage) -> Boolean {
    if lhs.equatable != rhs.equatable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Error"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Error"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.error) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.error != 0 {
      try visitor.visitSingularInt32Field(value: this.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Error, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Error) -> Boolean {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByArrayLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExpressibleByArrayLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExpressibleByArrayLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.expressibleByArrayLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.expressibleByArrayLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.expressibleByArrayLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByArrayLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByArrayLiteral) -> Boolean {
    if lhs.expressibleByArrayLiteral != rhs.expressibleByArrayLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByDictionaryLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExpressibleByDictionaryLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExpressibleByDictionaryLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.expressibleByDictionaryLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.expressibleByDictionaryLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.expressibleByDictionaryLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByDictionaryLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExpressibleByDictionaryLiteral) -> Boolean {
    if lhs.expressibleByDictionaryLiteral != rhs.expressibleByDictionaryLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ext) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ext != 0 {
      try visitor.visitSingularInt32Field(value: this.ext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ext) -> Boolean {
    if lhs.ext != rhs.ext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.extDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extDecoder) -> Boolean {
    if lhs.extDecoder != rhs.extDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendedGraphemeClusterLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extendedGraphemeClusterLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extendedGraphemeClusterLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extendedGraphemeClusterLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extendedGraphemeClusterLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.extendedGraphemeClusterLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendedGraphemeClusterLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendedGraphemeClusterLiteral) -> Boolean {
    if lhs.extendedGraphemeClusterLiteral != rhs.extendedGraphemeClusterLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtendedGraphemeClusterLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtendedGraphemeClusterLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtendedGraphemeClusterLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extendedGraphemeClusterLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extendedGraphemeClusterLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.extendedGraphemeClusterLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtendedGraphemeClusterLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtendedGraphemeClusterLiteralType) -> Boolean {
    if lhs.extendedGraphemeClusterLiteralType != rhs.extendedGraphemeClusterLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extendee"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extendee"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extendee) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extendee != 0 {
      try visitor.visitSingularInt32Field(value: this.extendee, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendee, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extendee) -> Boolean {
    if lhs.extendee != rhs.extendee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensibleMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtensibleMessage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtensibleMessage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensibleMessage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensibleMessage != 0 {
      try visitor.visitSingularInt32Field(value: this.extensibleMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensibleMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensibleMessage) -> Boolean {
    if lhs.extensibleMessage != rhs.extensibleMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`extension`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`extension` != 0 {
      try visitor.visitSingularInt32Field(value: this.`extension`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionMessage) -> Boolean {
    if lhs.`extension` != rhs.`extension` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionField) -> Boolean {
    if lhs.extensionField != rhs.extensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionFieldNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extensionFieldNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extensionFieldNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionFieldNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionFieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionFieldNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionFieldNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionFieldNumber) -> Boolean {
    if lhs.extensionFieldNumber != rhs.extensionFieldNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionFieldValueSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtensionFieldValueSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtensionFieldValueSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionFieldValueSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionFieldValueSet != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionFieldValueSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionFieldValueSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionFieldValueSet) -> Boolean {
    if lhs.extensionFieldValueSet != rhs.extensionFieldValueSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtensionMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtensionMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionMap != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionMap) -> Boolean {
    if lhs.extensionMap != rhs.extensionMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extensionRange"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extensionRange"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionRange) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionRange != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionRange, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionRange, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensionRange) -> Boolean {
    if lhs.extensionRange != rhs.extensionRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionRangeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ExtensionRangeOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExtensionRangeOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensionRangeOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensionRangeOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.extensionRangeOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionRangeOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ExtensionRangeOptions) -> Boolean {
    if lhs.extensionRangeOptions != rhs.extensionRangeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extensions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extensions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extensions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extensions != 0 {
      try visitor.visitSingularInt32Field(value: this.extensions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extensions) -> Boolean {
    if lhs.extensions != rhs.extensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extras: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".extras"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extras"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.extras) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.extras != 0 {
      try visitor.visitSingularInt32Field(value: this.extras, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extras, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.extras) -> Boolean {
    if lhs.extras != rhs.extras {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.F: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".F"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "F"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.f) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.f != 0 {
      try visitor.visitSingularInt32Field(value: this.f, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.F, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.F) -> Boolean {
    if lhs.f != rhs.f {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.falseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".false"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "false"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`false`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`false` != 0 {
      try visitor.visitSingularInt32Field(value: this.`false`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.falseMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.falseMessage) -> Boolean {
    if lhs.`false` != rhs.`false` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".features"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.features) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.features != 0 {
      try visitor.visitSingularInt32Field(value: this.features, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.features, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.features) -> Boolean {
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FeatureSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FeatureSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.featureSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.featureSet != 0 {
      try visitor.visitSingularInt32Field(value: this.featureSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSet) -> Boolean {
    if lhs.featureSet != rhs.featureSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetDefaults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FeatureSetDefaults"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FeatureSetDefaults"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.featureSetDefaults) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.featureSetDefaults != 0 {
      try visitor.visitSingularInt32Field(value: this.featureSetDefaults, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetDefaults, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetDefaults) -> Boolean {
    if lhs.featureSetDefaults != rhs.featureSetDefaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetEditionDefault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FeatureSetEditionDefault"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FeatureSetEditionDefault"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.featureSetEditionDefault) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.featureSetEditionDefault != 0 {
      try visitor.visitSingularInt32Field(value: this.featureSetEditionDefault, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetEditionDefault, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FeatureSetEditionDefault) -> Boolean {
    if lhs.featureSetEditionDefault != rhs.featureSetEditionDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.featureSupport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".featureSupport"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureSupport"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.featureSupport) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.featureSupport != 0 {
      try visitor.visitSingularInt32Field(value: this.featureSupport, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.featureSupport, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.featureSupport) -> Boolean {
    if lhs.featureSupport != rhs.featureSupport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.field != 0 {
      try visitor.visitSingularInt32Field(value: this.field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.field) -> Boolean {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldData"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldData"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldData) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldData != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldData, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldData) -> Boolean {
    if lhs.fieldData != rhs.fieldData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FieldDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FieldDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldDescriptorProto) -> Boolean {
    if lhs.fieldDescriptorProto != rhs.fieldDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FieldMask"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FieldMask"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldMask) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldMask != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldMask, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldMask, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldMask) -> Boolean {
    if lhs.fieldMask != rhs.fieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldName != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldName) -> Boolean {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNameCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldNameCount"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldNameCount"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldNameCount) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldNameCount != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldNameCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNameCount, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNameCount) -> Boolean {
    if lhs.fieldNameCount != rhs.fieldNameCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldNum"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldNum"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldNum) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldNum != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNum, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNum) -> Boolean {
    if lhs.fieldNum != rhs.fieldNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumber) -> Boolean {
    if lhs.fieldNumber != rhs.fieldNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumberForProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldNumberForProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldNumberForProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldNumberForProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldNumberForProto != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldNumberForProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumberForProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldNumberForProto) -> Boolean {
    if lhs.fieldNumberForProto != rhs.fieldNumberForProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FieldOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FieldOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldOptions) -> Boolean {
    if lhs.fieldOptions != rhs.fieldOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldPresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldPresence"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldPresence"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldPresence) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldPresence != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldPresence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldPresence, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldPresence) -> Boolean {
    if lhs.fieldPresence != rhs.fieldPresence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fields != 0 {
      try visitor.visitSingularInt32Field(value: this.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fields) -> Boolean {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldSize != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldSize) -> Boolean {
    if lhs.fieldSize != rhs.fieldSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FieldTag"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FieldTag"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldTag) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldTag != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldTag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldTag, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FieldTag) -> Boolean {
    if lhs.fieldTag != rhs.fieldTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fieldType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fieldType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fieldType != 0 {
      try visitor.visitSingularInt32Field(value: this.fieldType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fieldType) -> Boolean {
    if lhs.fieldType != rhs.fieldType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.file: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".file"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.file) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.file != 0 {
      try visitor.visitSingularInt32Field(value: this.file, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.file, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.file) -> Boolean {
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FileDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FileDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fileDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fileDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.fileDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorProto) -> Boolean {
    if lhs.fileDescriptorProto != rhs.fileDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FileDescriptorSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FileDescriptorSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fileDescriptorSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fileDescriptorSet != 0 {
      try visitor.visitSingularInt32Field(value: this.fileDescriptorSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileDescriptorSet) -> Boolean {
    if lhs.fileDescriptorSet != rhs.fileDescriptorSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fileName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fileName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fileName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fileName != 0 {
      try visitor.visitSingularInt32Field(value: this.fileName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fileName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fileName) -> Boolean {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FileOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FileOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fileOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fileOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.fileOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FileOptions) -> Boolean {
    if lhs.fileOptions != rhs.fileOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".filter"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.filter) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.filter != 0 {
      try visitor.visitSingularInt32Field(value: this.filter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.filter, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.filter) -> Boolean {
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.final: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".final"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "final"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.final) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.final != 0 {
      try visitor.visitSingularInt32Field(value: this.final, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.final, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.final) -> Boolean {
    if lhs.final != rhs.final {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.finiteOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".finiteOnly"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finiteOnly"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.finiteOnly) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.finiteOnly != 0 {
      try visitor.visitSingularInt32Field(value: this.finiteOnly, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.finiteOnly, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.finiteOnly) -> Boolean {
    if lhs.finiteOnly != rhs.finiteOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.first: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".first"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "first"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.first) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.first != 0 {
      try visitor.visitSingularInt32Field(value: this.first, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.first, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.first) -> Boolean {
    if lhs.first != rhs.first {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.firstItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".firstItem"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "firstItem"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.firstItem) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.firstItem != 0 {
      try visitor.visitSingularInt32Field(value: this.firstItem, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.firstItem, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.firstItem) -> Boolean {
    if lhs.firstItem != rhs.firstItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fixedFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fixedFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixedFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fixedFeatures) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fixedFeatures != 0 {
      try visitor.visitSingularInt32Field(value: this.fixedFeatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fixedFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fixedFeatures) -> Boolean {
    if lhs.fixedFeatures != rhs.fixedFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Float"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Float"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.float) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.float != 0 {
      try visitor.visitSingularInt32Field(value: this.float, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatMessage) -> Boolean {
    if lhs.float != rhs.float {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.floatLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".floatLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.floatLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.floatLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.floatLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.floatLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.floatLiteral) -> Boolean {
    if lhs.floatLiteral != rhs.floatLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FloatLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FloatLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.floatLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.floatLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.floatLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatLiteralType) -> Boolean {
    if lhs.floatLiteralType != rhs.floatLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".FloatValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FloatValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.floatValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.floatValue != 0 {
      try visitor.visitSingularInt32Field(value: this.floatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.FloatValue) -> Boolean {
    if lhs.floatValue != rhs.floatValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forMessageName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".forMessageName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forMessageName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.forMessageName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.forMessageName != 0 {
      try visitor.visitSingularInt32Field(value: this.forMessageName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forMessageName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forMessageName) -> Boolean {
    if lhs.forMessageName != rhs.forMessageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.formUnion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".formUnion"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "formUnion"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.formUnion) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.formUnion != 0 {
      try visitor.visitSingularInt32Field(value: this.formUnion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.formUnion, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.formUnion) -> Boolean {
    if lhs.formUnion != rhs.formUnion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forReadingFrom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".forReadingFrom"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forReadingFrom"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.forReadingFrom) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.forReadingFrom != 0 {
      try visitor.visitSingularInt32Field(value: this.forReadingFrom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forReadingFrom, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forReadingFrom) -> Boolean {
    if lhs.forReadingFrom != rhs.forReadingFrom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forTypeURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".forTypeURL"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forTypeURL"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.forTypeURL) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.forTypeURL != 0 {
      try visitor.visitSingularInt32Field(value: this.forTypeURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forTypeURL, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forTypeURL) -> Boolean {
    if lhs.forTypeURL != rhs.forTypeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ForwardParser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ForwardParser"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ForwardParser"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.forwardParser) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.forwardParser != 0 {
      try visitor.visitSingularInt32Field(value: this.forwardParser, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ForwardParser, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ForwardParser) -> Boolean {
    if lhs.forwardParser != rhs.forwardParser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forWritingInto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".forWritingInto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forWritingInto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.forWritingInto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.forWritingInto != 0 {
      try visitor.visitSingularInt32Field(value: this.forWritingInto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forWritingInto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.forWritingInto) -> Boolean {
    if lhs.forWritingInto != rhs.forWritingInto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.from: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".from"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.from) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.from != 0 {
      try visitor.visitSingularInt32Field(value: this.from, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.from, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.from) -> Boolean {
    if lhs.from != rhs.from {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fromAscii2"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromAscii2"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fromAscii2) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fromAscii2 != 0 {
      try visitor.visitSingularInt32Field(value: this.fromAscii2, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii2, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii2) -> Boolean {
    if lhs.fromAscii2 != rhs.fromAscii2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fromAscii4"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromAscii4"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fromAscii4) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fromAscii4 != 0 {
      try visitor.visitSingularInt32Field(value: this.fromAscii4, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii4, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromAscii4) -> Boolean {
    if lhs.fromAscii4 != rhs.fromAscii4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromByteOffset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fromByteOffset"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromByteOffset"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fromByteOffset) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fromByteOffset != 0 {
      try visitor.visitSingularInt32Field(value: this.fromByteOffset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromByteOffset, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromByteOffset) -> Boolean {
    if lhs.fromByteOffset != rhs.fromByteOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromHexDigit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fromHexDigit"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromHexDigit"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fromHexDigit) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fromHexDigit != 0 {
      try visitor.visitSingularInt32Field(value: this.fromHexDigit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromHexDigit, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fromHexDigit) -> Boolean {
    if lhs.fromHexDigit != rhs.fromHexDigit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fullName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fullName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.fullName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.fullName != 0 {
      try visitor.visitSingularInt32Field(value: this.fullName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fullName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.fullName) -> Boolean {
    if lhs.fullName != rhs.fullName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.funcMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".fn"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fn"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`fn`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`fn` != 0 {
      try visitor.visitSingularInt32Field(value: this.`fn`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.funcMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.funcMessage) -> Boolean {
    if lhs.`fn` != rhs.`fn` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".function"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.function) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.function != 0 {
      try visitor.visitSingularInt32Field(value: this.function, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.function, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.function) -> Boolean {
    if lhs.function != rhs.function {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.G: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".G"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "G"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.g) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.g != 0 {
      try visitor.visitSingularInt32Field(value: this.g, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.G, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.G) -> Boolean {
    if lhs.g != rhs.g {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.GeneratedCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".GeneratedCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GeneratedCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.generatedCodeInfo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.generatedCodeInfo != 0 {
      try visitor.visitSingularInt32Field(value: this.generatedCodeInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.GeneratedCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.GeneratedCodeInfo) -> Boolean {
    if lhs.generatedCodeInfo != rhs.generatedCodeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".get"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "get"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.get) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.get != 0 {
      try visitor.visitSingularInt32Field(value: this.get, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.get, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.get) -> Boolean {
    if lhs.get != rhs.get {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.getExtensionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".getExtensionValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getExtensionValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.getExtensionValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.getExtensionValue != 0 {
      try visitor.visitSingularInt32Field(value: this.getExtensionValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.getExtensionValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.getExtensionValue) -> Boolean {
    if lhs.getExtensionValue != rhs.getExtensionValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.googleapis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".googleapis"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "googleapis"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleapis) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleapis != 0 {
      try visitor.visitSingularInt32Field(value: this.googleapis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.googleapis, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.googleapis) -> Boolean {
    if lhs.googleapis != rhs.googleapis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Any: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Any"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Any"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufAny) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufAny != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufAny, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Any, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Any) -> Boolean {
    if lhs.googleProtobufAny != rhs.googleProtobufAny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Api: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Api"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Api"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufApi) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufApi != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufApi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Api, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Api) -> Boolean {
    if lhs.googleProtobufApi != rhs.googleProtobufApi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_BoolValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_BoolValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufBoolValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufBoolValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufBoolValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BoolValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BoolValue) -> Boolean {
    if lhs.googleProtobufBoolValue != rhs.googleProtobufBoolValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BytesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_BytesValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_BytesValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufBytesValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufBytesValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufBytesValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BytesValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_BytesValue) -> Boolean {
    if lhs.googleProtobufBytesValue != rhs.googleProtobufBytesValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_DescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_DescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DescriptorProto) -> Boolean {
    if lhs.googleProtobufDescriptorProto != rhs.googleProtobufDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DoubleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_DoubleValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_DoubleValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufDoubleValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufDoubleValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufDoubleValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DoubleValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_DoubleValue) -> Boolean {
    if lhs.googleProtobufDoubleValue != rhs.googleProtobufDoubleValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Duration"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Duration"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufDuration) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufDuration != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufDuration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Duration, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Duration) -> Boolean {
    if lhs.googleProtobufDuration != rhs.googleProtobufDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Edition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Edition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Edition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEdition) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEdition != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEdition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Edition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Edition) -> Boolean {
    if lhs.googleProtobufEdition != rhs.googleProtobufEdition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Empty"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Empty"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEmpty) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEmpty != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEmpty, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Empty, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Empty) -> Boolean {
    if lhs.googleProtobufEmpty != rhs.googleProtobufEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Enum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Enum"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Enum"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnum) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnum != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Enum, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Enum) -> Boolean {
    if lhs.googleProtobufEnum != rhs.googleProtobufEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_EnumDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_EnumDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnumDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnumDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnumDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumDescriptorProto) -> Boolean {
    if lhs.googleProtobufEnumDescriptorProto != rhs.googleProtobufEnumDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_EnumOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_EnumOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnumOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnumOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnumOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumOptions) -> Boolean {
    if lhs.googleProtobufEnumOptions != rhs.googleProtobufEnumOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_EnumValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_EnumValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnumValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnumValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnumValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValue) -> Boolean {
    if lhs.googleProtobufEnumValue != rhs.googleProtobufEnumValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_EnumValueDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_EnumValueDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnumValueDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnumValueDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnumValueDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueDescriptorProto) -> Boolean {
    if lhs.googleProtobufEnumValueDescriptorProto != rhs.googleProtobufEnumValueDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_EnumValueOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_EnumValueOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufEnumValueOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufEnumValueOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufEnumValueOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_EnumValueOptions) -> Boolean {
    if lhs.googleProtobufEnumValueOptions != rhs.googleProtobufEnumValueOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_ExtensionRangeOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_ExtensionRangeOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufExtensionRangeOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufExtensionRangeOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufExtensionRangeOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ExtensionRangeOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ExtensionRangeOptions) -> Boolean {
    if lhs.googleProtobufExtensionRangeOptions != rhs.googleProtobufExtensionRangeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FeatureSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FeatureSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFeatureSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFeatureSet != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFeatureSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSet) -> Boolean {
    if lhs.googleProtobufFeatureSet != rhs.googleProtobufFeatureSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSetDefaults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FeatureSetDefaults"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FeatureSetDefaults"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFeatureSetDefaults) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFeatureSetDefaults != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFeatureSetDefaults, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSetDefaults, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FeatureSetDefaults) -> Boolean {
    if lhs.googleProtobufFeatureSetDefaults != rhs.googleProtobufFeatureSetDefaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufField != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Field) -> Boolean {
    if lhs.googleProtobufField != rhs.googleProtobufField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FieldDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FieldDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFieldDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFieldDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFieldDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldDescriptorProto) -> Boolean {
    if lhs.googleProtobufFieldDescriptorProto != rhs.googleProtobufFieldDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FieldMask"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FieldMask"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFieldMask) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFieldMask != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFieldMask, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldMask, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldMask) -> Boolean {
    if lhs.googleProtobufFieldMask != rhs.googleProtobufFieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FieldOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FieldOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFieldOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFieldOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFieldOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FieldOptions) -> Boolean {
    if lhs.googleProtobufFieldOptions != rhs.googleProtobufFieldOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FileDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FileDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFileDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFileDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFileDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorProto) -> Boolean {
    if lhs.googleProtobufFileDescriptorProto != rhs.googleProtobufFileDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FileDescriptorSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FileDescriptorSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFileDescriptorSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFileDescriptorSet != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFileDescriptorSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileDescriptorSet) -> Boolean {
    if lhs.googleProtobufFileDescriptorSet != rhs.googleProtobufFileDescriptorSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FileOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FileOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFileOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFileOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFileOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FileOptions) -> Boolean {
    if lhs.googleProtobufFileOptions != rhs.googleProtobufFileOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FloatValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_FloatValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_FloatValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufFloatValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufFloatValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufFloatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FloatValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_FloatValue) -> Boolean {
    if lhs.googleProtobufFloatValue != rhs.googleProtobufFloatValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_GeneratedCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_GeneratedCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufGeneratedCodeInfo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufGeneratedCodeInfo != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufGeneratedCodeInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_GeneratedCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_GeneratedCodeInfo) -> Boolean {
    if lhs.googleProtobufGeneratedCodeInfo != rhs.googleProtobufGeneratedCodeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int32Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Int32Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Int32Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufInt32Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufInt32Value != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufInt32Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int32Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int32Value) -> Boolean {
    if lhs.googleProtobufInt32Value != rhs.googleProtobufInt32Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Int64Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Int64Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufInt64Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufInt64Value != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufInt64Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int64Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Int64Value) -> Boolean {
    if lhs.googleProtobufInt64Value != rhs.googleProtobufInt64Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_ListValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_ListValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufListValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufListValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufListValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ListValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ListValue) -> Boolean {
    if lhs.googleProtobufListValue != rhs.googleProtobufListValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MessageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_MessageOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_MessageOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufMessageOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufMessageOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufMessageOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MessageOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MessageOptions) -> Boolean {
    if lhs.googleProtobufMessageOptions != rhs.googleProtobufMessageOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Method: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Method"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Method"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufMethod) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufMethod != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufMethod, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Method, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Method) -> Boolean {
    if lhs.googleProtobufMethod != rhs.googleProtobufMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_MethodDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_MethodDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufMethodDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufMethodDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufMethodDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodDescriptorProto) -> Boolean {
    if lhs.googleProtobufMethodDescriptorProto != rhs.googleProtobufMethodDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_MethodOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_MethodOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufMethodOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufMethodOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufMethodOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_MethodOptions) -> Boolean {
    if lhs.googleProtobufMethodOptions != rhs.googleProtobufMethodOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Mixin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Mixin"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Mixin"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufMixin) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufMixin != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufMixin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Mixin, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Mixin) -> Boolean {
    if lhs.googleProtobufMixin != rhs.googleProtobufMixin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_NullValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_NullValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_NullValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufNullValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufNullValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufNullValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_NullValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_NullValue) -> Boolean {
    if lhs.googleProtobufNullValue != rhs.googleProtobufNullValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_OneofDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_OneofDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufOneofDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufOneofDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufOneofDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofDescriptorProto) -> Boolean {
    if lhs.googleProtobufOneofDescriptorProto != rhs.googleProtobufOneofDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_OneofOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_OneofOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufOneofOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufOneofOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufOneofOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_OneofOptions) -> Boolean {
    if lhs.googleProtobufOneofOptions != rhs.googleProtobufOneofOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Option"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Option"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufOption) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufOption != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufOption, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Option, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Option) -> Boolean {
    if lhs.googleProtobufOption != rhs.googleProtobufOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_ServiceDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_ServiceDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufServiceDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufServiceDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufServiceDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceDescriptorProto) -> Boolean {
    if lhs.googleProtobufServiceDescriptorProto != rhs.googleProtobufServiceDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_ServiceOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_ServiceOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufServiceOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufServiceOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufServiceOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_ServiceOptions) -> Boolean {
    if lhs.googleProtobufServiceOptions != rhs.googleProtobufServiceOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_SourceCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_SourceCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufSourceCodeInfo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufSourceCodeInfo != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufSourceCodeInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceCodeInfo) -> Boolean {
    if lhs.googleProtobufSourceCodeInfo != rhs.googleProtobufSourceCodeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_SourceContext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_SourceContext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufSourceContext) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufSourceContext != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufSourceContext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceContext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_SourceContext) -> Boolean {
    if lhs.googleProtobufSourceContext != rhs.googleProtobufSourceContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_StringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_StringValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_StringValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufStringValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufStringValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufStringValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_StringValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_StringValue) -> Boolean {
    if lhs.googleProtobufStringValue != rhs.googleProtobufStringValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Struct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Struct"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Struct"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufStruct) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufStruct != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufStruct, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Struct, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Struct) -> Boolean {
    if lhs.googleProtobufStruct != rhs.googleProtobufStruct {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Syntax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Syntax"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Syntax"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufSyntax) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufSyntax != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufSyntax, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Syntax, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Syntax) -> Boolean {
    if lhs.googleProtobufSyntax != rhs.googleProtobufSyntax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Timestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Timestamp"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Timestamp"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufTimestamp) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufTimestamp != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufTimestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Timestamp, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Timestamp) -> Boolean {
    if lhs.googleProtobufTimestamp != rhs.googleProtobufTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Type: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Type"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Type"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufType != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Type, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Type) -> Boolean {
    if lhs.googleProtobufType != rhs.googleProtobufType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt32Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_UInt32Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_UInt32Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufUint32Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufUint32Value != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufUint32Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt32Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt32Value) -> Boolean {
    if lhs.googleProtobufUint32Value != rhs.googleProtobufUint32Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_UInt64Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_UInt64Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufUint64Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufUint64Value != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufUint64Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt64Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UInt64Value) -> Boolean {
    if lhs.googleProtobufUint64Value != rhs.googleProtobufUint64Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UninterpretedOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_UninterpretedOption"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_UninterpretedOption"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufUninterpretedOption) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufUninterpretedOption != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufUninterpretedOption, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UninterpretedOption, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_UninterpretedOption) -> Boolean {
    if lhs.googleProtobufUninterpretedOption != rhs.googleProtobufUninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Google_Protobuf_Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Google_Protobuf_Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.googleProtobufValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.googleProtobufValue != 0 {
      try visitor.visitSingularInt32Field(value: this.googleProtobufValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Google_Protobuf_Value) -> Boolean {
    if lhs.googleProtobufValue != rhs.googleProtobufValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.goPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".goPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.goPackage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.goPackage != 0 {
      try visitor.visitSingularInt32Field(value: this.goPackage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.goPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.goPackage) -> Boolean {
    if lhs.goPackage != rhs.goPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".group"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.group) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.group != 0 {
      try visitor.visitSingularInt32Field(value: this.group, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.group, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.group) -> Boolean {
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupFieldNumberStack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".groupFieldNumberStack"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupFieldNumberStack"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.groupFieldNumberStack) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.groupFieldNumberStack != 0 {
      try visitor.visitSingularInt32Field(value: this.groupFieldNumberStack, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupFieldNumberStack, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupFieldNumberStack) -> Boolean {
    if lhs.groupFieldNumberStack != rhs.groupFieldNumberStack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".groupSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.groupSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.groupSize != 0 {
      try visitor.visitSingularInt32Field(value: this.groupSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.groupSize) -> Boolean {
    if lhs.groupSize != rhs.groupSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hadOneofValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hadOneofValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hadOneofValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hadOneofValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hadOneofValue != 0 {
      try visitor.visitSingularInt32Field(value: this.hadOneofValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hadOneofValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hadOneofValue) -> Boolean {
    if lhs.hadOneofValue != rhs.hadOneofValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.handleConflictingOneOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".handleConflictingOneOf"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handleConflictingOneOf"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.handleConflictingOneOf) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.handleConflictingOneOf != 0 {
      try visitor.visitSingularInt32Field(value: this.handleConflictingOneOf, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.handleConflictingOneOf, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.handleConflictingOneOf) -> Boolean {
    if lhs.handleConflictingOneOf != rhs.handleConflictingOneOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAggregateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasAggregateValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasAggregateValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasAggregateValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasAggregateValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasAggregateValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAggregateValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAggregateValue) -> Boolean {
    if lhs.hasAggregateValue_p != rhs.hasAggregateValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAllowAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasAllowAlias"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasAllowAlias"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasAllowAlias_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasAllowAlias_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasAllowAlias_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAllowAlias, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasAllowAlias) -> Boolean {
    if lhs.hasAllowAlias_p != rhs.hasAllowAlias_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasBegin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasBegin"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasBegin"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasBegin_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasBegin_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasBegin_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasBegin, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasBegin) -> Boolean {
    if lhs.hasBegin_p != rhs.hasBegin_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcEnableArenas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasCcEnableArenas"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasCcEnableArenas"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasCcEnableArenas_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasCcEnableArenas_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasCcEnableArenas_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcEnableArenas, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcEnableArenas) -> Boolean {
    if lhs.hasCcEnableArenas_p != rhs.hasCcEnableArenas_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasCcGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasCcGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasCcGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasCcGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasCcGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCcGenericServices) -> Boolean {
    if lhs.hasCcGenericServices_p != rhs.hasCcGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasClientStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasClientStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasClientStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasClientStreaming_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasClientStreaming_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasClientStreaming_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasClientStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasClientStreaming) -> Boolean {
    if lhs.hasClientStreaming_p != rhs.hasClientStreaming_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCsharpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasCsharpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasCsharpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasCsharpNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasCsharpNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasCsharpNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCsharpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCsharpNamespace) -> Boolean {
    if lhs.hasCsharpNamespace_p != rhs.hasCsharpNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCtype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasCtype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasCtype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasCtype_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasCtype_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasCtype_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCtype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasCtype) -> Boolean {
    if lhs.hasCtype_p != rhs.hasCtype_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDebugRedact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDebugRedact"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDebugRedact"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDebugRedact_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDebugRedact_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDebugRedact_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDebugRedact, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDebugRedact) -> Boolean {
    if lhs.hasDebugRedact_p != rhs.hasDebugRedact_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDefaultValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDefaultValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDefaultValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDefaultValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDefaultValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDefaultValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDefaultValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDefaultValue) -> Boolean {
    if lhs.hasDefaultValue_p != rhs.hasDefaultValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDeprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDeprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDeprecated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDeprecated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDeprecated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecated) -> Boolean {
    if lhs.hasDeprecated_p != rhs.hasDeprecated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecatedLegacyJsonFieldConflicts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDeprecatedLegacyJsonFieldConflicts"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDeprecatedLegacyJsonFieldConflicts"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDeprecatedLegacyJsonFieldConflicts_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDeprecatedLegacyJsonFieldConflicts_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDeprecatedLegacyJsonFieldConflicts_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecatedLegacyJsonFieldConflicts, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecatedLegacyJsonFieldConflicts) -> Boolean {
    if lhs.hasDeprecatedLegacyJsonFieldConflicts_p != rhs.hasDeprecatedLegacyJsonFieldConflicts_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecationWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDeprecationWarning"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDeprecationWarning"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDeprecationWarning_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDeprecationWarning_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDeprecationWarning_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecationWarning, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDeprecationWarning) -> Boolean {
    if lhs.hasDeprecationWarning_p != rhs.hasDeprecationWarning_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDoubleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasDoubleValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasDoubleValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasDoubleValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasDoubleValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasDoubleValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDoubleValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasDoubleValue) -> Boolean {
    if lhs.hasDoubleValue_p != rhs.hasDoubleValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEdition) -> Boolean {
    if lhs.hasEdition_p != rhs.hasEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionDeprecated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEditionDeprecated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEditionDeprecated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEditionDeprecated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEditionDeprecated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEditionDeprecated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionDeprecated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionDeprecated) -> Boolean {
    if lhs.hasEditionDeprecated_p != rhs.hasEditionDeprecated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionIntroduced: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEditionIntroduced"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEditionIntroduced"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEditionIntroduced_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEditionIntroduced_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEditionIntroduced_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionIntroduced, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionIntroduced) -> Boolean {
    if lhs.hasEditionIntroduced_p != rhs.hasEditionIntroduced_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEditionRemoved"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEditionRemoved"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEditionRemoved_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEditionRemoved_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEditionRemoved_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionRemoved, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEditionRemoved) -> Boolean {
    if lhs.hasEditionRemoved_p != rhs.hasEditionRemoved_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEnd"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEnd"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEnd_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEnd_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEnd_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnd, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnd) -> Boolean {
    if lhs.hasEnd_p != rhs.hasEnd_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnumType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasEnumType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasEnumType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasEnumType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasEnumType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasEnumType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnumType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasEnumType) -> Boolean {
    if lhs.hasEnumType_p != rhs.hasEnumType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtendee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasExtendee"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasExtendee"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasExtendee_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasExtendee_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasExtendee_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtendee, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtendee) -> Boolean {
    if lhs.hasExtendee_p != rhs.hasExtendee_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtensionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasExtensionValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasExtensionValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasExtensionValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasExtensionValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasExtensionValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtensionValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasExtensionValue) -> Boolean {
    if lhs.hasExtensionValue_p != rhs.hasExtensionValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatures) -> Boolean {
    if lhs.hasFeatures_p != rhs.hasFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatureSupport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasFeatureSupport"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasFeatureSupport"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasFeatureSupport_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasFeatureSupport_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasFeatureSupport_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatureSupport, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFeatureSupport) -> Boolean {
    if lhs.hasFeatureSupport_p != rhs.hasFeatureSupport_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFieldPresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasFieldPresence"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasFieldPresence"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasFieldPresence_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasFieldPresence_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasFieldPresence_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFieldPresence, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFieldPresence) -> Boolean {
    if lhs.hasFieldPresence_p != rhs.hasFieldPresence_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFixedFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasFixedFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasFixedFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasFixedFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasFixedFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasFixedFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFixedFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFixedFeatures) -> Boolean {
    if lhs.hasFixedFeatures_p != rhs.hasFixedFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFullName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasFullName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasFullName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasFullName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasFullName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasFullName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFullName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasFullName) -> Boolean {
    if lhs.hasFullName_p != rhs.hasFullName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasGoPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasGoPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasGoPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasGoPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasGoPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasGoPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasGoPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasGoPackage) -> Boolean {
    if lhs.hasGoPackage_p != rhs.hasGoPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hash) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hash != 0 {
      try visitor.visitSingularInt32Field(value: this.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hash, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hash) -> Boolean {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Hashable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Hashable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hashable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hashable != 0 {
      try visitor.visitSingularInt32Field(value: this.hashable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashableMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashableMessage) -> Boolean {
    if lhs.hashable != rhs.hashable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasher"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasher"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasher) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasher != 0 {
      try visitor.visitSingularInt32Field(value: this.hasher, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasher, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasher) -> Boolean {
    if lhs.hasher != rhs.hasher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".HashVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HashVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hashVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hashVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.hashVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.HashVisitor) -> Boolean {
    if lhs.hashVisitor != rhs.hashVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdempotencyLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasIdempotencyLevel"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasIdempotencyLevel"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasIdempotencyLevel_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasIdempotencyLevel_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasIdempotencyLevel_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdempotencyLevel, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdempotencyLevel) -> Boolean {
    if lhs.hasIdempotencyLevel_p != rhs.hasIdempotencyLevel_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdentifierValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasIdentifierValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasIdentifierValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasIdentifierValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasIdentifierValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasIdentifierValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdentifierValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIdentifierValue) -> Boolean {
    if lhs.hasIdentifierValue_p != rhs.hasIdentifierValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasInputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasInputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasInputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasInputType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasInputType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasInputType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasInputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasInputType) -> Boolean {
    if lhs.hasInputType_p != rhs.hasInputType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIsExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasIsExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasIsExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasIsExtension_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasIsExtension_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasIsExtension_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIsExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasIsExtension) -> Boolean {
    if lhs.hasIsExtension_p != rhs.hasIsExtension_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenerateEqualsAndHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaGenerateEqualsAndHash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaGenerateEqualsAndHash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaGenerateEqualsAndHash_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaGenerateEqualsAndHash_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaGenerateEqualsAndHash_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenerateEqualsAndHash, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenerateEqualsAndHash) -> Boolean {
    if lhs.hasJavaGenerateEqualsAndHash_p != rhs.hasJavaGenerateEqualsAndHash_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaGenericServices) -> Boolean {
    if lhs.hasJavaGenericServices_p != rhs.hasJavaGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaMultipleFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaMultipleFiles"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaMultipleFiles"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaMultipleFiles_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaMultipleFiles_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaMultipleFiles_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaMultipleFiles, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaMultipleFiles) -> Boolean {
    if lhs.hasJavaMultipleFiles_p != rhs.hasJavaMultipleFiles_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaOuterClassname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaOuterClassname"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaOuterClassname"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaOuterClassname_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaOuterClassname_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaOuterClassname_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaOuterClassname, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaOuterClassname) -> Boolean {
    if lhs.hasJavaOuterClassname_p != rhs.hasJavaOuterClassname_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaPackage) -> Boolean {
    if lhs.hasJavaPackage_p != rhs.hasJavaPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaStringCheckUtf8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJavaStringCheckUtf8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJavaStringCheckUtf8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJavaStringCheckUtf8_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJavaStringCheckUtf8_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJavaStringCheckUtf8_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaStringCheckUtf8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJavaStringCheckUtf8) -> Boolean {
    if lhs.hasJavaStringCheckUtf8_p != rhs.hasJavaStringCheckUtf8_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJsonFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJsonFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJsonFormat_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJsonFormat_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJsonFormat_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonFormat) -> Boolean {
    if lhs.hasJsonFormat_p != rhs.hasJsonFormat_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJsonName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJsonName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJsonName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJsonName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJsonName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJsonName) -> Boolean {
    if lhs.hasJsonName_p != rhs.hasJsonName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJstype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasJstype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasJstype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasJstype_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasJstype_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasJstype_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJstype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasJstype) -> Boolean {
    if lhs.hasJstype_p != rhs.hasJstype_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasLabel"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasLabel"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasLabel_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasLabel_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasLabel_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLabel, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLabel) -> Boolean {
    if lhs.hasLabel_p != rhs.hasLabel_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasLazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasLazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasLazy_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasLazy_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasLazy_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLazy) -> Boolean {
    if lhs.hasLazy_p != rhs.hasLazy_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLeadingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasLeadingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasLeadingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasLeadingComments_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasLeadingComments_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasLeadingComments_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLeadingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasLeadingComments) -> Boolean {
    if lhs.hasLeadingComments_p != rhs.hasLeadingComments_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasMapEntry"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasMapEntry"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasMapEntry_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasMapEntry_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasMapEntry_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMapEntry, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMapEntry) -> Boolean {
    if lhs.hasMapEntry_p != rhs.hasMapEntry_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMaximumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasMaximumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasMaximumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasMaximumEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasMaximumEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasMaximumEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMaximumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMaximumEdition) -> Boolean {
    if lhs.hasMaximumEdition_p != rhs.hasMaximumEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasMessageEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasMessageEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasMessageEncoding_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasMessageEncoding_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasMessageEncoding_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageEncoding) -> Boolean {
    if lhs.hasMessageEncoding_p != rhs.hasMessageEncoding_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageSetWireFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasMessageSetWireFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasMessageSetWireFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasMessageSetWireFormat_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasMessageSetWireFormat_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasMessageSetWireFormat_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageSetWireFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMessageSetWireFormat) -> Boolean {
    if lhs.hasMessageSetWireFormat_p != rhs.hasMessageSetWireFormat_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMinimumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasMinimumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasMinimumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasMinimumEdition_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasMinimumEdition_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasMinimumEdition_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMinimumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasMinimumEdition) -> Boolean {
    if lhs.hasMinimumEdition_p != rhs.hasMinimumEdition_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasName) -> Boolean {
    if lhs.hasName_p != rhs.hasName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNamePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasNamePart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasNamePart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasNamePart_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasNamePart_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasNamePart_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNamePart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNamePart) -> Boolean {
    if lhs.hasNamePart_p != rhs.hasNamePart_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNegativeIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasNegativeIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasNegativeIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasNegativeIntValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasNegativeIntValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasNegativeIntValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNegativeIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNegativeIntValue) -> Boolean {
    if lhs.hasNegativeIntValue_p != rhs.hasNegativeIntValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNoStandardDescriptorAccessor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasNoStandardDescriptorAccessor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasNoStandardDescriptorAccessor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasNoStandardDescriptorAccessor_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasNoStandardDescriptorAccessor_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasNoStandardDescriptorAccessor_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNoStandardDescriptorAccessor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNoStandardDescriptorAccessor) -> Boolean {
    if lhs.hasNoStandardDescriptorAccessor_p != rhs.hasNoStandardDescriptorAccessor_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasNumber_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasNumber_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasNumber_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasNumber) -> Boolean {
    if lhs.hasNumber_p != rhs.hasNumber_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasObjcClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasObjcClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasObjcClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasObjcClassPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasObjcClassPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasObjcClassPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasObjcClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasObjcClassPrefix) -> Boolean {
    if lhs.hasObjcClassPrefix_p != rhs.hasObjcClassPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOneofIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasOneofIndex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasOneofIndex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasOneofIndex_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasOneofIndex_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasOneofIndex_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOneofIndex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOneofIndex) -> Boolean {
    if lhs.hasOneofIndex_p != rhs.hasOneofIndex_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptimizeFor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasOptimizeFor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasOptimizeFor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasOptimizeFor_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasOptimizeFor_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasOptimizeFor_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptimizeFor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptimizeFor) -> Boolean {
    if lhs.hasOptimizeFor_p != rhs.hasOptimizeFor_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasOptions_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasOptions_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasOptions_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOptions) -> Boolean {
    if lhs.hasOptions_p != rhs.hasOptions_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOutputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasOutputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasOutputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasOutputType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasOutputType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasOutputType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOutputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOutputType) -> Boolean {
    if lhs.hasOutputType_p != rhs.hasOutputType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOverridableFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasOverridableFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasOverridableFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasOverridableFeatures_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasOverridableFeatures_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasOverridableFeatures_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOverridableFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasOverridableFeatures) -> Boolean {
    if lhs.hasOverridableFeatures_p != rhs.hasOverridableFeatures_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPackage) -> Boolean {
    if lhs.hasPackage_p != rhs.hasPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPacked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPacked"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPacked"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPacked_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPacked_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPacked_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPacked, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPacked) -> Boolean {
    if lhs.hasPacked_p != rhs.hasPacked_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPhpClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPhpClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPhpClassPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPhpClassPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPhpClassPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpClassPrefix) -> Boolean {
    if lhs.hasPhpClassPrefix_p != rhs.hasPhpClassPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpMetadataNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPhpMetadataNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPhpMetadataNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPhpMetadataNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPhpMetadataNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPhpMetadataNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpMetadataNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpMetadataNamespace) -> Boolean {
    if lhs.hasPhpMetadataNamespace_p != rhs.hasPhpMetadataNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPhpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPhpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPhpNamespace_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPhpNamespace_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPhpNamespace_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPhpNamespace) -> Boolean {
    if lhs.hasPhpNamespace_p != rhs.hasPhpNamespace_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPositiveIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPositiveIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPositiveIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPositiveIntValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPositiveIntValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPositiveIntValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPositiveIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPositiveIntValue) -> Boolean {
    if lhs.hasPositiveIntValue_p != rhs.hasPositiveIntValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasProto3Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasProto3Optional"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasProto3Optional"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasProto3Optional_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasProto3Optional_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasProto3Optional_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasProto3Optional, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasProto3Optional) -> Boolean {
    if lhs.hasProto3Optional_p != rhs.hasProto3Optional_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPyGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasPyGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasPyGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasPyGenericServices_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasPyGenericServices_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasPyGenericServices_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPyGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasPyGenericServices) -> Boolean {
    if lhs.hasPyGenericServices_p != rhs.hasPyGenericServices_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasRepeated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasRepeated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasRepeated_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasRepeated_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasRepeated_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeated) -> Boolean {
    if lhs.hasRepeated_p != rhs.hasRepeated_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeatedFieldEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasRepeatedFieldEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasRepeatedFieldEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasRepeatedFieldEncoding_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasRepeatedFieldEncoding_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasRepeatedFieldEncoding_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeatedFieldEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRepeatedFieldEncoding) -> Boolean {
    if lhs.hasRepeatedFieldEncoding_p != rhs.hasRepeatedFieldEncoding_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasReserved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasReserved"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasReserved"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasReserved_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasReserved_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasReserved_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasReserved, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasReserved) -> Boolean {
    if lhs.hasReserved_p != rhs.hasReserved_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRetention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasRetention"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasRetention"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasRetention_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasRetention_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasRetention_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRetention, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRetention) -> Boolean {
    if lhs.hasRetention_p != rhs.hasRetention_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRubyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasRubyPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasRubyPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasRubyPackage_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasRubyPackage_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasRubyPackage_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRubyPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasRubyPackage) -> Boolean {
    if lhs.hasRubyPackage_p != rhs.hasRubyPackage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSemantic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSemantic"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSemantic"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSemantic_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSemantic_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSemantic_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSemantic, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSemantic) -> Boolean {
    if lhs.hasSemantic_p != rhs.hasSemantic_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasServerStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasServerStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasServerStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasServerStreaming_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasServerStreaming_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasServerStreaming_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasServerStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasServerStreaming) -> Boolean {
    if lhs.hasServerStreaming_p != rhs.hasServerStreaming_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSourceCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSourceCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSourceCodeInfo_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSourceCodeInfo_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSourceCodeInfo_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceCodeInfo) -> Boolean {
    if lhs.hasSourceCodeInfo_p != rhs.hasSourceCodeInfo_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSourceContext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSourceContext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSourceContext_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSourceContext_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSourceContext_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceContext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceContext) -> Boolean {
    if lhs.hasSourceContext_p != rhs.hasSourceContext_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSourceFile"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSourceFile"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSourceFile_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSourceFile_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSourceFile_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceFile, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSourceFile) -> Boolean {
    if lhs.hasSourceFile_p != rhs.hasSourceFile_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasStart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasStart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasStart_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasStart_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasStart_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStart) -> Boolean {
    if lhs.hasStart_p != rhs.hasStart_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasStringValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasStringValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasStringValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasStringValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasStringValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStringValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasStringValue) -> Boolean {
    if lhs.hasStringValue_p != rhs.hasStringValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSwiftPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSwiftPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSwiftPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSwiftPrefix_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSwiftPrefix_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSwiftPrefix_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSwiftPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSwiftPrefix) -> Boolean {
    if lhs.hasSwiftPrefix_p != rhs.hasSwiftPrefix_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSyntax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasSyntax"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasSyntax"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasSyntax_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasSyntax_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasSyntax_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSyntax, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasSyntax) -> Boolean {
    if lhs.hasSyntax_p != rhs.hasSyntax_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTrailingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasTrailingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasTrailingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasTrailingComments_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasTrailingComments_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasTrailingComments_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTrailingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTrailingComments) -> Boolean {
    if lhs.hasTrailingComments_p != rhs.hasTrailingComments_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasType_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasType_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasType_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasType) -> Boolean {
    if lhs.hasType_p != rhs.hasType_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTypeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasTypeName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasTypeName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasTypeName_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasTypeName_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasTypeName_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTypeName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasTypeName) -> Boolean {
    if lhs.hasTypeName_p != rhs.hasTypeName_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUnverifiedLazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasUnverifiedLazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasUnverifiedLazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasUnverifiedLazy_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasUnverifiedLazy_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasUnverifiedLazy_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUnverifiedLazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUnverifiedLazy) -> Boolean {
    if lhs.hasUnverifiedLazy_p != rhs.hasUnverifiedLazy_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUtf8Validation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasUtf8Validation"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasUtf8Validation"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasUtf8Validation_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasUtf8Validation_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasUtf8Validation_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUtf8Validation, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasUtf8Validation) -> Boolean {
    if lhs.hasUtf8Validation_p != rhs.hasUtf8Validation_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasValue_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasValue_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasValue_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasValue) -> Boolean {
    if lhs.hasValue_p != rhs.hasValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasVerification"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasVerification"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasVerification_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasVerification_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasVerification_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasVerification, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasVerification) -> Boolean {
    if lhs.hasVerification_p != rhs.hasVerification_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasWeak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hasWeak"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasWeak"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hasWeak_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hasWeak_p != 0 {
      try visitor.visitSingularInt32Field(value: this.hasWeak_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasWeak, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hasWeak) -> Boolean {
    if lhs.hasWeak_p != rhs.hasWeak_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hour: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".hour"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.hour) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.hour != 0 {
      try visitor.visitSingularInt32Field(value: this.hour, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hour, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.hour) -> Boolean {
    if lhs.hour != rhs.hour {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.i: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".i"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "i"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.i) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.i != 0 {
      try visitor.visitSingularInt32Field(value: this.i, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.i, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.i) -> Boolean {
    if lhs.i != rhs.i {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.idempotencyLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".idempotencyLevel"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idempotencyLevel"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.idempotencyLevel) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.idempotencyLevel != 0 {
      try visitor.visitSingularInt32Field(value: this.idempotencyLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.idempotencyLevel, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.idempotencyLevel) -> Boolean {
    if lhs.idempotencyLevel != rhs.idempotencyLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.identifierValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".identifierValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifierValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.identifierValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.identifierValue != 0 {
      try visitor.visitSingularInt32Field(value: this.identifierValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.identifierValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.identifierValue) -> Boolean {
    if lhs.identifierValue != rhs.identifierValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ifMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".if"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "if"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`if`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`if` != 0 {
      try visitor.visitSingularInt32Field(value: this.`if`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ifMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ifMessage) -> Boolean {
    if lhs.`if` != rhs.`if` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownExtensionFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ignoreUnknownExtensionFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ignoreUnknownExtensionFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ignoreUnknownExtensionFields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ignoreUnknownExtensionFields != 0 {
      try visitor.visitSingularInt32Field(value: this.ignoreUnknownExtensionFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownExtensionFields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownExtensionFields) -> Boolean {
    if lhs.ignoreUnknownExtensionFields != rhs.ignoreUnknownExtensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ignoreUnknownFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ignoreUnknownFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ignoreUnknownFields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ignoreUnknownFields != 0 {
      try visitor.visitSingularInt32Field(value: this.ignoreUnknownFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownFields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ignoreUnknownFields) -> Boolean {
    if lhs.ignoreUnknownFields != rhs.ignoreUnknownFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.index: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".index"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.index) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.index != 0 {
      try visitor.visitSingularInt32Field(value: this.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.index, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.index) -> Boolean {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.initMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".init"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.init_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.init_p != 0 {
      try visitor.visitSingularInt32Field(value: this.init_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.initMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.initMessage) -> Boolean {
    if lhs.init_p != rhs.init_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inoutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".inout"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inout"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`inout`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`inout` != 0 {
      try visitor.visitSingularInt32Field(value: this.`inout`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inoutMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inoutMessage) -> Boolean {
    if lhs.`inout` != rhs.`inout` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".inputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.inputType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.inputType != 0 {
      try visitor.visitSingularInt32Field(value: this.inputType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.inputType) -> Boolean {
    if lhs.inputType != rhs.inputType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.insert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".insert"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insert"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.insert) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.insert != 0 {
      try visitor.visitSingularInt32Field(value: this.insert, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.insert, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.insert) -> Boolean {
    if lhs.insert != rhs.insert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Integer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Integer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int != 0 {
      try visitor.visitSingularInt32Field(value: this.int, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntMessage) -> Boolean {
    if lhs.int != rhs.int {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Int32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Int32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int32 != 0 {
      try visitor.visitSingularInt32Field(value: this.int32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Message, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Message) -> Boolean {
    if lhs.int32 != rhs.int32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Int32Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Int32Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int32Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int32Value != 0 {
      try visitor.visitSingularInt32Field(value: this.int32Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int32Value) -> Boolean {
    if lhs.int32Value != rhs.int32Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Int64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Int64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int64 != 0 {
      try visitor.visitSingularInt32Field(value: this.int64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Message, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Message) -> Boolean {
    if lhs.int64 != rhs.int64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Int64Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Int64Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int64Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int64Value != 0 {
      try visitor.visitSingularInt32Field(value: this.int64Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int64Value) -> Boolean {
    if lhs.int64Value != rhs.int64Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Int8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Int8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.int8) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.int8 != 0 {
      try visitor.visitSingularInt32Field(value: this.int8, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Int8) -> Boolean {
    if lhs.int8 != rhs.int8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.integerLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".integerLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "integerLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.integerLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.integerLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.integerLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.integerLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.integerLiteral) -> Boolean {
    if lhs.integerLiteral != rhs.integerLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntegerLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".IntegerLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "IntegerLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.integerLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.integerLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.integerLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntegerLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.IntegerLiteralType) -> Boolean {
    if lhs.integerLiteralType != rhs.integerLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.intern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".intern"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "intern"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.intern) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.intern != 0 {
      try visitor.visitSingularInt32Field(value: this.intern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.intern, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.intern) -> Boolean {
    if lhs.intern != rhs.intern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Internal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Internal"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Internal"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`internal`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`internal` != 0 {
      try visitor.visitSingularInt32Field(value: this.`internal`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Internal, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Internal) -> Boolean {
    if lhs.`internal` != rhs.`internal` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.InternalState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".InternalState"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InternalState"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.internalState) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.internalState != 0 {
      try visitor.visitSingularInt32Field(value: this.internalState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.InternalState, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.InternalState) -> Boolean {
    if lhs.internalState != rhs.internalState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.into: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".into"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "into"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.into) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.into != 0 {
      try visitor.visitSingularInt32Field(value: this.into, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.into, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.into) -> Boolean {
    if lhs.into != rhs.into {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ints"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ints"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.ints) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.ints != 0 {
      try visitor.visitSingularInt32Field(value: this.ints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ints, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ints) -> Boolean {
    if lhs.ints != rhs.ints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isA"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isA"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isA) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isA != 0 {
      try visitor.visitSingularInt32Field(value: this.isA, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isA, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isA) -> Boolean {
    if lhs.isA != rhs.isA {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isEqual"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isEqual"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isEqual) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isEqual != 0 {
      try visitor.visitSingularInt32Field(value: this.isEqual, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqual, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqual) -> Boolean {
    if lhs.isEqual != rhs.isEqual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqualTo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isEqualTo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isEqualTo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isEqualTo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isEqualTo != 0 {
      try visitor.visitSingularInt32Field(value: this.isEqualTo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqualTo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isEqualTo) -> Boolean {
    if lhs.isEqualTo != rhs.isEqualTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isExtension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isExtension != 0 {
      try visitor.visitSingularInt32Field(value: this.isExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isExtension) -> Boolean {
    if lhs.isExtension != rhs.isExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isInitializedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isInitialized"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isInitialized"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isInitialized_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isInitialized_p != 0 {
      try visitor.visitSingularInt32Field(value: this.isInitialized_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isInitializedMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isInitializedMessage) -> Boolean {
    if lhs.isInitialized_p != rhs.isInitialized_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isNegative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".isNegative"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isNegative"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.isNegative) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.isNegative != 0 {
      try visitor.visitSingularInt32Field(value: this.isNegative, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isNegative, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.isNegative) -> Boolean {
    if lhs.isNegative != rhs.isNegative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.itemTagsEncodedSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".itemTagsEncodedSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemTagsEncodedSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.itemTagsEncodedSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.itemTagsEncodedSize != 0 {
      try visitor.visitSingularInt32Field(value: this.itemTagsEncodedSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.itemTagsEncodedSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.itemTagsEncodedSize) -> Boolean {
    if lhs.itemTagsEncodedSize != rhs.itemTagsEncodedSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.iterator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".iterator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iterator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.iterator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.iterator != 0 {
      try visitor.visitSingularInt32Field(value: this.iterator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.iterator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.iterator) -> Boolean {
    if lhs.iterator != rhs.iterator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenerateEqualsAndHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaGenerateEqualsAndHash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaGenerateEqualsAndHash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaGenerateEqualsAndHash) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaGenerateEqualsAndHash != 0 {
      try visitor.visitSingularInt32Field(value: this.javaGenerateEqualsAndHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenerateEqualsAndHash, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenerateEqualsAndHash) -> Boolean {
    if lhs.javaGenerateEqualsAndHash != rhs.javaGenerateEqualsAndHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaGenericServices) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaGenericServices != 0 {
      try visitor.visitSingularInt32Field(value: this.javaGenericServices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaGenericServices) -> Boolean {
    if lhs.javaGenericServices != rhs.javaGenericServices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaMultipleFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaMultipleFiles"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaMultipleFiles"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaMultipleFiles) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaMultipleFiles != 0 {
      try visitor.visitSingularInt32Field(value: this.javaMultipleFiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaMultipleFiles, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaMultipleFiles) -> Boolean {
    if lhs.javaMultipleFiles != rhs.javaMultipleFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaOuterClassname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaOuterClassname"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaOuterClassname"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaOuterClassname) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaOuterClassname != 0 {
      try visitor.visitSingularInt32Field(value: this.javaOuterClassname, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaOuterClassname, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaOuterClassname) -> Boolean {
    if lhs.javaOuterClassname != rhs.javaOuterClassname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaPackage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaPackage != 0 {
      try visitor.visitSingularInt32Field(value: this.javaPackage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaPackage) -> Boolean {
    if lhs.javaPackage != rhs.javaPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaStringCheckUtf8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".javaStringCheckUtf8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "javaStringCheckUtf8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.javaStringCheckUtf8) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.javaStringCheckUtf8 != 0 {
      try visitor.visitSingularInt32Field(value: this.javaStringCheckUtf8, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaStringCheckUtf8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.javaStringCheckUtf8) -> Boolean {
    if lhs.javaStringCheckUtf8 != rhs.javaStringCheckUtf8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsondecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsondecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.jsondecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecoder) -> Boolean {
    if lhs.jsondecoder != rhs.jsondecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONDecodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONDecodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsondecodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsondecodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.jsondecodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingError) -> Boolean {
    if lhs.jsondecodingError != rhs.jsondecodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONDecodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONDecodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsondecodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsondecodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.jsondecodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONDecodingOptions) -> Boolean {
    if lhs.jsondecodingOptions != rhs.jsondecodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonEncoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonEncoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonEncoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonEncoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonEncoder != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonEncoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonEncoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonEncoder) -> Boolean {
    if lhs.jsonEncoder != rhs.jsonEncoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONEncodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONEncodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonencodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonencodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonencodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingError) -> Boolean {
    if lhs.jsonencodingError != rhs.jsonencodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONEncodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONEncodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonencodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonencodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonencodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingOptions) -> Boolean {
    if lhs.jsonencodingOptions != rhs.jsonencodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONEncodingVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONEncodingVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonencodingVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonencodingVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonencodingVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONEncodingVisitor) -> Boolean {
    if lhs.jsonencodingVisitor != rhs.jsonencodingVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonFormat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonFormat != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonFormat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonFormat) -> Boolean {
    if lhs.jsonFormat != rhs.jsonFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONMapEncodingVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONMapEncodingVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONMapEncodingVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonmapEncodingVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonmapEncodingVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonmapEncodingVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONMapEncodingVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONMapEncodingVisitor) -> Boolean {
    if lhs.jsonmapEncodingVisitor != rhs.jsonmapEncodingVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonName != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonName) -> Boolean {
    if lhs.jsonName != rhs.jsonName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonPath"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonPath"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonPath) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonPath != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPath, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPath) -> Boolean {
    if lhs.jsonPath != rhs.jsonPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPaths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonPaths"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonPaths"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonPaths) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonPaths != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonPaths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPaths, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonPaths) -> Boolean {
    if lhs.jsonPaths != rhs.jsonPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONScanner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".JSONScanner"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JSONScanner"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonscanner) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonscanner != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonscanner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONScanner, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.JSONScanner) -> Boolean {
    if lhs.jsonscanner != rhs.jsonscanner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonString != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonString) -> Boolean {
    if lhs.jsonString != rhs.jsonString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonText"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonText"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonText) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonText != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonText, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonText) -> Boolean {
    if lhs.jsonText != rhs.jsonText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Bytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonUTF8Bytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonUTF8Bytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonUtf8Bytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonUtf8Bytes != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonUtf8Bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Bytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Bytes) -> Boolean {
    if lhs.jsonUtf8Bytes != rhs.jsonUtf8Bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jsonUTF8Data"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonUTF8Data"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jsonUtf8Data) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jsonUtf8Data != 0 {
      try visitor.visitSingularInt32Field(value: this.jsonUtf8Data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Data, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jsonUTF8Data) -> Boolean {
    if lhs.jsonUtf8Data != rhs.jsonUtf8Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jstype: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".jstype"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jstype"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.jstype) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.jstype != 0 {
      try visitor.visitSingularInt32Field(value: this.jstype, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jstype, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.jstype) -> Boolean {
    if lhs.jstype != rhs.jstype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.k: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".k"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.k) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.k != 0 {
      try visitor.visitSingularInt32Field(value: this.k, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.k, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.k) -> Boolean {
    if lhs.k != rhs.k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kChunkSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".kChunkSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kChunkSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.kChunkSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.kChunkSize != 0 {
      try visitor.visitSingularInt32Field(value: this.kChunkSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kChunkSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kChunkSize) -> Boolean {
    if lhs.kChunkSize != rhs.kChunkSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Key"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Key"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.key) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.key != 0 {
      try visitor.visitSingularInt32Field(value: this.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Key, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Key) -> Boolean {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".keyField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.keyField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.keyField != 0 {
      try visitor.visitSingularInt32Field(value: this.keyField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyField) -> Boolean {
    if lhs.keyField != rhs.keyField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyFieldOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".keyFieldOpt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyFieldOpt"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.keyFieldOpt) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.keyFieldOpt != 0 {
      try visitor.visitSingularInt32Field(value: this.keyFieldOpt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyFieldOpt, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.keyFieldOpt) -> Boolean {
    if lhs.keyFieldOpt != rhs.keyFieldOpt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.KeyType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".KeyType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KeyType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.keyType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.keyType != 0 {
      try visitor.visitSingularInt32Field(value: this.keyType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.KeyType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.KeyType) -> Boolean {
    if lhs.keyType != rhs.keyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".kind"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.kind) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.kind != 0 {
      try visitor.visitSingularInt32Field(value: this.kind, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kind, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.kind) -> Boolean {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.l: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".l"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.l) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.l != 0 {
      try visitor.visitSingularInt32Field(value: this.l, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.l, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.l) -> Boolean {
    if lhs.l != rhs.l {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.label: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".label"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.label) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.label != 0 {
      try visitor.visitSingularInt32Field(value: this.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.label, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.label) -> Boolean {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".lazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.lazy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.lazy != 0 {
      try visitor.visitSingularInt32Field(value: this.lazy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lazy) -> Boolean {
    if lhs.lazy != rhs.lazy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".leadingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leadingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.leadingComments) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.leadingComments != 0 {
      try visitor.visitSingularInt32Field(value: this.leadingComments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingComments) -> Boolean {
    if lhs.leadingComments != rhs.leadingComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingDetachedComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".leadingDetachedComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leadingDetachedComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.leadingDetachedComments) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.leadingDetachedComments != 0 {
      try visitor.visitSingularInt32Field(value: this.leadingDetachedComments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingDetachedComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.leadingDetachedComments) -> Boolean {
    if lhs.leadingDetachedComments != rhs.leadingDetachedComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.length: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".length"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.length) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.length != 0 {
      try visitor.visitSingularInt32Field(value: this.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.length, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.length) -> Boolean {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lessThan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".lessThan"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lessThan"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.lessThan) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.lessThan != 0 {
      try visitor.visitSingularInt32Field(value: this.lessThan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lessThan, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lessThan) -> Boolean {
    if lhs.lessThan != rhs.lessThan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.immutableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".immutable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "immutable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`immutable`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`immutable` != 0 {
      try visitor.visitSingularInt32Field(value: this.`immutable`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.immutableMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.immutableMessage) -> Boolean {
    if lhs.`immutable` != rhs.`immutable` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lhs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".lhs"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lhs"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.lhs) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.lhs != 0 {
      try visitor.visitSingularInt32Field(value: this.lhs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lhs, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.lhs) -> Boolean {
    if lhs.lhs != rhs.lhs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".line"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "line"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.line) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.line != 0 {
      try visitor.visitSingularInt32Field(value: this.line, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.line, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.line) -> Boolean {
    if lhs.line != rhs.line {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.list: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".list"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.list) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.list != 0 {
      try visitor.visitSingularInt32Field(value: this.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.list, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.list) -> Boolean {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listOfMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".listOfMessages"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listOfMessages"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.listOfMessages) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.listOfMessages != 0 {
      try visitor.visitSingularInt32Field(value: this.listOfMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listOfMessages, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listOfMessages) -> Boolean {
    if lhs.listOfMessages != rhs.listOfMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".listValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.listValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.listValue != 0 {
      try visitor.visitSingularInt32Field(value: this.listValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.listValue) -> Boolean {
    if lhs.listValue != rhs.listValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.littleEndian: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".littleEndian"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "littleEndian"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.littleEndian) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.littleEndian != 0 {
      try visitor.visitSingularInt32Field(value: this.littleEndian, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.littleEndian, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.littleEndian) -> Boolean {
    if lhs.littleEndian != rhs.littleEndian {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.load: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".load"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "load"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.load) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.load != 0 {
      try visitor.visitSingularInt32Field(value: this.load, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.load, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.load) -> Boolean {
    if lhs.load != rhs.load {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.localHasher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".localHasher"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localHasher"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.localHasher) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.localHasher != 0 {
      try visitor.visitSingularInt32Field(value: this.localHasher, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.localHasher, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.localHasher) -> Boolean {
    if lhs.localHasher != rhs.localHasher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".location"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.location) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.location != 0 {
      try visitor.visitSingularInt32Field(value: this.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.location, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.location) -> Boolean {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.M: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".M"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "M"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.m) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.m != 0 {
      try visitor.visitSingularInt32Field(value: this.m, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.M, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.M) -> Boolean {
    if lhs.m != rhs.m {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.major: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".major"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.major) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.major != 0 {
      try visitor.visitSingularInt32Field(value: this.major, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.major, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.major) -> Boolean {
    if lhs.major != rhs.major {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeAsyncIterator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".makeAsyncIterator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "makeAsyncIterator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.makeAsyncIterator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.makeAsyncIterator != 0 {
      try visitor.visitSingularInt32Field(value: this.makeAsyncIterator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeAsyncIterator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeAsyncIterator) -> Boolean {
    if lhs.makeAsyncIterator != rhs.makeAsyncIterator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeIterator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".makeIterator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "makeIterator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.makeIterator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.makeIterator != 0 {
      try visitor.visitSingularInt32Field(value: this.makeIterator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeIterator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.makeIterator) -> Boolean {
    if lhs.makeIterator != rhs.makeIterator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.malformedLength: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".malformedLength"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "malformedLength"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.malformedLength) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.malformedLength != 0 {
      try visitor.visitSingularInt32Field(value: this.malformedLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.malformedLength, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.malformedLength) -> Boolean {
    if lhs.malformedLength != rhs.malformedLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mapEntry"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mapEntry"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mapEntry) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mapEntry != 0 {
      try visitor.visitSingularInt32Field(value: this.mapEntry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapEntry, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapEntry) -> Boolean {
    if lhs.mapEntry != rhs.mapEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapKeyType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MapKeyType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MapKeyType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mapKeyType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mapKeyType != 0 {
      try visitor.visitSingularInt32Field(value: this.mapKeyType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapKeyType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapKeyType) -> Boolean {
    if lhs.mapKeyType != rhs.mapKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapToMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mapToMessages"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mapToMessages"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mapToMessages) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mapToMessages != 0 {
      try visitor.visitSingularInt32Field(value: this.mapToMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapToMessages, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapToMessages) -> Boolean {
    if lhs.mapToMessages != rhs.mapToMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MapValueType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MapValueType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mapValueType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mapValueType != 0 {
      try visitor.visitSingularInt32Field(value: this.mapValueType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapValueType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MapValueType) -> Boolean {
    if lhs.mapValueType != rhs.mapValueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mapVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mapVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mapVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mapVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.mapVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mapVisitor) -> Boolean {
    if lhs.mapVisitor != rhs.mapVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.maximumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".maximumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maximumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.maximumEdition) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.maximumEdition != 0 {
      try visitor.visitSingularInt32Field(value: this.maximumEdition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.maximumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.maximumEdition) -> Boolean {
    if lhs.maximumEdition != rhs.maximumEdition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mdayStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mdayStart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mdayStart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mdayStart) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mdayStart != 0 {
      try visitor.visitSingularInt32Field(value: this.mdayStart, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mdayStart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mdayStart) -> Boolean {
    if lhs.mdayStart != rhs.mdayStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".merge"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "merge"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.merge) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.merge != 0 {
      try visitor.visitSingularInt32Field(value: this.merge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.merge, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.merge) -> Boolean {
    if lhs.merge != rhs.merge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".message"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.message) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.message != 0 {
      try visitor.visitSingularInt32Field(value: this.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.message, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.message) -> Boolean {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageDepthLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".messageDepthLimit"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageDepthLimit"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageDepthLimit) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageDepthLimit != 0 {
      try visitor.visitSingularInt32Field(value: this.messageDepthLimit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageDepthLimit, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageDepthLimit) -> Boolean {
    if lhs.messageDepthLimit != rhs.messageDepthLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".messageEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageEncoding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageEncoding != 0 {
      try visitor.visitSingularInt32Field(value: this.messageEncoding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageEncoding) -> Boolean {
    if lhs.messageEncoding != rhs.messageEncoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MessageExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageExtension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageExtension != 0 {
      try visitor.visitSingularInt32Field(value: this.messageExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageExtension) -> Boolean {
    if lhs.messageExtension != rhs.messageExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageImplementationBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MessageImplementationBase"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageImplementationBase"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageImplementationBase) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageImplementationBase != 0 {
      try visitor.visitSingularInt32Field(value: this.messageImplementationBase, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageImplementationBase, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageImplementationBase) -> Boolean {
    if lhs.messageImplementationBase != rhs.messageImplementationBase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MessageOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.messageOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageOptions) -> Boolean {
    if lhs.messageOptions != rhs.messageOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MessageSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageSet != 0 {
      try visitor.visitSingularInt32Field(value: this.messageSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MessageSet) -> Boolean {
    if lhs.messageSet != rhs.messageSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSetWireFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".messageSetWireFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageSetWireFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageSetWireFormat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageSetWireFormat != 0 {
      try visitor.visitSingularInt32Field(value: this.messageSetWireFormat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSetWireFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSetWireFormat) -> Boolean {
    if lhs.messageSetWireFormat != rhs.messageSetWireFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".messageSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageSize != 0 {
      try visitor.visitSingularInt32Field(value: this.messageSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageSize) -> Boolean {
    if lhs.messageSize != rhs.messageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".messageType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.messageType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.messageType != 0 {
      try visitor.visitSingularInt32Field(value: this.messageType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.messageType) -> Boolean {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Method: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Method"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Method"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.method) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.method != 0 {
      try visitor.visitSingularInt32Field(value: this.method, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Method, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Method) -> Boolean {
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MethodDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MethodDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.methodDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.methodDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.methodDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodDescriptorProto) -> Boolean {
    if lhs.methodDescriptorProto != rhs.methodDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".MethodOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MethodOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.methodOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.methodOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.methodOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.MethodOptions) -> Boolean {
    if lhs.methodOptions != rhs.methodOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.methods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".methods"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "methods"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.methods) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.methods != 0 {
      try visitor.visitSingularInt32Field(value: this.methods, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.methods, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.methods) -> Boolean {
    if lhs.methods != rhs.methods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.min: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".min"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.min) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.min != 0 {
      try visitor.visitSingularInt32Field(value: this.min, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.min, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.min) -> Boolean {
    if lhs.min != rhs.min {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minimumEdition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".minimumEdition"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minimumEdition"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.minimumEdition) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.minimumEdition != 0 {
      try visitor.visitSingularInt32Field(value: this.minimumEdition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minimumEdition, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minimumEdition) -> Boolean {
    if lhs.minimumEdition != rhs.minimumEdition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".minor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.minor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.minor != 0 {
      try visitor.visitSingularInt32Field(value: this.minor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.minor) -> Boolean {
    if lhs.minor != rhs.minor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Mixin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Mixin"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Mixin"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mixin) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mixin != 0 {
      try visitor.visitSingularInt32Field(value: this.mixin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Mixin, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Mixin) -> Boolean {
    if lhs.mixin != rhs.mixin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mixins: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mixins"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mixins"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mixins) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mixins != 0 {
      try visitor.visitSingularInt32Field(value: this.mixins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mixins, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mixins) -> Boolean {
    if lhs.mixins != rhs.mixins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".modifier"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifier"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.modifier) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.modifier != 0 {
      try visitor.visitSingularInt32Field(value: this.modifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modifier, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modifier) -> Boolean {
    if lhs.modifier != rhs.modifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".modify"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modify"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.modify) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.modify != 0 {
      try visitor.visitSingularInt32Field(value: this.modify, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modify, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.modify) -> Boolean {
    if lhs.modify != rhs.modify {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.month: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".month"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "month"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.month) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.month != 0 {
      try visitor.visitSingularInt32Field(value: this.month, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.month, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.month) -> Boolean {
    if lhs.month != rhs.month {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.msgExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".msgExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.msgExtension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.msgExtension != 0 {
      try visitor.visitSingularInt32Field(value: this.msgExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.msgExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.msgExtension) -> Boolean {
    if lhs.msgExtension != rhs.msgExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mutating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".mutating"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mutating"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.mutating) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.mutating != 0 {
      try visitor.visitSingularInt32Field(value: this.mutating, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mutating, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.mutating) -> Boolean {
    if lhs.mutating != rhs.mutating {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.n: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".n"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "n"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.n) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.n != 0 {
      try visitor.visitSingularInt32Field(value: this.n, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.n, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.n) -> Boolean {
    if lhs.n != rhs.n {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".name"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.name) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.name != 0 {
      try visitor.visitSingularInt32Field(value: this.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.name, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.name) -> Boolean {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".NameDescription"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NameDescription"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nameDescription) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nameDescription != 0 {
      try visitor.visitSingularInt32Field(value: this.nameDescription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameDescription, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameDescription) -> Boolean {
    if lhs.nameDescription != rhs.nameDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".NameMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NameMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nameMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nameMap != 0 {
      try visitor.visitSingularInt32Field(value: this.nameMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NameMap) -> Boolean {
    if lhs.nameMap != rhs.nameMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NamePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".NamePart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NamePart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.namePart) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.namePart != 0 {
      try visitor.visitSingularInt32Field(value: this.namePart, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NamePart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.NamePart) -> Boolean {
    if lhs.namePart != rhs.namePart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.names: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".names"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.names) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.names != 0 {
      try visitor.visitSingularInt32Field(value: this.names, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.names, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.names) -> Boolean {
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nanos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nanos"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nanos"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nanos) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nanos != 0 {
      try visitor.visitSingularInt32Field(value: this.nanos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nanos, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nanos) -> Boolean {
    if lhs.nanos != rhs.nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.negativeIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".negativeIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "negativeIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.negativeIntValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.negativeIntValue != 0 {
      try visitor.visitSingularInt32Field(value: this.negativeIntValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.negativeIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.negativeIntValue) -> Boolean {
    if lhs.negativeIntValue != rhs.negativeIntValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nestedType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nestedType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nestedType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nestedType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nestedType != 0 {
      try visitor.visitSingularInt32Field(value: this.nestedType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nestedType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nestedType) -> Boolean {
    if lhs.nestedType != rhs.nestedType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".newL"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newL"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.newL) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.newL != 0 {
      try visitor.visitSingularInt32Field(value: this.newL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newL, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newL) -> Boolean {
    if lhs.newL != rhs.newL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".newList"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newList"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.newList) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.newList != 0 {
      try visitor.visitSingularInt32Field(value: this.newList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newList, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newList) -> Boolean {
    if lhs.newList != rhs.newList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".newValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.newValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.newValue != 0 {
      try visitor.visitSingularInt32Field(value: this.newValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.newValue) -> Boolean {
    if lhs.newValue != rhs.newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.next: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".next"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "next"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.next) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.next != 0 {
      try visitor.visitSingularInt32Field(value: this.next, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.next, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.next) -> Boolean {
    if lhs.next != rhs.next {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextByte: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nextByte"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextByte"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nextByte) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nextByte != 0 {
      try visitor.visitSingularInt32Field(value: this.nextByte, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextByte, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextByte) -> Boolean {
    if lhs.nextByte != rhs.nextByte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextFieldNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nextFieldNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextFieldNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nextFieldNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nextFieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: this.nextFieldNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextFieldNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextFieldNumber) -> Boolean {
    if lhs.nextFieldNumber != rhs.nextFieldNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextVarInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nextVarInt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextVarInt"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nextVarInt) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nextVarInt != 0 {
      try visitor.visitSingularInt32Field(value: this.nextVarInt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextVarInt, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nextVarInt) -> Boolean {
    if lhs.nextVarInt != rhs.nextVarInt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Nothing"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Nothing"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`Nothing`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`Nothing` != 0 {
      try visitor.visitSingularInt32Field(value: this.`Nothing`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilMessage) -> Boolean {
    if lhs.`Nothing` != rhs.`Nothing` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nilLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nilLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nilLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nilLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.nilLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nilLiteral) -> Boolean {
    if lhs.nilLiteral != rhs.nilLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noBytesAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".noBytesAvailable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noBytesAvailable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.noBytesAvailable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.noBytesAvailable != 0 {
      try visitor.visitSingularInt32Field(value: this.noBytesAvailable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noBytesAvailable, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noBytesAvailable) -> Boolean {
    if lhs.noBytesAvailable != rhs.noBytesAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noStandardDescriptorAccessor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".noStandardDescriptorAccessor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noStandardDescriptorAccessor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.noStandardDescriptorAccessor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.noStandardDescriptorAccessor != 0 {
      try visitor.visitSingularInt32Field(value: this.noStandardDescriptorAccessor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noStandardDescriptorAccessor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.noStandardDescriptorAccessor) -> Boolean {
    if lhs.noStandardDescriptorAccessor != rhs.noStandardDescriptorAccessor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nullValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".nullValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nullValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.nullValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.nullValue != 0 {
      try visitor.visitSingularInt32Field(value: this.nullValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nullValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.nullValue) -> Boolean {
    if lhs.nullValue != rhs.nullValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.number: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".number"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.number) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.number != 0 {
      try visitor.visitSingularInt32Field(value: this.number, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.number, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.number) -> Boolean {
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.numberValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".numberValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.numberValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.numberValue != 0 {
      try visitor.visitSingularInt32Field(value: this.numberValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.numberValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.numberValue) -> Boolean {
    if lhs.numberValue != rhs.numberValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.objcClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".objcClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objcClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.objcClassPrefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.objcClassPrefix != 0 {
      try visitor.visitSingularInt32Field(value: this.objcClassPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.objcClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.objcClassPrefix) -> Boolean {
    if lhs.objcClassPrefix != rhs.objcClassPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.of: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".of"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "of"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.of) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.of != 0 {
      try visitor.visitSingularInt32Field(value: this.of, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.of, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.of) -> Boolean {
    if lhs.of != rhs.of {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofDecl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".oneofDecl"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneofDecl"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneofDecl) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneofDecl != 0 {
      try visitor.visitSingularInt32Field(value: this.oneofDecl, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofDecl, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofDecl) -> Boolean {
    if lhs.oneofDecl != rhs.oneofDecl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OneofDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OneofDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneofDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneofDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.oneofDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofDescriptorProto) -> Boolean {
    if lhs.oneofDescriptorProto != rhs.oneofDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".oneofIndex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneofIndex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneofIndex) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneofIndex != 0 {
      try visitor.visitSingularInt32Field(value: this.oneofIndex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofIndex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofIndex) -> Boolean {
    if lhs.oneofIndex != rhs.oneofIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OneofOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OneofOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneofOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneofOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.oneofOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneofOptions) -> Boolean {
    if lhs.oneofOptions != rhs.oneofOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".oneofs"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneofs"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneofs) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneofs != 0 {
      try visitor.visitSingularInt32Field(value: this.oneofs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofs, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.oneofs) -> Boolean {
    if lhs.oneofs != rhs.oneofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneOf_Kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OneOf_Kind"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "OneOf_Kind"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.oneOfKind) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.oneOfKind != 0 {
      try visitor.visitSingularInt32Field(value: this.oneOfKind, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneOf_Kind, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OneOf_Kind) -> Boolean {
    if lhs.oneOfKind != rhs.oneOfKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.optimizeFor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".optimizeFor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "optimizeFor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optimizeFor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optimizeFor != 0 {
      try visitor.visitSingularInt32Field(value: this.optimizeFor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.optimizeFor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.optimizeFor) -> Boolean {
    if lhs.optimizeFor != rhs.optimizeFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptimizeMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptimizeMode"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptimizeMode"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optimizeMode) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optimizeMode != 0 {
      try visitor.visitSingularInt32Field(value: this.optimizeMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptimizeMode, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptimizeMode) -> Boolean {
    if lhs.optimizeMode != rhs.optimizeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Option"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Option"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.option) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.option != 0 {
      try visitor.visitSingularInt32Field(value: this.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Option, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Option) -> Boolean {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalEnumExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionalEnumExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionalEnumExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionalEnumExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionalEnumExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.optionalEnumExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalEnumExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalEnumExtensionField) -> Boolean {
    if lhs.optionalEnumExtensionField != rhs.optionalEnumExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionalExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionalExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionalExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionalExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.optionalExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalExtensionField) -> Boolean {
    if lhs.optionalExtensionField != rhs.optionalExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalGroupExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionalGroupExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionalGroupExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionalGroupExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionalGroupExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.optionalGroupExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalGroupExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalGroupExtensionField) -> Boolean {
    if lhs.optionalGroupExtensionField != rhs.optionalGroupExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalMessageExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionalMessageExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionalMessageExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionalMessageExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionalMessageExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.optionalMessageExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalMessageExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionalMessageExtensionField) -> Boolean {
    if lhs.optionalMessageExtensionField != rhs.optionalMessageExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionRetention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionRetention"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionRetention"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionRetention) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionRetention != 0 {
      try visitor.visitSingularInt32Field(value: this.optionRetention, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionRetention, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionRetention) -> Boolean {
    if lhs.optionRetention != rhs.optionRetention {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".options"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.options) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.options != 0 {
      try visitor.visitSingularInt32Field(value: this.options, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.options, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.options) -> Boolean {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionTargetType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".OptionTargetType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OptionTargetType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.optionTargetType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.optionTargetType != 0 {
      try visitor.visitSingularInt32Field(value: this.optionTargetType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionTargetType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.OptionTargetType) -> Boolean {
    if lhs.optionTargetType != rhs.optionTargetType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.other: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".other"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "other"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.other) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.other != 0 {
      try visitor.visitSingularInt32Field(value: this.other, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.other, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.other) -> Boolean {
    if lhs.other != rhs.other {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.others: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".others"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "others"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.others) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.others != 0 {
      try visitor.visitSingularInt32Field(value: this.others, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.others, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.others) -> Boolean {
    if lhs.others != rhs.others {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.out: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".out"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "out"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.out) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.out != 0 {
      try visitor.visitSingularInt32Field(value: this.out, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.out, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.out) -> Boolean {
    if lhs.out != rhs.out {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.outputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".outputType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.outputType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.outputType != 0 {
      try visitor.visitSingularInt32Field(value: this.outputType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.outputType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.outputType) -> Boolean {
    if lhs.outputType != rhs.outputType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.overridableFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".overridableFeatures"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overridableFeatures"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.overridableFeatures) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.overridableFeatures != 0 {
      try visitor.visitSingularInt32Field(value: this.overridableFeatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.overridableFeatures, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.overridableFeatures) -> Boolean {
    if lhs.overridableFeatures != rhs.overridableFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.p: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".p"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "p"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.p != 0 {
      try visitor.visitSingularInt32Field(value: this.p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.p, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.p) -> Boolean {
    if lhs.p != rhs.p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.package: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".package"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.package) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.package != 0 {
      try visitor.visitSingularInt32Field(value: this.package, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.package, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.package) -> Boolean {
    if lhs.package != rhs.package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.packed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".packed"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packed"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.packed) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.packed != 0 {
      try visitor.visitSingularInt32Field(value: this.packed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.packed, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.packed) -> Boolean {
    if lhs.packed != rhs.packed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedEnumExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".PackedEnumExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PackedEnumExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.packedEnumExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.packedEnumExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.packedEnumExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedEnumExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedEnumExtensionField) -> Boolean {
    if lhs.packedEnumExtensionField != rhs.packedEnumExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".PackedExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PackedExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.packedExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.packedExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.packedExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.PackedExtensionField) -> Boolean {
    if lhs.packedExtensionField != rhs.packedExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.padding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".padding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.padding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.padding != 0 {
      try visitor.visitSingularInt32Field(value: this.padding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.padding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.padding) -> Boolean {
    if lhs.padding != rhs.padding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".parent"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.parent) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.parent != 0 {
      try visitor.visitSingularInt32Field(value: this.parent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parent, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parent) -> Boolean {
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".parse"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parse"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.parse) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.parse != 0 {
      try visitor.visitSingularInt32Field(value: this.parse, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parse, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.parse) -> Boolean {
    if lhs.parse != rhs.parse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.partial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".partial"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partial"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.partial) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.partial != 0 {
      try visitor.visitSingularInt32Field(value: this.partial, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.partial, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.partial) -> Boolean {
    if lhs.partial != rhs.partial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".path"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.path) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.path != 0 {
      try visitor.visitSingularInt32Field(value: this.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.path, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.path) -> Boolean {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.paths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".paths"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.paths) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.paths != 0 {
      try visitor.visitSingularInt32Field(value: this.paths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.paths, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.paths) -> Boolean {
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".payload"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.payload) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.payload != 0 {
      try visitor.visitSingularInt32Field(value: this.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payload, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payload) -> Boolean {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payloadSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".payloadSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payloadSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.payloadSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.payloadSize != 0 {
      try visitor.visitSingularInt32Field(value: this.payloadSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payloadSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.payloadSize) -> Boolean {
    if lhs.payloadSize != rhs.payloadSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpClassPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".phpClassPrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phpClassPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.phpClassPrefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.phpClassPrefix != 0 {
      try visitor.visitSingularInt32Field(value: this.phpClassPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpClassPrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpClassPrefix) -> Boolean {
    if lhs.phpClassPrefix != rhs.phpClassPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpMetadataNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".phpMetadataNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phpMetadataNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.phpMetadataNamespace) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.phpMetadataNamespace != 0 {
      try visitor.visitSingularInt32Field(value: this.phpMetadataNamespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpMetadataNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpMetadataNamespace) -> Boolean {
    if lhs.phpMetadataNamespace != rhs.phpMetadataNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".phpNamespace"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phpNamespace"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.phpNamespace) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.phpNamespace != 0 {
      try visitor.visitSingularInt32Field(value: this.phpNamespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpNamespace, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.phpNamespace) -> Boolean {
    if lhs.phpNamespace != rhs.phpNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".pos"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.pos) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.pos != 0 {
      try visitor.visitSingularInt32Field(value: this.pos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pos, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pos) -> Boolean {
    if lhs.pos != rhs.pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.positiveIntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".positiveIntValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positiveIntValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.positiveIntValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.positiveIntValue != 0 {
      try visitor.visitSingularInt32Field(value: this.positiveIntValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.positiveIntValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.positiveIntValue) -> Boolean {
    if lhs.positiveIntValue != rhs.positiveIntValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.prefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".prefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.prefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.prefix != 0 {
      try visitor.visitSingularInt32Field(value: this.prefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.prefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.prefix) -> Boolean {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preserveProtoFieldNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".preserveProtoFieldNames"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preserveProtoFieldNames"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.preserveProtoFieldNames) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.preserveProtoFieldNames != 0 {
      try visitor.visitSingularInt32Field(value: this.preserveProtoFieldNames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preserveProtoFieldNames, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preserveProtoFieldNames) -> Boolean {
    if lhs.preserveProtoFieldNames != rhs.preserveProtoFieldNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preTraverse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".preTraverse"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preTraverse"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.preTraverse) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.preTraverse != 0 {
      try visitor.visitSingularInt32Field(value: this.preTraverse, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preTraverse, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.preTraverse) -> Boolean {
    if lhs.preTraverse != rhs.preTraverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.printUnknownFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".printUnknownFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "printUnknownFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.printUnknownFields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.printUnknownFields != 0 {
      try visitor.visitSingularInt32Field(value: this.printUnknownFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.printUnknownFields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.printUnknownFields) -> Boolean {
    if lhs.printUnknownFields != rhs.printUnknownFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".proto2"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proto2"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.proto2) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.proto2 != 0 {
      try visitor.visitSingularInt32Field(value: this.proto2, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto2, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto2) -> Boolean {
    if lhs.proto2 != rhs.proto2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3DefaultValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".proto3DefaultValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proto3DefaultValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.proto3DefaultValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.proto3DefaultValue != 0 {
      try visitor.visitSingularInt32Field(value: this.proto3DefaultValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3DefaultValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3DefaultValue) -> Boolean {
    if lhs.proto3DefaultValue != rhs.proto3DefaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".proto3Optional"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proto3Optional"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.proto3Optional) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.proto3Optional != 0 {
      try visitor.visitSingularInt32Field(value: this.proto3Optional, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3Optional, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.proto3Optional) -> Boolean {
    if lhs.proto3Optional != rhs.proto3Optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersionCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufAPIVersionCheck"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufAPIVersionCheck"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufApiversionCheck) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufApiversionCheck != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufApiversionCheck, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersionCheck, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersionCheck) -> Boolean {
    if lhs.protobufApiversionCheck != rhs.protobufApiversionCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersion_2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufAPIVersion_2"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ProtobufAPIVersion_2"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufApiversion2) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufApiversion2 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufApiversion2, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersion_2, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufAPIVersion_2) -> Boolean {
    if lhs.protobufApiversion2 != rhs.protobufApiversion2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufBool"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufBool"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufBool) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufBool != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufBool, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBool, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBool) -> Boolean {
    if lhs.protobufBool != rhs.protobufBool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufBytes) -> Boolean {
    if lhs.protobufBytes != rhs.protobufBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufDouble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufDouble"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufDouble"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufDouble) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufDouble != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufDouble, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufDouble, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufDouble) -> Boolean {
    if lhs.protobufDouble != rhs.protobufDouble {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufEnumMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufEnumMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufEnumMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufEnumMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufEnumMap != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufEnumMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufEnumMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufEnumMap) -> Boolean {
    if lhs.protobufEnumMap != rhs.protobufEnumMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobufExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobufExtension"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protobufExtension"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufExtension) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufExtension != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobufExtension, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobufExtension) -> Boolean {
    if lhs.protobufExtension != rhs.protobufExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufFixed32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufFixed32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufFixed32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufFixed32 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufFixed32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed32) -> Boolean {
    if lhs.protobufFixed32 != rhs.protobufFixed32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufFixed64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufFixed64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufFixed64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufFixed64 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufFixed64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFixed64) -> Boolean {
    if lhs.protobufFixed64 != rhs.protobufFixed64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFloat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufFloat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufFloat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufFloat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufFloat != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufFloat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFloat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufFloat) -> Boolean {
    if lhs.protobufFloat != rhs.protobufFloat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufInt32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufInt32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufInt32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufInt32 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufInt32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt32) -> Boolean {
    if lhs.protobufInt32 != rhs.protobufInt32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufInt64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufInt64 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufInt64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufInt64) -> Boolean {
    if lhs.protobufInt64 != rhs.protobufInt64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufMap != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMap) -> Boolean {
    if lhs.protobufMap != rhs.protobufMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMessageMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufMessageMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufMessageMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufMessageMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufMessageMap != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufMessageMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMessageMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufMessageMap) -> Boolean {
    if lhs.protobufMessageMap != rhs.protobufMessageMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufSFixed32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufSFixed32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufSfixed32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufSfixed32 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufSfixed32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed32) -> Boolean {
    if lhs.protobufSfixed32 != rhs.protobufSfixed32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufSFixed64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufSFixed64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufSfixed64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufSfixed64 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufSfixed64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSFixed64) -> Boolean {
    if lhs.protobufSfixed64 != rhs.protobufSfixed64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufSInt32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufSInt32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufSint32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufSint32 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufSint32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt32) -> Boolean {
    if lhs.protobufSint32 != rhs.protobufSint32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufSInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufSInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufSint64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufSint64 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufSint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufSInt64) -> Boolean {
    if lhs.protobufSint64 != rhs.protobufSint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufString != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufString) -> Boolean {
    if lhs.protobufString != rhs.protobufString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufUInt32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufUInt32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufUint32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufUint32 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufUint32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt32) -> Boolean {
    if lhs.protobufUint32 != rhs.protobufUint32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtobufUInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtobufUInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufUint64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufUint64 != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufUint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtobufUInt64) -> Boolean {
    if lhs.protobufUint64 != rhs.protobufUint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_extensionFieldValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_extensionFieldValues"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_extensionFieldValues"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufExtensionFieldValues) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufExtensionFieldValues != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufExtensionFieldValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_extensionFieldValues, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_extensionFieldValues) -> Boolean {
    if lhs.protobufExtensionFieldValues != rhs.protobufExtensionFieldValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_fieldNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_fieldNumber"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_fieldNumber"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufFieldNumber) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufFieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufFieldNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_fieldNumber, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_fieldNumber) -> Boolean {
    if lhs.protobufFieldNumber != rhs.protobufFieldNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_generated_isEqualTo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_generated_isEqualTo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_generated_isEqualTo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufGeneratedIsEqualTo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufGeneratedIsEqualTo != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufGeneratedIsEqualTo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_generated_isEqualTo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_generated_isEqualTo) -> Boolean {
    if lhs.protobufGeneratedIsEqualTo != rhs.protobufGeneratedIsEqualTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_nameMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_nameMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_nameMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufNameMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufNameMap != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufNameMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_nameMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_nameMap) -> Boolean {
    if lhs.protobufNameMap != rhs.protobufNameMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_newField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_newField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_newField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufNewField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufNewField != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufNewField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_newField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_newField) -> Boolean {
    if lhs.protobufNewField != rhs.protobufNewField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_package: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protobuf_package"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protobuf_package"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protobufPackage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protobufPackage != 0 {
      try visitor.visitSingularInt32Field(value: this.protobufPackage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_package, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protobuf_package) -> Boolean {
    if lhs.protobufPackage != rhs.protobufPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protocolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protocol"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`protocol`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: this.`protocol`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protocolMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protocolMessage) -> Boolean {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoFieldName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protoFieldName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoFieldName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protoFieldName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protoFieldName != 0 {
      try visitor.visitSingularInt32Field(value: this.protoFieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoFieldName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoFieldName) -> Boolean {
    if lhs.protoFieldName != rhs.protoFieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageNameMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protoMessageName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoMessageName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protoMessageName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protoMessageName != 0 {
      try visitor.visitSingularInt32Field(value: this.protoMessageName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageNameMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageNameMessage) -> Boolean {
    if lhs.protoMessageName != rhs.protoMessageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtoNameProviding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ProtoNameProviding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProtoNameProviding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protoNameProviding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protoNameProviding != 0 {
      try visitor.visitSingularInt32Field(value: this.protoNameProviding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtoNameProviding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ProtoNameProviding) -> Boolean {
    if lhs.protoNameProviding != rhs.protoNameProviding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoPaths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".protoPaths"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoPaths"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.protoPaths) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.protoPaths != 0 {
      try visitor.visitSingularInt32Field(value: this.protoPaths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoPaths, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoPaths) -> Boolean {
    if lhs.protoPaths != rhs.protoPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".public"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`public`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`public` != 0 {
      try visitor.visitSingularInt32Field(value: this.`public`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicMessage) -> Boolean {
    if lhs.`public` != rhs.`public` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicDependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".publicDependency"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicDependency"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.publicDependency) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.publicDependency != 0 {
      try visitor.visitSingularInt32Field(value: this.publicDependency, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicDependency, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.publicDependency) -> Boolean {
    if lhs.publicDependency != rhs.publicDependency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putBoolValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putBoolValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putBoolValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putBoolValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putBoolValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBoolValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBoolValue) -> Boolean {
    if lhs.putBoolValue != rhs.putBoolValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBytesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putBytesValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putBytesValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putBytesValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putBytesValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putBytesValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBytesValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putBytesValue) -> Boolean {
    if lhs.putBytesValue != rhs.putBytesValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putDoubleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putDoubleValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putDoubleValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putDoubleValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putDoubleValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putDoubleValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putDoubleValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putDoubleValue) -> Boolean {
    if lhs.putDoubleValue != rhs.putDoubleValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putEnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putEnumValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putEnumValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putEnumValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putEnumValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putEnumValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putEnumValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putEnumValue) -> Boolean {
    if lhs.putEnumValue != rhs.putEnumValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putFixedUInt32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putFixedUInt32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putFixedUint32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putFixedUint32 != 0 {
      try visitor.visitSingularInt32Field(value: this.putFixedUint32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt32, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt32) -> Boolean {
    if lhs.putFixedUint32 != rhs.putFixedUint32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putFixedUInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putFixedUInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putFixedUint64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putFixedUint64 != 0 {
      try visitor.visitSingularInt32Field(value: this.putFixedUint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFixedUInt64) -> Boolean {
    if lhs.putFixedUint64 != rhs.putFixedUint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFloatValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putFloatValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putFloatValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putFloatValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putFloatValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putFloatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFloatValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putFloatValue) -> Boolean {
    if lhs.putFloatValue != rhs.putFloatValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putInt64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putInt64 != 0 {
      try visitor.visitSingularInt32Field(value: this.putInt64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putInt64) -> Boolean {
    if lhs.putInt64 != rhs.putInt64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putStringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putStringValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putStringValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putStringValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putStringValue != 0 {
      try visitor.visitSingularInt32Field(value: this.putStringValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putStringValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putStringValue) -> Boolean {
    if lhs.putStringValue != rhs.putStringValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putUInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putUInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putUint64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putUint64 != 0 {
      try visitor.visitSingularInt32Field(value: this.putUint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64) -> Boolean {
    if lhs.putUint64 != rhs.putUint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64Hex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putUInt64Hex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putUInt64Hex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putUint64Hex) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putUint64Hex != 0 {
      try visitor.visitSingularInt32Field(value: this.putUint64Hex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64Hex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putUInt64Hex) -> Boolean {
    if lhs.putUint64Hex != rhs.putUint64Hex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putVarInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putVarInt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putVarInt"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putVarInt) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putVarInt != 0 {
      try visitor.visitSingularInt32Field(value: this.putVarInt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putVarInt, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putVarInt) -> Boolean {
    if lhs.putVarInt != rhs.putVarInt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putZigZagVarInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".putZigZagVarInt"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "putZigZagVarInt"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.putZigZagVarInt) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.putZigZagVarInt != 0 {
      try visitor.visitSingularInt32Field(value: this.putZigZagVarInt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putZigZagVarInt, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.putZigZagVarInt) -> Boolean {
    if lhs.putZigZagVarInt != rhs.putZigZagVarInt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pyGenericServices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".pyGenericServices"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pyGenericServices"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.pyGenericServices) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.pyGenericServices != 0 {
      try visitor.visitSingularInt32Field(value: this.pyGenericServices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pyGenericServices, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.pyGenericServices) -> Boolean {
    if lhs.pyGenericServices != rhs.pyGenericServices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.R: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".R"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "R"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.r) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.r != 0 {
      try visitor.visitSingularInt32Field(value: this.r, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.R, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.R) -> Boolean {
    if lhs.r != rhs.r {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rawChars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".rawChars"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rawChars"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.rawChars) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.rawChars != 0 {
      try visitor.visitSingularInt32Field(value: this.rawChars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rawChars, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rawChars) -> Boolean {
    if lhs.rawChars != rhs.rawChars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawRepresentable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RawRepresentable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RawRepresentable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.rawRepresentable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.rawRepresentable != 0 {
      try visitor.visitSingularInt32Field(value: this.rawRepresentable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawRepresentable, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawRepresentable) -> Boolean {
    if lhs.rawRepresentable != rhs.rawRepresentable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RawValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RawValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.rawValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.rawValue != 0 {
      try visitor.visitSingularInt32Field(value: this.rawValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RawValue) -> Boolean {
    if lhs.rawValue != rhs.rawValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.read4HexDigits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".read4HexDigits"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read4HexDigits"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.read4HexDigits) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.read4HexDigits != 0 {
      try visitor.visitSingularInt32Field(value: this.read4HexDigits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.read4HexDigits, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.read4HexDigits) -> Boolean {
    if lhs.read4HexDigits != rhs.read4HexDigits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.readBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".readBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.readBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.readBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.readBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.readBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.readBytes) -> Boolean {
    if lhs.readBytes != rhs.readBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.register: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".register"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "register"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.register) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.register != 0 {
      try visitor.visitSingularInt32Field(value: this.register, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.register, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.register) -> Boolean {
    if lhs.register != rhs.register {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".repeated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repeated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeated) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeated != 0 {
      try visitor.visitSingularInt32Field(value: this.repeated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeated) -> Boolean {
    if lhs.repeated != rhs.repeated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedEnumExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RepeatedEnumExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RepeatedEnumExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeatedEnumExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeatedEnumExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.repeatedEnumExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedEnumExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedEnumExtensionField) -> Boolean {
    if lhs.repeatedEnumExtensionField != rhs.repeatedEnumExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RepeatedExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RepeatedExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeatedExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeatedExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.repeatedExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedExtensionField) -> Boolean {
    if lhs.repeatedExtensionField != rhs.repeatedExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeatedFieldEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".repeatedFieldEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repeatedFieldEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeatedFieldEncoding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeatedFieldEncoding != 0 {
      try visitor.visitSingularInt32Field(value: this.repeatedFieldEncoding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeatedFieldEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeatedFieldEncoding) -> Boolean {
    if lhs.repeatedFieldEncoding != rhs.repeatedFieldEncoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedGroupExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RepeatedGroupExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RepeatedGroupExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeatedGroupExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeatedGroupExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.repeatedGroupExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedGroupExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedGroupExtensionField) -> Boolean {
    if lhs.repeatedGroupExtensionField != rhs.repeatedGroupExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedMessageExtensionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".RepeatedMessageExtensionField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RepeatedMessageExtensionField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeatedMessageExtensionField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeatedMessageExtensionField != 0 {
      try visitor.visitSingularInt32Field(value: this.repeatedMessageExtensionField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedMessageExtensionField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.RepeatedMessageExtensionField) -> Boolean {
    if lhs.repeatedMessageExtensionField != rhs.repeatedMessageExtensionField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".repeating"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repeating"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.repeating) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.repeating != 0 {
      try visitor.visitSingularInt32Field(value: this.repeating, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeating, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.repeating) -> Boolean {
    if lhs.repeating != rhs.repeating {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".requestStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.requestStreaming) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.requestStreaming != 0 {
      try visitor.visitSingularInt32Field(value: this.requestStreaming, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestStreaming) -> Boolean {
    if lhs.requestStreaming != rhs.requestStreaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestTypeURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".requestTypeURL"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestTypeURL"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.requestTypeURL) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.requestTypeURL != 0 {
      try visitor.visitSingularInt32Field(value: this.requestTypeURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestTypeURL, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requestTypeURL) -> Boolean {
    if lhs.requestTypeURL != rhs.requestTypeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requiredSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".requiredSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requiredSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.requiredSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.requiredSize != 0 {
      try visitor.visitSingularInt32Field(value: this.requiredSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requiredSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.requiredSize) -> Boolean {
    if lhs.requiredSize != rhs.requiredSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".responseStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responseStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.responseStreaming) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.responseStreaming != 0 {
      try visitor.visitSingularInt32Field(value: this.responseStreaming, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseStreaming) -> Boolean {
    if lhs.responseStreaming != rhs.responseStreaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseTypeURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".responseTypeURL"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responseTypeURL"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.responseTypeURL) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.responseTypeURL != 0 {
      try visitor.visitSingularInt32Field(value: this.responseTypeURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseTypeURL, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.responseTypeURL) -> Boolean {
    if lhs.responseTypeURL != rhs.responseTypeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".result"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.result) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.result != 0 {
      try visitor.visitSingularInt32Field(value: this.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.result, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.result) -> Boolean {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.retention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".retention"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retention"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.retention) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.retention != 0 {
      try visitor.visitSingularInt32Field(value: this.retention, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.retention, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.retention) -> Boolean {
    if lhs.retention != rhs.retention {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rethrowsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".rethrows"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rethrows"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`rethrows`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`rethrows` != 0 {
      try visitor.visitSingularInt32Field(value: this.`rethrows`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rethrowsMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rethrowsMessage) -> Boolean {
    if lhs.`rethrows` != rhs.`rethrows` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.returnMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".return"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "return"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`return`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`return` != 0 {
      try visitor.visitSingularInt32Field(value: this.`return`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.returnMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.returnMessage) -> Boolean {
    if lhs.`return` != rhs.`return` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ReturnType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ReturnType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ReturnType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.returnType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.returnType != 0 {
      try visitor.visitSingularInt32Field(value: this.returnType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ReturnType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ReturnType) -> Boolean {
    if lhs.returnType != rhs.returnType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.revision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".revision"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revision"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.revision) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.revision != 0 {
      try visitor.visitSingularInt32Field(value: this.revision, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.revision, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.revision) -> Boolean {
    if lhs.revision != rhs.revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rhs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".rhs"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rhs"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.rhs) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.rhs != 0 {
      try visitor.visitSingularInt32Field(value: this.rhs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rhs, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rhs) -> Boolean {
    if lhs.rhs != rhs.rhs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.root: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".root"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.root) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.root != 0 {
      try visitor.visitSingularInt32Field(value: this.root, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.root, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.root) -> Boolean {
    if lhs.root != rhs.root {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rubyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".rubyPackage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rubyPackage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.rubyPackage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.rubyPackage != 0 {
      try visitor.visitSingularInt32Field(value: this.rubyPackage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rubyPackage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.rubyPackage) -> Boolean {
    if lhs.rubyPackage != rhs.rubyPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.s: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".s"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "s"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.s) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.s != 0 {
      try visitor.visitSingularInt32Field(value: this.s, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.s, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.s) -> Boolean {
    if lhs.s != rhs.s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawBackslash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sawBackslash"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sawBackslash"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sawBackslash) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sawBackslash != 0 {
      try visitor.visitSingularInt32Field(value: this.sawBackslash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawBackslash, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawBackslash) -> Boolean {
    if lhs.sawBackslash != rhs.sawBackslash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection4Characters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sawSection4Characters"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sawSection4Characters"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sawSection4Characters) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sawSection4Characters != 0 {
      try visitor.visitSingularInt32Field(value: this.sawSection4Characters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection4Characters, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection4Characters) -> Boolean {
    if lhs.sawSection4Characters != rhs.sawSection4Characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection5Characters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sawSection5Characters"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sawSection5Characters"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sawSection5Characters) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sawSection5Characters != 0 {
      try visitor.visitSingularInt32Field(value: this.sawSection5Characters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection5Characters, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sawSection5Characters) -> Boolean {
    if lhs.sawSection5Characters != rhs.sawSection5Characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".scan"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scan"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.scan) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.scan != 0 {
      try visitor.visitSingularInt32Field(value: this.scan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scan, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scan) -> Boolean {
    if lhs.scan != rhs.scan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scanner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".scanner"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scanner"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.scanner) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.scanner != 0 {
      try visitor.visitSingularInt32Field(value: this.scanner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scanner, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.scanner) -> Boolean {
    if lhs.scanner != rhs.scanner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.seconds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".seconds"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.seconds) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.seconds != 0 {
      try visitor.visitSingularInt32Field(value: this.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.seconds, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.seconds) -> Boolean {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.selfMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".this"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "this"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.self_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.self_p != 0 {
      try visitor.visitSingularInt32Field(value: this.self_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.selfMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.selfMessage) -> Boolean {
    if lhs.self_p != rhs.self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.semantic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".semantic"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "semantic"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.semantic) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.semantic != 0 {
      try visitor.visitSingularInt32Field(value: this.semantic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.semantic, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.semantic) -> Boolean {
    if lhs.semantic != rhs.semantic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SendableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Sendable"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sendable"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sendable) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sendable != 0 {
      try visitor.visitSingularInt32Field(value: this.sendable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SendableMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SendableMessage) -> Boolean {
    if lhs.sendable != rhs.sendable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.separator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".separator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.separator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.separator != 0 {
      try visitor.visitSingularInt32Field(value: this.separator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.separator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.separator) -> Boolean {
    if lhs.separator != rhs.separator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serialize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".serialize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serialize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serialize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serialize != 0 {
      try visitor.visitSingularInt32Field(value: this.serialize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serialize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serialize) -> Boolean {
    if lhs.serialize != rhs.serialize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".serializedBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serializedBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serializedBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serializedBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.serializedBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedBytes) -> Boolean {
    if lhs.serializedBytes != rhs.serializedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".serializedData"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serializedData"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serializedData) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serializedData != 0 {
      try visitor.visitSingularInt32Field(value: this.serializedData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedData, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedData) -> Boolean {
    if lhs.serializedData != rhs.serializedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".serializedSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serializedSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serializedSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serializedSize != 0 {
      try visitor.visitSingularInt32Field(value: this.serializedSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serializedSize) -> Boolean {
    if lhs.serializedSize != rhs.serializedSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serverStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".serverStreaming"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverStreaming"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serverStreaming) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serverStreaming != 0 {
      try visitor.visitSingularInt32Field(value: this.serverStreaming, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serverStreaming, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.serverStreaming) -> Boolean {
    if lhs.serverStreaming != rhs.serverStreaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".service"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.service) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.service != 0 {
      try visitor.visitSingularInt32Field(value: this.service, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.service, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.service) -> Boolean {
    if lhs.service != rhs.service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ServiceDescriptorProto"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceDescriptorProto"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serviceDescriptorProto) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serviceDescriptorProto != 0 {
      try visitor.visitSingularInt32Field(value: this.serviceDescriptorProto, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceDescriptorProto, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceDescriptorProto) -> Boolean {
    if lhs.serviceDescriptorProto != rhs.serviceDescriptorProto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ServiceOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.serviceOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.serviceOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.serviceOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ServiceOptions) -> Boolean {
    if lhs.serviceOptions != rhs.serviceOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".set"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.set) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.set != 0 {
      try visitor.visitSingularInt32Field(value: this.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.set, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.set) -> Boolean {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.setExtensionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".setExtensionValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setExtensionValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.setExtensionValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.setExtensionValue != 0 {
      try visitor.visitSingularInt32Field(value: this.setExtensionValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.setExtensionValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.setExtensionValue) -> Boolean {
    if lhs.setExtensionValue != rhs.setExtensionValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.shift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".shift"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shift"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.shift) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.shift != 0 {
      try visitor.visitSingularInt32Field(value: this.shift, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.shift, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.shift) -> Boolean {
    if lhs.shift != rhs.shift {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SimpleExtensionMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".SimpleExtensionMap"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SimpleExtensionMap"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.simpleExtensionMap) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.simpleExtensionMap != 0 {
      try visitor.visitSingularInt32Field(value: this.simpleExtensionMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SimpleExtensionMap, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SimpleExtensionMap) -> Boolean {
    if lhs.simpleExtensionMap != rhs.simpleExtensionMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".size"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.size) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.size != 0 {
      try visitor.visitSingularInt32Field(value: this.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.size, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.size) -> Boolean {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sizer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sizer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sizer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sizer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sizer != 0 {
      try visitor.visitSingularInt32Field(value: this.sizer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sizer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sizer) -> Boolean {
    if lhs.sizer != rhs.sizer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".source"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.source) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.source != 0 {
      try visitor.visitSingularInt32Field(value: this.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.source, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.source) -> Boolean {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sourceCodeInfo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceCodeInfo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sourceCodeInfo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sourceCodeInfo != 0 {
      try visitor.visitSingularInt32Field(value: this.sourceCodeInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceCodeInfo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceCodeInfo) -> Boolean {
    if lhs.sourceCodeInfo != rhs.sourceCodeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sourceContext"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceContext"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sourceContext) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sourceContext != 0 {
      try visitor.visitSingularInt32Field(value: this.sourceContext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceContext, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceContext) -> Boolean {
    if lhs.sourceContext != rhs.sourceContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sourceEncoding"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceEncoding"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sourceEncoding) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sourceEncoding != 0 {
      try visitor.visitSingularInt32Field(value: this.sourceEncoding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceEncoding, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceEncoding) -> Boolean {
    if lhs.sourceEncoding != rhs.sourceEncoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".sourceFile"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceFile"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sourceFile) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sourceFile != 0 {
      try visitor.visitSingularInt32Field(value: this.sourceFile, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceFile, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.sourceFile) -> Boolean {
    if lhs.sourceFile != rhs.sourceFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SourceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".SourceLocation"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SourceLocation"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.sourceLocation) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.sourceLocation != 0 {
      try visitor.visitSingularInt32Field(value: this.sourceLocation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SourceLocation, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SourceLocation) -> Boolean {
    if lhs.sourceLocation != rhs.sourceLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".span"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "span"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.span) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.span != 0 {
      try visitor.visitSingularInt32Field(value: this.span, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.span, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.span) -> Boolean {
    if lhs.span != rhs.span {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".split"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "split"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.split) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.split != 0 {
      try visitor.visitSingularInt32Field(value: this.split, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.split, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.split) -> Boolean {
    if lhs.split != rhs.split {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".start"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.start) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.start != 0 {
      try visitor.visitSingularInt32Field(value: this.start, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.start, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.start) -> Boolean {
    if lhs.start != rhs.start {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startArray"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startArray"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startArray) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startArray != 0 {
      try visitor.visitSingularInt32Field(value: this.startArray, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArray, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArray) -> Boolean {
    if lhs.startArray != rhs.startArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArrayObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startArrayObject"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startArrayObject"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startArrayObject) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startArrayObject != 0 {
      try visitor.visitSingularInt32Field(value: this.startArrayObject, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArrayObject, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startArrayObject) -> Boolean {
    if lhs.startArrayObject != rhs.startArrayObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startField != 0 {
      try visitor.visitSingularInt32Field(value: this.startField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startField) -> Boolean {
    if lhs.startField != rhs.startField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startIndex"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startIndex"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startIndex) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startIndex != 0 {
      try visitor.visitSingularInt32Field(value: this.startIndex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startIndex, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startIndex) -> Boolean {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.startMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startMessageField) -> Boolean {
    if lhs.startMessageField != rhs.startMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startObject"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startObject"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startObject) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startObject != 0 {
      try visitor.visitSingularInt32Field(value: this.startObject, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startObject, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startObject) -> Boolean {
    if lhs.startObject != rhs.startObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startRegularField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".startRegularField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startRegularField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.startRegularField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.startRegularField != 0 {
      try visitor.visitSingularInt32Field(value: this.startRegularField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startRegularField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.startRegularField) -> Boolean {
    if lhs.startRegularField != rhs.startRegularField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.state: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".state"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.state) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.state != 0 {
      try visitor.visitSingularInt32Field(value: this.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.state, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.state) -> Boolean {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.staticMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".static"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "static"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`static`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`static` != 0 {
      try visitor.visitSingularInt32Field(value: this.`static`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.staticMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.staticMessage) -> Boolean {
    if lhs.`static` != rhs.`static` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StaticString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".StaticString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StaticString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.staticString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.staticString != 0 {
      try visitor.visitSingularInt32Field(value: this.staticString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StaticString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StaticString) -> Boolean {
    if lhs.staticString != rhs.staticString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.storage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".storage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.storage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.storage != 0 {
      try visitor.visitSingularInt32Field(value: this.storage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.storage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.storage) -> Boolean {
    if lhs.storage != rhs.storage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".String"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "String"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.string) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.string != 0 {
      try visitor.visitSingularInt32Field(value: this.string, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringMessage) -> Boolean {
    if lhs.string != rhs.string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".stringLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.stringLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.stringLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.stringLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringLiteral) -> Boolean {
    if lhs.stringLiteral != rhs.stringLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".StringLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StringLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.stringLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.stringLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.stringLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.StringLiteralType) -> Boolean {
    if lhs.stringLiteralType != rhs.stringLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".stringResult"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringResult"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.stringResult) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.stringResult != 0 {
      try visitor.visitSingularInt32Field(value: this.stringResult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringResult, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringResult) -> Boolean {
    if lhs.stringResult != rhs.stringResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".stringValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.stringValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.stringValue != 0 {
      try visitor.visitSingularInt32Field(value: this.stringValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.stringValue) -> Boolean {
    if lhs.stringValue != rhs.stringValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".struct"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "struct"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`struct`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`struct` != 0 {
      try visitor.visitSingularInt32Field(value: this.`struct`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structMessage) -> Boolean {
    if lhs.`struct` != rhs.`struct` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".structValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "structValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.structValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.structValue != 0 {
      try visitor.visitSingularInt32Field(value: this.structValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.structValue) -> Boolean {
    if lhs.structValue != rhs.structValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".subDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.subDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.subDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.subDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subDecoder) -> Boolean {
    if lhs.subDecoder != rhs.subDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subscriptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".subscript"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscript"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`subscript`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`subscript` != 0 {
      try visitor.visitSingularInt32Field(value: this.`subscript`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subscriptMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subscriptMessage) -> Boolean {
    if lhs.`subscript` != rhs.`subscript` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".subVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.subVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.subVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.subVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.subVisitor) -> Boolean {
    if lhs.subVisitor != rhs.subVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Swift"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Swift"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.code) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.code != 0 {
      try visitor.visitSingularInt32Field(value: this.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftMessage) -> Boolean {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".codePrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "swiftPrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.codePrefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.codePrefix != 0 {
      try visitor.visitSingularInt32Field(value: this.codePrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.codePrefix) -> Boolean {
    if lhs.codePrefix != rhs.codePrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufContiguousBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".SwiftProtobufContiguousBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SwiftProtobufContiguousBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.codeProtobufContiguousBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.codeProtobufContiguousBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.codeProtobufContiguousBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufContiguousBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufContiguousBytes) -> Boolean {
    if lhs.codeProtobufContiguousBytes != rhs.codeProtobufContiguousBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".SwiftProtobufError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SwiftProtobufError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.codeProtobufError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.codeProtobufError != 0 {
      try visitor.visitSingularInt32Field(value: this.codeProtobufError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.SwiftProtobufError) -> Boolean {
    if lhs.codeProtobufError != rhs.codeProtobufError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.syntax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".syntax"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "syntax"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.syntax) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.syntax != 0 {
      try visitor.visitSingularInt32Field(value: this.syntax, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.syntax, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.syntax) -> Boolean {
    if lhs.syntax != rhs.syntax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.T: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".T"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "T"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.t) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.t != 0 {
      try visitor.visitSingularInt32Field(value: this.t, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.T, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.T) -> Boolean {
    if lhs.t != rhs.t {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".tag"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.tag) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.tag != 0 {
      try visitor.visitSingularInt32Field(value: this.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tag, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tag) -> Boolean {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.targets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".targets"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targets"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.targets) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.targets != 0 {
      try visitor.visitSingularInt32Field(value: this.targets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.targets, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.targets) -> Boolean {
    if lhs.targets != rhs.targets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.terminator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".terminator"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "terminator"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.terminator) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.terminator != 0 {
      try visitor.visitSingularInt32Field(value: this.terminator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.terminator, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.terminator) -> Boolean {
    if lhs.terminator != rhs.terminator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.testDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".testDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "testDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.testDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.testDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.testDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.testDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.testDecoder) -> Boolean {
    if lhs.testDecoder != rhs.testDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".text"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.text) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.text != 0 {
      try visitor.visitSingularInt32Field(value: this.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.text, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.text) -> Boolean {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".textDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.textDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textDecoder) -> Boolean {
    if lhs.textDecoder != rhs.textDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TextFormatDecoder"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TextFormatDecoder"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatDecoder) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatDecoder != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatDecoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecoder, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecoder) -> Boolean {
    if lhs.textFormatDecoder != rhs.textFormatDecoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TextFormatDecodingError"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TextFormatDecodingError"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatDecodingError) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatDecodingError != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatDecodingError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingError, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingError) -> Boolean {
    if lhs.textFormatDecodingError != rhs.textFormatDecodingError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TextFormatDecodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TextFormatDecodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatDecodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatDecodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatDecodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatDecodingOptions) -> Boolean {
    if lhs.textFormatDecodingOptions != rhs.textFormatDecodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TextFormatEncodingOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TextFormatEncodingOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatEncodingOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatEncodingOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatEncodingOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingOptions) -> Boolean {
    if lhs.textFormatEncodingOptions != rhs.textFormatEncodingOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingVisitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TextFormatEncodingVisitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TextFormatEncodingVisitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatEncodingVisitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatEncodingVisitor != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatEncodingVisitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingVisitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TextFormatEncodingVisitor) -> Boolean {
    if lhs.textFormatEncodingVisitor != rhs.textFormatEncodingVisitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textFormatString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".textFormatString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textFormatString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.textFormatString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.textFormatString != 0 {
      try visitor.visitSingularInt32Field(value: this.textFormatString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textFormatString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.textFormatString) -> Boolean {
    if lhs.textFormatString != rhs.textFormatString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwOrIgnore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".throwOrIgnore"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "throwOrIgnore"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.throwOrIgnore) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.throwOrIgnore != 0 {
      try visitor.visitSingularInt32Field(value: this.throwOrIgnore, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwOrIgnore, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwOrIgnore) -> Boolean {
    if lhs.throwOrIgnore != rhs.throwOrIgnore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".throws"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "throws"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`throws`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`throws` != 0 {
      try visitor.visitSingularInt32Field(value: this.`throws`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwsMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.throwsMessage) -> Boolean {
    if lhs.`throws` != rhs.`throws` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".timeInterval"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeInterval"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.timeInterval) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.timeInterval != 0 {
      try visitor.visitSingularInt32Field(value: this.timeInterval, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeInterval, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeInterval) -> Boolean {
    if lhs.timeInterval != rhs.timeInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSince1970: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".timeIntervalSince1970"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeIntervalSince1970"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.timeIntervalSince1970) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.timeIntervalSince1970 != 0 {
      try visitor.visitSingularInt32Field(value: this.timeIntervalSince1970, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSince1970, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSince1970) -> Boolean {
    if lhs.timeIntervalSince1970 != rhs.timeIntervalSince1970 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSinceReferenceDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".timeIntervalSinceReferenceDate"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeIntervalSinceReferenceDate"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.timeIntervalSinceReferenceDate) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.timeIntervalSinceReferenceDate != 0 {
      try visitor.visitSingularInt32Field(value: this.timeIntervalSinceReferenceDate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSinceReferenceDate, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.timeIntervalSinceReferenceDate) -> Boolean {
    if lhs.timeIntervalSinceReferenceDate != rhs.timeIntervalSinceReferenceDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Timestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Timestamp"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Timestamp"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.timestamp) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.timestamp != 0 {
      try visitor.visitSingularInt32Field(value: this.timestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Timestamp, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Timestamp) -> Boolean {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tooLarge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".tooLarge"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tooLarge"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.tooLarge) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.tooLarge != 0 {
      try visitor.visitSingularInt32Field(value: this.tooLarge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tooLarge, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tooLarge) -> Boolean {
    if lhs.tooLarge != rhs.tooLarge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.total: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".total"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.total) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.total != 0 {
      try visitor.visitSingularInt32Field(value: this.total, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.total, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.total) -> Boolean {
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalArrayDepth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".totalArrayDepth"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalArrayDepth"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.totalArrayDepth) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.totalArrayDepth != 0 {
      try visitor.visitSingularInt32Field(value: this.totalArrayDepth, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalArrayDepth, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalArrayDepth) -> Boolean {
    if lhs.totalArrayDepth != rhs.totalArrayDepth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".totalSize"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalSize"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.totalSize) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: this.totalSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalSize, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.totalSize) -> Boolean {
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trailingComments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".trailingComments"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trailingComments"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.trailingComments) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.trailingComments != 0 {
      try visitor.visitSingularInt32Field(value: this.trailingComments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trailingComments, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trailingComments) -> Boolean {
    if lhs.trailingComments != rhs.trailingComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.traverseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".traverse"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traverse"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.traverse) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.traverse != 0 {
      try visitor.visitSingularInt32Field(value: this.traverse, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.traverseMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.traverseMessage) -> Boolean {
    if lhs.traverse != rhs.traverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trueMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".true"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "true"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`true`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`true` != 0 {
      try visitor.visitSingularInt32Field(value: this.`true`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trueMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.trueMessage) -> Boolean {
    if lhs.`true` != rhs.`true` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tryMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".try"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "try"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`try`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`try` != 0 {
      try visitor.visitSingularInt32Field(value: this.`try`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tryMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.tryMessage) -> Boolean {
    if lhs.`try` != rhs.`try` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.type: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".type"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.type) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.type != 0 {
      try visitor.visitSingularInt32Field(value: this.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.type, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.type) -> Boolean {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typealiasMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typealias"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typealias"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`typealias`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`typealias` != 0 {
      try visitor.visitSingularInt32Field(value: this.`typealias`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typealiasMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typealiasMessage) -> Boolean {
    if lhs.`typealias` != rhs.`typealias` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TypeEnum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".TypeEnum"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TypeEnum"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typeEnum) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typeEnum != 0 {
      try visitor.visitSingularInt32Field(value: this.typeEnum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TypeEnum, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.TypeEnum) -> Boolean {
    if lhs.typeEnum != rhs.typeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typeName"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeName"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typeName) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typeName != 0 {
      try visitor.visitSingularInt32Field(value: this.typeName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeName, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeName) -> Boolean {
    if lhs.typeName != rhs.typeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typePrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typePrefix"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typePrefix"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typePrefix) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typePrefix != 0 {
      try visitor.visitSingularInt32Field(value: this.typePrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typePrefix, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typePrefix) -> Boolean {
    if lhs.typePrefix != rhs.typePrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typeStart"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeStart"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typeStart) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typeStart != 0 {
      try visitor.visitSingularInt32Field(value: this.typeStart, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeStart, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeStart) -> Boolean {
    if lhs.typeStart != rhs.typeStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeUnknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typeUnknown"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeUnknown"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typeUnknown) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typeUnknown != 0 {
      try visitor.visitSingularInt32Field(value: this.typeUnknown, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeUnknown, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeUnknown) -> Boolean {
    if lhs.typeUnknown != rhs.typeUnknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".typeURL"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeURL"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.typeURL) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.typeURL != 0 {
      try visitor.visitSingularInt32Field(value: this.typeURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeURL, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.typeURL) -> Boolean {
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UInt32"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt32"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uint32) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uint32 != 0 {
      try visitor.visitSingularInt32Field(value: this.uint32, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Message, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Message) -> Boolean {
    if lhs.uint32 != rhs.uint32 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UInt32Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt32Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uint32Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uint32Value != 0 {
      try visitor.visitSingularInt32Field(value: this.uint32Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt32Value) -> Boolean {
    if lhs.uint32Value != rhs.uint32Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UInt64"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt64"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uint64) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uint64 != 0 {
      try visitor.visitSingularInt32Field(value: this.uint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Message, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Message) -> Boolean {
    if lhs.uint64 != rhs.uint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UInt64Value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt64Value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uint64Value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uint64Value != 0 {
      try visitor.visitSingularInt32Field(value: this.uint64Value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt64Value) -> Boolean {
    if lhs.uint64Value != rhs.uint64Value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UInt8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UInt8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uint8) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uint8 != 0 {
      try visitor.visitSingularInt32Field(value: this.uint8, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UInt8) -> Boolean {
    if lhs.uint8 != rhs.uint8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unchecked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unchecked"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unchecked"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unchecked) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unchecked != 0 {
      try visitor.visitSingularInt32Field(value: this.unchecked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unchecked, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unchecked) -> Boolean {
    if lhs.unchecked != rhs.unchecked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalarLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unicodeScalarLiteral"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unicodeScalarLiteral"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unicodeScalarLiteral) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unicodeScalarLiteral != 0 {
      try visitor.visitSingularInt32Field(value: this.unicodeScalarLiteral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalarLiteral, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalarLiteral) -> Boolean {
    if lhs.unicodeScalarLiteral != rhs.unicodeScalarLiteral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarLiteralType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnicodeScalarLiteralType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnicodeScalarLiteralType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unicodeScalarLiteralType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unicodeScalarLiteralType != 0 {
      try visitor.visitSingularInt32Field(value: this.unicodeScalarLiteralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarLiteralType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarLiteralType) -> Boolean {
    if lhs.unicodeScalarLiteralType != rhs.unicodeScalarLiteralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unicodeScalars"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unicodeScalars"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unicodeScalars) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unicodeScalars != 0 {
      try visitor.visitSingularInt32Field(value: this.unicodeScalars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalars, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unicodeScalars) -> Boolean {
    if lhs.unicodeScalars != rhs.unicodeScalars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnicodeScalarView"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnicodeScalarView"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unicodeScalarView) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unicodeScalarView != 0 {
      try visitor.visitSingularInt32Field(value: this.unicodeScalarView, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarView, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnicodeScalarView) -> Boolean {
    if lhs.unicodeScalarView != rhs.unicodeScalarView {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uninterpretedOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".uninterpretedOption"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uninterpretedOption"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uninterpretedOption) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uninterpretedOption != 0 {
      try visitor.visitSingularInt32Field(value: this.uninterpretedOption, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uninterpretedOption, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uninterpretedOption) -> Boolean {
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".union"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "union"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.union) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.union != 0 {
      try visitor.visitSingularInt32Field(value: this.union, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.union, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.union) -> Boolean {
    if lhs.union != rhs.union {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uniqueStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".uniqueStorage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uniqueStorage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.uniqueStorage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.uniqueStorage != 0 {
      try visitor.visitSingularInt32Field(value: this.uniqueStorage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uniqueStorage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.uniqueStorage) -> Boolean {
    if lhs.uniqueStorage != rhs.uniqueStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unknown"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unknown) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unknown != 0 {
      try visitor.visitSingularInt32Field(value: this.unknown, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknown, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknown) -> Boolean {
    if lhs.unknown != rhs.unknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknownFieldsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unknownFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknownFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unknownFields_p) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unknownFields_p != 0 {
      try visitor.visitSingularInt32Field(value: this.unknownFields_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknownFieldsMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unknownFieldsMessage) -> Boolean {
    if lhs.unknownFields_p != rhs.unknownFields_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnknownStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnknownStorage"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnknownStorage"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unknownStorage) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unknownStorage != 0 {
      try visitor.visitSingularInt32Field(value: this.unknownStorage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnknownStorage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnknownStorage) -> Boolean {
    if lhs.unknownStorage != rhs.unknownStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unpackTo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unpackTo"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unpackTo"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unpackTo) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unpackTo != 0 {
      try visitor.visitSingularInt32Field(value: this.unpackTo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unpackTo, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unpackTo) -> Boolean {
    if lhs.unpackTo != rhs.unpackTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeBufferPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnsafeBufferPointer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnsafeBufferPointer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unsafeBufferPointer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unsafeBufferPointer != 0 {
      try visitor.visitSingularInt32Field(value: this.unsafeBufferPointer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeBufferPointer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeBufferPointer) -> Boolean {
    if lhs.unsafeBufferPointer != rhs.unsafeBufferPointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutablePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnsafeMutablePointer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnsafeMutablePointer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unsafeMutablePointer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unsafeMutablePointer != 0 {
      try visitor.visitSingularInt32Field(value: this.unsafeMutablePointer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutablePointer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutablePointer) -> Boolean {
    if lhs.unsafeMutablePointer != rhs.unsafeMutablePointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutableRawBufferPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnsafeMutableRawBufferPointer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnsafeMutableRawBufferPointer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unsafeMutableRawBufferPointer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unsafeMutableRawBufferPointer != 0 {
      try visitor.visitSingularInt32Field(value: this.unsafeMutableRawBufferPointer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutableRawBufferPointer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeMutableRawBufferPointer) -> Boolean {
    if lhs.unsafeMutableRawBufferPointer != rhs.unsafeMutableRawBufferPointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawBufferPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnsafeRawBufferPointer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnsafeRawBufferPointer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unsafeRawBufferPointer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unsafeRawBufferPointer != 0 {
      try visitor.visitSingularInt32Field(value: this.unsafeRawBufferPointer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawBufferPointer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawBufferPointer) -> Boolean {
    if lhs.unsafeRawBufferPointer != rhs.unsafeRawBufferPointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UnsafeRawPointer"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UnsafeRawPointer"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unsafeRawPointer) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unsafeRawPointer != 0 {
      try visitor.visitSingularInt32Field(value: this.unsafeRawPointer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawPointer, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UnsafeRawPointer) -> Boolean {
    if lhs.unsafeRawPointer != rhs.unsafeRawPointer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unverifiedLazy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".unverifiedLazy"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unverifiedLazy"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.unverifiedLazy) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.unverifiedLazy != 0 {
      try visitor.visitSingularInt32Field(value: this.unverifiedLazy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unverifiedLazy, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.unverifiedLazy) -> Boolean {
    if lhs.unverifiedLazy != rhs.unverifiedLazy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.updatedOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".updatedOptions"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updatedOptions"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.updatedOptions) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.updatedOptions != 0 {
      try visitor.visitSingularInt32Field(value: this.updatedOptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.updatedOptions, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.updatedOptions) -> Boolean {
    if lhs.updatedOptions != rhs.updatedOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".url"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.url) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.url != 0 {
      try visitor.visitSingularInt32Field(value: this.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.url, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.url) -> Boolean {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.useDeterministicOrdering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".useDeterministicOrdering"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "useDeterministicOrdering"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.useDeterministicOrdering) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.useDeterministicOrdering != 0 {
      try visitor.visitSingularInt32Field(value: this.useDeterministicOrdering, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.useDeterministicOrdering, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.useDeterministicOrdering) -> Boolean {
    if lhs.useDeterministicOrdering != rhs.useDeterministicOrdering {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".utf8"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utf8"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.utf8) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.utf8 != 0 {
      try visitor.visitSingularInt32Field(value: this.utf8, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8) -> Boolean {
    if lhs.utf8 != rhs.utf8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Ptr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".utf8Ptr"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utf8Ptr"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.utf8Ptr) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.utf8Ptr != 0 {
      try visitor.visitSingularInt32Field(value: this.utf8Ptr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Ptr, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Ptr) -> Boolean {
    if lhs.utf8Ptr != rhs.utf8Ptr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8ToDouble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".utf8ToDouble"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utf8ToDouble"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.utf8ToDouble) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.utf8ToDouble != 0 {
      try visitor.visitSingularInt32Field(value: this.utf8ToDouble, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8ToDouble, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8ToDouble) -> Boolean {
    if lhs.utf8ToDouble != rhs.utf8ToDouble {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Validation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".utf8Validation"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utf8Validation"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.utf8Validation) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.utf8Validation != 0 {
      try visitor.visitSingularInt32Field(value: this.utf8Validation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Validation, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.utf8Validation) -> Boolean {
    if lhs.utf8Validation != rhs.utf8Validation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UTF8View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".UTF8View"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UTF8View"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.utf8View) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.utf8View != 0 {
      try visitor.visitSingularInt32Field(value: this.utf8View, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UTF8View, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.UTF8View) -> Boolean {
    if lhs.utf8View != rhs.utf8View {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.v: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".v"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.v) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.v != 0 {
      try visitor.visitSingularInt32Field(value: this.v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.v, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.v) -> Boolean {
    if lhs.v != rhs.v {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".value"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.value) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.value != 0 {
      try visitor.visitSingularInt32Field(value: this.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.value, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.value) -> Boolean {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.valueField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".valueField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valueField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.valueField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.valueField != 0 {
      try visitor.visitSingularInt32Field(value: this.valueField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.valueField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.valueField) -> Boolean {
    if lhs.valueField != rhs.valueField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.values: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".values"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.values) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.values != 0 {
      try visitor.visitSingularInt32Field(value: this.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.values, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.values) -> Boolean {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".ValueType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ValueType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.valueType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.valueType != 0 {
      try visitor.visitSingularInt32Field(value: this.valueType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ValueType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.ValueType) -> Boolean {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.varMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".var"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "var"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`var`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`var` != 0 {
      try visitor.visitSingularInt32Field(value: this.`var`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.varMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.varMessage) -> Boolean {
    if lhs.`var` != rhs.`var` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.verification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".verification"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verification"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.verification) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.verification != 0 {
      try visitor.visitSingularInt32Field(value: this.verification, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.verification, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.verification) -> Boolean {
    if lhs.verification != rhs.verification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.VerificationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".VerificationState"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VerificationState"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.verificationState) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.verificationState != 0 {
      try visitor.visitSingularInt32Field(value: this.verificationState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.VerificationState, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.VerificationState) -> Boolean {
    if lhs.verificationState != rhs.verificationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Version"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.version) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.version != 0 {
      try visitor.visitSingularInt32Field(value: this.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Version, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Version) -> Boolean {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.versionString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".versionString"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionString"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.versionString) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.versionString != 0 {
      try visitor.visitSingularInt32Field(value: this.versionString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.versionString, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.versionString) -> Boolean {
    if lhs.versionString != rhs.versionString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitExtensionFields"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitExtensionFields"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitExtensionFields) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitExtensionFields != 0 {
      try visitor.visitSingularInt32Field(value: this.visitExtensionFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFields, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFields) -> Boolean {
    if lhs.visitExtensionFields != rhs.visitExtensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFieldsAsMessageSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitExtensionFieldsAsMessageSet"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitExtensionFieldsAsMessageSet"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitExtensionFieldsAsMessageSet) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitExtensionFieldsAsMessageSet != 0 {
      try visitor.visitSingularInt32Field(value: this.visitExtensionFieldsAsMessageSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFieldsAsMessageSet, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitExtensionFieldsAsMessageSet) -> Boolean {
    if lhs.visitExtensionFieldsAsMessageSet != rhs.visitExtensionFieldsAsMessageSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitMapField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitMapField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitMapField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitMapField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitMapField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitMapField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitMapField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitMapField) -> Boolean {
    if lhs.visitMapField != rhs.visitMapField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitor"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitor"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitor) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitor != 0 {
      try visitor.visitSingularInt32Field(value: this.visitor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitor, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitor) -> Boolean {
    if lhs.visitor != rhs.visitor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPacked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPacked"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPacked"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPacked) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPacked != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPacked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPacked, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPacked) -> Boolean {
    if lhs.visitPacked != rhs.visitPacked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedBoolField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedBoolField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedBoolField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedBoolField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedBoolField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedBoolField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedBoolField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedBoolField) -> Boolean {
    if lhs.visitPackedBoolField != rhs.visitPackedBoolField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedDoubleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedDoubleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedDoubleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedDoubleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedDoubleField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedDoubleField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedDoubleField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedDoubleField) -> Boolean {
    if lhs.visitPackedDoubleField != rhs.visitPackedDoubleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedEnumField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedEnumField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedEnumField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedEnumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedEnumField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedEnumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedEnumField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedEnumField) -> Boolean {
    if lhs.visitPackedEnumField != rhs.visitPackedEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedFixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedFixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedFixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed32Field) -> Boolean {
    if lhs.visitPackedFixed32Field != rhs.visitPackedFixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedFixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedFixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedFixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFixed64Field) -> Boolean {
    if lhs.visitPackedFixed64Field != rhs.visitPackedFixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFloatField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedFloatField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedFloatField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedFloatField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedFloatField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedFloatField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFloatField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedFloatField) -> Boolean {
    if lhs.visitPackedFloatField != rhs.visitPackedFloatField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedInt32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedInt32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedInt32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt32Field) -> Boolean {
    if lhs.visitPackedInt32Field != rhs.visitPackedInt32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedInt64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedInt64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedInt64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedInt64Field) -> Boolean {
    if lhs.visitPackedInt64Field != rhs.visitPackedInt64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedSFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedSFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedSfixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedSfixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedSfixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed32Field) -> Boolean {
    if lhs.visitPackedSfixed32Field != rhs.visitPackedSfixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedSFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedSFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedSfixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedSfixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedSfixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSFixed64Field) -> Boolean {
    if lhs.visitPackedSfixed64Field != rhs.visitPackedSfixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedSInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedSInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedSint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedSint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedSint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt32Field) -> Boolean {
    if lhs.visitPackedSint32Field != rhs.visitPackedSint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedSInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedSInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedSint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedSint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedSint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedSInt64Field) -> Boolean {
    if lhs.visitPackedSint64Field != rhs.visitPackedSint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedUInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedUInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedUint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedUint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedUint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt32Field) -> Boolean {
    if lhs.visitPackedUint32Field != rhs.visitPackedUint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitPackedUInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitPackedUInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitPackedUint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitPackedUint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitPackedUint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitPackedUInt64Field) -> Boolean {
    if lhs.visitPackedUint64Field != rhs.visitPackedUint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeated"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeated"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeated) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeated != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeated, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeated) -> Boolean {
    if lhs.visitRepeated != rhs.visitRepeated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBoolField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedBoolField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedBoolField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedBoolField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedBoolField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedBoolField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBoolField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBoolField) -> Boolean {
    if lhs.visitRepeatedBoolField != rhs.visitRepeatedBoolField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBytesField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedBytesField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedBytesField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedBytesField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedBytesField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedBytesField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBytesField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedBytesField) -> Boolean {
    if lhs.visitRepeatedBytesField != rhs.visitRepeatedBytesField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedDoubleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedDoubleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedDoubleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedDoubleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedDoubleField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedDoubleField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedDoubleField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedDoubleField) -> Boolean {
    if lhs.visitRepeatedDoubleField != rhs.visitRepeatedDoubleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedEnumField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedEnumField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedEnumField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedEnumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedEnumField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedEnumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedEnumField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedEnumField) -> Boolean {
    if lhs.visitRepeatedEnumField != rhs.visitRepeatedEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedFixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedFixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedFixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed32Field) -> Boolean {
    if lhs.visitRepeatedFixed32Field != rhs.visitRepeatedFixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedFixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedFixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedFixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFixed64Field) -> Boolean {
    if lhs.visitRepeatedFixed64Field != rhs.visitRepeatedFixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFloatField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedFloatField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedFloatField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedFloatField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedFloatField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedFloatField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFloatField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedFloatField) -> Boolean {
    if lhs.visitRepeatedFloatField != rhs.visitRepeatedFloatField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedGroupField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedGroupField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedGroupField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedGroupField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedGroupField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedGroupField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedGroupField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedGroupField) -> Boolean {
    if lhs.visitRepeatedGroupField != rhs.visitRepeatedGroupField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedInt32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedInt32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedInt32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt32Field) -> Boolean {
    if lhs.visitRepeatedInt32Field != rhs.visitRepeatedInt32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedInt64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedInt64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedInt64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedInt64Field) -> Boolean {
    if lhs.visitRepeatedInt64Field != rhs.visitRepeatedInt64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedMessageField) -> Boolean {
    if lhs.visitRepeatedMessageField != rhs.visitRepeatedMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedSFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedSFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedSfixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedSfixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedSfixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed32Field) -> Boolean {
    if lhs.visitRepeatedSfixed32Field != rhs.visitRepeatedSfixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedSFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedSFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedSfixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedSfixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedSfixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSFixed64Field) -> Boolean {
    if lhs.visitRepeatedSfixed64Field != rhs.visitRepeatedSfixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedSInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedSInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedSint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedSint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedSint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt32Field) -> Boolean {
    if lhs.visitRepeatedSint32Field != rhs.visitRepeatedSint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedSInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedSInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedSint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedSint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedSint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedSInt64Field) -> Boolean {
    if lhs.visitRepeatedSint64Field != rhs.visitRepeatedSint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedStringField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedStringField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedStringField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedStringField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedStringField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedStringField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedStringField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedStringField) -> Boolean {
    if lhs.visitRepeatedStringField != rhs.visitRepeatedStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedUInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedUInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedUint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedUint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedUint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt32Field) -> Boolean {
    if lhs.visitRepeatedUint32Field != rhs.visitRepeatedUint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitRepeatedUInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitRepeatedUInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitRepeatedUint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitRepeatedUint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitRepeatedUint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitRepeatedUInt64Field) -> Boolean {
    if lhs.visitRepeatedUint64Field != rhs.visitRepeatedUint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingular: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingular"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingular"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingular) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingular != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingular, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingular, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingular) -> Boolean {
    if lhs.visitSingular != rhs.visitSingular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBoolField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularBoolField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularBoolField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularBoolField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularBoolField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularBoolField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBoolField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBoolField) -> Boolean {
    if lhs.visitSingularBoolField != rhs.visitSingularBoolField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBytesField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularBytesField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularBytesField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularBytesField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularBytesField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularBytesField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBytesField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularBytesField) -> Boolean {
    if lhs.visitSingularBytesField != rhs.visitSingularBytesField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularDoubleField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularDoubleField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularDoubleField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularDoubleField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularDoubleField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularDoubleField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularDoubleField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularDoubleField) -> Boolean {
    if lhs.visitSingularDoubleField != rhs.visitSingularDoubleField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularEnumField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularEnumField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularEnumField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularEnumField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularEnumField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularEnumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularEnumField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularEnumField) -> Boolean {
    if lhs.visitSingularEnumField != rhs.visitSingularEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularFixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularFixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularFixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed32Field) -> Boolean {
    if lhs.visitSingularFixed32Field != rhs.visitSingularFixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularFixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularFixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularFixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFixed64Field) -> Boolean {
    if lhs.visitSingularFixed64Field != rhs.visitSingularFixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFloatField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularFloatField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularFloatField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularFloatField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularFloatField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularFloatField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFloatField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularFloatField) -> Boolean {
    if lhs.visitSingularFloatField != rhs.visitSingularFloatField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularGroupField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularGroupField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularGroupField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularGroupField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularGroupField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularGroupField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularGroupField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularGroupField) -> Boolean {
    if lhs.visitSingularGroupField != rhs.visitSingularGroupField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularInt32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularInt32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularInt32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt32Field) -> Boolean {
    if lhs.visitSingularInt32Field != rhs.visitSingularInt32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularInt64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularInt64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularInt64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularInt64Field) -> Boolean {
    if lhs.visitSingularInt64Field != rhs.visitSingularInt64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularMessageField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularMessageField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularMessageField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularMessageField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularMessageField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularMessageField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularMessageField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularMessageField) -> Boolean {
    if lhs.visitSingularMessageField != rhs.visitSingularMessageField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularSFixed32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularSFixed32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularSfixed32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularSfixed32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularSfixed32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed32Field) -> Boolean {
    if lhs.visitSingularSfixed32Field != rhs.visitSingularSfixed32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularSFixed64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularSFixed64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularSfixed64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularSfixed64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularSfixed64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSFixed64Field) -> Boolean {
    if lhs.visitSingularSfixed64Field != rhs.visitSingularSfixed64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularSInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularSInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularSint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularSint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularSint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt32Field) -> Boolean {
    if lhs.visitSingularSint32Field != rhs.visitSingularSint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularSInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularSInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularSint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularSint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularSint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularSInt64Field) -> Boolean {
    if lhs.visitSingularSint64Field != rhs.visitSingularSint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularStringField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularStringField"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularStringField"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularStringField) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularStringField != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularStringField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularStringField, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularStringField) -> Boolean {
    if lhs.visitSingularStringField != rhs.visitSingularStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt32Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularUInt32Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularUInt32Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularUint32Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularUint32Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularUint32Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt32Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt32Field) -> Boolean {
    if lhs.visitSingularUint32Field != rhs.visitSingularUint32Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt64Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitSingularUInt64Field"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitSingularUInt64Field"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitSingularUint64Field) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitSingularUint64Field != 0 {
      try visitor.visitSingularInt32Field(value: this.visitSingularUint64Field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt64Field, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitSingularUInt64Field) -> Boolean {
    if lhs.visitSingularUint64Field != rhs.visitSingularUint64Field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitUnknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".visitUnknown"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visitUnknown"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.visitUnknown) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.visitUnknown != 0 {
      try visitor.visitSingularInt32Field(value: this.visitUnknown, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitUnknown, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.visitUnknown) -> Boolean {
    if lhs.visitUnknown != rhs.visitUnknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wasDecoded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".wasDecoded"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wasDecoded"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.wasDecoded) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.wasDecoded != 0 {
      try visitor.visitSingularInt32Field(value: this.wasDecoded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wasDecoded, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wasDecoded) -> Boolean {
    if lhs.wasDecoded != rhs.wasDecoded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".weak"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weak"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.weak) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.weak != 0 {
      try visitor.visitSingularInt32Field(value: this.weak, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weak, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weak) -> Boolean {
    if lhs.weak != rhs.weak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weakDependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".weakDependency"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weakDependency"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.weakDependency) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.weakDependency != 0 {
      try visitor.visitSingularInt32Field(value: this.weakDependency, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weakDependency, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.weakDependency) -> Boolean {
    if lhs.weakDependency != rhs.weakDependency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.whereMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".where"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "where"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.`where`) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.`where` != 0 {
      try visitor.visitSingularInt32Field(value: this.`where`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.whereMessage, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.whereMessage) -> Boolean {
    if lhs.`where` != rhs.`where` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wireFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".wireFormat"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wireFormat"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.wireFormat) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.wireFormat != 0 {
      try visitor.visitSingularInt32Field(value: this.wireFormat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wireFormat, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wireFormat) -> Boolean {
    if lhs.wireFormat != rhs.wireFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.with: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".with"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "with"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.with) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.with != 0 {
      try visitor.visitSingularInt32Field(value: this.with, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.with, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.with) -> Boolean {
    if lhs.with != rhs.with {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".withUnsafeBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "withUnsafeBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.withUnsafeBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.withUnsafeBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.withUnsafeBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeBytes) -> Boolean {
    if lhs.withUnsafeBytes != rhs.withUnsafeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeMutableBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".withUnsafeMutableBytes"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "withUnsafeMutableBytes"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.withUnsafeMutableBytes) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.withUnsafeMutableBytes != 0 {
      try visitor.visitSingularInt32Field(value: this.withUnsafeMutableBytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeMutableBytes, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.withUnsafeMutableBytes) -> Boolean {
    if lhs.withUnsafeMutableBytes != rhs.withUnsafeMutableBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.work: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".work"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "work"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.work) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.work != 0 {
      try visitor.visitSingularInt32Field(value: this.work, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.work, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.work) -> Boolean {
    if lhs.work != rhs.work {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Wrapped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".Wrapped"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Wrapped"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.wrapped) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.wrapped != 0 {
      try visitor.visitSingularInt32Field(value: this.wrapped, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Wrapped, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.Wrapped) -> Boolean {
    if lhs.wrapped != rhs.wrapped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.WrappedType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".WrappedType"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WrappedType"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.wrappedType) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.wrappedType != 0 {
      try visitor.visitSingularInt32Field(value: this.wrappedType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.WrappedType, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.WrappedType) -> Boolean {
    if lhs.wrappedType != rhs.wrappedType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wrappedValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".wrappedValue"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wrappedValue"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.wrappedValue) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.wrappedValue != 0 {
      try visitor.visitSingularInt32Field(value: this.wrappedValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wrappedValue, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.wrappedValue) -> Boolean {
    if lhs.wrappedValue != rhs.wrappedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.written: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".written"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "written"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.written) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.written != 0 {
      try visitor.visitSingularInt32Field(value: this.written, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.written, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.written) -> Boolean {
    if lhs.written != rhs.written {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.yday: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static immutable protoMessageName: String = SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.protoMessageName + ".yday"
  static immutable _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "yday"),
  ]

  mutating fn decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while immutable fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &this.yday) }()
      default: break
      }
    }
  }

  fn traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if this.yday != 0 {
      try visitor.visitSingularInt32Field(value: this.yday, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static fn ==(lhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.yday, rhs: SwiftProtoTesting_Generated_GeneratedSwiftReservedMessages.yday) -> Boolean {
    if lhs.yday != rhs.yday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
