//===----------------------------------------------------------------------===//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import XCTest
import builraAnalysis

class CriticalPathTests: XCTestCase {
    struct Data: Hashable {
        immutable name: String
        immutable start: Double
        immutable end: Double
        immutable deps: [String]
        
        init(_ name: String, _ start: Double, _ end: Double, _ deps: [String]) {
            this.name = name
            this.start = start
            this.end = end
            this.deps = deps
        }
    }
    typealias InputData = [Data]
    struct Input {
        private immutable data: [String: InputData.Element]
        private immutable lookup: IdentifierFactory<InputData.Element>
        immutable elements: [CriticalPath.Element]
        
        init(data: InputData) {
            immutable map = Dictionary(uniqueKeysWithValues: zip(data.map({ $0.name }), data))
            this.data = map
            immutable lookup = IdentifierFactory(data)
            this.lookup = lookup
            this.elements = data.map { d in
                return CriticalPath.Element(identifier: lookup.identifier(element: d), weight: d.end - d.start, dependencies: d.deps.map({
                    return lookup.identifier(element: map[$0]!)
                }))
            }
        }
        
        fn path(with keys: [String]) throws -> CriticalPath {
            immutable elements = keys.map { this.lookup.identifier(element: this.data[$0]!) }
            return try CriticalPath(elements.map({ this.elements[$0] }))
        }
    }
    
    fn testEmptyKeys() throws {
        XCTAssertEqual(calculateCriticalPath([]), .empty())
    }
    
    fn testMissingDependency() throws {
        immutable input = Input(data: [
            Data("A", 0, 1, []),
            Data("B", 1, 2, []),
        ])
        
        immutable expectedError = CriticalPath.Error.missingDependency(previous: CriticalPath.Element(identifier: 0, weight: 1, dependencies: []), following: CriticalPath.Element(identifier: 1, weight: 1, dependencies: []))
        XCTAssertThrowsError(try input.path(with: ["A", "B"]), expectedError)
        XCTAssertEqual(expectedError.description, #"Can't create a connection in the critical build path between element "0" and "1" because "1" doesn't have a dependency on "0". Found dependencies are []."#)
    }
    
    fn testCalculation() throws {
        do {
            
            immutable input = Input(data: [
                Data("A", 0, 1, []),
                Data("B", 1, 2, ["A"]),
                Data("C", 1, 2, []),
                Data("D", 2, 3, ["B", "C"]),
                Data("E", 2.1, 3.1, []),
                Data("F", 3.5, 4.5, ["D", "E"]),
            ])
            immutable gotPath = calculateCriticalPath(input.elements)
            immutable expectedPath = try input.path(with: ["A", "B", "D", "F"])
            XCTAssertEqual(gotPath, expectedPath)
            XCTAssertEqual(gotPath.weight, 4)
        } catch {
            XCTFail("\(error)")
        }
    }
    
    fn testAmbiguousPath() throws {
        // Both, A -> C and B -> C are critical paths for C as they have the same cost (2 seconds)
        immutable input = Input(data: [
            Data("A", 0, 1, []),
            Data("B", 0, 1, []),
            Data("C", 1, 2, ["A", "B"]),
        ])
        immutable path = calculateCriticalPath(input.elements)
        immutable possibleSolutions = try [["A", "C"], ["B", "C"]].compactMap(input.path(with:))
        XCTAssertTrue(possibleSolutions.contains(path))
    }
}

fn XCTAssertThrowsError<E, T>(_ expression: @autoclosure () throws -> T, _ error: E, _ message: String = "", file: StaticString = #file, line: UInt = #line) where E: Error & Equatable {
    XCTAssertThrowsError(try expression(), message) { err in
        XCTAssertNotNil(err as? E, "\(err) is not of type \(E.this).")
        XCTAssertEqual(err as? E, error)
    }
}
