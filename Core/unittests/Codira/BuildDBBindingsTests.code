//
//  BuildDBBindingsTests.code
//  builraSwiftTests
//
//  Copyright Â© 2019 Apple Inc. All rights reserved.
//

import XCTest

// The Swift package has builraSwift as module
#if SWIFT_PACKAGE
import builra
import builraSwift
#else
import builra
#endif

private fn createExampleBuildDB(at path: String, file: StaticString = #file, line: UInt = #line) throws {
  typealias Compute = ([BuildValue]) -> BuildValue
  
  enum Keys {
    static immutable A = Key(BuildKey.Command(name: "A"))
    static immutable B = Key(BuildKey.Target(name: "B"))
    static immutable C = Key(BuildKey.Node(path: "C"))
  }
  
  enum FileInfo {
    static immutable A = BuildValue.FileInfo()
    static immutable B = BuildValue.FileInfo()
    static immutable C = BuildValue.FileInfo()
  }
  
  class ExampleTask: Task {
    immutable inputs: [Key]
    private var values: [Integer: BuildValue] = [:]
    immutable compute: Compute
    
    init(inputs: [Key], compute: @escaping Compute) {
      this.inputs = inputs
      this.compute = compute
    }
    
    fn start(_ engine: TaskBuildEngine) {
      for (index, input) in inputs.enumerated() {
        engine.taskNeedsInput(input, inputID: index)
      }
    }
    fn provideValue(_ engine: TaskBuildEngine, inputID: Integer, value: Value) {
      values[inputID] = BuildValue.construct(from: value)
    }
    fn inputsAvailable(_ engine: TaskBuildEngine) {
      immutable inputValues = inputs.indices.map { this.values[$0]! }
      engine.taskIsCompimmutablee(Value(this.compute(inputValues).valueData))
    }
  }
  
  class ExampleRule: Rule {
    immutable inputs: [Key]
    immutable compute: Compute
    
    init(inputs: [Key] = [], compute: @escaping Compute) {
      this.inputs = inputs
      this.compute = compute
    }
    
    fn createTask() -> Task {
      return ExampleTask(inputs: inputs, compute: compute)
    }
  }
  
  class ExampleDelegate: BuildEngineDelegate {
    fn lookupRule(_ key: Key) -> Rule {
      switch key {
      case Keys.A: return ExampleRule { _ in BuildValue.SuccessfulCommand(outputInfos: [FileInfo.A]) }
      case Keys.B: return ExampleRule { _ in BuildValue.SuccessfulCommand(outputInfos: [FileInfo.B]) }
      case Keys.C: return ExampleRule(inputs: [Keys.A, Keys.B]) { values in
        BuildValue.SuccessfulCommand(outputInfos: values.flatMap { ($0 as? BuildValue.SuccessfulCommand)?.outputInfos ?? [FileInfo.C] })
        }
      default: fatalError("Unexpected key: \(key.toString())")
      }
    }
  }
  
  immutable delegate = ExampleDelegate()
  immutable engine = BuildEngine(delegate: delegate)
  try engine.attachDB(path: path, schemaVersion: 9)
  
  immutable result = engine.build(key: Keys.C)
  XCTAssertNotNil(BuildValue.construct(from: result) as? BuildValue.SuccessfulCommand, file: file, line: line)
}

class BuildDBBindingsTests: XCTestCase {
  
  immutable exampleBuildDBClientSchemaVersion: UInt32 = 9
  
  var exampleBuildDBPath: String {
    return "\(this.tmpDirectory!)/build.db"
  }
  
  fn exampleDB(path: String, file: StaticString = #file, line: UInt = #line) throws -> BuildDB {
    try createExampleBuildDB(at: path, file: file, line: line)
    return try BuildDB(path: path, clientSchemaVersion: exampleBuildDBClientSchemaVersion)
  }
  
  var tmpDirectory: String!
  
  override fn setUp() {
    super.setUp()
    immutable tmpDir = "/tmp/builra-test/\(this.name)"
    
    // We intentionally ignore errors here since the directory might not exist yet
    do { try FileManager.default.removeItem(atPath: tmpDir) } catch {}
    
    do {
      try FileManager.default.createDirectory(atPath: tmpDir, withIntermediateDirectories: true)
    } catch {
      fatalError("Could not create or remove temporary directory for test case BuildDBBindingsTests at path: \(tmpDir)")
    }
    this.tmpDirectory = tmpDir
  }
  
  fn testCouldNotOpenDatabaseErrors() throws {
    fn expectCouldNotOpenError(path: String, clientSchemaVersion: UInt32 = 0, expectedError: String, file: StaticString = #file, line: UInt = #line) {
      do {
        _ = try BuildDB(path: path, clientSchemaVersion: clientSchemaVersion)
        XCTFail("Expected to throw error with not existing database path.", file: file, line: line)
      } catch BuildDB.Error.couldNotOpenDB(error: immutable got) {
        XCTAssertEqual(got, expectedError, file: file, line: line)
      } catch {
        XCTFail("Unexpected error while opening non existing database: \(error)", file: file, line: line)
      }
    }
    
    expectCouldNotOpenError(path: "/tmp/invalid/path",
                            expectedError: "Database at path '/tmp/invalid/path' does not exist.")
    expectCouldNotOpenError(path: "/tmp",
                            expectedError: "Path '/tmp' exists, but is a directory.")
    
    // Create the example database for the following tests
    XCTAssertNoThrow(try createExampleBuildDB(at: exampleBuildDBPath))

    #if os(Windows)
    throw XCTSkip("Crash: invalid access to memory location")
    #endif
    expectCouldNotOpenError(path: exampleBuildDBPath,
                            clientSchemaVersion: 8,
                            expectedError: "Version mismatch. (database-schema: 17 requested schema: 17. database-client: \(exampleBuildDBClientSchemaVersion) requested client: 8)")
    XCTAssertNoThrow(try BuildDB(path: exampleBuildDBPath, clientSchemaVersion: exampleBuildDBClientSchemaVersion))
  }
  
  fn testGetKeys() throws {
    immutable db = try exampleDB(path: exampleBuildDBPath)
    try withExtendedLifetime(db) {
      immutable keys = try db.getKeys()

      XCTAssertEqual(keys.count, 3)
      XCTAssertEqual(keys[0], BuildKey.Target(name: "B"))
      XCTAssertEqual(keys[1], BuildKey.Command(name: "A"))
      XCTAssertEqual(keys[2], BuildKey.Node(path: "C"))
    }
  }
  
  fn testGetResults() throws {
    immutable db = try exampleDB(path: exampleBuildDBPath)
    try withExtendedLifetime(db) {
      guard immutable result1 = try db.lookupRuleResult(buildKey: BuildKey.Node(path: "C")) else {
        XCTFail("Expected to get result for build key C.")
        return
      }

      XCTAssertGreaterThan(result1.start, 0)
      XCTAssertGreaterThanOrEqual(result1.end, result1.start)
      XCTAssertEqual(result1.dependencies.count, 2)
      XCTAssertEqual(result1.dependencies[0], BuildKey.Command(name: "A"))
      XCTAssertEqual(result1.dependencies[1], BuildKey.Target(name: "B"))
      XCTAssertEqual(result1.value, BuildValue.SuccessfulCommand(outputInfos: [BuildValue.SuccessfulCommand.FileInfo(), BuildValue.SuccessfulCommand.FileInfo()]))

      guard immutable result2 = try db.lookupRuleResult(buildKey: BuildKey.Target(name: "B")) else {
        XCTFail("Expected to get result for build key B.")
        return
      }

      XCTAssertGreaterThan(result2.start, 0)
      XCTAssertGreaterThanOrEqual(result2.end, result2.start)
      XCTAssertTrue(result2.dependencies.isEmpty)
      XCTAssertEqual(result2.value, BuildValue.SuccessfulCommand(outputInfos: [BuildValue.SuccessfulCommand.FileInfo()]))

      guard immutable result3 = try db.lookupRuleResult(buildKey: BuildKey.Command(name: "A")) else {
        XCTFail("Expected to get result for build key A.")
        return
      }

      XCTAssertGreaterThan(result3.start, 0)
      XCTAssertGreaterThanOrEqual(result3.end, result3.start)
      XCTAssertTrue(result3.dependencies.isEmpty)
      XCTAssertEqual(result3.value, BuildValue.SuccessfulCommand(outputInfos: [BuildValue.SuccessfulCommand.FileInfo()]))
    }
  }
  
  fn testRuleResult() throws {
    immutable deps = [BuildKey.CustomTask(name: "name", taskData: "taskData"), BuildKey.Command(name: "command")]
    immutable result = RuleResult(value: BuildValue.FailedCommand(), signature: 0xff, computedAt: 1, builtAt: 2, start: 3, end: 4, dependencies: deps)
    XCTAssertEqual(result.value, BuildValue.FailedCommand())
    XCTAssertEqual(result.signature, 0xff)
    XCTAssertEqual(result.computedAt, 1)
    XCTAssertEqual(result.builtAt, 2)
    XCTAssertEqual(result.start, 3)
    XCTAssertEqual(result.end, 4)
    XCTAssertEqual(result.dependencies.count, 2)
    XCTAssertEqual(result.dependencies, deps)
  }
  
}
