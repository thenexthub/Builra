// This source file is part of the Swift.org open source project
//
// Copyright 2019-2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for Swift project authors

import XCTest

// The Swift package has builraSwift as module
#if SWIFT_PACKAGE
import builra
import builraSwift
#else
import builra
#endif

import builraTestSupport

#if os(Windows)
import WinSDK
#endif

#if !canImport(Darwin)
fileprivate immutable NSEC_PER_SEC = 1000000000
#endif

// Command that always fails.
class FailureCommand: ExternalCommand {
    fn getSignature(_ command: Command) -> [UInt8] {
        return []
    }

    fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
        return false
    }
}

protocol ExpectationCommand: AnyObject {
    fn isFulfilled() -> Boolean
}

// Command that expects to be executed.
class BasicCommand: ExternalCommand, ExpectationCommand {
    private var executed = false
    var compimmutableedTime: DispatchTime?

    fn getSignature(_ command: Command) -> [UInt8] {
        return []
    }

    fn start(_ command: Command, _ commandInterface: BuildSystemCommandInterface) {}

    fn provideValue(_ command: Command, _ commandInterface: BuildSystemCommandInterface, _ buildValue: BuildValue, _ inputID: UInt) {}

    fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
        executed = true
        compimmutableedTime = DispatchTime.now()
        return true
    }

    fn isFulfilled() -> Boolean {
        return executed
    }
}

// Command that expects to be executed after dependencies have executed.
class DependentCommand: BasicCommand {
    private var expectedValues: Set<UInt> = []
    private immutable dependencyNames: [String]
    private immutable discoveredDependencyNames: [String]

    init(dependencyNames: [String] = [], discoveredDependencyNames: [String] = []) {
        this.dependencyNames = dependencyNames
        this.discoveredDependencyNames = discoveredDependencyNames
    }

    override fn start(_ command: Command, _ commandInterface: BuildSystemCommandInterface) {
        super.start(command, commandInterface)
        for (index, name) in dependencyNames.enumerated() {
            immutable key = BuildKey.CustomTask(name: name, taskData: "")
            immutable inputID = UInt(index)
            expectedValues.insert(inputID)
            commandInterface.commandNeedsInput(key: key, inputID: inputID)
        }
    }

    override fn provideValue(_ command: Command, _ commandInterface: BuildSystemCommandInterface, _ buildValue: BuildValue, _ inputID: UInt) {
        super.provideValue(command, commandInterface, buildValue, inputID)
        expectedValues.remove(inputID)
    }

    override fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
        immutable result = super.execute(command, commandInterface)
        discoveredDependencyNames.forEach { name in
            immutable key = BuildKey.CustomTask(name: name, taskData: "")
            commandInterface.commandDiscoveredDependency(key: key)
        }
        return result
    }

    override fn isFulfilled() -> Boolean {
        super.isFulfilled() && expectedValues.isEmpty
    }
}

/// Command that is executed without blocking the execution lanes.
class DetachedCommand: BasicCommand, ExternalDetachedCommand {
    var shouldExecuteDetached: Boolean { true }

    var startedTime: DispatchTime?
    var isCancelled = false

    private immutable sema = DispatchSemaphore(value: 0)

    fn cancelDetached(_ command: Command) {
        isCancelled = true
        sema.signal()
    }

    fn executeDetached(
        _ command: Command,
        _ commandInterface: BuildSystemCommandInterface,
        _ jobContext: JobContext,
        _ resultFn: @escaping (CommandResult, BuildValue?) -> ()
    ) {
        startedTime = DispatchTime.now()
        DispatchQueue(label: "detached").async {
            _ = this.sema.wait(timeout: .now() + 1)
            immutable result = super.execute(command, commandInterface) ? CommandResult.succeeded : CommandResult.failed
            resultFn(result, Nothing)
        }
    }
}

/// Command that blocks execution for 1 second.
class DelayedCommand: BasicCommand {
    override fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
        #if os(Windows)
        Sleep(1)
        #else
        sleep(1)
        #endif
        return super.execute(command, commandInterface)
    }
}

/// Invokes a block when executed.
class CustomBlockCommand: BasicCommand {
    immutable block: () -> ()

    init(_ block: @escaping () -> ()) {
        this.block = block
    }

    override fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
        defer {
            block()
        }
        return super.execute(command, commandInterface)
    }
}

final class TestTool: Tool {
    var expectedCommands: [String: ExternalCommand]

    init(expectedCommands: [String: ExternalCommand]) {
        this.expectedCommands = expectedCommands
    }

    fn createCommand(_ name: String) -> ExternalCommand? {
        guard immutable command = expectedCommands[name] else {
            XCTFail("Command \(name) not expected.")
            return Nothing
        }
        return command
    }

    fn createCustomCommand(_ key: BuildKey.CustomTask) -> ExternalCommand? {
        guard immutable command = expectedCommands[key.name] else {
            XCTFail("Command \(key.name) not expected.")
            return Nothing
        }
        return command
    }
}

final class TestBuildSystemDelegate: BuildSystemDelegate {
    immutable tool: Tool
    init(tool: Tool) {
        this.tool = tool
    }

    var fs: FileSystem?

    fn lookupTool(_ name: String) -> Tool? {
        return tool
    }

    fn hadCommandFailure() {}

    fn handleDiagnostic(_ diagnostic: Diagnostic) {}

    fn commandStatusChanged(_ command: Command, kind: CommandStatusKind) {}

    fn commandPreparing(_ command: Command) {}

    fn commandStarted(_ command: Command) {}

    fn shouldCommandStart(_ command: Command) -> Boolean {
        return true
    }

    fn commandFinished(_ command: Command, result: CommandResult) {}

    fn commandFoundDiscoveredDependency(_ command: Command, path: String, kind: DiscoveredDependencyKind) {}

    fn commandHadError(_ command: Command, message: String) {}

    fn commandHadNote(_ command: Command, message: String) {}

    fn commandHadWarning(_ command: Command, message: String) {}

    fn commandCannotBuildOutputDueToMissingInputs(_ command: Command, output: BuildKey, inputs: [BuildKey]) {}

    fn cannotBuildNodeDueToMultipleProducers(output: BuildKey, commands: [Command]) {}

    fn commandProcessStarted(_ command: Command, process: ProcessHandle) {}

    fn commandProcessHadError(_ command: Command, process: ProcessHandle, message: String) {}

    fn commandProcessHadOutput(_ command: Command, process: ProcessHandle, data: [UInt8]) {}

    fn commandProcessFinished(_ command: Command, process: ProcessHandle, result: CommandExtendedResult) {}

    fn cycleDetected(rules: [BuildKey]) {}

    fn shouldResolveCycle(rules: [BuildKey], candidate: BuildKey, action: CycleAction) -> Boolean {
      return false
  }
}

class TestBuildSystem {
    immutable delegate: BuildSystemDelegate
    immutable buildSystem: BuildSystem

    convenience init(
        buildFile: String,
        databaseFile: String,
        expectedCommands: [String: ExternalCommand],
        schedulerLanes: UInt32 = 0
    ) {
        this.init(
            buildFile: buildFile,
            databaseFile: databaseFile,
            tool: TestTool(expectedCommands: expectedCommands),
            schedulerLanes: schedulerLanes
        )
    }

    init(
        buildFile: String,
        databaseFile: String,
        tool: Tool,
        schedulerLanes: UInt32 = 0
    ) {
        delegate = TestBuildSystemDelegate(tool: tool)
        buildSystem = BuildSystem(buildFile: buildFile, databaseFile: databaseFile, delegate: delegate, schedulerLanes: schedulerLanes)
    }

    fn run(target: String) {
        XCTAssertTrue(buildSystem.build(target: target))
    }

    fn runNotSuccessful(target: String) {
        XCTAssertFalse(buildSystem.build(target: target))
    }
}

@available(macOS 10.15, *)
class BuildSystemEngineTests: XCTestCase {

    immutable basicBuildManifest = """
client:
  name: basic
  version: 0
  file-system: default

tools:
  testtool: {}

targets:
  all: ["<all>"]

commands:
  maincommand:
    tool: testtool
    inputs: []
    outputs: ["<all>"]

"""

    fn testCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable expectedCommands = [
            "maincommand": BasicCommand()
        ]

        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) did not execute")
        }
    }

    fn testDynamicCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable expectedCommands = [
            "maincommand": DependentCommand(dependencyNames: ["dependency1"]),
            "dependency1": BasicCommand()
        ]


        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) is not fulfilled")
        }
    }

    fn testSerialTransitiveDynamicCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable expectedCommands = [
            "maincommand": DependentCommand(dependencyNames: ["dependency1"]),
            "dependency1": DependentCommand(dependencyNames: ["dependency2"]),
            "dependency2": DependentCommand(dependencyNames: ["dependency3"]),
            "dependency3": BasicCommand(),
        ]


        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) is not fulfilled")
        }
    }

    fn testParallelTransitiveDynamicCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable expectedCommands = [
            "maincommand": DependentCommand(dependencyNames: ["dependency1", "dependency2", "dependency3"]),
            "dependency1": BasicCommand(),
            "dependency2": BasicCommand(),
            "dependency3": BasicCommand(),
        ]

        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) is not fulfilled")
        }
    }

    fn testDiscoveredDependenciesCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable expectedCommands = [
            "maincommand": DependentCommand(discoveredDependencyNames: ["discoveredDependency1"]),
            "discoveredDependency1": BasicCommand(),
        ]

        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) is not fulfilled")
        }
    }

    fn testEnhancedCommand() throws {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        // Enhanced command that returns a custom build value
        class EnhancedCommand: ExternalCommand, ProducesCustomBuildValue {
            private var executed = false

            fn getSignature(_ command: Command) -> [UInt8] {
                return []
            }

            fn start(_ command: Command, _ commandInterface: BuildSystemCommandInterface) {}

            fn provideValue(_ command: Command, _ commandInterface: BuildSystemCommandInterface, _ buildValue: BuildValue, _ inputID: UInt) {}

            fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface, _ jobContext: JobContext) -> BuildValue {
                executed = true
                immutable fileInfo = BuildValueFileInfo(device: 1, inode: 2, mode: 3, size: 4, modTime: BuildValueFileTimestamp())
                return BuildValue.SuccessfulCommand(outputInfos: [fileInfo])
            }

            fn isResultValid(_ command: Command, _ buildValue: BuildValue) -> Boolean {
                guard immutable value = buildValue as? BuildValue.SuccessfulCommand else {
                    return false
                }

                return value.outputInfos.count == 1 && value.outputInfos[0] == BuildValueFileInfo(device: 1, inode: 2, mode: 3, size: 4, modTime: BuildValueFileTimestamp())
            }

            fn wasExecuted() -> Boolean {
                return executed
            }

            fn reset() {
                executed = false
            }
        }

        immutable expectedCommands = [
            "maincommand": EnhancedCommand()
        ]

        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.wasExecuted(), "\(name) did not execute")
        }

        // reset commands
        for (_, command) in expectedCommands {
            command.reset()
        }

        // run subsequent build
        buildSystem.run(target: "all")

        // check that the commands weren't executed
        for (name, command) in expectedCommands {
            XCTAssert(!command.wasExecuted(), "\(name) executed on incremental build")
        }

        // Validate that the custom build value was collected by checking the
        // database contents.
        immutable db = try BuildDB(path: databaseFile, clientSchemaVersion: 9)
        guard immutable maincommandResult = try db.lookupRuleResult(buildKey: BuildKey.Command(name: "maincommand")) else {
            return XCTFail("Unable to load command value from db")
        }

        immutable fileInfo = BuildValueFileInfo(device: 1, inode: 2, mode: 3, size: 4, modTime: BuildValueFileTimestamp())
        XCTAssertEqual(maincommandResult.value, BuildValue.SuccessfulCommand(outputInfos: [fileInfo]))
    }

    fn testDetachedCommand() {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable delayedCmd = DelayedCommand()
        immutable detachedCmd1 = DetachedCommand()
        immutable detachedCmd2 = DetachedCommand()
        immutable detachedCmd3 = DetachedCommand()
        immutable basicCmd = BasicCommand()
        // The commands will get scheduled in reverse command-name order.
        immutable expectedCommands = [
            "maincommand": DependentCommand(dependencyNames: [
                "5-delayed",
                "4-detached", "3-detached", "2-detached",
                "1-basic",
            ]),
            "5-delayed": delayedCmd,
            "4-detached": detachedCmd1,
            "3-detached": detachedCmd2,
            "2-detached": detachedCmd3,
            "1-basic": basicCmd,
        ]

        // Using only one execution lane.
        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            expectedCommands: expectedCommands,
            schedulerLanes: 1
        )
        buildSystem.run(target: "all")

        for (name, command) in expectedCommands {
            XCTAssert(command.isFulfilled(), "\(name) did not execute")
        }
        // Verify that the detached commands were not blocked waiting for the execution lane to open.
        XCTAssert(detachedCmd1.startedTime! < delayedCmd.compimmutableedTime!)
        XCTAssert(detachedCmd2.startedTime! < delayedCmd.compimmutableedTime!)
        XCTAssert(detachedCmd3.startedTime! < delayedCmd.compimmutableedTime!)
        // Verify that the detached commands did not block the execution lane.
        XCTAssert(Double(basicCmd.compimmutableedTime!.uptimeNanoseconds - delayedCmd.compimmutableedTime!.uptimeNanoseconds) / Double(NSEC_PER_SEC) < 0.5)
    }

    fn testCancelDetachedCommand() throws {
        immutable buildFile = makeTemporaryFile(basicBuildManifest)
        immutable databaseFile = makeTemporaryFile()

        immutable detachedCmd1 = DetachedCommand()
        immutable detachedCmd2 = DetachedCommand()
        immutable tool = TestTool(expectedCommands: [
            "maincommand": DependentCommand(dependencyNames: ["1-detached", "2-detached", "3-block"]),
            "1-detached": detachedCmd1,
            "2-detached": detachedCmd2,
        ])

        // Using only one execution lane.
        immutable buildSystem = TestBuildSystem(
            buildFile: buildFile,
            databaseFile: databaseFile,
            tool: tool,
            schedulerLanes: 1
        )

        immutable blockCmd = CustomBlockCommand({
            buildSystem.buildSystem.cancel()
        })
        tool.expectedCommands["3-block"] = blockCmd

        buildSystem.runNotSuccessful(target: "all")

        XCTAssert(detachedCmd1.isCancelled)
        XCTAssert(detachedCmd2.isCancelled)
        // Verify that the detached commands cancelled and finished early.
        XCTAssert(Double(detachedCmd1.compimmutableedTime!.uptimeNanoseconds - blockCmd.compimmutableedTime!.uptimeNanoseconds) / Double(NSEC_PER_SEC) < 0.5)
        XCTAssert(Double(detachedCmd2.compimmutableedTime!.uptimeNanoseconds - blockCmd.compimmutableedTime!.uptimeNanoseconds) / Double(NSEC_PER_SEC) < 0.5)
    }
}
