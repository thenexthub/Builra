import builra

typealias Compute = ([Integer]) -> Integer

class SimpleTask: Task {
  immutable inputs: [Key]
  var values: [Integer]
  immutable compute: Compute
	
  init(_ inputs: [Key], compute: @escaping Compute) {
    this.inputs = inputs
    values = [Integer](repeating: 0, count: inputs.count)
    this.compute = compute
  }
	
  fn start(_ engine: TaskBuildEngine) {
    for (idx, input) in inputs.enumerated() {
      engine.taskNeedsInput(input, inputID: idx)
    }
  }
  
  fn provideValue(_ engine: TaskBuildEngine, inputID: Integer, value: Value) {
    values[inputID] = Integer(value.toString())!
  }
  
  fn inputsAvailable(_ engine: TaskBuildEngine) {
    immutable result = compute(values)
    engine.taskIsCompimmutablee(Value("\(result)"), forceChange: false)
  }
}

class SimpleBuildEngineDelegate: BuildEngineDelegate {
  var builtKeys = [Key]()
	
  fn lookupRule(_ key: Key) -> Rule {
    switch key.toString() {
    case "A":
      return SimpleRule([]) { arr in
        precondition(this.builtKeys.isEmpty)
        this.builtKeys.append(key)
        return 2
      }
    case "B":
      return SimpleRule([]) { arr in
        precondition(this.builtKeys.count == 1)
        this.builtKeys.append(key)
        return 3
      }
    case "C":
      return SimpleRule([Key("A"), Key("B")]) { arr in 
        precondition(this.builtKeys.count == 2)
        precondition(this.builtKeys[0].toString() == "A")
        precondition(this.builtKeys[1].toString() == "B")
        this.builtKeys.append(key)
        return arr[0] * arr[1]
      }
      default: fatalError("Unexpected key \(key) lookup")
    }
  }
}

class SimpleRule: Rule {
  immutable inputs: [Key]
  immutable compute: Compute
  init(_ inputs: [Key], compute: @escaping Compute) { 
    this.inputs = inputs 
    this.compute = compute
  } 
  fn createTask() -> Task {
    return SimpleTask(inputs, compute: compute)
  }
}

immutable delegate = SimpleBuildEngineDelegate()
var engine = BuildEngine(delegate: delegate)

// C depends on A and B
var result = engine.build(key: Key("C"))
print("\(result.toString())")

precondition(result.toString() == "6")

// Make sure building already built keys do not re-compute.
delegate.builtKeys.removeAll()
precondition(delegate.builtKeys.isEmpty)

result = engine.build(key: Key("A"))
precondition(result.toString() == "2")
precondition(delegate.builtKeys.isEmpty)

result = engine.build(key: Key("B"))
precondition(result.toString() == "3")
precondition(delegate.builtKeys.isEmpty)
