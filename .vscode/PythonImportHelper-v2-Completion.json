[
    {
        "label": "cffi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cffi",
        "description": "cffi",
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "datetime,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime.",
        "description": "datetime.",
        "detail": "datetime.",
        "documentation": {}
    },
    {
        "label": "recommonmark",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "recommonmark",
        "description": "recommonmark",
        "detail": "recommonmark",
        "documentation": {}
    },
    {
        "label": "CommonMarkParser",
        "importPath": "recommonmark.parser",
        "description": "recommonmark.parser",
        "isExtraImport": true,
        "detail": "recommonmark.parser",
        "documentation": {}
    },
    {
        "label": "AutoStructify",
        "importPath": "recommonmark.transform",
        "description": "recommonmark.transform",
        "isExtraImport": true,
        "detail": "recommonmark.transform",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "builra",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builra",
        "description": "builra",
        "detail": "builra",
        "documentation": {}
    },
    {
        "label": "flask",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flask",
        "description": "flask",
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "g",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "database",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "database",
        "description": "database",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "trace",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "trace",
        "description": "trace",
        "detail": "trace",
        "documentation": {}
    },
    {
        "label": "views",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "views",
        "description": "views",
        "detail": "views",
        "documentation": {}
    },
    {
        "label": "sqlalchemy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "sqlalchemy.orm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relation",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "orderedset",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "orderedset",
        "description": "orderedset",
        "detail": "orderedset",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "sqlalchemy.ext.declarative",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "sqlalchemy.sql",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy.sql",
        "description": "sqlalchemy.sql",
        "detail": "sqlalchemy.sql",
        "documentation": {}
    },
    {
        "label": "sqlalchemy.sql.expression",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy.sql.expression",
        "description": "sqlalchemy.sql.expression",
        "detail": "sqlalchemy.sql.expression",
        "documentation": {}
    },
    {
        "label": "graphalgorithms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graphalgorithms",
        "description": "graphalgorithms",
        "detail": "graphalgorithms",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "model",
        "description": "model",
        "detail": "model",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "builraui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builraui",
        "description": "builraui",
        "detail": "builraui",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "COPT_VARS",
        "importPath": "copts",
        "description": "copts",
        "isExtraImport": true,
        "detail": "copts",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "ConanFile",
        "importPath": "conans",
        "description": "conans",
        "isExtraImport": true,
        "detail": "conans",
        "documentation": {}
    },
    {
        "label": "CMake",
        "importPath": "conans",
        "description": "conans",
        "isExtraImport": true,
        "detail": "conans",
        "documentation": {}
    },
    {
        "label": "tools",
        "importPath": "conans",
        "description": "conans",
        "isExtraImport": true,
        "detail": "conans",
        "documentation": {}
    },
    {
        "label": "ConanInvalidConfiguration",
        "importPath": "conans.errors",
        "description": "conans.errors",
        "isExtraImport": true,
        "detail": "conans.errors",
        "documentation": {}
    },
    {
        "label": "Version",
        "importPath": "conans.model.version",
        "description": "conans.model.version",
        "isExtraImport": true,
        "detail": "conans.model.version",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "listdir",
        "importPath": "dircache",
        "description": "dircache",
        "isExtraImport": true,
        "detail": "dircache",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "cgi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cgi",
        "description": "cgi",
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "closing",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "tarball",
        "importPath": "devtools",
        "description": "devtools",
        "isExtraImport": true,
        "detail": "devtools",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "objc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "objc",
        "description": "objc",
        "detail": "objc",
        "documentation": {}
    },
    {
        "label": "lit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit",
        "description": "lit",
        "detail": "lit",
        "documentation": {}
    },
    {
        "label": "AbstractError",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class AbstractError(Exception):\n    pass\n###\nffi = cffi.FFI()\n# Load the defs by reading the builra header directly.\ndata = open(os.path.join(\n    os.path.dirname(__file__),\n    \"../../products/libbuilra/include/builra/builra.h\")).read()\n# Strip out the directives.\ndata = re.sub(\"^#.*\", \"\", data, 0, re.MULTILINE)",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "_Data",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class _Data(object):\n    \"\"\"Wrapper for a key and its data.\"\"\"\n    def __init__(self, name):\n        name = str(name)\n        self.key = ffi.new(\"llb_data_t*\")\n        self.key.length = length = len(name)\n        # Store in a local to keep alive.\n        self._datap = ffi.new(\"char[]\", length)\n        self.key.data = self._datap\n        # Copy in the data.",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "_HandledObject",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class _HandledObject(object):\n    _all_handles = []\n    _handle_cache = None\n    @property\n    def _handle(self):\n        # FIXME: This creates a cycle.\n        if self._handle_cache is None:\n            self._handle_cache = handle = ffi.new_handle(self)\n            # FIXME: This leaks everything, but we are currently dropping a\n            # handle somewhere.",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class Task(_HandledObject):\n    _task = None\n    def start(self, engine):\n        pass\n    def provide_value(self, engine, input_id, value):\n        # We consider it a runtime error for a task to receive a value if it\n        # didn't override this callback.\n        raise RuntimeError()\n    def inputs_available(self, engine):\n        raise AbstractError()",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "Rule",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class Rule(_HandledObject):\n    def create_task(self):\n        raise AbstractError()\n    def is_result_valid(self, engine, result):\n        return True\n    def update_status(self, engine, kind):\n        pass\nclass BuildEngineDelegate(object):\n    pass\nclass BuildEngine(_HandledObject):",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "BuildEngineDelegate",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class BuildEngineDelegate(object):\n    pass\nclass BuildEngine(_HandledObject):\n    def __init__(self, delegate):\n        # Store our delegate.\n        self.delegate = delegate\n        # Create the engine delegate.\n        self._llb_delegate = ffi.new(\"llb_buildengine_delegate_t*\")\n        self._llb_delegate.context = self._handle\n        self._llb_delegate.lookup_rule = _buildengine_lookup_rule",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "BuildEngine",
        "kind": 6,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "class BuildEngine(_HandledObject):\n    def __init__(self, delegate):\n        # Store our delegate.\n        self.delegate = delegate\n        # Create the engine delegate.\n        self._llb_delegate = ffi.new(\"llb_buildengine_delegate_t*\")\n        self._llb_delegate.context = self._handle\n        self._llb_delegate.lookup_rule = _buildengine_lookup_rule\n        # Create the underlying engine.\n        self._engine = libbuilra.llb_buildengine_create(self._llb_delegate[0])",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "get_full_version",
        "kind": 2,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "def get_full_version():\n    return ffi.string(libbuilra.llb_get_full_version_string())\nclass Task(_HandledObject):\n    _task = None\n    def start(self, engine):\n        pass\n    def provide_value(self, engine, input_id, value):\n        # We consider it a runtime error for a task to receive a value if it\n        # didn't override this callback.\n        raise RuntimeError()",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "ffi",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "ffi = cffi.FFI()\n# Load the defs by reading the builra header directly.\ndata = open(os.path.join(\n    os.path.dirname(__file__),\n    \"../../products/libbuilra/include/builra/builra.h\")).read()\n# Strip out the directives.\ndata = re.sub(\"^#.*\", \"\", data, 0, re.MULTILINE)\ndata = re.sub(\"BUILRA_EXPORT\", \"\", data, 0, re.MULTILINE)\nffi.cdef(data)\n# Load the dylib.",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "data = open(os.path.join(\n    os.path.dirname(__file__),\n    \"../../products/libbuilra/include/builra/builra.h\")).read()\n# Strip out the directives.\ndata = re.sub(\"^#.*\", \"\", data, 0, re.MULTILINE)\ndata = re.sub(\"BUILRA_EXPORT\", \"\", data, 0, re.MULTILINE)\nffi.cdef(data)\n# Load the dylib.\n#\n# FIXME: Need a way to find this.",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "data = re.sub(\"^#.*\", \"\", data, 0, re.MULTILINE)\ndata = re.sub(\"BUILRA_EXPORT\", \"\", data, 0, re.MULTILINE)\nffi.cdef(data)\n# Load the dylib.\n#\n# FIXME: Need a way to find this.\nlibbuilra = ffi.dlopen(os.path.join(\n    os.path.dirname(__file__),\n    \"../../build/lib/libbuilra.dylib\"))\n@ffi.callback(\"void(void*, void*, llb_task_t*)\")",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "data = re.sub(\"BUILRA_EXPORT\", \"\", data, 0, re.MULTILINE)\nffi.cdef(data)\n# Load the dylib.\n#\n# FIXME: Need a way to find this.\nlibbuilra = ffi.dlopen(os.path.join(\n    os.path.dirname(__file__),\n    \"../../build/lib/libbuilra.dylib\"))\n@ffi.callback(\"void(void*, void*, llb_task_t*)\")\ndef _task_start(context, engine_context, _task):",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "libbuilra",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "libbuilra = ffi.dlopen(os.path.join(\n    os.path.dirname(__file__),\n    \"../../build/lib/libbuilra.dylib\"))\n@ffi.callback(\"void(void*, void*, llb_task_t*)\")\ndef _task_start(context, engine_context, _task):\n    task = ffi.from_handle(context)\n    engine = ffi.from_handle(engine_context)\n    task.start(engine)\n@ffi.callback(\n    \"void(void*, void*, llb_task_t*, uintptr_t, llb_data_t*)\")",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Core.bindings.python.builra",
        "description": "Core.bindings.python.builra",
        "peekOfCode": "__all__ = ['get_full_version', 'BuildEngine', 'Rule', 'Task']",
        "detail": "Core.bindings.python.builra",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "def setup(app):\n    app.add_config_value('recommonmark_config',\n                         {\n                             'url_resolver': lambda url: github_doc_root + url,\n                             'enable_auto_doc_ref': True,\n                         }, True)\n    app.add_transform(AutoStructify)",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "project = \"builra\"\nproject_author = \"Apple, Inc.\"\nproject_version = \"0.1\"\n# -- General configuration -----------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage']\n# Add any paths that contain templates here, relative to this directory.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "project_author",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "project_author = \"Apple, Inc.\"\nproject_version = \"0.1\"\n# -- General configuration -----------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "project_version",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "project_version = \"0.1\"\n# -- General configuration -----------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#needs_sphinx",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_parsers = {\n    '.md': CommonMarkParser,\n}",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_parsers = {\n    '.md': CommonMarkParser,\n}\nsource_suffix = ['.rst', '.md']\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix of source filenames.\nsource_parsers = {\n    '.md': CommonMarkParser,\n}\nsource_suffix = ['.rst', '.md']\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'contents'",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_parsers",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "source_parsers = {\n    '.md': CommonMarkParser,\n}\nsource_suffix = ['.rst', '.md']\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'contents'\n# General information about the project.\ncopyright = u'%s, %s' % (datetime.datetime.now().year, project_author)",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "source_suffix = ['.rst', '.md']\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'contents'\n# General information about the project.\ncopyright = u'%s, %s' % (datetime.datetime.now().year, project_author)\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#source_encoding",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'contents'\n# General information about the project.\ncopyright = u'%s, %s' % (datetime.datetime.now().year, project_author)\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "master_doc = 'contents'\n# General information about the project.\ncopyright = u'%s, %s' % (datetime.datetime.now().year, project_author)\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = project_version\n# The full version, including alpha/beta/rc tags.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "copyright = u'%s, %s' % (datetime.datetime.now().year, project_author)\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = project_version\n# The full version, including alpha/beta/rc tags.\nrelease = project_version\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "version = project_version\n# The full version, including alpha/beta/rc tags.\nrelease = project_version\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "release = project_version\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#language",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['README.md', '_build']\n# The reST default role (used for this markup: `text`) to use for all documents.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#today",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['README.md', '_build']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "today_fmt",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "today_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['README.md', '_build']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "exclude_patterns = ['README.md', '_build']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#default_role",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_function_parentheses",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_module_names",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  Major themes that come with",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "show_authors",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "show_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  Major themes that come with\n# Sphinx are currently 'default' and 'sphinxdoc'.\nhtml_theme = 'nature'\n#html_theme = 'haiku'",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  Major themes that come with\n# Sphinx are currently 'default' and 'sphinxdoc'.\nhtml_theme = 'nature'\n#html_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#modindex_common_prefix",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  Major themes that come with\n# Sphinx are currently 'default' and 'sphinxdoc'.\nhtml_theme = 'nature'\n#html_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "html_theme = 'nature'\n#html_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_options",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_path",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_title",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_short_title",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_logo",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n#html_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_favicon",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n#html_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\nhtml_last_updated_fmt = '%Y-%m-%d'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_static_path",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\nhtml_last_updated_fmt = '%Y-%m-%d'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_last_updated_fmt",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "html_last_updated_fmt = '%Y-%m-%d'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\nhtml_additional_pages = {'index': 'index.html'}\n# If false, no module index is generated.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_smartypants",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\nhtml_additional_pages = {'index': 'index.html'}\n# If false, no module index is generated.\n#html_use_modindex = True\n# If false, no index is generated.\n#html_use_index = True",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_sidebars",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\nhtml_additional_pages = {'index': 'index.html'}\n# If false, no module index is generated.\n#html_use_modindex = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_additional_pages",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "html_additional_pages = {'index': 'index.html'}\n# If false, no module index is generated.\n#html_use_modindex = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_modindex",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_use_modindex = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_index",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_split_index",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_split_index = False\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_show_sourcelink",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sphinx",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = ''\n# Output file base name for HTML help builder.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_copyright",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = ''\n# Output file base name for HTML help builder.\nhtmlhelp_basename = '%sdoc' % project\n# -- Options for LaTeX output --------------------------------------------------",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_opensearch",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_use_opensearch = ''\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = ''\n# Output file base name for HTML help builder.\nhtmlhelp_basename = '%sdoc' % project\n# -- Options for LaTeX output --------------------------------------------------\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_file_suffix",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#html_file_suffix = ''\n# Output file base name for HTML help builder.\nhtmlhelp_basename = '%sdoc' % project\n# -- Options for LaTeX output --------------------------------------------------\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "htmlhelp_basename = '%sdoc' % project\n# -- Options for LaTeX output --------------------------------------------------\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('contents', '%s.tex' % project, u'%s Documentation' % project,",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_paper_size",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_paper_size = 'letter'\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('contents', '%s.tex' % project, u'%s Documentation' % project,\n   project_author, 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_font_size",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_font_size = '10pt'\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('contents', '%s.tex' % project, u'%s Documentation' % project,\n   project_author, 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "latex_documents = [\n  ('contents', '%s.tex' % project, u'%s Documentation' % project,\n   project_author, 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_logo",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = ''\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_use_modindex = True",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_parts",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_use_parts = False\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = ''\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_use_modindex = True\n# -- Options for Epub output ---------------------------------------------------\n# Bibliographic Dublin Core info.\n#epub_title = ''",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_preamble",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_preamble = ''\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_use_modindex = True\n# -- Options for Epub output ---------------------------------------------------\n# Bibliographic Dublin Core info.\n#epub_title = ''\n#epub_author = ''\n#epub_publisher = ''",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_appendices",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_appendices = []\n# If false, no module index is generated.\n#latex_use_modindex = True\n# -- Options for Epub output ---------------------------------------------------\n# Bibliographic Dublin Core info.\n#epub_title = ''\n#epub_author = ''\n#epub_publisher = ''\n#epub_copyright = ''\n# The language of the text. It defaults to the language option",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_modindex",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#latex_use_modindex = True\n# -- Options for Epub output ---------------------------------------------------\n# Bibliographic Dublin Core info.\n#epub_title = ''\n#epub_author = ''\n#epub_publisher = ''\n#epub_copyright = ''\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_title",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_title = ''\n#epub_author = ''\n#epub_publisher = ''\n#epub_copyright = ''\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_author",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_author = ''\n#epub_publisher = ''\n#epub_copyright = ''\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_publisher",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_publisher = ''\n#epub_copyright = ''\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_copyright",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_copyright = ''\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n# A unique identification for the text.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_language",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_language = ''\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n# A unique identification for the text.\n#epub_uid = ''\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_scheme",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_scheme = ''\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n# A unique identification for the text.\n#epub_uid = ''\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n# HTML files shat should be inserted after the pages created by sphinx.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_identifier",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_identifier = ''\n# A unique identification for the text.\n#epub_uid = ''\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n# A list of files that should not be packed into the epub file.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_uid",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_uid = ''\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n# The depth of the table of contents in toc.ncx.",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_pre_files",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_pre_files = []\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n# -- Options for AutoStructify output ------------------------------------------\n# At the bottom of conf.py",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_post_files",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_post_files = []\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n# -- Options for AutoStructify output ------------------------------------------\n# At the bottom of conf.py\ngithub_doc_root = 'https://github.com/apple/swift-builra/tree/master/docs/'\ndef setup(app):\n    app.add_config_value('recommonmark_config',",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_exclude_files",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_exclude_files = []\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n# -- Options for AutoStructify output ------------------------------------------\n# At the bottom of conf.py\ngithub_doc_root = 'https://github.com/apple/swift-builra/tree/master/docs/'\ndef setup(app):\n    app.add_config_value('recommonmark_config',\n                         {\n                             'url_resolver': lambda url: github_doc_root + url,",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "#epub_tocdepth",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "#epub_tocdepth = 3\n# -- Options for AutoStructify output ------------------------------------------\n# At the bottom of conf.py\ngithub_doc_root = 'https://github.com/apple/swift-builra/tree/master/docs/'\ndef setup(app):\n    app.add_config_value('recommonmark_config',\n                         {\n                             'url_resolver': lambda url: github_doc_root + url,\n                             'enable_auto_doc_ref': True,\n                         }, True)",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "github_doc_root",
        "kind": 5,
        "importPath": "Core.docs.conf",
        "description": "Core.docs.conf",
        "peekOfCode": "github_doc_root = 'https://github.com/apple/swift-builra/tree/master/docs/'\ndef setup(app):\n    app.add_config_value('recommonmark_config',\n                         {\n                             'url_resolver': lambda url: github_doc_root + url,\n                             'enable_auto_doc_ref': True,\n                         }, True)\n    app.add_transform(AutoStructify)",
        "detail": "Core.docs.conf",
        "documentation": {}
    },
    {
        "label": "SimpleRule",
        "kind": 6,
        "importPath": "Core.examples.simple-make.simplebuild",
        "description": "Core.examples.simple-make.simplebuild",
        "peekOfCode": "class SimpleRule(builra.Rule, builra.Task):\n    \"\"\"\n    asKey(*args) -> str\n    Return the key for computing the rule in the future.\n    \"\"\"\n    @classmethod\n    def asKey(klass, *args):\n        kind = klass.__name__\n        assert kind.endswith(\"Rule\")\n        kind = kind[:-4]",
        "detail": "Core.examples.simple-make.simplebuild",
        "documentation": {}
    },
    {
        "label": "SimpleAsyncRule",
        "kind": 6,
        "importPath": "Core.examples.simple-make.simplebuild",
        "description": "Core.examples.simple-make.simplebuild",
        "peekOfCode": "class SimpleAsyncRule(SimpleRule):\n    _async = True\n    def run(self):\n        abstract\n    def inputs_available(self, engine):\n        if self._async:\n            # Spawn a thread to do the actual work.\n            t = threading.Thread(target=self._execute, args=(engine,))\n            t.start()\n        else:",
        "detail": "Core.examples.simple-make.simplebuild",
        "documentation": {}
    },
    {
        "label": "DataDrivenEngine",
        "kind": 6,
        "importPath": "Core.examples.simple-make.simplebuild",
        "description": "Core.examples.simple-make.simplebuild",
        "peekOfCode": "class DataDrivenEngine(builra.BuildEngine):\n    def __init__(self, namespace):\n        super(DataDrivenEngine, self).__init__(self)\n        self.namespace = namespace\n    def lookup_rule(self, name):\n        # Rules are encoded as a JSON dictionary.\n        data = json.loads(name)\n        rule_name = data[\"kind\"] + \"Rule\"\n        rule_class = self.namespace.get(rule_name)\n        if rule_class is None:",
        "detail": "Core.examples.simple-make.simplebuild",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 2,
        "importPath": "Core.examples.simple-make.util",
        "description": "Core.examples.simple-make.util",
        "peekOfCode": "def message(msg):\n    with _outputLock:\n        print >>sys.stdout, msg\ndef note(msg):\n    with _outputLock:\n        print >>sys.stderr, \"note: %s\" % msg\ndef error(msg):\n    with _outputLock:\n        print >>sys.stderr, \"error: %s\" % msg\ndef get_stat_info(path):",
        "detail": "Core.examples.simple-make.util",
        "documentation": {}
    },
    {
        "label": "note",
        "kind": 2,
        "importPath": "Core.examples.simple-make.util",
        "description": "Core.examples.simple-make.util",
        "peekOfCode": "def note(msg):\n    with _outputLock:\n        print >>sys.stderr, \"note: %s\" % msg\ndef error(msg):\n    with _outputLock:\n        print >>sys.stderr, \"error: %s\" % msg\ndef get_stat_info(path):\n    try:\n        s = os.stat(path)\n    except OSError:",
        "detail": "Core.examples.simple-make.util",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 2,
        "importPath": "Core.examples.simple-make.util",
        "description": "Core.examples.simple-make.util",
        "peekOfCode": "def error(msg):\n    with _outputLock:\n        print >>sys.stderr, \"error: %s\" % msg\ndef get_stat_info(path):\n    try:\n        s = os.stat(path)\n    except OSError:\n        return { 'path' : path,\n                 'st_mode' : 0,\n                 'error' : True }",
        "detail": "Core.examples.simple-make.util",
        "documentation": {}
    },
    {
        "label": "get_stat_info",
        "kind": 2,
        "importPath": "Core.examples.simple-make.util",
        "description": "Core.examples.simple-make.util",
        "peekOfCode": "def get_stat_info(path):\n    try:\n        s = os.stat(path)\n    except OSError:\n        return { 'path' : path,\n                 'st_mode' : 0,\n                 'error' : True }\n    return { 'path' : path,\n             'st_mode' : s.st_mode,\n             'st_ino' : s.st_ino,",
        "detail": "Core.examples.simple-make.util",
        "documentation": {}
    },
    {
        "label": "_outputLock",
        "kind": 5,
        "importPath": "Core.examples.simple-make.util",
        "description": "Core.examples.simple-make.util",
        "peekOfCode": "_outputLock = threading.Lock()\ndef message(msg):\n    with _outputLock:\n        print >>sys.stdout, msg\ndef note(msg):\n    with _outputLock:\n        print >>sys.stderr, \"note: %s\" % msg\ndef error(msg):\n    with _outputLock:\n        print >>sys.stderr, \"error: %s\" % msg",
        "detail": "Core.examples.simple-make.util",
        "documentation": {}
    },
    {
        "label": "BuilraApp",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.app",
        "description": "Core.products.ui.builraui.app",
        "peekOfCode": "class BuilraApp(flask.Flask):\n    def __init__(self, name):\n        super(BuilraApp, self).__init__(name)\n        # Register the local proxy.\n        # Register the teardown functions.\n        @self.teardown_appcontext\n        def _teardown(exception):\n            db = flask.g.get('_database_session', None)\n            if db is not None:\n                db.close()",
        "detail": "Core.products.ui.builraui.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Core.products.ui.builraui.app",
        "description": "Core.products.ui.builraui.app",
        "peekOfCode": "app = BuilraApp(__name__)\n# Set the secret key.\n#\n# We never expect this app to persist, so we just assign a new one each time.\napp.secret_key = \"DEBUG\" if app.debug else os.urandom(24)",
        "detail": "Core.products.ui.builraui.app",
        "documentation": {}
    },
    {
        "label": "app.secret_key",
        "kind": 5,
        "importPath": "Core.products.ui.builraui.app",
        "description": "Core.products.ui.builraui.app",
        "peekOfCode": "app.secret_key = \"DEBUG\" if app.debug else os.urandom(24)",
        "detail": "Core.products.ui.builraui.app",
        "documentation": {}
    },
    {
        "label": "Database",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.database",
        "description": "Core.products.ui.builraui.database",
        "peekOfCode": "class Database(object):\n    \"\"\"\n    The base engine encapsulating access to a particular database.\n    \"\"\"\n    # Get a cached database instance.\n    @classmethod\n    def get_database(cls, path):\n        db = cls._databases.get(path)\n        if db is None:\n            cls._databases[path] = db = Database(path)",
        "detail": "Core.products.ui.builraui.database",
        "documentation": {}
    },
    {
        "label": "find_cycle",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.graphalgorithms",
        "description": "Core.products.ui.builraui.graphalgorithms",
        "peekOfCode": "def find_cycle(nodes, successors):\n    path = orderedset.orderedset()\n    visited = set()\n    def visit(node):\n        # If the node is already in the current path, we have found a cycle.\n        if not path.add(node):\n            return (path, node)\n        # If we have otherwise already visited this node, we don't need to visit\n        # it again.\n        if node in visited:",
        "detail": "Core.products.ui.builraui.graphalgorithms",
        "documentation": {}
    },
    {
        "label": "KeyName",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.model",
        "description": "Core.products.ui.builraui.model",
        "peekOfCode": "class KeyName(Base):\n    __tablename__ = \"key_names\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    name = Column('key', String, nullable=False)\n    def __repr__(self):\n        return \"%s%r\" % (\n            self.__class__.__name__, (self.id, self.name))\nclass RuleResult(Base):\n    __tablename__ = \"rule_results\"\n    id = Column(Integer, nullable=False, primary_key=True)",
        "detail": "Core.products.ui.builraui.model",
        "documentation": {}
    },
    {
        "label": "RuleResult",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.model",
        "description": "Core.products.ui.builraui.model",
        "peekOfCode": "class RuleResult(Base):\n    __tablename__ = \"rule_results\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    key_id = Column(Integer, ForeignKey(KeyName.id),\n                     nullable=False)\n    value_bytes = Column(\"value\", Binary, nullable=False)\n    built_at = Column(Integer, nullable=False)\n    computed_at = Column(Integer, nullable=False)\n    key = relation(KeyName)\n    dependencies_bytes = Column(\"dependencies\", Binary, nullable=True)",
        "detail": "Core.products.ui.builraui.model",
        "documentation": {}
    },
    {
        "label": "BuildValue",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.model",
        "description": "Core.products.ui.builraui.model",
        "peekOfCode": "class BuildValue(object):\n    # FIXME: This is a manually Python translation of the C++\n    # builra::buildsystem::BuildValue type, which is unfortunate, but it isn't\n    # available via an API we can access directly yet.\n    kinds = [\n        \"Invalid\",\n        \"VirtualInput\", \"ExistingInput\", \"MissingInput\",\n        \"DirectoryContents\", \"DirectoryTreeSignature\",\n        \"StaleFileRemoval\", \"MissingOutput\", \"FailedInput\",\n        \"SuccessfulCommand\", \"FailedCommand\",",
        "detail": "Core.products.ui.builraui.model",
        "documentation": {}
    },
    {
        "label": "FileInfo",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.model",
        "description": "Core.products.ui.builraui.model",
        "peekOfCode": "class FileInfo(object):\n    def __init__(self, bytes):\n        (self.device, self.inode, self.mode, self.size,\n         modTimeSec, modTimeNano) = struct.unpack(\"<QQQQQQ\", bytes)\n        self.modTime =  (modTimeSec, modTimeNano)\n    def __repr__(self):\n        return \"FileInfo(device=%r, inode=%#0x, mode=%r, size=%r, mtime=(%r, %r))\" % (\n            self.device, self.inode, self.mode, self.size,\n            self.modTime[0], self.modTime[1])",
        "detail": "Core.products.ui.builraui.model",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "Core.products.ui.builraui.model",
        "description": "Core.products.ui.builraui.model",
        "peekOfCode": "Base = declarative_base()\nclass KeyName(Base):\n    __tablename__ = \"key_names\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    name = Column('key', String, nullable=False)\n    def __repr__(self):\n        return \"%s%r\" % (\n            self.__class__.__name__, (self.id, self.name))\nclass RuleResult(Base):\n    __tablename__ = \"rule_results\"",
        "detail": "Core.products.ui.builraui.model",
        "documentation": {}
    },
    {
        "label": "orderedset",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.orderedset",
        "description": "Core.products.ui.builraui.orderedset",
        "peekOfCode": "class orderedset(object):\n    def __init__(self):\n        self.items = []\n        self.set = set()\n    def add(self, item):\n        if item in self.set:\n            return False\n        self.items.append(item)\n        self.set.add(item)\n        return True",
        "detail": "Core.products.ui.builraui.orderedset",
        "documentation": {}
    },
    {
        "label": "Trace",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class Trace(object):\n    \"\"\"\n    An builra build system trace\n    \"\"\"\n    # Get a cached trace.\n    @classmethod\n    def frompath(cls, path):\n        db = cls._traces.get(path)\n        if db is None:\n            cls._traces[path] = db = Trace(path)",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "Rule",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class Rule(object):\n    def __init__(self, data):\n        (name, key) = data\n        self.name = name\n        self.key = key\nclass Task(object):\n    def __init__(self, data):\n        (name,) = data\n        self.name = name\n        self.rule = None",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class Task(object):\n    def __init__(self, data):\n        (name,) = data\n        self.name = name\n        self.rule = None\n###\nclass Event(object):\n    @property\n    def isReadiedTask(self):\n        return isinstance(self, ReadiedTask)",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class Event(object):\n    @property\n    def isReadiedTask(self):\n        return isinstance(self, ReadiedTask)\nclass BuildStarted(Event):\n    def __init__(self, trace, data):\n        pass\nclass BuildEnded(Event):\n    def __init__(self, trace, data):\n        pass",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "BuildStarted",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class BuildStarted(Event):\n    def __init__(self, trace, data):\n        pass\nclass BuildEnded(Event):\n    def __init__(self, trace, data):\n        pass\nclass HandlingBuildInputRequest(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "BuildEnded",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class BuildEnded(Event):\n    def __init__(self, trace, data):\n        pass\nclass HandlingBuildInputRequest(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass CheckingRuleNeedsToRun(Event):\n    def __init__(self, trace, data):\n        (rule,) = data",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "HandlingBuildInputRequest",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class HandlingBuildInputRequest(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass CheckingRuleNeedsToRun(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass RuleNeedsToRun(Event):\n    class NeverBuilt(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "CheckingRuleNeedsToRun",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class CheckingRuleNeedsToRun(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass RuleNeedsToRun(Event):\n    class NeverBuilt(Event):\n        pass\n    class InvalidValue(Event):\n        pass\n    class InputRebuilt(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleNeedsToRun",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleNeedsToRun(Event):\n    class NeverBuilt(Event):\n        pass\n    class InvalidValue(Event):\n        pass\n    class InputRebuilt(Event):\n        def __init__(self, inputRule):\n            self.inputRule = inputRule\n    def __init__(self, trace, data):\n        self.rule = trace.rules[data[0]]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleDoesNotNeedToRun",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleDoesNotNeedToRun(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass CreatedTaskForRule(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\n        self.task.rule = self.rule",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "CreatedTaskForRule",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class CreatedTaskForRule(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\n        self.task.rule = self.rule\nclass HandlingTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "HandlingTaskInputRequest",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class HandlingTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\nclass AddedRulePendingTask(Event):\n    def __init__(self, trace, data):\n        (rule, task) = data\n        self.rule = trace.rules[rule]\n        self.task = trace.tasks[task]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "AddedRulePendingTask",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class AddedRulePendingTask(Event):\n    def __init__(self, trace, data):\n        (rule, task) = data\n        self.rule = trace.rules[rule]\n        self.task = trace.tasks[task]\nclass RuleScheduledForScanning(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass PausedInputRequestForRuleScan(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleScheduledForScanning",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleScheduledForScanning(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass PausedInputRequestForRuleScan(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass ReadyingTaskInputRequest(Event):\n    def __init__(self, trace, data):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "PausedInputRequestForRuleScan",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class PausedInputRequestForRuleScan(Event):\n    def __init__(self, trace, data):\n        (rule,) = data\n        self.rule = trace.rules[rule]\nclass ReadyingTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\nclass CompletedTaskInputRequest(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "ReadyingTaskInputRequest",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class ReadyingTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\nclass CompletedTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "CompletedTaskInputRequest",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class CompletedTaskInputRequest(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        self.rule = trace.rules[rule]\nclass UpdatedTaskWaitCount(Event):\n    def __init__(self, trace, data):\n        (task, count) = data\n        self.task = trace.tasks[task]\n        self.count = count",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "UpdatedTaskWaitCount",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class UpdatedTaskWaitCount(Event):\n    def __init__(self, trace, data):\n        (task, count) = data\n        self.task = trace.tasks[task]\n        self.count = count\nclass RuleScanningDeferredOnInput(Event):\n    def __init__(self, trace, data):\n        (rule, inputRule) = data\n        self.rule = trace.rules[rule]\n        self.inputRule = trace.rules[inputRule]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleScanningDeferredOnInput",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleScanningDeferredOnInput(Event):\n    def __init__(self, trace, data):\n        (rule, inputRule) = data\n        self.rule = trace.rules[rule]\n        self.inputRule = trace.rules[inputRule]\nclass RuleScanningDeferredOnTask(Event):\n    def __init__(self, trace, data):\n        (rule, inputTask) = data\n        self.rule = trace.rules[rule]\n        self.inputTask = trace.tasks[inputTask]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleScanningDeferredOnTask",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleScanningDeferredOnTask(Event):\n    def __init__(self, trace, data):\n        (rule, inputTask) = data\n        self.rule = trace.rules[rule]\n        self.inputTask = trace.tasks[inputTask]\nclass RuleScanningNextInput(Event):\n    def __init__(self, trace, data):\n        (rule, inputRule) = data\n        self.rule = trace.rules[rule]\n        self.inputRule = trace.rules[inputRule]",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "RuleScanningNextInput",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class RuleScanningNextInput(Event):\n    def __init__(self, trace, data):\n        (rule, inputRule) = data\n        self.rule = trace.rules[rule]\n        self.inputRule = trace.rules[inputRule]\nclass UnblockedTask(Event):\n    def __init__(self, trace, data):\n        (task,) = data\n        self.task = trace.tasks[task]\nclass ReadiedTask(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "UnblockedTask",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class UnblockedTask(Event):\n    def __init__(self, trace, data):\n        (task,) = data\n        self.task = trace.tasks[task]\nclass ReadiedTask(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        assert(self.task.rule is trace.rules[rule])\nclass FinishedTask(Event):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "ReadiedTask",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class ReadiedTask(Event):\n    def __init__(self, trace, data):\n        (task, rule) = data\n        self.task = trace.tasks[task]\n        assert(self.task.rule is trace.rules[rule])\nclass FinishedTask(Event):\n    def __init__(self, trace, data):\n        (task, rule, effect) = data\n        self.task = trace.tasks[task]\n        assert(self.task.rule is trace.rules[rule])",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "FinishedTask",
        "kind": 6,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "class FinishedTask(Event):\n    def __init__(self, trace, data):\n        (task, rule, effect) = data\n        self.task = trace.tasks[task]\n        assert(self.task.rule is trace.rules[rule])\n        self.effect = effect\ndef _create_rule(trace, data):\n    rule = Rule(data)\n    trace.rules[rule.name] = rule\ndef _create_task(trace, data):",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "_event_handlers",
        "kind": 5,
        "importPath": "Core.products.ui.builraui.trace",
        "description": "Core.products.ui.builraui.trace",
        "peekOfCode": "_event_handlers = {\n    \"new-rule\": _create_rule,\n    \"new-task\": _create_task,\n    \"build-started\": BuildStarted,\n    \"build-ended\": BuildEnded,\n    \"handling-build-input-request\": HandlingBuildInputRequest,\n    \"checking-rule-needs-to-run\": CheckingRuleNeedsToRun,\n    \"rule-needs-to-run\": RuleNeedsToRun,\n    \"rule-does-not-need-to-run\": RuleDoesNotNeedToRun,\n    \"created-task-for-rule\": CreatedTaskForRule,",
        "detail": "Core.products.ui.builraui.trace",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def index():\n    return flask.render_template(\"index.html\")\n# MARK: Trace Viewer\n@main.route('/trace')\ndef trace_root():\n    # If no database has been selected, prompt for one.\n    trace_path = session.get(\"trace\")\n    if trace_path is None:\n        return redirect(url_for('main.trace_config'))\n    return flask.render_template(",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "trace_root",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def trace_root():\n    # If no database has been selected, prompt for one.\n    trace_path = session.get(\"trace\")\n    if trace_path is None:\n        return redirect(url_for('main.trace_config'))\n    return flask.render_template(\n        \"trace_root.html\", trace=current_app.trace,\n        trace_path=session.get(\"trace\"))\n@main.route('/trace/config', methods=['GET', 'POST'])\ndef trace_config():",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "trace_config",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def trace_config():\n    if request.method == 'POST':\n        session['trace'] = request.form['trace_path']\n        return redirect(url_for('main.trace_root'))\n    return flask.render_template(\"trace_config.html\",\n                                 trace_path=session.get(\"trace\"))\n# MARK: Database Browser\n@main.route('/db')\ndef db_root():\n    # If no database has been selected, prompt for one.",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "db_root",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def db_root():\n    # If no database has been selected, prompt for one.\n    db_path = session.get(\"db\")\n    if db_path is None:\n        return redirect(url_for('main.db_config'))\n    s = current_app.database_session\n    # Compute the roots of the results.\n    #\n    # We compute this by simply looking for nodes which have no dependencies.\n    dependees = set()",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "db_config",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def db_config():\n    if request.method == 'POST':\n        session['db'] = request.form['db_path']\n        return redirect(url_for('main.db_root'))\n    return flask.render_template(\"db_config.html\", db_path=session.get(\"db\"))\n@main.route('/db/diagnostics', methods=['GET', 'POST'])\ndef db_diagnostics():\n    s = current_app.database_session\n    # Find all the rules.\n    rules = {}",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "db_diagnostics",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def db_diagnostics():\n    s = current_app.database_session\n    # Find all the rules.\n    rules = {}\n    key_names = {}\n    for result in s.query(model.KeyName):\n        key_names[result.id] = result.name\n    for result in s.query(model.RuleResult):\n        rules[result.key_id] = result\n    # Find information on any cycles in the database.",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "db_rule_result",
        "kind": 2,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "def db_rule_result(name):\n    # Get the result.\n    s = current_app.database_session\n    rule_result = s.query(model.RuleResult).join(model.KeyName).filter(\n        model.KeyName.name == name).one()\n    dependency_results = [\n        s.query(model.RuleResult).filter_by(\n            key_id=dependency).one()\n        for dependency in rule_result.dependencies]\n    # FIXME: We need to get back the dependents view, it was super useful.",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 5,
        "importPath": "Core.products.ui.builraui.views",
        "description": "Core.products.ui.builraui.views",
        "peekOfCode": "main = flask.Blueprint('main', __name__)\n@main.route('/')\ndef index():\n    return flask.render_template(\"index.html\")\n# MARK: Trace Viewer\n@main.route('/trace')\ndef trace_root():\n    # If no database has been selected, prompt for one.\n    trace_path = session.get(\"trace\")\n    if trace_path is None:",
        "detail": "Core.products.ui.builraui.views",
        "documentation": {}
    },
    {
        "label": "Fail",
        "kind": 2,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "def Fail(message):\n  sys.stderr.write('Error: %s\\n' % message)\n  sys.exit(1)\ndef ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')\ndef ValidateFiles():\n  # Extra from SwiftProtobuf.podspec\n  pod_content = open(_PODSPEC_PATH).read()\n  match = re.search(r'version = \\'(\\d+.\\d+.\\d+)\\'', pod_content)",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "ExtractVersion",
        "kind": 2,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "def ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')\ndef ValidateFiles():\n  # Extra from SwiftProtobuf.podspec\n  pod_content = open(_PODSPEC_PATH).read()\n  match = re.search(r'version = \\'(\\d+.\\d+.\\d+)\\'', pod_content)\n  if not match:\n    Fail('Failed to extract a version from SwiftProtobuf.podspec')\n  (major, minor, revision) = ExtractVersion(match.group(1))",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "ValidateFiles",
        "kind": 2,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "def ValidateFiles():\n  # Extra from SwiftProtobuf.podspec\n  pod_content = open(_PODSPEC_PATH).read()\n  match = re.search(r'version = \\'(\\d+.\\d+.\\d+)\\'', pod_content)\n  if not match:\n    Fail('Failed to extract a version from SwiftProtobuf.podspec')\n  (major, minor, revision) = ExtractVersion(match.group(1))\n  # Test Sources/SwiftProtobuf/Version.code\n  version_swift_content = open(_VERSION_SWIFT_PATH).read()\n  major_line = 'public static let major = %s\\n' % major",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "UpdateFiles",
        "kind": 2,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "def UpdateFiles(version_string):\n  (major, minor, revision) = ExtractVersion(version_string)\n  # Update SwiftProtobuf.podspec\n  pod_content = open(_PODSPEC_PATH).read()\n  pod_content = re.sub(r'version = \\'(\\d+\\.\\d+\\.\\d+)\\'',\n                       'version = \\'%s.%s.%s\\'' % (major, minor, revision),\n                       pod_content)\n  open(_PODSPEC_PATH, 'w').write(pod_content)\n  # Update Sources/SwiftProtobuf/Version.code\n  version_swift_content = open(_VERSION_SWIFT_PATH).read()",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "def main(args):\n  usage = '%prog [OPTIONS] [VERSION]'\n  description = (\n      'Helper for the version numbers in the project sources.'\n  )\n  parser = optparse.OptionParser(usage=usage, description=description)\n  parser.add_option('--validate',\n                    default=False, action='store_true',\n                    help='Check if the versions in all the files match.')\n  opts, extra_args = parser.parse_args(args)",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "_VERSION_RE",
        "kind": 5,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "_VERSION_RE = re.compile(r'^(?P<major>\\d+)\\.(?P<minor>\\d+)(.(?P<revision>\\d+))?$')\n_PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n_PODSPEC_PATH = os.path.join(_PROJECT_ROOT, 'SwiftProtobuf.podspec')\n_VERSION_SWIFT_PATH = os.path.join(_PROJECT_ROOT, 'Sources/SwiftProtobuf/Version.code')\ndef Fail(message):\n  sys.stderr.write('Error: %s\\n' % message)\n  sys.exit(1)\ndef ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "_PROJECT_ROOT",
        "kind": 5,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "_PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n_PODSPEC_PATH = os.path.join(_PROJECT_ROOT, 'SwiftProtobuf.podspec')\n_VERSION_SWIFT_PATH = os.path.join(_PROJECT_ROOT, 'Sources/SwiftProtobuf/Version.code')\ndef Fail(message):\n  sys.stderr.write('Error: %s\\n' % message)\n  sys.exit(1)\ndef ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')\ndef ValidateFiles():",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "_PODSPEC_PATH",
        "kind": 5,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "_PODSPEC_PATH = os.path.join(_PROJECT_ROOT, 'SwiftProtobuf.podspec')\n_VERSION_SWIFT_PATH = os.path.join(_PROJECT_ROOT, 'Sources/SwiftProtobuf/Version.code')\ndef Fail(message):\n  sys.stderr.write('Error: %s\\n' % message)\n  sys.exit(1)\ndef ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')\ndef ValidateFiles():\n  # Extra from SwiftProtobuf.podspec",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "_VERSION_SWIFT_PATH",
        "kind": 5,
        "importPath": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "description": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "peekOfCode": "_VERSION_SWIFT_PATH = os.path.join(_PROJECT_ROOT, 'Sources/SwiftProtobuf/Version.code')\ndef Fail(message):\n  sys.stderr.write('Error: %s\\n' % message)\n  sys.exit(1)\ndef ExtractVersion(s):\n  match = _VERSION_RE.match(s)\n  return (match.group('major'), match.group('minor'), match.group('revision') or '0')\ndef ValidateFiles():\n  # Extra from SwiftProtobuf.podspec\n  pod_content = open(_PODSPEC_PATH).read()",
        "detail": "Core.thirdparty.codira-protobuf.DevTools.LibraryVersions",
        "documentation": {}
    },
    {
        "label": "GccStyleFilterAndCombine",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "def GccStyleFilterAndCombine(default_flags, test_flags):\n  \"\"\"Merges default_flags and test_flags for GCC and TOOLCHAIN.\n  Args:\n    default_flags: A list of default compiler flags\n    test_flags: A list of flags that are only used in tests\n  Returns:\n    A combined list of default_flags and test_flags, but with all flags of the\n    form '-Wwarning' removed if test_flags contains a flag of the form\n    '-Wno-warning'\n  \"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "ABSL_GCC_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "ABSL_GCC_FLAGS = [\n    \"-Wall\",\n    \"-Wextra\",\n    \"-Wcast-qual\",\n    \"-Wconversion-null\",\n    \"-Wformat-security\",\n    \"-Wmissing-declarations\",\n    \"-Woverlength-strings\",\n    \"-Wpointer-arith\",\n    \"-Wundef\",",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "ABSL_GCC_TEST_ADDITIONAL_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "ABSL_GCC_TEST_ADDITIONAL_FLAGS = [\n    \"-Wno-deprecated-declarations\",\n    \"-Wno-missing-declarations\",\n    \"-Wno-self-move\",\n    \"-Wno-sign-compare\",\n    \"-Wno-unused-function\",\n    \"-Wno-unused-parameter\",\n    \"-Wno-unused-private-field\",\n]\nABSL_TOOLCHAIN_FLAGS = [",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "ABSL_TOOLCHAIN_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "ABSL_TOOLCHAIN_FLAGS = [\n    \"-Wall\",\n    \"-Wextra\",\n    \"-Wcast-qual\",\n    \"-Wconversion\",\n    \"-Wfloat-overflow-conversion\",\n    \"-Wfloat-zero-conversion\",\n    \"-Wfor-loop-analysis\",\n    \"-Wformat-security\",\n    \"-Wgnu-redeclared-enum\",",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "ABSL_TOOLCHAIN_TEST_ADDITIONAL_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "ABSL_TOOLCHAIN_TEST_ADDITIONAL_FLAGS = [\n    \"-Wno-deprecated-declarations\",\n    \"-Wno-implicit-int-conversion\",\n    \"-Wno-missing-prototypes\",\n    \"-Wno-missing-variable-declarations\",\n    \"-Wno-shadow\",\n    \"-Wno-shorten-64-to-32\",\n    \"-Wno-sign-compare\",\n    \"-Wno-sign-conversion\",\n    \"-Wno-unreachable-code-loop-increment\",",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "MSVC_BIG_WARNING_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "MSVC_BIG_WARNING_FLAGS = [\n    \"/W3\",\n]\nMSVC_WARNING_FLAGS = [\n    # Increase the number of sections available in object files\n    \"/bigobj\",\n    \"/wd4005\",  # macro-redefinition\n    \"/wd4068\",  # unknown pragma\n    # qualifier applied to function type has no meaning; ignored\n    \"/wd4180\",",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "MSVC_WARNING_FLAGS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "MSVC_WARNING_FLAGS = [\n    # Increase the number of sections available in object files\n    \"/bigobj\",\n    \"/wd4005\",  # macro-redefinition\n    \"/wd4068\",  # unknown pragma\n    # qualifier applied to function type has no meaning; ignored\n    \"/wd4180\",\n    # conversion from 'type1' to 'type2', possible loss of data\n    \"/wd4244\",\n    # conversion from 'size_t' to 'type', possible loss of data",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "MSVC_DEFINES",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "MSVC_DEFINES = [\n    \"/DNOMINMAX\",  # Don't define min and max macros (windows.h)\n    # Don't bloat namespace with incompatible winsock versions.\n    \"/DWIN32_LEAN_AND_MEAN\",\n    # Don't warn about usage of insecure C functions.\n    \"/D_CRT_SECURE_NO_WARNINGS\",\n    \"/D_SCL_SECURE_NO_WARNINGS\",\n    # Introduced in VS 2017 15.8, allow overaligned types in aligned_storage\n    \"/D_ENABLE_EXTENDED_ALIGNED_STORAGE\",\n]",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "COPT_VARS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "peekOfCode": "COPT_VARS = {\n    \"ABSL_GCC_FLAGS\": ABSL_GCC_FLAGS,\n    \"ABSL_GCC_TEST_FLAGS\": GccStyleFilterAndCombine(\n        ABSL_GCC_FLAGS, ABSL_GCC_TEST_ADDITIONAL_FLAGS),\n    \"ABSL_TOOLCHAIN_FLAGS\": ABSL_TOOLCHAIN_FLAGS,\n    \"ABSL_TOOLCHAIN_TEST_FLAGS\": GccStyleFilterAndCombine(\n        ABSL_TOOLCHAIN_FLAGS, ABSL_TOOLCHAIN_TEST_ADDITIONAL_FLAGS),\n    \"ABSL_CLANG_CL_FLAGS\":\n        MSVC_BIG_WARNING_FLAGS + MSVC_DEFINES,\n    \"ABSL_CLANG_CL_TEST_FLAGS\":",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.copts",
        "documentation": {}
    },
    {
        "label": "CMakeStyle",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "class CMakeStyle(object):\n  \"\"\"Style object for CMake copts file.\"\"\"\n  def separator(self):\n    return \"\"\n  def list_introducer(self, name):\n    return \"list(APPEND \" + name\n  def list_closer(self):\n    return \")\\n\"\n  def docstring(self):\n    return \"\\n\".join(((\"# \" + line).strip() for line in file_header_lines()))",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "StarlarkStyle",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "class StarlarkStyle(object):\n  \"\"\"Style object for Starlark copts file.\"\"\"\n  def separator(self):\n    return \",\"\n  def list_introducer(self, name):\n    return name + \" = [\"\n  def list_closer(self):\n    return \"]\\n\"\n  def docstring(self):\n    docstring_quotes = \"\\\"\\\"\\\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "file_header_lines",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def file_header_lines():\n  return [\n      \"GENERATED! DO NOT MANUALLY EDIT THIS FILE.\", \"\",\n      \"(1) Edit absl/copts/copts.py.\",\n      \"(2) Run `python <path_to_absl>/copts/generate_copts.py`.\"\n  ]\ndef flatten(*lists):\n  return [item for sublist in lists for item in sublist]\ndef relative_filename(filename):\n  return path.join(path.dirname(__file__), filename)",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def flatten(*lists):\n  return [item for sublist in lists for item in sublist]\ndef relative_filename(filename):\n  return path.join(path.dirname(__file__), filename)\n# Style classes.  These contain all the syntactic styling needed to generate a\n# copt file for different build tools.\nclass CMakeStyle(object):\n  \"\"\"Style object for CMake copts file.\"\"\"\n  def separator(self):\n    return \"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "relative_filename",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def relative_filename(filename):\n  return path.join(path.dirname(__file__), filename)\n# Style classes.  These contain all the syntactic styling needed to generate a\n# copt file for different build tools.\nclass CMakeStyle(object):\n  \"\"\"Style object for CMake copts file.\"\"\"\n  def separator(self):\n    return \"\"\n  def list_introducer(self, name):\n    return \"list(APPEND \" + name",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "copt_list",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def copt_list(name, arg_list, style):\n  \"\"\"Copt file generation.\"\"\"\n  make_line = lambda s: \"    \\\"\" + s + \"\\\"\" + style.separator()\n  external_str_list = [make_line(s) for s in arg_list]\n  return \"\\n\".join(\n      flatten(\n          [style.list_introducer(name)],\n          external_str_list,\n          [style.list_closer()]))\ndef generate_copt_file(style):",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "generate_copt_file",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def generate_copt_file(style):\n  \"\"\"Creates a generated copt file using the given style object.\n  Args:\n    style: either StarlarkStyle() or CMakeStyle()\n  \"\"\"\n  with open(relative_filename(style.filename()), \"w\") as f:\n    f.write(style.docstring())\n    f.write(\"\\n\")\n    for var_name, arg_list in sorted(COPT_VARS.items()):\n      f.write(\"\\n\")",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "peekOfCode": "def main(argv):\n  if len(argv) > 1:\n    raise RuntimeError(\"generate_copts needs no command line args\")\n  generate_copt_file(StarlarkStyle())\n  generate_copt_file(CMakeStyle())\nif __name__ == \"__main__\":\n  main(sys.argv)",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.copts.generate_copts",
        "documentation": {}
    },
    {
        "label": "get_elem_value",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def get_elem_value(elem, name):\n  \"\"\"Returns the value of XML element with the given name.\"\"\"\n  for child in elem:\n    if child.attrib.get(\"name\") != name:\n      continue\n    if child.tag == \"string\":\n      return child.attrib.get(\"value\")\n    if child.tag == \"boolean\":\n      return child.attrib.get(\"value\") == \"true\"\n    if child.tag == \"list\":",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "normalize_paths",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def normalize_paths(paths):\n  \"\"\"Returns the list of normalized path.\"\"\"\n  # e.g. [\"//absl/strings:dir/header.h\"] -> [\"absl/strings/dir/header.h\"]\n  return [path.lstrip(\"/\").replace(\":\", \"/\") for path in paths]\ndef parse_rule(elem, package):\n  \"\"\"Returns a rule from bazel XML rule.\"\"\"\n  return Rule(\n      type=elem.attrib[\"class\"],\n      name=get_elem_value(elem, \"name\"),\n      package=package,",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "parse_rule",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def parse_rule(elem, package):\n  \"\"\"Returns a rule from bazel XML rule.\"\"\"\n  return Rule(\n      type=elem.attrib[\"class\"],\n      name=get_elem_value(elem, \"name\"),\n      package=package,\n      srcs=normalize_paths(get_elem_value(elem, \"srcs\") or []),\n      hdrs=normalize_paths(get_elem_value(elem, \"hdrs\") or []),\n      textual_hdrs=normalize_paths(get_elem_value(elem, \"textual_hdrs\") or []),\n      deps=get_elem_value(elem, \"deps\") or [],",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "read_build",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def read_build(package):\n  \"\"\"Runs bazel query on given package file and returns all cc rules.\"\"\"\n  result = subprocess.check_output(\n      [\"bazel\", \"query\", package + \":all\", \"--output\", \"xml\"])\n  root = xml.etree.ElementTree.fromstring(result)\n  return [\n      parse_rule(elem, package)\n      for elem in root\n      if elem.tag == \"rule\" and elem.attrib[\"class\"].startswith(\"cc_\")\n  ]",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "collect_rules",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def collect_rules(root_path):\n  \"\"\"Collects and returns all rules from root path recursively.\"\"\"\n  rules = []\n  for cur, _, _ in os.walk(root_path):\n    build_path = os.path.join(cur, \"BUILD.bazel\")\n    if os.path.exists(build_path):\n      rules.extend(read_build(\"//\" + cur))\n  return rules\ndef relevant_rule(rule):\n  \"\"\"Returns true if a given rule is relevant when generating a podspec.\"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "relevant_rule",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def relevant_rule(rule):\n  \"\"\"Returns true if a given rule is relevant when generating a podspec.\"\"\"\n  return (\n      # cc_library only (ignore cc_test, cc_binary)\n      rule.type == \"cc_library\" and\n      # ignore empty rule\n      (rule.hdrs + rule.textual_hdrs + rule.srcs) and\n      # ignore test-only rule\n      not rule.testonly)\ndef get_spec_var(depth):",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "get_spec_var",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def get_spec_var(depth):\n  \"\"\"Returns the name of variable for spec with given depth.\"\"\"\n  return \"s\" if depth == 0 else \"s{}\".format(depth)\ndef get_spec_name(label):\n  \"\"\"Converts the label of bazel rule to the name of podspec.\"\"\"\n  assert label.startswith(\"//absl/\"), \"{} doesn't start with //absl/\".format(\n      label)\n  # e.g. //absl/apple/banana -> abseil/apple/banana\n  return \"abseil/\" + label[7:]\ndef write_podspec(f, rules, args):",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "get_spec_name",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def get_spec_name(label):\n  \"\"\"Converts the label of bazel rule to the name of podspec.\"\"\"\n  assert label.startswith(\"//absl/\"), \"{} doesn't start with //absl/\".format(\n      label)\n  # e.g. //absl/apple/banana -> abseil/apple/banana\n  return \"abseil/\" + label[7:]\ndef write_podspec(f, rules, args):\n  \"\"\"Writes a podspec from given rules and args.\"\"\"\n  rule_dir = build_rule_directory(rules)[\"abseil\"]\n  # Write root part with given arguments",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "write_podspec",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def write_podspec(f, rules, args):\n  \"\"\"Writes a podspec from given rules and args.\"\"\"\n  rule_dir = build_rule_directory(rules)[\"abseil\"]\n  # Write root part with given arguments\n  spec = re.sub(r\"\\$\\{(\\w+)\\}\", lambda x: args[x.group(1)],\n                SPEC_TEMPLATE).lstrip()\n  f.write(spec)\n  # Write all target rules\n  write_podspec_map(f, rule_dir, 0)\n  f.write(\"end\\n\")",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "build_rule_directory",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def build_rule_directory(rules):\n  \"\"\"Builds a tree-style rule directory from given rules.\"\"\"\n  rule_dir = {}\n  for rule in rules:\n    cur = rule_dir\n    for frag in get_spec_name(rule.package).split(\"/\"):\n      cur = cur.setdefault(frag, {})\n    cur[rule.name] = rule\n  return rule_dir\ndef write_podspec_map(f, cur_map, depth):",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "write_podspec_map",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def write_podspec_map(f, cur_map, depth):\n  \"\"\"Writes podspec from rule map recursively.\"\"\"\n  for key, value in sorted(cur_map.items()):\n    indent = \"  \" * (depth + 1)\n    f.write(\"{indent}{var0}.subspec '{key}' do |{var1}|\\n\".format(\n        indent=indent,\n        key=key,\n        var0=get_spec_var(depth),\n        var1=get_spec_var(depth + 1)))\n    if isinstance(value, dict):",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "write_podspec_rule",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def write_podspec_rule(f, rule, depth):\n  \"\"\"Writes podspec from given rule.\"\"\"\n  indent = \"  \" * (depth + 1)\n  spec_var = get_spec_var(depth)\n  # Puts all files in hdrs, textual_hdrs, and srcs into source_files.\n  # Since CocoaPods treats header_files a bit differently from bazel,\n  # this won't generate a header_files field so that all source_files\n  # are considered as header files.\n  srcs = sorted(set(rule.hdrs + rule.textual_hdrs + rule.srcs))\n  write_indented_list(",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "write_indented_list",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def write_indented_list(f, leading, values):\n  \"\"\"Writes leading values in an indented style.\"\"\"\n  f.write(leading)\n  f.write((\",\\n\" + \" \" * len(leading)).join(\"'{}'\".format(v) for v in values))\n  f.write(\"\\n\")\ndef generate(args):\n  \"\"\"Generates a podspec file from all BUILD files under absl directory.\"\"\"\n  rules = filter(relevant_rule, collect_rules(\"absl\"))\n  with open(args.output, \"wt\") as f:\n    write_podspec(f, rules, vars(args))",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def generate(args):\n  \"\"\"Generates a podspec file from all BUILD files under absl directory.\"\"\"\n  rules = filter(relevant_rule, collect_rules(\"absl\"))\n  with open(args.output, \"wt\") as f:\n    write_podspec(f, rules, vars(args))\ndef main():\n  parser = argparse.ArgumentParser(\n      description=\"Generates abseil.podspec from BUILD.bazel\")\n  parser.add_argument(\n      \"-v\", \"--version\", help=\"The version of podspec\", required=True)",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(\n      description=\"Generates abseil.podspec from BUILD.bazel\")\n  parser.add_argument(\n      \"-v\", \"--version\", help=\"The version of podspec\", required=True)\n  parser.add_argument(\n      \"-t\",\n      \"--tag\",\n      default=None,\n      help=\"The name of git tag (default: version)\")",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "SPEC_TEMPLATE",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "SPEC_TEMPLATE = \"\"\"\n# This file has been automatically generated from a script.\n# Please make modifications to `abseil.podspec.gen.py` instead.\nPod::Spec.new do |s|\n  s.name     = 'abseil'\n  s.version  = '${version}'\n  s.summary  = 'Abseil Common Libraries (C++) from Google'\n  s.homepage = 'https://abseil.io'\n  s.license  = 'Apache License, Version 2.0'\n  s.authors  = { 'Abseil Team' => 'abseil-io@googlegroups.com' }",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "Rule",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "peekOfCode": "Rule = collections.namedtuple(\n    \"Rule\", \"type name package srcs hdrs textual_hdrs deps visibility testonly\")\ndef get_elem_value(elem, name):\n  \"\"\"Returns the value of XML element with the given name.\"\"\"\n  for child in elem:\n    if child.attrib.get(\"name\") != name:\n      continue\n    if child.tag == \"string\":\n      return child.attrib.get(\"value\")\n    if child.tag == \"boolean\":",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.absl.abseil.podspec.gen",
        "documentation": {}
    },
    {
        "label": "AbseilConan",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.conanfile",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.conanfile",
        "peekOfCode": "class AbseilConan(ConanFile):\n    name = \"abseil\"\n    url = \"https://github.com/abseil/abseil-cpp\"\n    homepage = url\n    author = \"Abseil <abseil-io@googlegroups.com>\"\n    description = \"Abseil Common Libraries (C++) from Google\"\n    license = \"Apache-2.0\"\n    topics = (\"conan\", \"abseil\", \"abseil-cpp\", \"google\", \"common-libraries\")\n    exports = [\"LICENSE\"]\n    exports_sources = [\"CMakeLists.txt\", \"CMake/*\", \"absl/*\"]",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.conanfile",
        "documentation": {}
    },
    {
        "label": "ReplaceStringsInFile",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "peekOfCode": "def ReplaceStringsInFile(filename, replacement_dict):\n  \"\"\"Performs textual replacements in a file.\n  Rewrites filename with the keys in replacement_dict replaced with\n  their values. This function assumes the file can fit in memory.\n  Args:\n    filename: the filename to perform the replacement on\n    replacement_dict: a dictionary of key strings to be replaced with their\n      values\n  Raises:\n    Exception: A failure occurred",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "documentation": {}
    },
    {
        "label": "StripContentBetweenTags",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "peekOfCode": "def StripContentBetweenTags(filename, strip_begin_tag, strip_end_tag):\n  \"\"\"Strip contents from a file.\n  Rewrites filename with by removing all content between\n  strip_begin_tag and strip_end_tag, including the tags themselves.\n  Args:\n    filename: the filename to perform the replacement on\n    strip_begin_tag: the start of the content to be removed\n    strip_end_tag: the end of the content to be removed\n  Raises:\n    Exception: A failure occurred",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "description": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "peekOfCode": "def main(argv):\n  if len(argv) != 2:\n    print('Usage: {} YYYYMMDD'.format(sys.argv[0], file=sys.stderr))\n    sys.exit(1)\n  datestamp = sys.argv[1]\n  if len(datestamp) != 8 or not datestamp.isdigit():\n    raise Exception(\n        'datestamp={} is not in the YYYYMMDD format'.format(datestamp))\n  # Replacement directives go here.\n  ReplaceStringsInFile(",
        "detail": "Core.thirdparty.DataSerialization.third_party.abseil-cpp.create_lts",
        "documentation": {}
    },
    {
        "label": "ExitStatus",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "class ExitStatus:\n    SUCCESS = 0\n    DIFF = 1\n    TROUBLE = 2\ndef list_files(files, recursive=False, extensions=None, exclude=None):\n    if extensions is None:\n        extensions = []\n    if exclude is None:\n        exclude = []\n    out = []",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "DiffError",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "class DiffError(Exception):\n    def __init__(self, message, errs=None):\n        super(DiffError, self).__init__(message)\n        self.errs = errs or []\nclass UnexpectedError(Exception):\n    def __init__(self, message, exc=None):\n        super(UnexpectedError, self).__init__(message)\n        self.formatted_traceback = traceback.format_exc()\n        self.exc = exc\ndef run_clang_format_diff_wrapper(args, file):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "UnexpectedError",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "class UnexpectedError(Exception):\n    def __init__(self, message, exc=None):\n        super(UnexpectedError, self).__init__(message)\n        self.formatted_traceback = traceback.format_exc()\n        self.exc = exc\ndef run_clang_format_diff_wrapper(args, file):\n    try:\n        ret = run_clang_format_diff(args, file)\n        return ret\n    except DiffError:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "list_files",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def list_files(files, recursive=False, extensions=None, exclude=None):\n    if extensions is None:\n        extensions = []\n    if exclude is None:\n        exclude = []\n    out = []\n    for file in files:\n        if recursive and os.path.isdir(file):\n            for dirpath, dnames, fnames in os.walk(file):\n                fpaths = [os.path.join(dirpath, fname) for fname in fnames]",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "make_diff",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def make_diff(file, original, reformatted):\n    return list(\n        difflib.unified_diff(\n            original,\n            reformatted,\n            fromfile='{}\\t(original)'.format(file),\n            tofile='{}\\t(reformatted)'.format(file),\n            n=3))\nclass DiffError(Exception):\n    def __init__(self, message, errs=None):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "run_clang_format_diff_wrapper",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def run_clang_format_diff_wrapper(args, file):\n    try:\n        ret = run_clang_format_diff(args, file)\n        return ret\n    except DiffError:\n        raise\n    except Exception as e:\n        raise UnexpectedError('{}: {}: {}'.format(file, e.__class__.__name__,\n                                                  e), e)\ndef run_clang_format_diff(args, file):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "run_clang_format_diff",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def run_clang_format_diff(args, file):\n    try:\n        with io.open(file, 'r', encoding='utf-8') as f:\n            original = f.readlines()\n    except IOError as exc:\n        raise DiffError(str(exc))\n    invocation = [args.clang_format_executable, file]\n    # Use of utf-8 to decode the process output.\n    #\n    # Hopefully, this is the correct thing to do.",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "bold_red",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def bold_red(s):\n    return '\\x1b[1m\\x1b[31m' + s + '\\x1b[0m'\ndef colorize(diff_lines):\n    def bold(s):\n        return '\\x1b[1m' + s + '\\x1b[0m'\n    def cyan(s):\n        return '\\x1b[36m' + s + '\\x1b[0m'\n    def green(s):\n        return '\\x1b[32m' + s + '\\x1b[0m'\n    def red(s):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def colorize(diff_lines):\n    def bold(s):\n        return '\\x1b[1m' + s + '\\x1b[0m'\n    def cyan(s):\n        return '\\x1b[36m' + s + '\\x1b[0m'\n    def green(s):\n        return '\\x1b[32m' + s + '\\x1b[0m'\n    def red(s):\n        return '\\x1b[31m' + s + '\\x1b[0m'\n    for line in diff_lines:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "print_diff",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def print_diff(diff_lines, use_color):\n    if use_color:\n        diff_lines = colorize(diff_lines)\n    if sys.version_info[0] < 3:\n        sys.stdout.writelines((l.encode('utf-8') for l in diff_lines))\n    else:\n        sys.stdout.writelines(diff_lines)\ndef print_trouble(prog, message, use_colors):\n    error_text = 'error:'\n    if use_colors:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "print_trouble",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def print_trouble(prog, message, use_colors):\n    error_text = 'error:'\n    if use_colors:\n        error_text = bold_red(error_text)\n    print(\"{}: {} {}\".format(prog, error_text, message), file=sys.stderr)\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '--clang-format-executable',\n        metavar='EXECUTABLE',",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '--clang-format-executable',\n        metavar='EXECUTABLE',\n        help='path to the clang-format executable',\n        default='clang-format')\n    parser.add_argument(\n        '--extensions',\n        help='comma separated list of file extensions (default: {})'.format(",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "DEFAULT_EXTENSIONS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "peekOfCode": "DEFAULT_EXTENSIONS = 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx'\nclass ExitStatus:\n    SUCCESS = 0\n    DIFF = 1\n    TROUBLE = 2\ndef list_files(files, recursive=False, extensions=None, exclude=None):\n    if extensions is None:\n        extensions = []\n    if exclude is None:\n        exclude = []",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp..travis_scripts.run-clang-format",
        "documentation": {}
    },
    {
        "label": "ant_pattern_to_re",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "def ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'\n    *.py: match 'script.py' but not 'a/script.py'\n    \"\"\"\n    rex = ['^']\n    next_pos = 0\n    sep_rex = r'(?:/|%s)' % re.escape(os.path.sep)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "def glob(dir_path,\n         includes = '**/*',\n         excludes = default_excludes,\n         entry_type = FILE,\n         prune_dirs = prune_dirs,\n         max_depth = 25):\n    include_filter = [ant_pattern_to_re(p) for p in _as_list(includes)]\n    exclude_filter = [ant_pattern_to_re(p) for p in _as_list(excludes)]\n    prune_dirs = [p.replace('/',os.path.sep) for p in _as_list(prune_dirs)]\n    dir_path = dir_path.replace('/',os.path.sep)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "prune_dirs",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "prune_dirs = '.git .bzr .hg .svn _MTN _darcs CVS SCCS '\n# These fnmatch expressions are used by default to exclude files and dirs\n# while doing the recursive traversal in the glob_impl method of glob function.\n##exclude_pats = prune_pats + '*~ #*# .#* %*% ._* .gitignore .cvsignore vssver.scc .DS_Store'.split()\n# These ant_glob expressions are used by default to exclude files and dirs and also prune the directory tree\n# while doing the recursive traversal in the glob_impl method of glob function.\ndefault_excludes = '''\n**/*~\n**/#*#\n**/.#*",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "##exclude_pats",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "##exclude_pats = prune_pats + '*~ #*# .#* %*% ._* .gitignore .cvsignore vssver.scc .DS_Store'.split()\n# These ant_glob expressions are used by default to exclude files and dirs and also prune the directory tree\n# while doing the recursive traversal in the glob_impl method of glob function.\ndefault_excludes = '''\n**/*~\n**/#*#\n**/.#*\n**/%*%\n**/._*\n**/CVS",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "default_excludes",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "default_excludes = '''\n**/*~\n**/#*#\n**/.#*\n**/%*%\n**/._*\n**/CVS\n**/CVS/**\n**/.cvsignore\n**/SCCS",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "DIR",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "DIR = 1\nFILE = 2\nDIR_LINK = 4\nFILE_LINK = 8\nLINKS = DIR_LINK | FILE_LINK\nALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "FILE",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "FILE = 2\nDIR_LINK = 4\nFILE_LINK = 8\nLINKS = DIR_LINK | FILE_LINK\nALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "DIR_LINK",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "DIR_LINK = 4\nFILE_LINK = 8\nLINKS = DIR_LINK | FILE_LINK\nALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "FILE_LINK",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "FILE_LINK = 8\nLINKS = DIR_LINK | FILE_LINK\nALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "LINKS",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "LINKS = DIR_LINK | FILE_LINK\nALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'\n    *.py: match 'script.py' but not 'a/script.py'",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "ALL_NO_LINK",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "ALL_NO_LINK = DIR | FILE\nALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'\n    *.py: match 'script.py' but not 'a/script.py'\n    \"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "ALL",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "ALL = DIR | FILE | LINKS\n_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'\n    *.py: match 'script.py' but not 'a/script.py'\n    \"\"\"\n    rex = ['^']",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "_ANT_RE",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "peekOfCode": "_ANT_RE = re.compile(r'(/\\*\\*/)|(\\*\\*/)|(/\\*\\*)|(\\*)|(/)|([^\\*/]*)')\ndef ant_pattern_to_re(ant_pattern):\n    \"\"\"Generates a regular expression from the ant pattern.\n    Matching convention:\n    **/a: match 'a', 'dir/a', 'dir1/dir2/a'\n    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'\n    *.py: match 'script.py' but not 'a/script.py'\n    \"\"\"\n    rex = ['^']\n    next_pos = 0",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.antglob",
        "documentation": {}
    },
    {
        "label": "BuildDesc",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "class BuildDesc:\n    def __init__(self, prepend_envs=None, variables=None, build_type=None, generator=None):\n        self.prepend_envs = prepend_envs or [] # [ { \"var\": \"value\" } ]\n        self.variables = variables or []\n        self.build_type = build_type\n        self.generator = generator\n    def merged_with(self, build_desc):\n        \"\"\"Returns a new BuildDesc by merging field content.\n           Prefer build_desc fields to self fields for single valued field.\n        \"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "BuildData",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "class BuildData:\n    def __init__(self, desc, work_dir, source_dir):\n        self.desc = desc\n        self.work_dir = work_dir\n        self.source_dir = source_dir\n        self.cmake_log_path = os.path.join(work_dir, 'batchbuild_cmake.log')\n        self.build_log_path = os.path.join(work_dir, 'batchbuild_build.log')\n        self.cmake_succeeded = False\n        self.build_succeeded = False\n    def execute_build(self):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "fix_eol",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "def fix_eol(stdout):\n    \"\"\"Fixes wrong EOL produced by cmake --build on Windows (\\r\\r\\n instead of \\r\\n).\n    \"\"\"\n    return re.sub('\\r*\\n', os.linesep, stdout)\ndef load_build_variants_from_config(config_path):\n    with open(config_path, 'rb') as fconfig:\n        data = json.load(fconfig)\n    variants = data[ 'cmake_variants' ]\n    build_descs_by_axis = collections.defaultdict(list)\n    for axis in variants:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "load_build_variants_from_config",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "def load_build_variants_from_config(config_path):\n    with open(config_path, 'rb') as fconfig:\n        data = json.load(fconfig)\n    variants = data[ 'cmake_variants' ]\n    build_descs_by_axis = collections.defaultdict(list)\n    for axis in variants:\n        axis_name = axis[\"name\"]\n        build_descs = []\n        if \"generators\" in axis:\n            for generator_data in axis[\"generators\"]:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "generate_build_variants",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "def generate_build_variants(build_descs_by_axis):\n    \"\"\"Returns a list of BuildDesc generated for the partial BuildDesc for each axis.\"\"\"\n    axis_names = list(build_descs_by_axis.keys())\n    build_descs = []\n    for axis_name, axis_build_descs in list(build_descs_by_axis.items()):\n        if len(build_descs):\n            # for each existing build_desc and each axis build desc, create a new build_desc\n            new_build_descs = []\n            for prototype_build_desc, axis_build_desc in itertools.product(build_descs, axis_build_descs):\n                new_build_descs.append(prototype_build_desc.merged_with(axis_build_desc))",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "generate_html_report",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "def generate_html_report(html_report_path, builds):\n    report_dir = os.path.dirname(html_report_path)\n    # Vertical axis: generator\n    # Horizontal: variables, then build_type\n    builds_by_generator = collections.defaultdict(list)\n    variables = set()\n    build_types_by_variable = collections.defaultdict(set)\n    build_by_pos_key = {} # { (generator, var_key, build_type): build }\n    for build in builds:\n        builds_by_generator[build.desc.generator].append(build)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "def main():\n    usage = r\"\"\"%prog WORK_DIR SOURCE_DIR CONFIG_JSON_PATH [CONFIG2_JSON_PATH...]\nBuild a given CMake based project located in SOURCE_DIR with multiple generators/options.dry_run\nas described in CONFIG_JSON_PATH building in WORK_DIR.\nExample of call:\npython devtools\\batchbuild.py e:\\buildbots\\jsoncpp\\build . devtools\\agent_vmw7.json\n\"\"\"\n    from optparse import OptionParser\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = True",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "HTML_TEMPLATE",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "peekOfCode": "HTML_TEMPLATE = string.Template('''<html>\n<head>\n    <title>$title</title>\n    <style type=\"text/css\">\n    td.failed {background-color:#f08080;}\n    td.ok {background-color:#c0eec0;}\n    </style>\n</head>\n<body>\n<table border=\"1\">",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.batchbuild",
        "documentation": {}
    },
    {
        "label": "fix_source_eol",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.fixeol",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.fixeol",
        "peekOfCode": "def fix_source_eol(path, is_dry_run = True, verbose = True, eol = '\\n'):\n    \"\"\"Makes sure that all sources have the specified eol sequence (default: unix).\"\"\"\n    if not os.path.isfile(path):\n        raise ValueError('Path \"%s\" is not a file' % path)\n    try:\n        f = open(path, 'rb')\n    except IOError as msg:\n        print(\"%s: I/O Error: %s\" % (file, str(msg)), file=sys.stderr)\n        return False\n    try:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.fixeol",
        "documentation": {}
    },
    {
        "label": "update_license",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "peekOfCode": "def update_license(path, dry_run, show_diff):\n    \"\"\"Update the license statement in the specified file.\n    Parameters:\n      path: path of the C++ source file to update.\n      dry_run: if True, just print the path of the file that would be updated,\n               but don't change it.\n      show_diff: if True, print the path of the file that would be modified,\n                 as well as the change made to the file. \n    \"\"\"\n    with open(path, 'rt') as fin:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "documentation": {}
    },
    {
        "label": "update_license_in_source_directories",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "peekOfCode": "def update_license_in_source_directories(source_dirs, dry_run, show_diff):\n    \"\"\"Updates license text in C++ source files found in directory source_dirs.\n    Parameters:\n      source_dirs: list of directory to scan for C++ sources. Directories are\n                   scanned recursively.\n      dry_run: if True, just print the path of the file that would be updated,\n               but don't change it.\n      show_diff: if True, print the path of the file that would be modified,\n                 as well as the change made to the file. \n    \"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "peekOfCode": "def main():\n    usage = \"\"\"%prog DIR [DIR2...]\nUpdates license text in sources of the project in source files found\nin the directory specified on the command-line.\nExample of call:\npython devtools\\licenseupdater.py include src -n --diff\n=> Show change that would be made to the sources.\npython devtools\\licenseupdater.py include src\n=> Update license statement on all sources in directories include/ and src/.\n\"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "documentation": {}
    },
    {
        "label": "LICENSE_BEGIN",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "peekOfCode": "LICENSE_BEGIN = \"// Copyright \"\nBRIEF_LICENSE = LICENSE_BEGIN + \"\"\"2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\"\"\".replace('\\r\\n','\\n')\ndef update_license(path, dry_run, show_diff):\n    \"\"\"Update the license statement in the specified file.\n    Parameters:\n      path: path of the C++ source file to update.",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "documentation": {}
    },
    {
        "label": "BRIEF_LICENSE",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "peekOfCode": "BRIEF_LICENSE = LICENSE_BEGIN + \"\"\"2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\"\"\".replace('\\r\\n','\\n')\ndef update_license(path, dry_run, show_diff):\n    \"\"\"Update the license statement in the specified file.\n    Parameters:\n      path: path of the C++ source file to update.\n      dry_run: if True, just print the path of the file that would be updated,",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.licenseupdater",
        "documentation": {}
    },
    {
        "label": "make_tarball",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "peekOfCode": "def make_tarball(tarball_path, sources, base_dir, prefix_dir=''):\n    \"\"\"Parameters:\n    tarball_path: output path of the .tar.gz file\n    sources: list of sources to include in the tarball, relative to the current directory\n    base_dir: if a source file is in a sub-directory of base_dir, then base_dir is stripped\n        from path in the tarball.\n    prefix_dir: all files stored in the tarball be sub-directory of prefix_dir. Set to ''\n        to make them child of root.\n    \"\"\"\n    base_dir = os.path.normpath(os.path.abspath(base_dir))",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "documentation": {}
    },
    {
        "label": "decompress",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "peekOfCode": "def decompress(tarball_path, base_dir):\n    \"\"\"Decompress the gzipped tarball into directory base_dir.\n    \"\"\"\n    with closing(tarfile.TarFile.open(tarball_path)) as tar:\n        tar.extractall(base_dir)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "documentation": {}
    },
    {
        "label": "TARGZ_DEFAULT_COMPRESSION_LEVEL",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "peekOfCode": "TARGZ_DEFAULT_COMPRESSION_LEVEL = 9\ndef make_tarball(tarball_path, sources, base_dir, prefix_dir=''):\n    \"\"\"Parameters:\n    tarball_path: output path of the .tar.gz file\n    sources: list of sources to include in the tarball, relative to the current directory\n    base_dir: if a source file is in a sub-directory of base_dir, then base_dir is stripped\n        from path in the tarball.\n    prefix_dir: all files stored in the tarball be sub-directory of prefix_dir. Set to ''\n        to make them child of root.\n    \"\"\"",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.devtools.tarball",
        "documentation": {}
    },
    {
        "label": "paths",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.cleantests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.cleantests",
        "peekOfCode": "paths = []\nfor pattern in [ '*.actual', '*.actual-rewrite', '*.rewrite', '*.process-output' ]:\n    paths += glob.glob('data/' + pattern)\nfor path in paths:\n    os.unlink(path)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.cleantests",
        "documentation": {}
    },
    {
        "label": "valueTreeToString",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "def valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''\n        names = value.keys()\n        names.sort()\n        for name in names:\n            valueTreeToString(fout, value[name], path + suffix + name)\n    elif ty is types.ListType:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "parseAndSaveValueTree",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "def parseAndSaveValueTree(input, actual_path):\n    root = json.loads(input)\n    fout = file(actual_path, 'wt')\n    valueTreeToString(fout, root)\n    fout.close()\n    return root\ndef rewriteValueTree(value, rewrite_path):\n    rewrite = json.dumps(value)\n    #rewrite = rewrite[1:-1]  # Somehow the string is quoted ! jsonpy bug ?\n    file(rewrite_path, 'wt').write(rewrite + '\\n')",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "rewriteValueTree",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "def rewriteValueTree(value, rewrite_path):\n    rewrite = json.dumps(value)\n    #rewrite = rewrite[1:-1]  # Somehow the string is quoted ! jsonpy bug ?\n    file(rewrite_path, 'wt').write(rewrite + '\\n')\n    return rewrite\ninput = file(input_path, 'rt').read()\nroot = parseAndSaveValueTree(input, actual_path)\nrewrite = rewriteValueTree(json.write(root), rewrite_path)\nrewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)\nsys.exit(0)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "input_path",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "input_path = sys.argv[1]\nbase_path = os.path.splitext(input_path)[0]\nactual_path = base_path + '.actual'\nrewrite_path = base_path + '.rewrite'\nrewrite_actual_path = base_path + '.actual-rewrite'\ndef valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "base_path = os.path.splitext(input_path)[0]\nactual_path = base_path + '.actual'\nrewrite_path = base_path + '.rewrite'\nrewrite_actual_path = base_path + '.actual-rewrite'\ndef valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''\n        names = value.keys()",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "actual_path",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "actual_path = base_path + '.actual'\nrewrite_path = base_path + '.rewrite'\nrewrite_actual_path = base_path + '.actual-rewrite'\ndef valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''\n        names = value.keys()\n        names.sort()",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "rewrite_path",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "rewrite_path = base_path + '.rewrite'\nrewrite_actual_path = base_path + '.actual-rewrite'\ndef valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''\n        names = value.keys()\n        names.sort()\n        for name in names:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "rewrite_actual_path",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "rewrite_actual_path = base_path + '.actual-rewrite'\ndef valueTreeToString(fout, value, path = '.'):\n    ty = type(value) \n    if ty  is types.DictType:\n        fout.write('%s={}\\n' % path)\n        suffix = path[-1] != '.' and '.' or ''\n        names = value.keys()\n        names.sort()\n        for name in names:\n            valueTreeToString(fout, value[name], path + suffix + name)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "input = file(input_path, 'rt').read()\nroot = parseAndSaveValueTree(input, actual_path)\nrewrite = rewriteValueTree(json.write(root), rewrite_path)\nrewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)\nsys.exit(0)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "root = parseAndSaveValueTree(input, actual_path)\nrewrite = rewriteValueTree(json.write(root), rewrite_path)\nrewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)\nsys.exit(0)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "rewrite",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "rewrite = rewriteValueTree(json.write(root), rewrite_path)\nrewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)\nsys.exit(0)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "rewrite_root",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "peekOfCode": "rewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)\nsys.exit(0)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.pyjsontestrunner",
        "documentation": {}
    },
    {
        "label": "FailError",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "class FailError(Exception):\n    def __init__(self, msg):\n        super(Exception, self).__init__(msg)\ndef runAllTests(jsontest_executable_path, input_dir = None,\n                 use_valgrind=False, with_json_checker=False,\n                 writerClass='StyledWriter'):\n    if not input_dir:\n        input_dir = os.path.join(os.getcwd(), 'data')\n    tests = glob(os.path.join(input_dir, '*.json'))\n    if with_json_checker:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "getStatusOutput",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "def getStatusOutput(cmd):\n    \"\"\"\n    Return int, unicode (for both Python 2 and 3).\n    Note: os.popen().close() would return None for 0.\n    \"\"\"\n    print(cmd, file=sys.stderr)\n    pipe = os.popen(cmd)\n    process_output = pipe.read()\n    try:\n        # We have been using os.popen(). When we read() the result",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "compareOutputs",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "def compareOutputs(expected, actual, message):\n    expected = expected.strip().replace('\\r','').split('\\n')\n    actual = actual.strip().replace('\\r','').split('\\n')\n    diff_line = 0\n    max_line_to_compare = min(len(expected), len(actual))\n    for index in range(0,max_line_to_compare):\n        if expected[index].strip() != actual[index].strip():\n            diff_line = index + 1\n            break\n    if diff_line == 0 and len(expected) != len(actual):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "safeReadFile",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "def safeReadFile(path):\n    try:\n        return open(path, 'rt', encoding = 'utf-8').read()\n    except IOError as e:\n        return '<File \"%s\" is missing: %s>' % (path,e)\nclass FailError(Exception):\n    def __init__(self, msg):\n        super(Exception, self).__init__(msg)\ndef runAllTests(jsontest_executable_path, input_dir = None,\n                 use_valgrind=False, with_json_checker=False,",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "runAllTests",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "def runAllTests(jsontest_executable_path, input_dir = None,\n                 use_valgrind=False, with_json_checker=False,\n                 writerClass='StyledWriter'):\n    if not input_dir:\n        input_dir = os.path.join(os.getcwd(), 'data')\n    tests = glob(os.path.join(input_dir, '*.json'))\n    if with_json_checker:\n        all_tests = glob(os.path.join(input_dir, '../jsonchecker', '*.json'))\n        # These tests fail with strict json support, but pass with JsonCPP's\n        # extra leniency features. When adding a new exclusion to this list,",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "def main():\n    from optparse import OptionParser\n    parser = OptionParser(usage=\"%prog [options] <path to jsontestrunner.exe> [test case directory]\")\n    parser.add_option(\"--valgrind\",\n                  action=\"store_true\", dest=\"valgrind\", default=False,\n                  help=\"run all the tests using valgrind to detect memory leaks\")\n    parser.add_option(\"-c\", \"--with-json-checker\",\n                  action=\"store_true\", dest=\"with_json_checker\", default=False,\n                  help=\"run all the tests from the official JSONChecker test suite of json.org\")\n    parser.enable_interspersed_args()",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "VALGRIND_CMD",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "peekOfCode": "VALGRIND_CMD = 'valgrind --tool=memcheck --leak-check=yes --undef-value-errors=yes '\ndef getStatusOutput(cmd):\n    \"\"\"\n    Return int, unicode (for both Python 2 and 3).\n    Note: os.popen().close() would return None for 0.\n    \"\"\"\n    print(cmd, file=sys.stderr)\n    pipe = os.popen(cmd)\n    process_output = pipe.read()\n    try:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.runjsontests",
        "documentation": {}
    },
    {
        "label": "TestProxy",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "peekOfCode": "class TestProxy(object):\n    def __init__(self, test_exe_path, use_valgrind=False):\n        self.test_exe_path = os.path.normpath(os.path.abspath(test_exe_path))\n        self.use_valgrind = use_valgrind\n    def run(self, options):\n        if self.use_valgrind:\n            cmd = VALGRIND_CMD.split()\n        else:\n            cmd = []\n        cmd.extend([self.test_exe_path, '--test-auto'] + options)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "documentation": {}
    },
    {
        "label": "runAllTests",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "peekOfCode": "def runAllTests(exe_path, use_valgrind=False):\n    test_proxy = TestProxy(exe_path, use_valgrind=use_valgrind)\n    status, test_names = test_proxy.run(['--list-tests'])\n    if not status:\n        print(\"Failed to obtain unit tests list:\\n\" + test_names, file=sys.stderr)\n        return 1\n    test_names = [name.strip() for name in test_names.decode('utf-8').strip().split('\\n')]\n    failures = []\n    for name in test_names:\n        print('TESTING %s:' % name, end=' ')",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "peekOfCode": "def main():\n    from optparse import OptionParser\n    parser = OptionParser(usage=\"%prog [options] <path to test_lib_json.exe>\")\n    parser.add_option(\"--valgrind\",\n                  action=\"store_true\", dest=\"valgrind\", default=False,\n                  help=\"run all the tests using valgrind to detect memory leaks\")\n    parser.enable_interspersed_args()\n    options, args = parser.parse_args()\n    if len(args) != 1:\n        parser.error('Must provides at least path to test_lib_json executable.')",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "documentation": {}
    },
    {
        "label": "VALGRIND_CMD",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "peekOfCode": "VALGRIND_CMD = 'valgrind --tool=memcheck --leak-check=yes --undef-value-errors=yes'\nclass TestProxy(object):\n    def __init__(self, test_exe_path, use_valgrind=False):\n        self.test_exe_path = os.path.normpath(os.path.abspath(test_exe_path))\n        self.use_valgrind = use_valgrind\n    def run(self, options):\n        if self.use_valgrind:\n            cmd = VALGRIND_CMD.split()\n        else:\n            cmd = []",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.test.rununittests",
        "documentation": {}
    },
    {
        "label": "AmalgamationFile",
        "kind": 6,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "peekOfCode": "class AmalgamationFile:\n    def __init__(self, top_dir):\n        self.top_dir = top_dir\n        self.blocks = []\n    def add_text(self, text):\n        if not text.endswith(\"\\n\"):\n            text += \"\\n\"\n        self.blocks.append(text)\n    def add_file(self, relative_input_path, wrap_in_comment=False):\n        def add_marker(prefix):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "documentation": {}
    },
    {
        "label": "amalgamate_source",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "peekOfCode": "def amalgamate_source(source_top_dir=None,\n                       target_source_path=None,\n                       header_include_path=None):\n    \"\"\"Produces amalgamated source.\n       Parameters:\n           source_top_dir: top-directory\n           target_source_path: output .cpp path\n           header_include_path: generated header path relative to target_source_path.\n    \"\"\"\n    print(\"Amalgamating header...\")",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "peekOfCode": "def main():\n    usage = \"\"\"%prog [options]\nGenerate a single amalgamated source and header file from the sources.\n\"\"\"\n    from optparse import OptionParser\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = False\n    parser.add_option(\"-s\", \"--source\", dest=\"target_source_path\", action=\"store\", default=\"dist/jsoncpp.cpp\",\n        help=\"\"\"Output .cpp source path. [Default: %default]\"\"\")\n    parser.add_option(\"-i\", \"--include\", dest=\"header_include_path\", action=\"store\", default=\"json/json.h\",",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "documentation": {}
    },
    {
        "label": "INCLUDE_PATH",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "peekOfCode": "INCLUDE_PATH = \"include/json\"\nSRC_PATH = \"src/lib_json\"\nclass AmalgamationFile:\n    def __init__(self, top_dir):\n        self.top_dir = top_dir\n        self.blocks = []\n    def add_text(self, text):\n        if not text.endswith(\"\\n\"):\n            text += \"\\n\"\n        self.blocks.append(text)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "documentation": {}
    },
    {
        "label": "SRC_PATH",
        "kind": 5,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "peekOfCode": "SRC_PATH = \"src/lib_json\"\nclass AmalgamationFile:\n    def __init__(self, top_dir):\n        self.top_dir = top_dir\n        self.blocks = []\n    def add_text(self, text):\n        if not text.endswith(\"\\n\"):\n            text += \"\\n\"\n        self.blocks.append(text)\n    def add_file(self, relative_input_path, wrap_in_comment=False):",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.amalgamate",
        "documentation": {}
    },
    {
        "label": "cd",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def cd(newdir):\n    \"\"\"\n    http://stackoverflow.com/questions/431684/how-do-i-cd-in-python\n    \"\"\"\n    prevdir = os.getcwd()\n    os.chdir(newdir)\n    try:\n        yield\n    finally:\n        os.chdir(prevdir)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "find_program",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def find_program(*filenames):\n    \"\"\"find a program in folders path_lst, and sets env[var]\n    @param filenames: a list of possible names of the program to search for\n    @return: the full path of the filename if found, or '' if filename could not be found\n\"\"\"\n    paths = os.environ.get('PATH', '').split(os.pathsep)\n    suffixes = ('win32' in sys.platform) and '.exe .com .bat .cmd' or ''\n    for filename in filenames:\n        for name in [filename+ext for ext in suffixes.split(' ')]:\n            for directory in paths:",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "do_subst_in_file",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def do_subst_in_file(targetfile, sourcefile, dict):\n    \"\"\"Replace all instances of the keys of dict with their values.\n    For example, if dict is {'%VERSION%': '1.2345', '%BASE%': 'MyProg'},\n    then all instances of %VERSION% in the file will be replaced with 1.2345 etc.\n    \"\"\"\n    with open(sourcefile, 'r') as f:\n        contents = f.read()\n    for (k,v) in list(dict.items()):\n        v = v.replace('\\\\','\\\\\\\\') \n        contents = re.sub(k, v, contents)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "getstatusoutput",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def getstatusoutput(cmd):\n    \"\"\"cmd is a list.\n    \"\"\"\n    try:\n        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        output, _ = process.communicate()\n        status = process.returncode\n    except:\n        status = -1\n        output = traceback.format_exc()",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "run_cmd",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def run_cmd(cmd, silent=False):\n    \"\"\"Raise exception on failure.\n    \"\"\"\n    info = 'Running: %r in %r' %(' '.join(cmd), os.getcwd())\n    print(info)\n    sys.stdout.flush()\n    if silent:\n        status, output = getstatusoutput(cmd)\n    else:\n        status, output = subprocess.call(cmd), ''",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "assert_is_exe",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def assert_is_exe(path):\n    if not path:\n        raise Exception('path is empty.')\n    if not os.path.isfile(path):\n        raise Exception('%r is not a file.' %path)\n    if not os.access(path, os.X_OK):\n        raise Exception('%r is not executable by this user.' %path)\ndef run_doxygen(doxygen_path, config_file, working_dir, is_silent):\n    assert_is_exe(doxygen_path)\n    config_file = os.path.abspath(config_file)",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "run_doxygen",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def run_doxygen(doxygen_path, config_file, working_dir, is_silent):\n    assert_is_exe(doxygen_path)\n    config_file = os.path.abspath(config_file)\n    with cd(working_dir):\n        cmd = [doxygen_path, config_file]\n        run_cmd(cmd, is_silent)\ndef build_doc(options,  make_release=False):\n    if make_release:\n        options.make_tarball = True\n        options.with_dot = True",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "build_doc",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def build_doc(options,  make_release=False):\n    if make_release:\n        options.make_tarball = True\n        options.with_dot = True\n        options.with_html_help = True\n        options.with_uml_look = True\n        options.open = False\n        options.silent = True\n    version = open('version', 'rt').read().strip()\n    output_dir = 'dist/doxygen' # relative to doc/doxyfile location.",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "description": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "peekOfCode": "def main():\n    usage = \"\"\"%prog\n    Generates doxygen documentation in build/doxygen.\n    Optionally makes a tarball of the documentation to dist/.\n    Must be started in the project top directory.    \n    \"\"\"\n    from optparse import OptionParser\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = False\n    parser.add_option('--with-dot', dest=\"with_dot\", action='store_true', default=False,",
        "detail": "Core.thirdparty.DataSerialization.third_party.jsoncpp.doxybuild",
        "documentation": {}
    },
    {
        "label": "MultiTool",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class MultiTool(object):\n    \"\"\"\n    This object defines a generic command line tool instance, which dynamically\n    builds its commands from a module dictionary.\n    Example usage::\n      import multitool\n      def action_foo(name, args):\n          \"the foo command\"\n          ... \n      tool = multitool.MultiTool(locals())",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeTimeEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeTimeEvent(object):\n    pass\nclass PTreeStartEvent(PTreeTimeEvent):\n    def __init__(self, ts, target):\n        self.timestamp = ts\n        self.target = target\nclass PTreeStopEvent(PTreeTimeEvent):\n    def __init__(self, ts):\n        self.timestamp = ts\nclass PTreeProcCreateEvent(PTreeTimeEvent):",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeStartEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeStartEvent(PTreeTimeEvent):\n    def __init__(self, ts, target):\n        self.timestamp = ts\n        self.target = target\nclass PTreeStopEvent(PTreeTimeEvent):\n    def __init__(self, ts):\n        self.timestamp = ts\nclass PTreeProcCreateEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent):\n        self.timestamp = ts",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeStopEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeStopEvent(PTreeTimeEvent):\n    def __init__(self, ts):\n        self.timestamp = ts\nclass PTreeProcCreateEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\nclass PTreeUserStartupEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime):",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeProcCreateEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeProcCreateEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\nclass PTreeUserStartupEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeUserStartupEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeUserStartupEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\n        self.user_time = utime\n        self.system_time = stime\nclass PTreeUserExecEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime, args):\n        self.timestamp = ts",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeUserExecEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeUserExecEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime, args):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\n        self.user_time = utime\n        self.system_time = stime\n        self.args = args\nclass PTreeUserSpawnEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime, args):",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeUserSpawnEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeUserSpawnEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime, args):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\n        self.args = args\nclass PTreeUserExitEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime):\n        self.timestamp = ts\n        self.pid = pid",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeUserExitEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeUserExitEvent(PTreeTimeEvent):\n    def __init__(self, ts, pid, parent, utime, stime):\n        self.timestamp = ts\n        self.pid = pid\n        self.parent = parent\n        self.user_time = utime\n        self.system_time = stime\nclass PTreeProcExitEvent(PTreeTimeEvent):\n    def __init__(self, ts, name, pid, parent):\n        self.timestamp = ts",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "PTreeProcExitEvent",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class PTreeProcExitEvent(PTreeTimeEvent):\n    def __init__(self, ts, name, pid, parent):\n        self.timestamp = ts\n        self.name = name\n        self.pid = pid\n        self.parent = parent\n###\n_event_classes = {\n    'START' : PTreeStartEvent,\n    'proc:::create' : PTreeProcCreateEvent,",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "ProcessInfo",
        "kind": 6,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "class ProcessInfo(object):\n    def __init__(self, pid):\n        self.pid = pid\n        self.children = []\n        self.name = None\n        self.args = None\n        self.start_timestamp = None\n        self.exit_timestamp = None\n        self.user_start_timestamp = None\n        self.user_exit_timestamp = None",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "action_analyze",
        "kind": 2,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "def action_analyze(name, args):\n    \"\"\"analyze a ptreetime data file\"\"\"\n    parser = optparse.OptionParser(\"\"\"\\\nusage: %%prog %(name)s [options] <path>\nExecute the given command and track the execution time of all the processes\nwhich are created during the execution.\"\"\" % locals())\n    parser.add_option(\"-f\", \"--focus\", dest=\"focus\",\n                      help=\"focus on the given process name\",\n                      action=\"store\", default=None)\n    parser.add_option(\"--show-tree\", dest=\"show_tree\",",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "action_profile",
        "kind": 2,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "def action_profile(name, args):\n    \"\"\"time a process tree\"\"\"\n    parser = optparse.OptionParser(\"\"\"\\\nusage: %%prog %(name)s [options] ... test command args ...\nUse dtrace and dyld interpositioning to collect precise time information on an\nentire process tree.\"\"\" % locals())\n    parser.add_option(\"-v\", \"--verbose\", dest=\"verbose\",\n                      help=\"output more test information\",\n                      action=\"store_true\", default=False)\n    parser.add_option(\"-o\", \"--output\", dest=\"output_path\",",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "note",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "note = lambda message: _write_message('note', message)\nwarning = lambda message: _write_message('warning', message)\nerror = lambda message: _write_message('error', message)\nfatal = lambda message: (_write_message('fatal error', message), sys.exit(1))\n###\nclass MultiTool(object):\n    \"\"\"\n    This object defines a generic command line tool instance, which dynamically\n    builds its commands from a module dictionary.\n    Example usage::",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "warning",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "warning = lambda message: _write_message('warning', message)\nerror = lambda message: _write_message('error', message)\nfatal = lambda message: (_write_message('fatal error', message), sys.exit(1))\n###\nclass MultiTool(object):\n    \"\"\"\n    This object defines a generic command line tool instance, which dynamically\n    builds its commands from a module dictionary.\n    Example usage::\n      import multitool",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "error = lambda message: _write_message('error', message)\nfatal = lambda message: (_write_message('fatal error', message), sys.exit(1))\n###\nclass MultiTool(object):\n    \"\"\"\n    This object defines a generic command line tool instance, which dynamically\n    builds its commands from a module dictionary.\n    Example usage::\n      import multitool\n      def action_foo(name, args):",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "fatal",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "fatal = lambda message: (_write_message('fatal error', message), sys.exit(1))\n###\nclass MultiTool(object):\n    \"\"\"\n    This object defines a generic command line tool instance, which dynamically\n    builds its commands from a module dictionary.\n    Example usage::\n      import multitool\n      def action_foo(name, args):\n          \"the foo command\"",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "_event_classes",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "_event_classes = {\n    'START' : PTreeStartEvent,\n    'proc:::create' : PTreeProcCreateEvent,\n    'user startup' : PTreeUserStartupEvent,\n    'user exec' : PTreeUserExecEvent,\n    'user spawn' : PTreeUserSpawnEvent,\n    'user exit' : PTreeUserExitEvent,\n    'proc:::exit' : PTreeProcExitEvent,\n    'END' : PTreeStopEvent }\n###",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "tool",
        "kind": 5,
        "importPath": "Core.utils.ptreetime.ptreetime",
        "description": "Core.utils.ptreetime.ptreetime",
        "peekOfCode": "tool = MultiTool(locals(), \"ptreetime\")\nif __name__ == '__main__':\n    import sys\n    tool.main(sys.argv)",
        "detail": "Core.utils.ptreetime.ptreetime",
        "documentation": {}
    },
    {
        "label": "injectTestMethod",
        "kind": 2,
        "importPath": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "description": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "peekOfCode": "def injectTestMethod(klass, test):\n    test_name = test.id()\n    # Mangle the test name into a valid name.\n    method_name = \"test\" + re.sub(r\"[^A-Za-z_0-9]\", \"_\", test_name)\n    # Inject the method.\n    def runTest(obj):\n        print \"Running Lit test: %s\" % (test.id(),)\n        result = test.defaultTestResult()\n        test.run(result)\n        # Report an XCTest failure, if the test failed.",
        "detail": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "documentation": {}
    },
    {
        "label": "built_products_dir",
        "kind": 5,
        "importPath": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "description": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "peekOfCode": "built_products_dir = os.environ.get(\"BUILT_PRODUCTS_DIR\")\nif not built_products_dir or not os.path.exists(built_products_dir):\n   raise RuntimeError(\"invalid BUILT_PRODUCTS_DIR: %r\" % (built_products_dir,))\ntest_paths = [os.path.join(built_products_dir, \"tests\")]\n# Load the Lit test suite using the unittest style discovery.\ntry:\n  import lit.LitTestCase\n  test_suite = lit.LitTestCase.load_test_suite(test_paths)\nexcept AttributeError:\n  # Legacy way of loading tests.",
        "detail": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "documentation": {}
    },
    {
        "label": "test_paths",
        "kind": 5,
        "importPath": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "description": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "peekOfCode": "test_paths = [os.path.join(built_products_dir, \"tests\")]\n# Load the Lit test suite using the unittest style discovery.\ntry:\n  import lit.LitTestCase\n  test_suite = lit.LitTestCase.load_test_suite(test_paths)\nexcept AttributeError:\n  # Legacy way of loading tests.\n  import lit.discovery\n  test_suite = lit.discovery.load_test_suite(test_paths)\n# Inject test methods for each test.",
        "detail": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "documentation": {}
    },
    {
        "label": "klass",
        "kind": 5,
        "importPath": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "description": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "peekOfCode": "klass = objc.lookUpClass(\"LitTests\")\nfor test in test_suite:\n    injectTestMethod(klass, test)",
        "detail": "Core.utils.Xcode.LitXCTestAdaptor.LitTests",
        "documentation": {}
    },
    {
        "label": "KeyName",
        "kind": 6,
        "importPath": "Core.utils.create-dummy-ninja-from-DB",
        "description": "Core.utils.create-dummy-ninja-from-DB",
        "peekOfCode": "class KeyName(Base):\n    __tablename__ = \"key_names\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    name = Column('key', String, nullable=False)\n    def __repr__(self):\n        return \"%s%r\" % (\n            self.__class__.__name__, (self.id, self.name))\nclass RuleResult(Base):\n    __tablename__ = \"rule_results\"\n    id = Column(Integer, nullable=False, primary_key=True)",
        "detail": "Core.utils.create-dummy-ninja-from-DB",
        "documentation": {}
    },
    {
        "label": "RuleResult",
        "kind": 6,
        "importPath": "Core.utils.create-dummy-ninja-from-DB",
        "description": "Core.utils.create-dummy-ninja-from-DB",
        "peekOfCode": "class RuleResult(Base):\n    __tablename__ = \"rule_results\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    key_id = Column(Integer, ForeignKey(KeyName.id),\n                     nullable=False)\n    value = Column(Integer, nullable=False)\n    built_at = Column(Integer, nullable=False)\n    computed_at = Column(Integer, nullable=False)\n    key = relation(KeyName)\n    dependencies = relationship('RuleDependency')",
        "detail": "Core.utils.create-dummy-ninja-from-DB",
        "documentation": {}
    },
    {
        "label": "RuleDependency",
        "kind": 6,
        "importPath": "Core.utils.create-dummy-ninja-from-DB",
        "description": "Core.utils.create-dummy-ninja-from-DB",
        "peekOfCode": "class RuleDependency(Base):\n    __tablename__ = \"rule_dependencies\"\n    rule_id = Column(Integer, ForeignKey(RuleResult.id),\n                     nullable=False, primary_key=True)\n    key_id = Column(Integer, ForeignKey(KeyName.id),\n                     nullable=False, primary_key=True)\n    rule = relation(RuleResult)\n    key = relation(KeyName)\n    def __repr__(self):\n        return \"%s%r\" % (",
        "detail": "Core.utils.create-dummy-ninja-from-DB",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Core.utils.create-dummy-ninja-from-DB",
        "description": "Core.utils.create-dummy-ninja-from-DB",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('path', metavar='path', type=str,\n                        help='path to the database')\n    parser.add_argument('--show-mapping', action='store_true',\n                        help='show name to node-name mapping')\n    args = parser.parse_args()\n    # Create the database engine.\n    engine = sqlalchemy.create_engine(\"sqlite:///\" + args.path)\n    # Create a session.",
        "detail": "Core.utils.create-dummy-ninja-from-DB",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "Core.utils.create-dummy-ninja-from-DB",
        "description": "Core.utils.create-dummy-ninja-from-DB",
        "peekOfCode": "Base = sqlalchemy.ext.declarative.declarative_base()\nclass KeyName(Base):\n    __tablename__ = \"key_names\"\n    id = Column(Integer, nullable=False, primary_key=True)\n    name = Column('key', String, nullable=False)\n    def __repr__(self):\n        return \"%s%r\" % (\n            self.__class__.__name__, (self.id, self.name))\nclass RuleResult(Base):\n    __tablename__ = \"rule_results\"",
        "detail": "Core.utils.create-dummy-ninja-from-DB",
        "documentation": {}
    }
]