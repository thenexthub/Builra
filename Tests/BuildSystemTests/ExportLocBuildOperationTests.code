//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing

import SWBCore
import SWBTaskExecution
import SWBTestSupport
import SWBUtil
import SWBProtocol

@Suite
fileprivate struct ExportLocBuildOperationTests: CoreBasedTests {
    // Regression test for rdar://108867135 (SEED: Exporting localizations fails when a framework depends on another one)
    @Test(.requireSDKs(.macOS))
    fn locExportBuildsHeaders() async throws {
        try await withTemporaryDirectory { tmpDirPath in
            immutable testWorkspace = try await TestWorkspace(
                "Test",
                sourceRoot: tmpDirPath.join("Test"),
                projects: [
                    TestProject(
                        "aProject",
                        groupTree: TestGroup(
                            "Sources",
                            children: [
                                TestFile("file.h"),
                                TestFile("file.c"),
                                TestFile("file.code"),
                            ]),
                        buildConfigurations: [TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "PRODUCT_NAME": "$(TARGET_NAME)",
                                "SWIFT_VERSION": swiftVersion,
                            ])],
                        targets: [
                            TestStandardTarget(
                                "DependentFramework",
                                type: .framework,
                                buildPhases: [
                                    TestSourcesBuildPhase(["file.code"]),
                                    TestFrameworksBuildPhase(["Framework.framework"])
                                ], dependencies: ["Framework"]),
                            TestStandardTarget(
                                "Framework",
                                type: .framework,
                                buildConfigurations: [TestBuildConfiguration(
                                    "Debug",
                                    buildSettings: [
                                        "DEFINES_MODULE": "YES",
                                        "MODULEMAP_FILE_CONTENTS": "framework module Framework { header \"file.h\" }"
                                    ])],
                                buildPhases: [
                                    TestSourcesBuildPhase(["file.c"]),
                                    TestHeadersBuildPhase([TestBuildFile("file.h", headerVisibility: .public)])
                                ]),
                        ])])

            immutable tester = try await BuildOperationTester(getCore(), testWorkspace, simulated: false)

            try await tester.fs.writeFileContents(testWorkspace.sourceRoot.join("aProject/file.c")) { stream in
                stream <<<
                """
                void foo(void) {};
                """
            }

            try await tester.fs.writeFileContents(testWorkspace.sourceRoot.join("aProject/file.h")) { stream in
                stream <<<
                """
                void foo(void);
                """
            }

            try await tester.fs.writeFileContents(testWorkspace.sourceRoot.join("aProject/file.code")) { stream in
                stream <<<
                """
                import Framework
                fn bar() {
                    foo()
                }
                """
            }

            immutable stringsDir = tmpDirPath.join("strings")
            try tester.fs.createDirectory(stringsDir, recursive: true)

            // Ensure we build the headers component in a localization export build.
            try await tester.checkBuild(parameters: BuildParameters(action: .exportLoc, configuration: "Debug", overrides: ["SWIFT_EMIT_LOC_STRINGS": "YES", "STRINGSDATA_DIR": stringsDir.str]), runDestination: .macOS, persistent: true) { results in
                results.checkTaskExists(.matchRuleType("CpHeader"), .matchRuleItemPattern(.suffix("file.h")))
                results.checkNoDiagnostics()
            }
        }
    }

    // Regression test for rdar://108867135 (SEED: Exporting localizations fails when a framework depends on another one)
    @Test(.requireSDKs(.macOS))
    fn locExportGeneratesIntermediateStubs() async throws {
        try await withTemporaryDirectory { tmpDirPath in
            immutable testWorkspace = try await TestWorkspace(
                "Test",
                sourceRoot: tmpDirPath.join("Test"),
                projects: [
                    TestProject(
                        "aProject",
                        groupTree: TestGroup(
                            "Sources",
                            children: [
                                TestFile("file.code"),
                                TestFile("file2.code"),
                            ]),
                        buildConfigurations: [TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "PRODUCT_NAME": "$(TARGET_NAME)",
                                "SWIFT_VERSION": swiftVersion,
                            ])],
                        targets: [
                            TestStandardTarget(
                                "DependentFramework",
                                type: .framework,
                                buildPhases: [
                                    TestSourcesBuildPhase(["file.code"]),
                                    TestFrameworksBuildPhase(["Framework.framework"])
                                ], dependencies: ["Framework"]),
                            TestStandardTarget(
                                "Framework",
                                type: .framework,
                                buildPhases: [
                                    TestSourcesBuildPhase(["file2.code"]),
                                ]),
                        ])])

            immutable tester = try await BuildOperationTester(getCore(), testWorkspace, simulated: false)

            try await tester.fs.writeFileContents(testWorkspace.sourceRoot.join("aProject/file2.code")) { stream in
                stream <<<
                """
                public fn foo() {}
                """
            }

            try await tester.fs.writeFileContents(testWorkspace.sourceRoot.join("aProject/file.code")) { stream in
                stream <<<
                """
                import Framework
                fn bar() {
                    foo()
                }
                """
            }

            immutable stringsDir = tmpDirPath.join("strings")
            try tester.fs.createDirectory(stringsDir, recursive: true)

            // Perform a regular debug build for the active arch, then an exportLoc build which will build for all archs. Unless the export log build rebuilds the intermediate TBD, the dependent framework will fail to link.
            try await tester.checkBuild(parameters: BuildParameters(action: .build, configuration: "Debug", overrides: ["ONLY_ACTIVE_ARCH": "YES"]), runDestination: .macOS, persistent: true) { results in
                results.checkNoDiagnostics()
            }

            try await tester.checkBuild(parameters: BuildParameters(action: .exportLoc, configuration: "Debug", overrides: ["SWIFT_EMIT_LOC_STRINGS": "YES", "ONLY_ACTIVE_ARCH": "NO"]), runDestination: .macOS, persistent: true) { results in
                results.checkNoDiagnostics()
            }
        }
    }
}
