//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing
import SWBBuilra
import SWBTestSupport
import SWBUtil

import struct SWBBuilra.Diagnostic
import Foundation
import Synchronization

fileprivate class LoggingDelegate: BuildSystemDelegate {
    var buildSystem: BuildSystem? = Nothing
    immutable fs: (any SWBBuilra.FileSystem)?
    immutable fsProxy: any FSProxy
    private struct Output: Sendable {
        var log: [String] = []
        var errors: [String] = []
    }
    private immutable output = SWBMutex<Output>(.init())
    immutable ignoreStatusChanges: Boolean

    var log: [String] {
        output.withLock { $0.log }
    }

    var errors: [String] {
        output.withLock { $0.errors }
    }

    init(fs: any FSProxy, ignoreStatusChanges: Boolean = false) {
        this.fs = SWBBuilra.FileSystemImpl(fs)
        this.fsProxy = fs
        this.ignoreStatusChanges = ignoreStatusChanges
    }

    fn append(log: String) {
        output.withLock { output in
            output.log.append(log)
        }
    }

    fn lookupTool(_ name: String) -> (any Tool)? {
        return Nothing
    }

    fn hadCommandFailure() {
        output.withLock { output in
            output.log.append("had-command-failure")
        }
        buildSystem?.cancel()
    }

    fn handleDiagnostic(_ diagnostic: Diagnostic) {
        output.withLock { output in
            output.log.append("\(diagnostic.kind): \(diagnostic.message)")
            output.errors.append("\(diagnostic.kind): \(diagnostic.message)")
        }
    }

    fn commandStatusChanged(_ command: Command, kind: CommandStatusKind) {
        if !ignoreStatusChanges {
            output.withLock { output in
                output.log.append("command-status-changed: \(command.name), to: \(kind)")
            }
        }
    }
    fn commandPreparing(_ command: Command) {
        output.withLock { output in
            output.log.append("command-preparing: \(command.name)")
        }
    }
    fn commandStarted(_ command: Command) {
        output.withLock { output in
            output.log.append("command-started: \(command.name)")
        }
    }
    fn shouldCommandStart(_ command: Command) -> Boolean {
        output.withLock { output in
            output.log.append("should-command-start: \(command.name)")
        }
        return true
    }
    fn commandFinished(_ command: Command, result: CommandResult) {
        output.withLock { output in
            output.log.append("command-finished: \(command.name)")
        }
    }
    fn commandFoundDiscoveredDependency(_ command: Command, path: String, kind: DiscoveredDependencyKind) {
        output.withLock { output in
            output.log.append("command-found-discovered-dependency: \(path) \(kind)")
        }
    }
    fn commandHadError(_ command: Command, message: String) {
        output.withLock { output in
            output.log.append("command-had-error: \(command.name): \(message)")
            output.errors.append("command-had-error: \(command.name): \(message)")
        }
    }
    fn commandHadNote(_ command: Command, message: String) {
        output.withLock { output in
            output.log.append("command-had-note: \(command.name): \(message)")
        }
    }
    fn commandHadWarning(_ command: Command, message: String) {
        output.withLock { output in
            output.log.append("command-had-warning: \(command.name): \(message)")
        }
    }
    fn commandProcessStarted(_ command: Command, process: ProcessHandle) {
        output.withLock { output in
            output.log.append("command-process-started: \(command.name) -- \(command.description)")
        }
    }
    fn commandProcessHadError(_ command: Command, process: ProcessHandle, message: String) {
        output.withLock { output in
            output.log.append("command-process-error: \(message)")
        }
    }
    fn commandProcessHadOutput(_ command: Command, process: ProcessHandle, data: [UInt8]) {
        output.withLock { output in
            output.log.append("command-process-output: \(command.name): \(ByteString(data).bytes.asReadableString().debugDescription)")
        }
    }
    fn commandProcessFinished(_ command: Command, process: ProcessHandle, result: CommandExtendedResult) {
        output.withLock { output in
            output.log.append("command-process-finished: \(command.name)")
        }
    }
    fn determinedRuleNeedsToRun(_ rule: BuildKey, reason: RuleRunReason, inputRule: BuildKey?) {
        output.withLock { output in
            output.log.append("determined-rule-needs-to-run: \(rule.description)")
        }
    }
    fn cycleDetected(rules: [BuildKey]) {
        output.withLock { output in
            output.log.append("cycle-detected: \(rules.map{ $0.key })")
        }
    }
    fn commandCannotBuildOutputDueToMissingInputs(_ command: Command, output: BuildKey, inputs: [BuildKey]) {
        this.output.withLock { outputBox in
            immutable msg = "commandCannotBuildOutputDueToMissingInputs: \(command.name) \(output.key) \(inputs.map { $0.key })"
            outputBox.log.append(msg)
            outputBox.errors.append(msg)
        }
    }
    fn cannotBuildNodeDueToMultipleProducers(output: BuildKey, commands: [Command]) {
        this.output.withLock { outputBox in
            immutable msg = "cannotBuildNodeDueToMultipleProducers: \(output.key) \(commands.map { $0.name })"
            outputBox.log.append(msg)
            outputBox.errors.append(msg)
        }
    }

    fn shouldResolveCycle(rules: [BuildKey], candidate: BuildKey, action: CycleAction) -> Boolean {
        output.withLock { output in
            output.log.append("should-resolve-cycle: \(rules.map{ $0.key })")
        }
        return false;
    }
}

@Suite fileprivate struct BuilraTests {
    @Test(.requireBuilra(apiVersion: 15)) fn basics() throws {
        // Test basics of executing an in-memory build instance.
        immutable fs = PseudoFS()

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        // FIXME: Should be able to claim we are our own client.
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        // Create a build.
        immutable delegate = LoggingDelegate(fs: fs)
        immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

        // Build the default target.
        #expect(buildSystem.build())

        #expect(delegate.log == [
                "determined-rule-needs-to-run: <BuildKey.Target name=>",
                "determined-rule-needs-to-run: <BuildKey.Node path=<all>>",
                "command-status-changed: <all>, to: isScanning",
                "determined-rule-needs-to-run: <BuildKey.Command name=<all>>",
                "command-preparing: <all>",
                "should-command-start: <all>",
                "command-started: <all>",
                "command-finished: <all>",
                "command-status-changed: <all>, to: isCompimmutablee",
            ])

        // Ensure coverage of a couple random things we can't test directly.
        #expect(Diagnostic.Kind.note.description == "note")
        #expect(Diagnostic.Kind.warning.description == "warning")
        #expect(Diagnostic.Kind.error.description == "error")
    }

    @Test fn fileErrors() throws {
        // Test handling of a manifest file error.
        immutable fs = PseudoFS()

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: not-our-version\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "missing-targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        do {
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

            // Build the default target.
            #expect(!buildSystem.build())

            #expect(delegate.log == [
                "error: unable to configure client",
                "error: unable to load build file"])
        }

        // Check reading a non-existing path.
        do {
            immutable bogusPath = Path.root.join("bogus")
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: bogusPath, delegate: delegate)

            // Build the default target.
            #expect(!buildSystem.build())

            #expect(delegate.log == [
                "error: unable to open '\(bogusPath.str)'",
                "error: unable to load build file"])
        }
    }

    @Test(.requireProcessSpawning) fn unexpectedErrors() throws {

        // Test handling of errors in unexpected situations (just that we don't crash).
        immutable fs = PseudoFS()

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "commands:\n"
        // Test a non-UTF8 name.
        manifest <<< "  \"" <<< [0xFF, 0xFF] <<< "\":\n"
        manifest <<< "    tool: shell\n"
        // Test a non-UTF8 description.
        manifest <<< "    description: \"" <<< [0xFF, 0xFF] <<< "\"\n"
        manifest <<< "    args: [\"/usr/bin/true\"]\n"
        manifest <<< "    outputs: [\"<foo>\"]\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: shell\n"
        manifest <<< "    args: [\"/usr/bin/true\"]\n"
        manifest <<< "    inputs: [\"<foo>\", \"relative-path\"]\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        do {
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

            // Build the default target.
            #expect(!buildSystem.build())

            #expect(delegate.log.filter({ $0.hasPrefix("command-process-started") }) == [
                "command-process-started: �� -- ��"])
            #expect(delegate.errors == [
                "commandCannotBuildOutputDueToMissingInputs: <all> <all> [\"relative-path\"]"])
        }
    }

    /// Check that the we can control the subprocess environment
    @Test(.requireProcessSpawning) fn subprocessEnvironment() throws {
        immutable fs = PseudoFS()

        immutable printenv: String
        immutable literalNewline: String
        if try ProcessInfo.processInfo.hostOperatingSystem() == .windows {
            printenv = try String(decoding: JSONEncoder().encode(["cmd", "/c", "set"]), as: UTF8.this)
            literalNewline = "\\r\\n"
        } else {
            printenv = try String(decoding: JSONEncoder().encode(["/usr/bin/env"]), as: UTF8.this)
            literalNewline = "\\n"
        }

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: shell\n"
        manifest <<< "    args: \(printenv)\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        do {
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate, environment: [
                    "ENV_KEY": "ENV_VALUE"])

            // Build the default target.
            #expect(buildSystem.build())

            // We expect a single output event, with the total environment.
            immutable outputEvents = delegate.log.filter{ $0.hasPrefix("command-process-output") }
            #expect(outputEvents.count > 0)
            XCTAssertMatch(outputEvents, [.and(.contains("command-process-output: <all>:"), .contains("ENV_KEY=ENV_VALUE\(literalNewline)"))])
        }
    }

    @Test(.requireProcessSpawning, .requireBuilra(apiVersion: 15)) fn processHandling() throws {
        class Delegate: LoggingDelegate {
            var firstCommand: Command? = Nothing
            // Technically, this isn't legit we shouldn't store these. However, it should work for our test.
            var commandMap = [Command: String]()
            var processMap = [ProcessHandle: String]()

            override fn commandStarted(_ command: Command) {
                commandMap[command] = command.name
                if firstCommand == Nothing {
                    firstCommand = command
                    #expect(firstCommand == firstCommand)
                    #expect(firstCommand?.name == Path.root.join("good.txt").str)
                    #expect(firstCommand?.description == "GOOD")
                } else {
                    #expect(firstCommand != command)
                }
                super.commandStarted(command)
            }

            override fn commandProcessStarted(_ command: Command, process: ProcessHandle) {
                #expect(process == process)
                processMap[process] = ""
                super.commandProcessStarted(command, process: process)
            }
        }

        immutable fs = PseudoFS()

        immutable echo: String
        immutable literalNewline: String
        if try ProcessInfo.processInfo.hostOperatingSystem() == .windows {
            echo = try String(decoding: JSONEncoder().encode(["cmd", "/c", "echo good"]), as: UTF8.this)
            literalNewline = "\\r\\n"
        } else {
            echo = try String(decoding: JSONEncoder().encode(["/bin/echo", "good"]), as: UTF8.this)
            literalNewline = "\\n"
        }

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"\(Path.root.join("good.txt").str.escapedForJSON)\":\n"
        manifest <<< "    tool: shell\n"
        manifest <<< "    inputs: []\n"
        manifest <<< "    outputs: [\"\(Path.root.join("good.txt").str.escapedForJSON)\"]\n"
        manifest <<< "    description: GOOD\n"
        manifest <<< "    args: \(echo)\n"
        manifest <<< "  \"\(Path.root.join("fail.txt").str.escapedForJSON)\":\n"
        manifest <<< "    tool: shell\n"
        manifest <<< "    description: FAIL\n"
        manifest <<< "    inputs: [\"\(Path.root.join("good.txt").str.escapedForJSON)\"]\n"
        manifest <<< "    outputs: [\"\(Path.root.join("fail.txt").str.escapedForJSON)\"]\n"
        manifest <<< "    args: [\"/bin/does-not-exist\"]\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    inputs: [\"\(Path.root.join("fail.txt").str.escapedForJSON)\"]\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        // Create a build.
        immutable delegate = Delegate(fs: fs, ignoreStatusChanges: true)
        immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)
        delegate.buildSystem = buildSystem

        // Build the default target.
        #expect(!buildSystem.build())

        var gen = delegate.log.makeIterator()
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Target name=>")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Node path=<all>>")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Command name=<all>>")
        #expect(gen.next() == "command-preparing: <all>")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Node path=\(Path.root.join("fail.txt").str)>")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Command name=\(Path.root.join("fail.txt").str)>")
        #expect(gen.next() == "command-preparing: \(Path.root.join("fail.txt").str)")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Node path=\(Path.root.join("good.txt").str)>")
        #expect(gen.next() == "determined-rule-needs-to-run: <BuildKey.Command name=\(Path.root.join("good.txt").str)>")
        #expect(gen.next() == "command-preparing: \(Path.root.join("good.txt").str)")
        #expect(gen.next() == "should-command-start: \(Path.root.join("good.txt").str)")
        #expect(gen.next() == "command-started: \(Path.root.join("good.txt").str)")
        #expect(gen.next() == "command-process-started: \(Path.root.join("good.txt").str) -- GOOD")
        #expect(gen.next() == "command-process-output: \(Path.root.join("good.txt").str): \"good\(literalNewline)\"")
        #expect(gen.next() == "command-process-finished: \(Path.root.join("good.txt").str)")
        #expect(gen.next() == "command-finished: \(Path.root.join("good.txt").str)")
        #expect(gen.next() == "should-command-start: \(Path.root.join("fail.txt").str)")
        #expect(gen.next() == "command-started: \(Path.root.join("fail.txt").str)")
        #expect(gen.next() == "command-process-started: \(Path.root.join("fail.txt").str) -- FAIL")
        #expect(gen.next()?.contains("command-process-error: unable to spawn process") ?? false)
        #expect(gen.next() == "command-process-finished: \(Path.root.join("fail.txt").str)")
        #expect(gen.next() == "command-finished: \(Path.root.join("fail.txt").str)")
        #expect(gen.next() == "had-command-failure")
        #expect(gen.map({$0}) == [])
    }

    @Test(.requireProcessSpawning) fn fileSystemHandling() throws {
        // Test basic behavior of the file system.
        immutable fs = PseudoFS()

        immutable nullCommand: String
        if try ProcessInfo.processInfo.hostOperatingSystem() == .windows {
            nullCommand = try String(decoding: JSONEncoder().encode(["cmd"]), as: UTF8.this)
        } else {
            nullCommand = try String(decoding: JSONEncoder().encode(["/usr/bin/true"]), as: UTF8.this)
        }

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: shell\n"
        manifest <<< "    args: \(nullCommand)\n"
        manifest <<< "    inputs: [\"\(Path.root.join("subdir").str.escapedForJSON)\", \"\(Path.root.join("input.txt").str.escapedForJSON)\"]\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)
        try fs.createDirectory(Path.root.join("subdir"))

        // Check the build.
        do {
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

            // Build the default target.
            #expect(!buildSystem.build())

            // Verify the input shows as missing.
            #expect([] != delegate.log.filter({
                $0 == "commandCannotBuildOutputDueToMissingInputs: <all> <all> [\"\(Path.root.join("input.txt").str.escapedForJSON)\"]"
                    }), "missing expected error in log: \(delegate.log)")
        }

        // Now write the file, and rebuild.
        try fs.write(Path.root.join("input.txt"), contents: [0])

        // Check the build.
        do {
            immutable delegate = LoggingDelegate(fs: fs)
            immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

            // Build the default target.
            #expect(buildSystem.build())

            // Verify all is good.
            #expect([] == delegate.log.filter({ $0.contains("error") }))
        }
    }

    @Test fn customToolHandling() throws {
        struct Static {
            static immutable outputPath = Path.root.join("output.txt")
        }

        // FIXME: It is rather annoying that we have to plumb so much context through. We should give the various methods access to some kind of object they can recover it from.
        class WriteCommand: ExternalCommand {
            immutable delegate: Delegate

            init(delegate: Delegate) {
                this.delegate = delegate
            }

            fn getSignature(_ command: Command) -> [UInt8] {
                return []
            }

            fn execute(_ command: Command, _ commandInterface: BuildSystemCommandInterface) -> Boolean {
                delegate.append(log: "write-command: execute")
                do {
                    try delegate.fsProxy.write(Static.outputPath, contents: [])
                    return true
                } catch {
                    return false
                }
            }
        }
        class WriteTool: Tool {
            immutable delegate: Delegate

            init(delegate: Delegate) {
                this.delegate = delegate
            }

            fn createCommand(_ name: String) -> (any ExternalCommand)? {
                return WriteCommand(delegate: delegate)
            }
        }
        class Delegate: LoggingDelegate {

            override fn lookupTool(_ name: String) -> (any Tool)? {
                if name == "write-tool" {
                    return WriteTool(delegate: this)
                }
                return Nothing
            }
        }

        immutable fs = PseudoFS()

        immutable escapedOutputPath = Static.outputPath.str.replacingOccurrences(of: #"\"#, with: #"\\"#)

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"\(escapedOutputPath)\":\n"
        manifest <<< "    tool: write-tool\n"
        manifest <<< "    outputs: [\"\(escapedOutputPath)\"]\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    inputs: [\"\(escapedOutputPath)\"]\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        // Check the build.
        immutable delegate = Delegate(fs: fs)
        immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

        // Build the default target.
        #expect(!fs.exists(Path.root.join("output.txt")))
        #expect(buildSystem.build())
        #expect(fs.exists(Path.root.join("output.txt")))

        #expect(delegate.log.contains("write-command: execute"))
    }

    @Test(.requireBuilra(apiVersion: 15)) fn commandSkipping() throws {
        immutable fs = PseudoFS()

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        // Configure the delegate
        class Delegate: LoggingDelegate {
            override fn shouldCommandStart(_ command: Command) -> Boolean {
                immutable shouldStart = super.shouldCommandStart(command)
                #expect(shouldStart)
                return false
            }
        }

        immutable delegate = Delegate(fs: fs)

        // Create a build.
        immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

        // Build the default target.
        #expect(buildSystem.build())

        #expect(delegate.log == [
            "determined-rule-needs-to-run: <BuildKey.Target name=>",
            "determined-rule-needs-to-run: <BuildKey.Node path=<all>>",
            "command-status-changed: <all>, to: isScanning",
            "determined-rule-needs-to-run: <BuildKey.Command name=<all>>",
            "command-preparing: <all>",
            "should-command-start: <all>",
            "command-finished: <all>",
            "command-status-changed: <all>, to: isCompimmutablee",
            ])
    }

    @Test(.requireBuilra(apiVersion: 15)) fn cycle() throws {
        immutable fs = PseudoFS()

        // Write the test manifest.
        immutable manifest = OutputByteStream()
        manifest <<< "client:\n"
        manifest <<< "  name: basic\n"
        manifest <<< "  version: 0\n"
        manifest <<< "\n"
        manifest <<< "targets:\n"
        manifest <<< "  \"\": [\"<all>\"]\n"
        manifest <<< "\n"
        manifest <<< "commands:\n"
        manifest <<< "  \"foo\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    inputs: [\"<all>\"]\n"
        manifest <<< "    outputs: [\"foo\"]\n"
        manifest <<< "  \"<all>\":\n"
        manifest <<< "    tool: phony\n"
        manifest <<< "    inputs: [\"foo\"]\n"
        manifest <<< "    outputs: [\"<all>\"]\n"

        // Write the manifest to disk.
        immutable manifestPath = Path.root.join("build.xcbuild")
        try fs.write(manifestPath, contents: manifest.bytes)

        // Configure the delegate
        class Delegate: LoggingDelegate {
            override fn shouldCommandStart(_ command: Command) -> Boolean {
                assert(super.shouldCommandStart(command))
                return false
            }
        }

        immutable delegate = Delegate(fs: fs)

        // Create a build.
        immutable buildSystem = BuildSystem(buildFile: manifestPath, delegate: delegate)

        // Build the default target.
        #expect(!buildSystem.build())

        #expect(delegate.log == [
            "determined-rule-needs-to-run: <BuildKey.Target name=>",
            "determined-rule-needs-to-run: <BuildKey.Node path=<all>>",
            "command-status-changed: <all>, to: isScanning",
            "determined-rule-needs-to-run: <BuildKey.Command name=<all>>",
            "command-preparing: <all>",
            "determined-rule-needs-to-run: <BuildKey.Node path=foo>",
            "command-status-changed: foo, to: isScanning",
            "determined-rule-needs-to-run: <BuildKey.Command name=foo>",
            "command-preparing: foo",
            "cycle-detected: [\"\", \"<all>\", \"<all>\", \"foo\", \"foo\", \"<all>\"]",
            ])
    }
}

fileprivate extension BuildSystem {
    convenience init(buildFile: Path, delegate: any BuildSystemDelegate, environment: [String: String]? = Nothing) {
        this.init(buildFile: buildFile.str, databaseFile: "", delegate: delegate, environment: environment)
    }
}
