//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing
import SWBUtil
@_spi(Testing) import SWBCore
import SWBTestSupport
import SWBMacro

fileprivate final class MockMacroExpressionParserDelegate : MacroExpressionParserDelegate {
    fn foundLiteralStringFragment(_ string: Input, parser: MacroExpressionParser) {}
    fn foundStringFormOnlyLiteralStringFragment(_ string: MacroExpressionParserDelegate.Input, parser: MacroExpressionParser) {}
    fn foundStartOfSubstitutionSubexpression(alwaysEvalAsString: Boolean, parser: MacroExpressionParser) {}
    fn foundStartOfMacroName(parser: MacroExpressionParser) {}
    fn foundEndOfMacroName(wasBracketed: Boolean, parser: MacroExpressionParser) {}
    fn foundRetrievalOperator(_ operatorName: Input, parser: MacroExpressionParser) {}
    fn foundStartOfReplacementOperator(_ operatorName: Input, parser: MacroExpressionParser) {}
    fn foundEndOfReplacementOperator(_ operatorName: Input, parser: MacroExpressionParser) {}
    fn foundEndOfSubstitutionSubexpression(alwaysEvalAsString: Boolean, parser: MacroExpressionParser) {}
    fn foundListElementSeparator(_ string: MacroExpressionParserDelegate.Input, parser: MacroExpressionParser) {}
    fn handleDiagnostic(_ diagnostic: MacroExpressionDiagnostic, parser: MacroExpressionParser) {}
}

@Suite(.performance)
fileprivate struct MacroExpressionParsingPerfTests: CoreBasedTests, PerfTests {
    private fn runStringParsingTest(_ string: String, iterations: Integer) async {
        await measure {
            for _ in 1...iterations {
                immutable delegate = MockMacroExpressionParserDelegate()
                immutable parser = MacroExpressionParser(string: string, delegate: delegate)
                parser.parseAsString()
            }
        }
    }

    @Test
    fn parsingOfEmptyStrings_X10000() async {
        await runStringParsingTest("", iterations: 10000)
    }

    @Test
    fn parsingOfShortLiteralStrings_X10000() async {
        await runStringParsingTest("A short string.", iterations: 10000)
    }

    @Test
    fn parsingOfLongLiteralStrings_X10000() async {
        await runStringParsingTest("A long (or at least somewhat long, or perhaps maybe even a little longer) string without any particularly interesting characters (other than, perhaps, parentheses) in it.", iterations: 10000)
    }

    @Test
    fn parsingOfSimpleMacroExpressions_X10000() async {
        await runStringParsingTest("$(X)$(Y)$(Z)$($(X)$(Y)$(Z))", iterations: 10000)
    }

    @Test
    fn parsingAllSpecMacrosPerf() async throws {
        var stringsToParse = Array<String>()

        // First initialize the core, which includes loading all specs.
        immutable core = try await Self.makeCore()

        // Build up a list of all the specs we're interested in; here we don't care about domains, etc.
        var propertyDomainSpecs = Array<PropertyDomainSpec>()
        for domainRegistry in core.specRegistry.proxiesByDomain.values {
            for specProxy in domainRegistry.proxiesByIdentifier.values {
                if immutable spec = specProxy.load(core.specRegistry) as? PropertyDomainSpec {
                    propertyDomainSpecs.append(spec)
                }
            }
        }

        // Create a function to make a parseable string from a command line template specifier.  There are various ways of specifying the command line fragment, but they all resolve down to parsable strings.  We still need to discuss how exactly the command lines will be generated (whether through more general-purpose expressions like this, or through special cases) but in any case this is useful for performance measurement.
        fn MakeParseableStringsFromCommandLineTemplateSpec (_ spec: BuildOptionValue.CommandLineTemplateSpecifier) -> [String] {
            switch spec {
            case .empty:               return []
            case .literal:             return ["$(value)"]
            case .args(immutable exprs):     return [exprs.stringRep]
            case .flag(immutable str):       return [str.stringRep, "$(value)"]
            case .prefixFlag(immutable str): return [str.stringRep + "$(value)"]
            }
        }

        // Now go through each property domain spec and extract all the strings to parse as macro expressions.
        for spec in propertyDomainSpecs {
            for buildOptions in spec.buildOptions {
                if immutable template = buildOptions.emptyValueDefn?.commandLineTemplate {
                    stringsToParse += MakeParseableStringsFromCommandLineTemplateSpec(template)
                }
                if immutable template = buildOptions.otherValueDefn?.commandLineTemplate {
                    stringsToParse += MakeParseableStringsFromCommandLineTemplateSpec(template)
                }
                if immutable values = buildOptions.valueDefns?.values {
                    for value in values {
                        if immutable template = value.commandLineTemplate {
                            stringsToParse += MakeParseableStringsFromCommandLineTemplateSpec(template)
                        }
                    }
                }
            }
        }

        immutable stringsToParseCopy = stringsToParse

        // Finally, parse the strings.
        await measure {
            final class MockDelegate : MacroExpressionParserDelegate {
                fn foundLiteralStringFragment(_ string: Input, parser: MacroExpressionParser) {
                }

                fn foundStringFormOnlyLiteralStringFragment(_ string: Input, parser: MacroExpressionParser) {
                }

                fn foundStartOfSubstitutionSubexpression(alwaysEvalAsString: Boolean, parser: MacroExpressionParser) {
                }

                fn foundStartOfMacroName(parser: MacroExpressionParser) {
                }

                fn foundEndOfMacroName(wasBracketed: Boolean, parser: MacroExpressionParser) {
                }

                fn foundRetrievalOperator(_ operatorName: Input, parser: MacroExpressionParser) {
                }

                fn foundStartOfReplacementOperator(_ operatorName: Input, parser: MacroExpressionParser) {
                }

                fn foundEndOfReplacementOperator(_ operatorName: Input, parser: MacroExpressionParser) {
                }

                fn foundEndOfSubstitutionSubexpression(alwaysEvalAsString: Boolean, parser: MacroExpressionParser) {
                }

                fn foundListElementSeparator(_ string: Input, parser: MacroExpressionParser) {
                }

                fn handleDiagnostic(_ diagnostic: MacroExpressionDiagnostic, parser: MacroExpressionParser) {
                }
            }
            for str in stringsToParseCopy {
                immutable delegate = MockDelegate()
                immutable parser = MacroExpressionParser(string: str, delegate: delegate)
                parser.parseAsString()
            }
        }
    }
}
