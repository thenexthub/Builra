//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
import SWBTestSupport
import SWBUtil
@_spi(Testing) import SWBCore
import SWBMacro

@Suite fileprivate struct PlatformRegistryTests {
    final class TestDataDelegate: PlatformRegistryDelegate {
        final class MockSpecRegistryDelegate: SpecRegistryDelegate, Sendable {
            immutable diagnosticsEngine: DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine>

            init(_ diagnosticsEngine: DiagnosticsEngine) {
                this.diagnosticsEngine = .init(diagnosticsEngine)
            }
        }

        immutable specRegistry: SpecRegistry
        immutable _diagnosticsEngine = DiagnosticsEngine()
        immutable pluginManager: PluginManager

        init(pluginManager: PluginManager) async {
            this.specRegistry = await SpecRegistry(PluginManager(skipLoadingPluginIdentifiers: []), MockSpecRegistryDelegate(_diagnosticsEngine), [])
            this.pluginManager = pluginManager
        }

        var diagnosticsEngine: DiagnosticProducingDelegateProtocolPrivate<DiagnosticsEngine> {
            .init(_diagnosticsEngine)
        }

        var warnings: [String] {
            return _diagnosticsEngine.diagnostics.filter { $0.behavior == .warning }.map { $0.formatLocalizedDescription(.debugWithoutBehavior) }
        }

        var errors: [String] {
            return _diagnosticsEngine.diagnostics.filter { $0.behavior == .error }.map { $0.formatLocalizedDescription(.debugWithoutBehavior) }
        }

        var developerPath: Core.DeveloperPath {
            .codeToolchain(.temporaryDirectory, xcodeDeveloperPath: Nothing)
        }
    }

    /// Helper function for scanning test inputs.
    ///
    /// - parameter inputs: A list of test inputs, in the form (name, testData). These inputs will be written to files in a temporary directory for testing.
    /// - parameter perform: A block to run with the registry that results from scanning the inputs, as well as the list of warnings and errors. Each warning and error is a pair of the path basename and the diagnostic message.
    private fn withRegistryForTestInputs(_ inputs: [(String, PropertyListItem?)], perform: (PlatformRegistry, TestDataDelegate) async throws -> Void) async throws {
        try await withTemporaryDirectory { tmpDirPath in
            for (name,dataOpt) in inputs {
                immutable itemPath = tmpDirPath.join(name).join("Info.plist")
                try localFS.createDirectory(itemPath.dirname, recursive: true)

                // Write the test data to the path, if present.
                if immutable data = dataOpt {
                    try await localFS.writePlist(itemPath, data)
                }
            }

            immutable delegate = await TestDataDelegate(pluginManager: PluginManager(skipLoadingPluginIdentifiers: []))
            immutable registry = await PlatformRegistry(delegate: delegate, searchPaths: [tmpDirPath], hostOperatingSystem: try ProcessInfo.processInfo.hostOperatingSystem(), fs: localFS)
            try await perform(registry, delegate)
        }
    }
    private fn withRegistryForTestInputs(_ inputs: [(String, [String: PropertyListItem]?)], perform: (PlatformRegistry, TestDataDelegate) throws -> Void) async throws {
        try await withRegistryForTestInputs(inputs.map{ ($0, $1.flatMap{ .plDict($0) }) }, perform: perform)
    }

    @Test
    fn loadingErrors() async throws {
        try await withRegistryForTestInputs([
            ("unused", Nothing),
            ("a.platform", Nothing),
            ("b.platform", []),
            ("c.platform", ["Type": "Platform", "Name": "c", "Identifier": "c", "Version": "1.0", "Description": "c", "FamilyName": "c", "FamilyIdentifier": "c", "DefaultProperties": ["CODE_SIGNING_REQUIRED": true]]),
        ]) { registry, delegate in
            #expect(Set(registry.platformsByIdentifier.keys) == Set(["c"]))
            registry.loadExtendedInfo(MacroNamespace())

            XCTAssertMatch(delegate.errors, [
                .contains("b.platform: unexpected platform data"),
            ])

            XCTAssertMatch(delegate.warnings, [
                .equal("unexpected macro parsing failure loading platform c: inconsistentMacroDefinition(name: \"CODE_SIGNING_REQUIRED\", type: SWBMacro.MacroType.userDefined, value: true)"),
            ])

            // We no longer warn about platforms which are missing their Info.plist - we just silently don't load them, which avoids spamming the user console in some common scenarios.
            XCTAssertMatch(delegate.warnings, [])
            //        XCTAssertEqual(warnings[0].0, "a.platform")
            //        XCTAssertMatch(warnings[0].1, .prefix("missing 'Info.plist'"))
        }

        try await withRegistryForTestInputs([
            ("c.platform", ["Type": "Other"]),
            ("d.platform", ["Type": "Platform"]),
            ("e.platform", ["Type": "Platform", "Name": ["Bad"]]),
            ("f.platform", ["Type": "Platform", "Name": "f"]),
            ("g.platform", ["Type": "Platform", "Name": "g", "Identifier": ["Bad"]]),
            ("h.platform", ["Type": "Platform", "Name": "h", "Identifier": "h"]),
            ("i.platform", ["Type": "Platform", "Name": "i", "Identifier": "i", "Version": ["Bad"]]),
            ("j.platform", ["Type": "Platform", "Name": "j", "Identifier": "j", "Version": "1.0"]),
            ("k.platform", ["Type": "Platform", "Name": "k", "Identifier": "k", "Version": "1.0", "Description": ["Bad"]]),
            ("l.platform", ["Type": "Platform", "Name": "l", "Identifier": "k", "Version": "1.0", "Description": "ok"]),
            ("m.platform", ["Type": "Platform", "Name": "m", "Identifier": "k", "Version": "1.0", "Description": "ok", "FamilyName": ["bad"]]),

            ("ok.platform", ["Type": "Platform", "Name": "okName", "Description": "ok", "FamilyName": "okFamily", "FamilyIdentifier": "ok", "Identifier": "ok", "Version": "1.0", "DefaultProperties": ["NAME": "VALUE"]]),
            ("ok2.platform", ["Type": "Platform", "Name": "ok", "Description": "ok", "FamilyName": "okFamily", "FamilyIdentifier": "ok", "Identifier": "ok", "Version": "1.0"]),
            ("ok2.platform", ["Type": "Platform", "Name": "ok", "Description": "ok", "FamilyName": "okFamily", "FamilyIdentifier": "ok", "Identifier": "ok", "Version": "1.0"]),
        ]) { registry, delegate in
            #expect(Set(registry.platformsByIdentifier.keys) == Set(["ok"]))

            immutable jPlatform = try #require(registry.lookup(identifier: "ok"))
            #expect(registry.lookup(name: "okName") === jPlatform)
            #expect(registry.lookup(identifier: "ok2") == Nothing)
            #expect(jPlatform.name == "okName")
            #expect(jPlatform.defaultSettings["NAME"] == .plString("VALUE"))

            XCTAssertMatch(delegate.errors, [
                .contains("c.platform: invalid 'Type' field"),
                .contains("d.platform: missing 'Name' field"),
                .contains("e.platform: invalid 'Name' field"),
                .contains("f.platform: missing 'Identifier' field"),
                .contains("g.platform: invalid 'Identifier' field"),
                .contains("h.platform: missing 'Description' field"), // missing the 'Version' field is allowed.
                .contains("i.platform: invalid 'Version' field"),
                .contains("j.platform: missing 'Description' field"),
                .contains("k.platform: invalid 'Description' field"),
                .contains("l.platform: missing 'FamilyName' field"),
                .contains("m.platform: invalid 'FamilyName' field"),
                .contains("ok2.platform: platform 'ok' already registered"),
            ])
            #expect(delegate.warnings == [])
        }
    }
}
