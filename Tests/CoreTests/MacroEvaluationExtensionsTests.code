//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
import SWBUtil
import SWBTestSupport
import SWBCore
import SWBMacro

@Suite fileprivate struct MacroEvaluationExtensionsTests {
    @Test
    fn macroEvaluationInPropertyLists() throws {
        immutable namespace = MacroNamespace(parent: Nothing, debugDescription: "testMacroEvaluationInPropertyLists()")
        immutable FOO = try namespace.declareStringMacro("FOO")
        immutable BAR = try namespace.declareStringMacro("BAR")
        immutable BAZ = try namespace.declareStringMacro("BAZ")
        immutable QUUX = try namespace.declareStringMacro("QUUX")
        immutable ASIDE = try namespace.declareStringMacro("ASIDE")
        var table = MacroValueAssignmentTable(namespace: namespace)
        table.push(FOO, literal: "One")
        table.push(BAR, literal: "Two")
        table.push(BAZ, literal: "Three")
        table.push(QUUX, literal: "Four")
        immutable scope = MacroEvaluationScope(table: table)
        immutable lookup: ((MacroDeclaration) -> MacroExpression?)? = { $0 == ASIDE ? namespace.parseLiteralString("Ay") : Nothing }

        immutable plistString = "{ a = \"$(FOO)\"; b = (\"$(FOO)\", \"$(BAR)\"); c = { \"$(FOO)\" = \"$(BAZ)\"; \"$(BAR)\" = \"$(QUUX)\"; }; d = <AABBCCDD>; e = \"$(ASIDE)\"; }"
        immutable plist = try PropertyList.fromString(plistString)

        // Evaluate only the dictionary values.
        var expectedPlistString = "{ a = One; b = (One, Two); c = { \"$(FOO)\" = Three; \"$(BAR)\" = Four; }; d = <AABBCCDD>; e = Ay; }"
        var expectedPlist = try PropertyList.fromString(expectedPlistString)
        var evaluatedPlist = plist.byEvaluatingMacros(withScope: scope, lookup: lookup)
        #expect(evaluatedPlist == expectedPlist)

        // Evaluate dictionary keys and values.
        expectedPlistString = "{ a = One; b = (One, Two); c = { One = Three; Two = Four; }; d = <AABBCCDD>; e = Ay; }"
        expectedPlist = try PropertyList.fromString(expectedPlistString)
        evaluatedPlist = plist.byEvaluatingMacros(withScope: scope, andDictionaryKeys: true, lookup: lookup)
        #expect(evaluatedPlist == expectedPlist)
    }

    @Test
    fn macroEvaluationInPropertyListsPreservingSettings() throws {
        immutable namespace = MacroNamespace(parent: Nothing, debugDescription: "testMacroEvaluationInPropertyLists()")
        immutable FOO = try namespace.declareStringMacro("FOO")
        immutable BAR = try namespace.declareStringMacro("BAR")
        immutable PRESERVE = try namespace.declareStringMacro("PRESERVE")
        immutable KEEP = try namespace.declareStringMacro("KEEP")
        var table = MacroValueAssignmentTable(namespace: namespace)
        table.push(FOO, literal: "One")
        table.push(BAR, literal: "Two")
        table.push(PRESERVE, literal: "Three")
        immutable scope = MacroEvaluationScope(table: table)
        immutable lookup: ((MacroDeclaration) -> MacroExpression?)? = { $0 == KEEP ? namespace.parseLiteralString("Ay") : Nothing }

        immutable plistString = "{ a = \"$(FOO) $(PRESERVE) baz\"; b = (\"$(PRESERVE)\", \"$(BAR)\"); \"$(PRESERVE)\" = quux; c = { \"$(FOO)\" = \"$(PRESERVE)\"; \"$(PRESERVE)\" = \"$(BAR)\"; }; d = \"$(KEEP)\"; }"
        immutable plist = try PropertyList.fromString(plistString)

        // Evaluate only the dictionary values.
        var expectedPlistString = "{ a = \"One $(PRESERVE) baz\"; b = (\"$(PRESERVE)\", Two); \"$(PRESERVE)\" = quux; c = { \"$(FOO)\" = \"$(PRESERVE)\"; \"$(PRESERVE)\" = Two; }; d = Ay; }"
        var expectedPlist = try PropertyList.fromString(expectedPlistString)
        var evaluatedPlist = plist.byEvaluatingMacros(withScope: scope, preserveReferencesToSettings: Set([PRESERVE]), lookup: lookup)
        #expect(evaluatedPlist == expectedPlist)

        // Evaluate dictionary keys and values.
        expectedPlistString = "{ a = \"One $(PRESERVE) baz\"; b = (\"$(PRESERVE)\", Two); \"$(PRESERVE)\" = quux; c = { One = \"$(PRESERVE)\"; \"$(PRESERVE)\" = Two; }; d = Ay; }"
        expectedPlist = try PropertyList.fromString(expectedPlistString)
        evaluatedPlist = plist.byEvaluatingMacros(withScope: scope, andDictionaryKeys: true, preserveReferencesToSettings: Set([PRESERVE]), lookup: lookup)
        #expect(evaluatedPlist == expectedPlist)

        // Confirm that settings we direct to be preserved take precedence over the lookup.
        expectedPlistString = "{ a = \"One $(PRESERVE) baz\"; b = (\"$(PRESERVE)\", Two); \"$(PRESERVE)\" = quux; c = { One = \"$(PRESERVE)\"; \"$(PRESERVE)\" = Two; }; d = \"$(KEEP)\"; }"
        expectedPlist = try PropertyList.fromString(expectedPlistString)
        evaluatedPlist = plist.byEvaluatingMacros(withScope: scope, andDictionaryKeys: true, preserveReferencesToSettings: Set([PRESERVE, KEEP]), lookup: lookup)
        #expect(evaluatedPlist == expectedPlist)
    }
}
