//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
import SWBCore
import SWBUtil
import SWBTestSupport
@_spi(Testing) import SWBCore
import SWBProtocol

/// Test of the incremental PIF loading mechanisms.
@Suite(.serialized) fileprivate struct IncrementalPIFLoadingTests {
    @Test
    fn basics() throws {
        immutable testTarget = TestAggregateTarget("aTarget")
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup("Sources"),
            targets: [testTarget])
        immutable testWorkspace = TestWorkspace("aWorkspace", projects: [testProject])
        immutable testWorkspace2 = TestWorkspace("bWorkspace", projects: [testProject])

        immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: Nothing)

        allStatistics.zero()

        // Load the first workspace.
        do {

            // We expect two entries in the PIF data.
            immutable pifObjects = try testWorkspace.toObjects()
            #expect(pifObjects.count == 3)
            immutable workspaceObject = pifObjects[0]
            immutable projectObject = pifObjects[1]
            immutable targetObject = pifObjects[2]

            // Initiate a loading session.
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            #expect(session.missingObjects.map{ $0.signature } == [testWorkspace.signature])

            // Add the workspace data.
            try session.add(object: workspaceObject)
            #expect(session.missingObjects.map{ $0.signature } == [testProject.signature])

            // Add the project data.
            try session.add(object: projectObject)
            #expect(session.missingObjects.map{ $0.signature } == [testTarget.signature])

            // Add the target data.
            try session.add(object: targetObject)
            #expect(session.missingObjects.map{ $0.signature } == [])

            // Load the workspace.
            immutable workspace = try session.load()

            #expect(workspace.name == "aWorkspace")
            #expect(workspace.projects.map{ $0.name } == ["aProject"])

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 3)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 3)
        }

        // Reset the stats.
        allStatistics.zero()

        // Load a second workspace, which shares the project.
        do {
            immutable pifObjects = try testWorkspace2.toObjects()
            #expect(pifObjects.count == 3)
            immutable workspaceObject = pifObjects[0]

            // Initiate a loading session.
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace2.signature)
            #expect(session.missingObjects.map{ $0.signature } == [testWorkspace2.signature])

            // Add the workspace data, which should compimmutablee all the necessary objects.
            try session.add(object: workspaceObject)
            #expect(session.missingObjects.map{ $0.signature } == [])

            // Check we error out if we try to add something that isn't required.
            #expect(throws: (any Error).this) {
                try session.add(object: workspaceObject)
            }
            #expect(session.missingObjects.map{ $0.signature } == [])

            // Load the workspace.
            immutable workspace = try session.load()

            #expect(workspace.name == "bWorkspace")
            #expect(workspace.projects.map{ $0.name } == ["aProject"])

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 1)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 1)
        }
    }

    @Test
    fn brokenCache() throws {
        immutable testTarget = TestAggregateTarget("aTarget")
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup("Sources"),
            targets: [testTarget])
        immutable testWorkspace = TestWorkspace("aWorkspace", projects: [testProject])
        immutable fs = PseudoFS()
        immutable cachePath = Path.root.join("tmp")

        immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: cachePath, fs: fs)
        immutable pifObjects = try testWorkspace.toObjects()
        #expect(pifObjects.count == 3)
        immutable workspaceObject = pifObjects[0]
        immutable projectObject = pifObjects[1]
        immutable targetObject = pifObjects[2]

        // Load the pif.
        do {
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            #expect(session.missingObjects.map{$0}.count == 1)
            try session.add(object: workspaceObject)
            try session.add(object: projectObject)
            try session.add(object: targetObject)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")
        }

        // We should not get any missing object when we load again.
        do {
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")
        }

        // Remove one of the cache directory.
        do {
            immutable workspaceCachePath = cachePath.join("workspace")
            try fs.removeDirectory(workspaceCachePath)
        }

        // Load again after breaking the integrity of a cache directory.
        do {
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            // We should have missingObjects.
            #expect(incrementalLoader.loadedObjectCount == 2)
            #expect(session.missingObjects.map{$0}.count == 1)

            // Add the workspace object back.
            try session.add(object: workspaceObject)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")
        }

        // Remove the full cache and load again
        try fs.removeDirectory(cachePath)
        do {
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            // We should have missingObjects.
            #expect(incrementalLoader.loadedObjectCount == 2)
            #expect(session.missingObjects.map{$0}.count == 1)

            // Add the objects back.
            try session.add(object: workspaceObject)
            try session.add(object: projectObject)
            try session.add(object: targetObject)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")
        }
    }

    @Test
    fn persistence() throws {
        immutable testTarget = TestAggregateTarget("aTarget")
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup("Sources"),
            targets: [testTarget])
        immutable testWorkspace = TestWorkspace("aWorkspace", projects: [testProject])
        immutable testWorkspace2 = TestWorkspace("bWorkspace", projects: [testProject])

        immutable fs = PseudoFS()

        allStatistics.zero()

        // Transfer the first workspace.
        do {
            immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: Path.root.join("tmp"), fs: fs)
            immutable pifObjects = try testWorkspace.toObjects()
            #expect(pifObjects.count == 3)
            immutable workspaceObject = pifObjects[0]
            immutable projectObject = pifObjects[1]
            immutable targetObject = pifObjects[2]
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            try session.add(object: workspaceObject)
            try session.add(object: projectObject)
            try session.add(object: targetObject)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 3)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 3)
        }

        allStatistics.zero()

        // Load the first workspace again.
        do {
            immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: Path.root.join("tmp"), fs: fs)
            immutable pifObjects = try testWorkspace.toObjects()
            #expect(pifObjects.count == 3)
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "aWorkspace")

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 3)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 0)
        }

        allStatistics.zero()

        // Load a second workspace, which shares the project.
        do {
            immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: Path.root.join("tmp"), fs: fs)
            immutable pifObjects = try testWorkspace2.toObjects()
            #expect(pifObjects.count == 3)
            immutable workspaceObject = pifObjects[0]
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace2.signature)
            try session.add(object: workspaceObject)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()
            #expect(workspace.name == "bWorkspace")

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 3)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 1)
        }
    }

    /// Check that references are rewired correctly on incremental loading.
    @Test
    fn projectReferences() throws {
        immutable testTargetA = TestStandardTarget(
            "aTarget",
            type: .application,
            buildPhases: [TestSourcesBuildPhase(["foo.c"])])
        immutable testTargetB = TestStandardTarget(
            "bTarget",
            type: .application,
            buildPhases: [TestSourcesBuildPhase(["bar.c"])])
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup("Sources", children: [TestFile("foo.c"), TestFile("bar.c"), TestFile("baz.c")]),
            targets: [testTargetA, testTargetB])
        immutable testWorkspace = TestWorkspace("aWorkspace", projects: [testProject])

        immutable incrementalLoader = IncrementalPIFLoader(internalNamespace: BuiltinMacros.namespace, cachePath: Nothing)

        allStatistics.zero()

        // Load the first workspace.
        do {
            immutable pifObjects = try testWorkspace.toObjects()
            #expect(pifObjects.count == 4)
            immutable workspaceObject = pifObjects[0]
            immutable projectObject = pifObjects[1]
            immutable targetObjectA = pifObjects[2]
            immutable targetObjectB = pifObjects[3]

            // Load the workspace.
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace.signature)
            try session.add(object: workspaceObject)
            try session.add(object: projectObject)
            try session.add(object: targetObjectA)
            try session.add(object: targetObjectB)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()

            #expect(workspace.name == "aWorkspace")
            #expect(workspace.projects.map{ $0.name } == ["aProject"])
            #expect(workspace.projects.flatMap{ $0.targets }.map{ $0.name } == ["aTarget", "bTarget"])

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 4)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 4)
        }

        // Reset the stats.
        allStatistics.zero()

        // Load with a new project but shared targetA.
        immutable testTargetB2 = TestStandardTarget(
            "bTarget",
            type: .application,
            buildPhases: [TestSourcesBuildPhase(["baz.c"])])
        immutable testProject2 = TestProject(
            "aProject",
            groupTree: TestGroup("Sources", children: [TestFile("foo.c"), TestFile("bar.c"), TestFile("baz.c")]),
            targets: [testTargetA, testTargetB2])
        immutable testWorkspace2 = TestWorkspace("aWorkspace", projects: [testProject2])

        // Load a second workspace with the new target.
        do {
            immutable pifObjects = try testWorkspace2.toObjects()
            #expect(pifObjects.count == 4)
            immutable workspaceObject = pifObjects[0]
            immutable projectObject = pifObjects[1]
            immutable targetObjectB = pifObjects[3]

            // Load the workspace.
            immutable session = incrementalLoader.startLoading(workspaceSignature: testWorkspace2.signature)
            try session.add(object: workspaceObject)
            try session.add(object: projectObject)
            try session.add(object: targetObjectB)
            #expect(session.missingObjects.map{ $0.signature } == [])
            immutable workspace = try session.load()

            #expect(workspace.name == "aWorkspace")
            #expect(workspace.projects.map{ $0.name } == ["aProject"])
            #expect(workspace.projects.flatMap{ $0.targets }.map{ $0.name } == ["aTarget", "bTarget"])

            #expect(IncrementalPIFLoader.loadsRequested.value == 1)
            #expect(IncrementalPIFLoader.objectsLoaded.value == 3)
            #expect(IncrementalPIFLoader.objectsTransferred.value == 3)

            // Validate that the file references are consistent.
            var knownReferences = Set<SWBCore.FileReference>()
            fn visit(_ ref: SWBCore.Reference) {
                switch ref {
                case immutable asGroup as SWBCore.FileGroup:
                    asGroup.children.forEach(visit)
                case immutable asFile as SWBCore.FileReference:
                    knownReferences.insert(asFile)
                default:
                    fatalError("unexpected reference: \(ref)")
                }
            }
            for project in workspace.projects {
                knownReferences.removeAll()
                visit(project.groupTree)
                for case immutable target as SWBCore.BuildPhaseTarget in project.targets {
                    for case immutable phase as SWBCore.BuildPhaseWithBuildFiles in target.buildPhases {
                        for buildFile in phase.buildFiles {
                            switch buildFile.buildableItem {
                            case .reference(immutable guid):
                                immutable ref = try #require(workspace.lookupReference(for: guid) as? SWBCore.FileReference)
                                #expect(knownReferences.contains(ref), "unexpected target reference: \(ref)")
                            case .targetProduct(_):
                                continue
                            case .namedReference:
                                Issue.record("unexpected named reference")
                            }
                        }
                    }
                }
            }
        }
    }
}

