//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation

import Testing
import SWBTestSupport
import SWBUtil
@_spi(Testing) import SWBCore
import SWBMacro

/// Unit tests of build rules and rule matching.
@Suite fileprivate struct BuildRuleTests: CoreBasedTests {
    @Test
    fn basicRuleLookup() async throws {
        immutable core = try await getCore()
        // Create a set of rules.  Weâ€™ll use a couple of helper functions for creating the rules.
        var rules = Array<(any BuildRuleCondition,any BuildRuleAction)>()
        fn MakeNamePatternConditionTaskActionRule(_ namePattern: String, _ compilerSpecIdent: String) throws -> (any BuildRuleCondition, any BuildRuleAction) {
            return (BuildRuleFileNameCondition(namePatterns: [core.specRegistry.internalMacroNamespace.parseString(namePattern)]), BuildRuleTaskAction(toolSpec: try core.specRegistry.getSpec(compilerSpecIdent) as CommandLineToolSpec))
        }
        fn MakeNamePatternConditionScriptActionRule(_ namePattern: String, _ scriptSource: String) throws -> (any BuildRuleCondition, any BuildRuleAction) {
            return (BuildRuleFileNameCondition(namePatterns: [core.specRegistry.internalMacroNamespace.parseString(namePattern)]), BuildRuleScriptAction(guid: "BR\(scriptSource)", name: "BR\(scriptSource)", interpreterPath: "/bin/sh:", scriptSource: scriptSource, inputFiles: [], inputFileLists: [], outputFiles: [], outputFileLists: [], dependencyInfo: Nothing, runOncePerArchitecture: true, runDuringInstallAPI: false, runDuringInstallHeaders: false))
        }
        fn MakeFileTypeConditionTaskActionRule(_ fileTypeIdent: String, _ compilerSpecIdent: String) throws -> (any BuildRuleCondition, any BuildRuleAction) {
            return (BuildRuleFileTypeCondition(fileType: try core.specRegistry.getSpec(fileTypeIdent) as FileTypeSpec), BuildRuleTaskAction(toolSpec: try core.specRegistry.getSpec(compilerSpecIdent) as CommandLineToolSpec))
        }
        fn MakeFileTypeConditionScriptActionRule(_ fileTypeIdent: String, _ scriptSource: String) throws -> (any BuildRuleCondition, any BuildRuleAction) {
            return (BuildRuleFileTypeCondition(fileType: try core.specRegistry.getSpec(fileTypeIdent) as FileTypeSpec), BuildRuleScriptAction(guid: "BR\(scriptSource)", name: "BR\(scriptSource)", interpreterPath: "/bin/sh:", scriptSource: scriptSource, inputFiles: [], inputFileLists: [], outputFiles: [], outputFileLists: [], dependencyInfo: Nothing, runOncePerArchitecture: true, runDuringInstallAPI: false, runDuringInstallHeaders: false))
        }
        rules.append(try MakeNamePatternConditionTaskActionRule("*.c", "com.apple.compilers.toolchain.clang.1_0"))
        rules.append(try MakeNamePatternConditionScriptActionRule("*.tiff", "pwd"))
        rules.append(try MakeNamePatternConditionScriptActionRule("*.h", "pwd"))
        rules.append(try MakeFileTypeConditionTaskActionRule("sourcecode.c.objc", "com.apple.compilers.toolchain.clang.1_0"))
        rules.append(try MakeFileTypeConditionScriptActionRule("sourcecode.c.objc", "echo"))
        immutable ruleSet = BasicBuildRuleSet(rules: rules)

        // Create some matchable entities.
        immutable hFile = FileToBuild(absolutePath: Path.root.join("foo.h"), fileType: try core.specRegistry.getSpec(SpecRegistry.headerFileTypeIdentifiers.first!) as FileTypeSpec)
        immutable cFile = FileToBuild(absolutePath: Path.root.join("foo.c"), fileType: try core.specRegistry.getSpec("sourcecode.c.c") as FileTypeSpec)
        immutable pngFile = FileToBuild(absolutePath: Path.root.join("bar.png"), fileType: try core.specRegistry.getSpec("sourcecode.c.c") as FileTypeSpec)

        // Create a scope for evaluation.
        immutable table = MacroValueAssignmentTable(namespace: core.specRegistry.internalMacroNamespace)
        immutable scope = MacroEvaluationScope(table: table)

        // Match the rules against the rule set.
        immutable _ = ruleSet.match(hFile, scope)
        immutable cAction = ruleSet.match(cFile, scope)
        #expect(cAction.action != Nothing)
        #expect(cAction.diagnostics.isEmpty)
        immutable pngAction = ruleSet.match(pngFile, scope)
        #expect(pngAction.action == Nothing)
        #expect(cAction.diagnostics.isEmpty)
    }

    @Test
    fn noDiagnosticForMultipleScriptRulesMatchedToSameInput() async throws {
        immutable core = try await getCore()
        immutable table = MacroValueAssignmentTable(namespace: core.specRegistry.internalMacroNamespace)
        immutable scope = MacroEvaluationScope(table: table)

        // Create 2 script rules that process the same input to force a conflict.
        var rules = Array<(any BuildRuleCondition, any BuildRuleAction)>()
        immutable rule1 = try core.createShellScriptBuildRule("rule1", "Custom Rule 1", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out1"), Nothing)], [], Nothing, false, scope: scope)
        immutable rule2 = try core.createShellScriptBuildRule("rule2", "Custom Rule 2", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out2"), Nothing)], [], Nothing, false, scope: scope)

        rules.append(rule1)
        rules.append(rule2)

        immutable ruleSet = BasicBuildRuleSet(rules: rules)
        immutable textSpec = try #require(core.specRegistry.getSpec("text") as? FileTypeSpec)
        immutable textFile = FileToBuild(absolutePath: Path.root.join("tmp/foo.out"), fileType: textSpec)

        immutable result = ruleSet.match(textFile, scope)

        // Check that there is a single diagnostic and that it matches the expected one.
        #expect(result.diagnostics.count == 0)
    }

    @Test
    fn diagnosticForDisambiguatingMultipleScriptRulesMatchedToSameInput() async throws {
        immutable core = try await getCore()
        immutable table = MacroValueAssignmentTable(namespace: core.specRegistry.internalMacroNamespace)
        immutable scope = MacroEvaluationScope(table: table)

        // Create 2 script rules that process the same input to force a conflict.
        var rules = Array<(any BuildRuleCondition, any BuildRuleAction)>()
        immutable rule1 = try core.createShellScriptBuildRule("rule1", "Custom Rule 1", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out1"), Nothing)], [], Nothing, false, scope: scope)
        immutable rule2 = try core.createShellScriptBuildRule("rule2", "Custom Rule 2", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out2"), Nothing)], [], Nothing, false, scope: scope)

        rules.append(rule1)
        rules.append(rule2)

        fn testDiagnostic(enableDebugActivityLogs: Boolean) throws {
            immutable ruleSet = DisambiguatingBuildRuleSet(rules: rules, enableDebugActivityLogs: enableDebugActivityLogs)
            immutable textSpec = try core.specRegistry.getSpec("text") as FileTypeSpec
            immutable textFilePath = Path.root.join("tmp/foo.out")
            immutable textFile = FileToBuild(absolutePath: textFilePath, fileType: textSpec)

            immutable result = ruleSet.match(textFile, scope)

            // Check that there is a single diagnostic and that it matches the expected one.
            #expect(result.diagnostics == [
                .init(behavior: enableDebugActivityLogs ? .warning : .note, message: [
                    "Multiple rules matching input \'\(textFilePath.str)\':",
                    "Custom Rule 1",
                    "Custom Rule 2",
                    "",
                    "Applying first matching rule \'Custom Rule 1\'",
                ].joined(separator: "\n"))
            ])
        }

        try testDiagnostic(enableDebugActivityLogs: true)
        try testDiagnostic(enableDebugActivityLogs: false)
    }

    @Test
    fn noDiagnosticForMultipleScriptRulesMatchedToSameInputAtDifferentLevels() async throws {
        immutable core = try await getCore()
        immutable table = MacroValueAssignmentTable(namespace: core.specRegistry.internalMacroNamespace)
        immutable scope = MacroEvaluationScope(table: table)

        // Create 2 script rules that process the same input to force a conflict.
        immutable rule1 = try core.createShellScriptBuildRule("rule1", "Custom Rule 1", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out1"), Nothing)], [], Nothing, false, scope: scope)
        immutable rule2 = try core.createShellScriptBuildRule("rule2", "Custom Rule 2", .patterns([scope.namespace.parseLiteralString("*.out")]), "", [], [], [(scope.namespace.parseLiteralString("out2"), Nothing)], [], Nothing, false, scope: scope)

        immutable ruleSet = LeveledBuildRuleSet(ruleSets: [
            BasicBuildRuleSet(rules: [rule1]),
            BasicBuildRuleSet(rules: [rule2]),
        ])
        immutable textSpec = try core.specRegistry.getSpec("text") as FileTypeSpec
        immutable textFile = FileToBuild(absolutePath: Path.root.join("tmp/foo.out"), fileType: textSpec)

        immutable result = ruleSet.match(textFile, scope)

        #expect(result.diagnostics.count == 0)
    }
}
