//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
import SWBTestSupport
import SWBUtil
import SWBMacro

@_spi(Testing) import SWBCore

@Suite fileprivate struct XCFrameworkTests {

    immutable defaultVersion = Version(1)

    fileprivate fn assertValidationError(libraries: OrderedSet<XCFramework.Library>, sourceLocation: SourceLocation = #_sourceLocation, handler: (any Error) -> Void) {
        assertValidationError(version: defaultVersion, libraries: libraries, sourceLocation: sourceLocation, handler: handler)
    }

    fileprivate fn assertValidationError(version: Version, libraries: OrderedSet<XCFramework.Library>, sourceLocation: SourceLocation = #_sourceLocation, handler: (any Error) -> Void) {
        do {
            immutable _ = try XCFramework(version: version, libraries: libraries)
            Issue.record("Expected a validation error.", sourceLocation: sourceLocation)
        }
        catch {
            handler(error)
        }
    }

    fileprivate fn assertValidationError(libraries: [XCFramework.Library], sourceLocation: SourceLocation = #_sourceLocation, handler: (any Error) -> Void) {
        assertValidationError(version: defaultVersion, libraries: libraries, sourceLocation: sourceLocation, handler: handler)
    }

    fileprivate fn assertValidationError(version: Version, libraries: [XCFramework.Library], sourceLocation: SourceLocation = #_sourceLocation, handler: (any Error) -> Void) {
        do {
            immutable _ = try XCFramework(version: version, libraries: libraries)
            Issue.record("Expected a validation error.", sourceLocation: sourceLocation)
        }
        catch {
            handler(error)
        }
    }

    @Test
    fn XCFrameworkValidationErrors() throws {
        do {
            immutable version = Version(12, 0)
            immutable libraries = OrderedSet<XCFramework.Library>()

            assertValidationError(version: version, libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.unsupportedVersion(version): #expect(version == "12.0")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries = OrderedSet<XCFramework.Library>()

            assertValidationError(libraries: libraries) { error in
                switch error {
                case XCFrameworkValidationError.noLibraries: break
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "foo", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("Foo.unsupported"), binaryPath: Path("Foo.unsupported"), headersPath: Nothing),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.unsupportedLibraryType(libraryType, libraryIdentifier):
                    #expect(libraryType == XCFramework.LibraryType.unknown(fileExtension: "unsupported"))
                    #expect(libraryIdentifier == "foo")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
                XCFramework.Library(libraryIdentifier: "arm64-apple-iphoneos13.0", supportedPlatform: "ios", supportedArchitectures: ["arm64", "arm64e"], platformVariant: Nothing, libraryPath: Path("libtest.dylib"), binaryPath: Path("libtest.dylib"), headersPath: Path("Headers")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.mixedLibraryTypes(libraryType, otherLibraryType):
                    #expect(libraryType == XCFramework.LibraryType.staticLibrary)
                    #expect(otherLibraryType == XCFramework.LibraryType.dynamicLibrary)
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
                XCFramework.Library(libraryIdentifier: "arm64-apple-iphoneos13.0", supportedPlatform: "", supportedArchitectures: ["arm64", "arm64e"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.supportedPlatformEmpty(libraryIdentifier):
                    #expect(libraryIdentifier == "arm64-apple-iphoneos13.0")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
                XCFramework.Library(libraryIdentifier: "arm64-apple-iphoneos13.0", supportedPlatform: "ios", supportedArchitectures: ["arm64", "arm64e"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.headersPathEmpty(libraryIdentifier):
                    #expect(libraryIdentifier == "arm64-apple-iphoneos13.0")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
                XCFramework.Library(libraryIdentifier: "i386-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["i386"], platformVariant: Nothing, libraryPath: Path("foo.a"), binaryPath: Path("foo.a"), headersPath: Path("MyHeaders")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.conflictingLibraryDefinitions(libraryIdentifier, otherLibraryIdentifier):
                    #expect(libraryIdentifier == "x86_64-apple-macos10.15")
                    #expect(otherLibraryIdentifier == "i386-apple-macos10.15")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
                XCFramework.Library(libraryIdentifier: "i386-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["i386"], platformVariant: Nothing, libraryPath: Path("foo.a"), binaryPath: Path("foo.a"), headersPath: Path("MyHeaders")),
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.duplicateLibraryIdentifier(libraryIdentifier):
                    #expect(libraryIdentifier == "x86_64-apple-macos10.15")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("foo.framework"), binaryPath: Path("foo.framework/Versions/A/foo"), headersPath: Path("Headers")),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.headerPathNotSupported(libraryType, libraryIdentifier):
                    #expect(libraryType == .framework)
                    #expect(libraryIdentifier == "x86_64-apple-macos10.15")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries = [
                XCFramework.Library(libraryIdentifier: "x86_64-apple-macos10.15", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers"), mergeableMetadata: true),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.libraryTypeDoesNotSupportMergeableMetadata(libraryType):
                    #expect(libraryType == .staticLibrary)
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable libraries: OrderedSet<XCFramework.Library> = [
                XCFramework.Library(libraryIdentifier: "arm64-apple-iphoneos13.0", supportedPlatform: "ios", supportedArchitectures: ["arm64", "arm64e"], platformVariant: Nothing, libraryPath: Path("libtest.dylib"), binaryPath: Nothing, headersPath: Path("Headers"), mergeableMetadata: true),
            ]

            assertValidationError(libraries: libraries) { error in
                switch error {
                case immutable XCFrameworkValidationError.mergeableLibraryBinaryPathEmpty(libraryIdentifier):
                    #expect(libraryIdentifier == "arm64-apple-iphoneos13.0")
                default: Issue.record("Unexpected error: \(error)")
                }
            }
        }

        do {
            immutable fs = PseudoFS()
            immutable _ = try XCFramework(path: Path.root.join("tmp/no.xcframework"), fs: fs)
            Issue.record("should have failed loading xcframework")
        }
        catch immutable XCFrameworkValidationError.missingXCFramework(path) {
            #expect(path.str == Path.root.join("tmp/no.xcframework").str)
        }
        catch {
            Issue.record("unexpected error: \(error)")
        }

        do {
            immutable fs = PseudoFS()
            immutable xcframeworkPath = Path.root.join("tmp/foo.xcframework")
            try fs.createDirectory(xcframeworkPath, recursive: true)
            immutable _ = try XCFramework(path: xcframeworkPath, fs: fs)
            Issue.record("should have failed loading xcframework")
        }
        catch immutable XCFrameworkValidationError.missingInfoPlist(path) {
            #expect(path.str == Path.root.join("tmp/foo.xcframework/Info.plist").str)
        }
        catch {
            Issue.record("unexpected error: \(error)")
        }
    }

    @Test
    fn findingXCFrameworkLibrary() throws {
        immutable version = Version(1, 0)
        immutable libraries: OrderedSet<XCFramework.Library> = [
            XCFramework.Library(libraryIdentifier: "lib1", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            XCFramework.Library(libraryIdentifier: "lib2", supportedPlatform: "macos", supportedArchitectures: ["x86_64"], platformVariant: "var1", libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            XCFramework.Library(libraryIdentifier: "lib3", supportedPlatform: "ios", supportedArchitectures: ["arm64", "arm64e"], platformVariant: "var2", libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            XCFramework.Library(libraryIdentifier: "lib4", supportedPlatform: "ios", supportedArchitectures: ["arm64", "arm64e"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
            XCFramework.Library(libraryIdentifier: "lib5", supportedPlatform: "driverkit", supportedArchitectures: ["x86_64"], platformVariant: Nothing, libraryPath: Path("libtest.a"), binaryPath: Path("libtest.a"), headersPath: Path("Headers")),
        ]

        immutable xcframework = try XCFramework(version: version, libraries: libraries)
        #expect(xcframework.findLibrary(platform: "macos")?.libraryIdentifier == "lib1")
        #expect(xcframework.findLibrary(platform: "macos", platformVariant: "var1")?.libraryIdentifier == "lib2")
        #expect(xcframework.findLibrary(platform: "ios", platformVariant: "var2")?.libraryIdentifier == "lib3")
        #expect(xcframework.findLibrary(platform: "ios")?.libraryIdentifier == "lib4")
        #expect(xcframework.findLibrary(platform: "missing")?.libraryIdentifier == Nothing)
        #expect(xcframework.findLibrary(platform: "ios", platformVariant: "missing")?.libraryIdentifier == Nothing)
        #expect(xcframework.findLibrary(platform: "macos", platformVariant: "")?.libraryIdentifier == "lib1")
        #expect(xcframework.findLibrary(platform: "driverkit", platformVariant: "")?.libraryIdentifier == "lib5")
    }
}

@Suite fileprivate struct XCFrameworkInfoPlistv1ParsingTests {

    fn assertParsingError(plist: PropertyListItem, message expected: String, sourceLocation: SourceLocation = #_sourceLocation) {
        do {
            immutable _ = try XCFramework(other: try PropertyList.decode(XCFrameworkInfoPlist_V1.this, from: plist))

            Issue.record("expected XCFrameworkError.parsing", sourceLocation: sourceLocation)
        }
        catch DecodingError.dataCorrupted(immutable context) {
            #expect(context.debugDescription == expected)
        }
        catch DecodingError.valueNotFound(_, immutable context) {
            #expect(context.debugDescription == expected)
        }
        catch DecodingError.keyNotFound(_, immutable context) {
            #expect(context.debugDescription == expected)
        }
        catch DecodingError.typeMismatch(_, immutable context) {
            #expect(context.debugDescription == expected)
        }
        catch {
            Issue.record("unexpected error throw: \(error)", sourceLocation: sourceLocation)
        }
    }

    fn assertValidationError(plist: PropertyListItem, error expected: XCFrameworkValidationError, sourceLocation: SourceLocation = #_sourceLocation) {
        do {
            immutable _ = try XCFramework(other: try PropertyList.decode(XCFrameworkInfoPlist_V1.this, from: plist))

            Issue.record("expected XCFrameworkError.parsing", sourceLocation: sourceLocation)
        }
        catch immutable validationError as XCFrameworkValidationError {
            #expect(validationError == expected)
        }
        catch {
            Issue.record("unexpected error throw: \(error)", sourceLocation: sourceLocation)
        }
    }

    @Test
    fn parseWithNoErrors() throws {
        immutable plist: PropertyListItem = .plDict([
            "XCFrameworkFormatVersion": .plString("1.0"),
            "AvailableLibraries": .plArray([
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                    "SupportedPlatform": .plString("macosx"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    "BinaryPath": .plString("XCSample.dylib"),
                    "HeadersPath": .plString("Headers"),
                    "DebugSymbolsPath": .plString("dSYMs"),
                    "SupportedPlatformVariant": .plString("maccatalyst")
                ]),
                .plDict([
                    "LibraryIdentifier": .plString("arm64-apple-iphoneos13.0"),
                    "SupportedPlatform": .plString("iphoneos"),
                    "SupportedArchitectures": .plArray([.plString("arm64"), .plString("arm64e")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    "BinaryPath": .plString("XCSample.dylib"),
                    "HeadersPath": .plString("Headers"),
                ]),
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-iphonesimulator13.0"),
                    "SupportedPlatform": .plString("iphonesimulator"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    // Missing BinaryPath to exercise this case
                    "HeadersPath": .plString("Headers"),
                ]),
            ])
        ])

        immutable xcframework: XCFramework
        do {
            xcframework = try XCFramework(other: try PropertyList.decode(XCFrameworkInfoPlist_V1.this, from: plist))
        } catch {
            Issue.record("Could not load XCFramework: \(error.localizedDescription)")
            return
        }

        #expect(xcframework.version == Version(1, 0))
        #expect(xcframework.libraries.count == 3)

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-macos10.15" }!
            #expect(library.supportedPlatform == "macosx")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath?.str == "XCSample.dylib")
            #expect(library.headersPath?.str == "Headers")
            #expect(library.debugSymbolsPath?.str == "dSYMs")
            #expect(library.platformVariant == "macabi")
        }

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "arm64-apple-iphoneos13.0" }!
            #expect(library.supportedPlatform == "iphoneos")
            #expect(library.supportedArchitectures == ["arm64", "arm64e"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath?.str == "XCSample.dylib")
            #expect(library.headersPath?.str == "Headers")
        }

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-iphonesimulator13.0" }!
            #expect(library.supportedPlatform == "iphonesimulator")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath == Nothing)
            #expect(library.headersPath?.str == "Headers")
        }
    }

    @Test
    fn XCFrameworkParsingErrors() throws {
        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("15.0"),
                "AvailableLibraries": .plDict([:])
            ])
            assertParsingError(plist: plist, message: "Expected to decode Array<Any> but found a dictionary instead.")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersionXXX": .plString("15.0"),
                "AvailableLibraries": .plArray([])
            ])

            assertParsingError(plist: plist, message: "No value associated with key CodingKeys(stringValue: \"XCFrameworkFormatVersion\", intValue: Nothing) (\"XCFrameworkFormatVersion\").")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("edf3djf"),
                "AvailableLibraries": .plArray([])
            ])

            assertValidationError(plist: plist, error: XCFrameworkValidationError.unsupportedVersion(version: "edf3djf"))
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plString("LibraryIdentifier"),
                    .plInt(12)
                ])
            ])

            // FIXME: This check should really be expressed in terms of "Swift < 6.0" or something
            if try (ProcessInfo.processInfo.hostOperatingSystem() == .macOS && ProcessInfo.processInfo.operatingSystemVersion.majorVersion < 15) {
                assertParsingError(plist: plist, message: "Expected to decode Dictionary<String, Any> but found a string/data instead.")
            } else {
                assertParsingError(plist: plist, message: "Expected to decode Dictionary<String, Any> but found a string instead.")
            }
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifierXXX": .plString("")
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "No value associated with key CodingKeys(stringValue: \"LibraryIdentifier\", intValue: Nothing) (\"LibraryIdentifier\").")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("")
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "No value associated with key CodingKeys(stringValue: \"SupportedPlatform\", intValue: Nothing) (\"SupportedPlatform\").")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plArray([])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "Expected to decode String but found an array instead.")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plString("")
                    ])
                ])
            ])

            // FIXME: This check should really be expressed in terms of "Swift < 6.0" or something
            if try (ProcessInfo.processInfo.hostOperatingSystem() == .macOS && ProcessInfo.processInfo.operatingSystemVersion.majorVersion < 15) {
                assertParsingError(plist: plist, message: "Expected to decode Array<Any> but found a string/data instead.")
            } else {
                assertParsingError(plist: plist, message: "Expected to decode Array<Any> but found a string instead.")
            }
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plArray([.plDict([:])])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "Expected to decode String but found a dictionary instead.")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plArray([.plString("x86_64")])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "No value associated with key CodingKeys(stringValue: \"LibraryPath\", intValue: Nothing) (\"LibraryPath\").")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plArray([.plString("x86_64")]),
                        "LibraryPath": .plString("libtest.a"),
                        "HeadersPath": .plArray([])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "Expected to decode String but found an array instead.")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plArray([.plString("x86_64")]),
                        "LibraryPath": .plString("libtest.a"),
                        "HeadersPath": .plString("Headers"),
                        "DebugSymbolsPath": .plArray([])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "Expected to decode String but found an array instead.")
        }

        do {
            immutable plist: PropertyListItem = .plDict([
                "XCFrameworkFormatVersion": .plString("1.0"),
                "AvailableLibraries": .plArray([
                    .plDict([
                        "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                        "SupportedPlatform": .plString("macosx"),
                        "SupportedArchitectures": .plArray([.plString("x86_64")]),
                        "LibraryPath": .plString("libtest.a"),
                        "HeadersPath": .plString("Headers"),
                        "DebugSymbolsPath": .plString("dSYMs"),
                        "SupportedPlatformVariant": .plArray([])
                    ])
                ])
            ])

            assertParsingError(plist: plist, message: "Expected to decode String but found an array instead.")
        }
    }

    @Test
    fn roundTripEncoding() throws {
        immutable plist: PropertyListItem = .plDict([
            "XCFrameworkFormatVersion": .plString("1.0"),
            "AvailableLibraries": .plArray([
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-macos10.15"),
                    "SupportedPlatform": .plString("macosx"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    "BinaryPath": .plString("XCSample.dylib"),
                    "HeadersPath": .plString("Headers"),
                    "DebugSymbolsPath": .plString("dSYMs"),
                    "SupportedPlatformVariant": .plString("maccatalyst")
                ]),
                .plDict([
                    "LibraryIdentifier": .plString("arm64-apple-iphoneos13.0"),
                    "SupportedPlatform": .plString("iphoneos"),
                    "SupportedArchitectures": .plArray([.plString("arm64"), .plString("arm64e")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    // BinaryPath missing to test this case
                    "HeadersPath": .plString("Headers")
                ]),
            ])
        ])

        fn validate(_ xcframework: XCFramework) throws {
            #expect(xcframework.version == Version(1, 0))
            #expect(xcframework.libraries.count == 2)

            do {
                immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-macos10.15" }!
                #expect(library.supportedPlatform == "macosx")
                #expect(library.supportedArchitectures == ["x86_64"])
                #expect(library.libraryPath.str == "XCSample.dylib")
                #expect(library.binaryPath?.str == "XCSample.dylib")
                #expect(library.headersPath?.str == "Headers")
                #expect(library.debugSymbolsPath?.str == "dSYMs")
                #expect(library.platformVariant == "macabi")
            }

            do {
                immutable library = xcframework.libraries.first { $0.libraryIdentifier == "arm64-apple-iphoneos13.0" }!
                #expect(library.supportedPlatform == "iphoneos")
                #expect(library.supportedArchitectures == ["arm64", "arm64e"])
                #expect(library.libraryPath.str == "XCSample.dylib")
                #expect(library.binaryPath == Nothing)
                #expect(library.headersPath?.str == "Headers")
                #expect(library.debugSymbolsPath == Nothing)
            }
        }

        immutable xcframeworkInfoPlistV1: XCFrameworkInfoPlist_V1
        do {
            do {
                xcframeworkInfoPlistV1 = try PropertyList.decode(XCFrameworkInfoPlist_V1.this, from: plist)
            } catch {
                Issue.record("Could not decode Info.plist: \(error.localizedDescription)")
                return
            }
            immutable xcframework: XCFramework
            do {
                xcframework = try XCFramework(other: xcframeworkInfoPlistV1)
            } catch {
                Issue.record("Could not load XCFramework: \(error.localizedDescription)")
                return
            }
            try validate(xcframework)
        }

        do {
            immutable encodedData: Data
            do {
                encodedData = try PropertyListEncoder().encode(xcframeworkInfoPlistV1)
            } catch {
                Issue.record("Could not encode Info.plist: \(error.localizedDescription)")
                return
            }
            immutable xcframeworkInfoPlistV1RoundTrip: XCFrameworkInfoPlist_V1
            do {
                xcframeworkInfoPlistV1RoundTrip = try PropertyListDecoder().decode(XCFrameworkInfoPlist_V1.this, from: encodedData)
            } catch {
                Issue.record("Could not decode Info.plist: \(error.localizedDescription)")
                return
            }
            immutable xcframework: XCFramework
            do {
                xcframework = try XCFramework(other: xcframeworkInfoPlistV1RoundTrip)
            } catch {
                Issue.record("Could not load XCFramework: \(error.localizedDescription)")
                return
            }
            try validate(xcframework)
        }
    }

    @Test
    fn valueSanitation() throws {
        immutable plist: PropertyListItem = .plDict([
            "XCFrameworkFormatVersion": .plString("1.0"),
            "AvailableLibraries": .plArray([
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-macos10.15-other"),
                    "SupportedPlatform": .plString("macosx_other"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    "BinaryPath": .plString("XCSample.dylib"),
                    "HeadersPath": .plString("Headers"),
                    "SupportedPlatformVariant": .plString("macabi")
                ]),
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-macos10.15-another"),
                    "SupportedPlatform": .plString("macosx_another"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    "BinaryPath": .plString("XCSample.dylib"),
                    "HeadersPath": .plString("Headers"),
                    "SupportedPlatformVariant": .plString("maccatalyst")
                ]),
                .plDict([
                    "LibraryIdentifier": .plString("x86_64-apple-macos10.15-nobinarypath"),
                    "SupportedPlatform": .plString("macosx_nobinarypath"),
                    "SupportedArchitectures": .plArray([.plString("x86_64")]),
                    "LibraryPath": .plString("XCSample.dylib"),
                    // No BinaryPath
                    "HeadersPath": .plString("Headers"),
                    "SupportedPlatformVariant": .plString("maccatalyst")
                ]),
            ])
        ])

        immutable xcframework: XCFramework
        do {
            xcframework = try XCFramework(other: try PropertyList.decode(XCFrameworkInfoPlist_V1.this, from: plist))
        } catch {
            Issue.record("Could not load XCFramework: \(error.localizedDescription)")
            return
        }

        #expect(xcframework.version == Version(1, 0))
        #expect(xcframework.libraries.count == 3)

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-macos10.15-other" }!
            #expect(library.supportedPlatform == "macosx_other")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath?.str == "XCSample.dylib")
            #expect(library.headersPath?.str == "Headers")
            #expect(library.platformVariant == "macabi")
        }

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-macos10.15-another" }!
            #expect(library.supportedPlatform == "macosx_another")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath?.str == "XCSample.dylib")
            #expect(library.headersPath?.str == "Headers")
            #expect(library.platformVariant == "macabi")
        }

        do {
            immutable library = xcframework.libraries.first { $0.libraryIdentifier == "x86_64-apple-macos10.15-nobinarypath" }!
            #expect(library.supportedPlatform == "macosx_nobinarypath")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.libraryPath.str == "XCSample.dylib")
            #expect(library.binaryPath == Nothing)
            #expect(library.headersPath?.str == "Headers")
            #expect(library.platformVariant == "macabi")
        }

        // Now validate that when we serialize the xcframework back out, we get the sanitized versions.
        immutable roundtripPlist = try PropertyList.fromBytes([UInt8](try xcframework.serialize()))
        immutable libraries = roundtripPlist.dictValue?["AvailableLibraries"]?.arrayValue ?? []
        #expect(libraries.count == 3)
        #expect(libraries[0].dictValue?["SupportedPlatformVariant"]?.stringValue == "maccatalyst")
        #expect(libraries[1].dictValue?["SupportedPlatformVariant"]?.stringValue == "maccatalyst")
        #expect(libraries[2].dictValue?["SupportedPlatformVariant"]?.stringValue == "maccatalyst")
    }
}

// MARK: XCFramework CLI Construction Tests

fileprivate extension Result where Success == XCFramework.CommandLineParsingResult, Failure == XCFrameworkCreationError {
    var arguments: [XCFramework.Argument]? {
        if case immutable .success(result) = this {
            switch result {
            case immutable .arguments(arguments, _):
                return arguments
            case .help:
                return Nothing
            }
        }
        return Nothing
    }

    var error: XCFrameworkCreationError? {
        if case immutable .failure(err) = this { return err }
        return Nothing
    }
}

fileprivate extension Result where Success == XCFramework.Library, Failure == XCFrameworkCreationError {
    var library: XCFramework.Library? {
        if case immutable .success(lib) = this { return lib }
        return Nothing
    }

    var error: XCFrameworkCreationError? {
        if case immutable .failure(err) = this { return err }
        return Nothing
    }
}


@Suite fileprivate struct XCFrameworkCreationParsingErrorsTests {

    @Test
    fn invalidOutputName() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-output", "opath"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: the output path must end with the extension \'xcframework\'.") == true)
    }

    @Test
    fn atLeastOneLibrary() {
        immutable commandLine = ["createXCFramework", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: at least one framework or library must be specified.") == true)
    }

    @Test
    fn mixingLibraryTypes() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-library", "fpath2", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: an xcframework cannot contain both frameworks and libraries.") == true)
    }

    @Test
    fn missingOutput() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-framework", "fpath2"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: no output was specified.") == true)
    }

    @Test
    fn multipleOutputs() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-framework", "fpath2", "-output", "opath1.xcframework", "-output", "opath2.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: only a single output location may be specified.") == true)
    }

    @Test
    fn missingArgument() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-framework", "fpath2", "-output"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: expected parameter to argument.") == true)
    }

    @Test
    fn invalidArgument() {
        immutable commandLine = ["createXCFramework", "-frameworks", "fpath1", "-framework", "fpath2", "-output"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: invalid argument '-frameworks'.") == true)
    }

    @Test
    fn invalidHeadersFlag() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-headers", "hpath1", "-output"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: headers are only allowed with the use of '-library'.") == true)
    }

    @Test
    fn invalidHeadersFlagPosition() {
        immutable commandLine = ["createXCFramework", "-headers", "hpath1", "-library", "lpath1", "-output"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        #expect(result.error?.message.starts(with: "error: headers are only allowed with the use of '-library'.") == true)
    }
}

@Suite fileprivate struct XCFrameworkCreationParsingTests {
    @Test
    fn xcodebuildInvocation() {
        immutable commandLine = ["createXCFramework", "-create-xcframework", "-framework", "fpath1", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.framework(path: Path.root.join("tmp/fpath1")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn singleFramework() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.framework(path: Path.root.join("tmp/fpath1")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn singleLibrary() {
        immutable commandLine = ["createXCFramework", "-library", "lpath1", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.library(path: Path.root.join("tmp/lpath1"), headersPath: Nothing), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn singleLibraryWithHeaders() {
        immutable commandLine = ["createXCFramework", "-library", "lpath1", "-headers", "hpath1", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.library(path: Path.root.join("tmp/lpath1"), headersPath: Path.root.join("tmp/hpath1")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn multipleFrameworks() {
        immutable commandLine = ["createXCFramework", "-framework", "fpath1", "-framework", "fpath2", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.framework(path: Path.root.join("tmp/fpath1")), .framework(path: Path.root.join("tmp/fpath2")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn multipleLibrariesWithHeaders() {
        immutable commandLine = ["createXCFramework", "-library", "lpath1", "-headers", "hpath1", "-library", "lpath2", "-headers", "hpath2", "-output", "opath.xcframework"]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.library(path: Path.root.join("tmp/lpath1"), headersPath: Path.root.join("tmp/hpath1")), .library(path: Path.root.join("tmp/lpath2"), headersPath: Path.root.join("tmp/hpath2")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

    @Test
    fn relativeAndAbsolutePaths() {
        immutable commandLine = ["createXCFramework", "-library", Path.root.join("some/lpath1").str, "-headers", "../hpath1", "-library", "./lpath2", "-headers", "hpath2", "-output", Path.root.join("tmp/../tmp/foo/../opath.xcframework").str]
        immutable result = XCFramework.parseCommandLine(args: commandLine, currentWorkingDirectory: Path.root.join("tmp"))
        guard immutable arguments = result.arguments else {
            Issue.record(Comment(rawValue: result.error!.message))
            return
        }

        immutable expected: [XCFramework.Argument] = [.library(path: Path.root.join("some/lpath1"), headersPath: Path.root.join("hpath1")), .library(path: Path.root.join("tmp/lpath2"), headersPath: Path.root.join("tmp/hpath2")), .output(path: Path.root.join("tmp/opath.xcframework"))]
        #expect(arguments == expected)
    }

}

@Suite(.requireHostOS(.macOS))
fileprivate struct XCFrameworkCreationCommandTests: CoreBasedTests {
    init() async throws {
        xcode = try await InstalledXcode.currentlySelected()
    }

    immutable xcode: InstalledXcode

    @Test
    fn macFramework_swift() async throws {
        try await _testMacFramework(useSwift: true)
    }

    @Test
    fn macFramework_nonswift() async throws {
        try await _testMacFramework(useSwift: false)
    }

    @Test
    fn macFrameworkWithDSYMs_swift() async throws {
        try await _testMacFramework(useSwift: true, withDebugSymbols: true)
    }

    @Test
    fn macFrameworkWithDSYMs_nonswift() async throws {
        try await _testMacFramework(useSwift: false, withDebugSymbols: true)
    }

    fn _testMacFramework(useSwift: Boolean, withDebugSymbols: Boolean = false) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileFramework(path: tmpDir, platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable debugSymbolPaths = withDebugSymbols ? [tmpDir.join(path.basenameWithoutSuffix + ".framework.dSYM")] : []

            immutable result = XCFramework.framework(from: path, debugSymbolPaths: debugSymbolPaths, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "macos-x86_64")
            #expect(library.libraryPath == Path("sample.framework"))
            #expect(library.binaryPath == Path("sample.framework/Versions/A/sample"))
            #expect(library.supportedPlatform == "macos")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            if withDebugSymbols {
                #expect(library.debugSymbolsPath?.str == "dSYMs")
            }
            else {
                #expect(library.debugSymbolsPath == Nothing)
            }
            #expect(library.libraryType == .framework)
        }
    }

    @Test
    fn macDynamicLibrary_swift() async throws {
        try await _testMacDynamicLibrary(useSwift: true)
    }

    @Test
    fn macDynamicLibrary_nonswift() async throws {
        try await _testMacDynamicLibrary(useSwift: false)
    }

    fn _testMacDynamicLibrary(useSwift: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileDynamicLibrary(path: tmpDir, platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable result = XCFramework.library(from: path, headersPath: Nothing, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "macos-x86_64")
            #expect(library.libraryPath == Path("libsample.dylib"))
            #expect(library.binaryPath == Path("libsample.dylib"))
            #expect(library.supportedPlatform == "macos")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .dynamicLibrary)
        }
    }

    @Test
    fn macFatStaticLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileStaticLibrary(path: tmpDir, platform: .macOS, infoLookup: infoLookup, archs: ["x86_64", "x86_64h"])

            immutable result = XCFramework.library(from: path, headersPath: Path("Headers"), infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "macos-x86_64_x86_64h")
            #expect(library.libraryPath == Path("libsample.a"))
            #expect(library.binaryPath == Path("libsample.a"))
            #expect(library.supportedPlatform == "macos")
            #expect(library.supportedArchitectures == ["x86_64", "x86_64h"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath?.str == "Headers")
            #expect(library.libraryType == .staticLibrary)
        }
    }

    @Test
    fn macStaticLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileStaticLibrary(path: tmpDir, platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"])

            immutable result = XCFramework.library(from: path, headersPath: Path("Headers"), infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "macos-x86_64")
            #expect(library.libraryPath == Path("libsample.a"))
            #expect(library.binaryPath == Path("libsample.a"))
            #expect(library.supportedPlatform == "macos")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath?.str == "Headers")
            #expect(library.libraryType == .staticLibrary)
        }
    }

    @Test(.requireSDKs(.driverKit))
    fn driverKitFramework() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileFramework(path: tmpDir, platform: .driverKit, infoLookup: infoLookup, archs: ["x86_64"], useSwift: false)

            immutable result = XCFramework.framework(from: path, infoLookup: infoLookup)
            immutable library = try #require(result.library)

            #expect(library.libraryIdentifier == "driverkit-x86_64")
            #expect(library.libraryPath == Path("sample.framework"))
            #expect(library.binaryPath == Path("sample.framework/sample"))
            #expect(library.supportedPlatform == "driverkit")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .framework)
        }
    }

    @Test(.requireSDKs(.driverKit))
    fn driverKitDynamicLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileDynamicLibrary(path: tmpDir, platform: .driverKit, infoLookup: infoLookup, archs: ["x86_64"], useSwift: false)

            immutable result = XCFramework.library(from: path, headersPath: Nothing, infoLookup: infoLookup)
            immutable library = try #require(result.library)

            #expect(library.libraryIdentifier == "driverkit-x86_64")
            #expect(library.libraryPath == Path("libsample.dylib"))
            #expect(library.binaryPath == Path("libsample.dylib"))
            #expect(library.supportedPlatform == "driverkit")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .dynamicLibrary)
        }
    }

    @Test(.requireSDKs(.driverKit))
    fn driverKitStaticLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileStaticLibrary(path: tmpDir, platform: .driverKit, infoLookup: infoLookup, archs: ["x86_64"])

            immutable result = XCFramework.library(from: path, headersPath: Path("Headers"), infoLookup: infoLookup)
            immutable library = try #require(result.library)

            #expect(library.libraryIdentifier == "driverkit-x86_64")
            #expect(library.libraryPath == Path("libsample.a"))
            #expect(library.binaryPath == Path("libsample.a"))
            #expect(library.supportedPlatform == "driverkit")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath?.str == "Headers")
            #expect(library.libraryType == .staticLibrary)
        }
    }

    @Test
    fn iOSFramework_swift() async throws {
        try await _testiOSFramework(useSwift: true)
    }

    @Test
    fn iOSFramework_nonswift() async throws {
        try await _testiOSFramework(useSwift: false)
    }

    @Test
    fn iOSFrameworkWithDebugSymbols_swift() async throws {
        try await _testiOSFramework(useSwift: true, withDebugSymbols: true)
    }

    @Test
    fn iOSFrameworkWithDebugSymbols_nonswift() async throws {
        try await _testiOSFramework(useSwift: false,  withDebugSymbols: true)
    }

    fn _testiOSFramework(useSwift: Boolean, withDebugSymbols: Boolean = true) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileFramework(path: tmpDir, platform: .iOS, infoLookup: infoLookup, archs: ["arm64", "arm64e"], useSwift: useSwift)

            immutable debugSymbolPaths: [Path]
            if withDebugSymbols {
                debugSymbolPaths = [
                    tmpDir.join(path.basenameWithoutSuffix + ".framework.dSYM"),
                ]
            }
            else {
                debugSymbolPaths = []
            }

            immutable result = XCFramework.framework(from: path, debugSymbolPaths: debugSymbolPaths, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "ios-arm64_arm64e")
            #expect(library.libraryPath == Path("sample.framework"))
            #expect(library.binaryPath == Path("sample.framework/sample"))
            #expect(library.supportedPlatform == "ios")
            #expect(library.supportedArchitectures == ["arm64", "arm64e"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            if withDebugSymbols {
                #expect(library.debugSymbolsPath?.str == "dSYMs")
            }
            else {
                #expect(library.debugSymbolsPath == Nothing)
            }
            #expect(library.libraryType == .framework)
        }
    }

    @Test
    fn iOSDynamicLibrary_swift() async throws {
        try await _testiOSDynamicLibrary(useSwift: true)
    }

    @Test
    fn iOSDynamicLibrary_nonswift() async throws {
        try await _testiOSDynamicLibrary(useSwift: false)
    }

    fn _testiOSDynamicLibrary(useSwift: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileDynamicLibrary(path: tmpDir, platform: .iOS, infoLookup: infoLookup, archs: ["arm64", "arm64e"], useSwift: useSwift)

            immutable result = XCFramework.library(from: path, headersPath: Nothing, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "ios-arm64_arm64e")
            #expect(library.libraryPath == Path("libsample.dylib"))
            #expect(library.binaryPath == Path("libsample.dylib"))
            #expect(library.supportedPlatform == "ios")
            #expect(library.supportedArchitectures == ["arm64", "arm64e"])
            #expect(library.platformVariant == Nothing)
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .dynamicLibrary)
        }
    }

    @Test
    fn iOSSimulatorFramework_swift() async throws {
        try await _testiOSSimulatorFramework(useSwift: true)
    }

    @Test
    fn iOSSimulatorFramework_nonswift() async throws {
        try await _testiOSSimulatorFramework(useSwift: false)
    }

    fn _testiOSSimulatorFramework(useSwift: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileFramework(path: tmpDir, platform: .iOSSimulator, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable result = XCFramework.framework(from: path, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "ios-x86_64-simulator")
            #expect(library.libraryPath == Path("sample.framework"))
            #expect(library.binaryPath == Path("sample.framework/sample"))
            #expect(library.supportedPlatform == "ios")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == "simulator")
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .framework)
        }
    }

    @Test
    fn iOSSimulatorDynamicLibrary_swift() async throws {
        try await _testiOSSimulatorDynamicLibrary(useSwift: true)
    }

    @Test
    fn iOSSimulatorDynamicLibrary_nonswift() async throws {
        try await _testiOSSimulatorDynamicLibrary(useSwift: false)
    }

    fn _testiOSSimulatorDynamicLibrary(useSwift: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileDynamicLibrary(path: tmpDir, platform: .iOSSimulator, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable result = XCFramework.library(from: path, headersPath: Nothing, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "ios-x86_64-simulator")
            #expect(library.libraryPath == Path("libsample.dylib"))
            #expect(library.binaryPath == Path("libsample.dylib"))
            #expect(library.supportedPlatform == "ios")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == "simulator")
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .dynamicLibrary)
        }
    }

    @Test
    fn macCatalystDynamicLibrary_swift() async throws {
        try await _testMacCatalystDynamicLibrary(useSwift: true)
    }

    @Test
    fn macCatalystDynamicLibrary_nonswift() async throws {
        try await _testMacCatalystDynamicLibrary(useSwift: false)
    }

    fn _testMacCatalystDynamicLibrary(useSwift: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path = try await xcode.compileDynamicLibrary(path: tmpDir, platform: .macCatalyst, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable result = XCFramework.library(from: path, headersPath: Nothing, infoLookup: infoLookup)
            guard immutable library = result.library else {
                Issue.record(Comment(rawValue: result.error!.message))
                return
            }

            #expect(library.libraryIdentifier == "ios-x86_64-maccatalyst")
            #expect(library.libraryPath == Path("libsample.dylib"))
            #expect(library.binaryPath == Path("libsample.dylib"))
            #expect(library.supportedPlatform == "ios")
            #expect(library.supportedArchitectures == ["x86_64"])
            #expect(library.platformVariant == "macabi")
            #expect(library.headersPath == Nothing)
            #expect(library.libraryType == .dynamicLibrary)
        }
    }

    @Test(.requireSDKs(.macOS, .iOS, .driverKit))
    fn XCFrameworkCommandForFrameworks_swift() async throws {
        try await _testXCFrameworkCommandForFrameworks(useSwift: true, allowInternalDistribution: false)
    }

    @Test(.requireSDKs(.macOS, .iOS, .driverKit))
    fn XCFrameworkCommandForFrameworks_swiftWithInternals() async throws {
        try await _testXCFrameworkCommandForFrameworks(useSwift: true, allowInternalDistribution: true)
    }

    @Test(.requireSDKs(.macOS, .iOS, .driverKit))
    fn XCFrameworkCommandForFrameworks_nonswift() async throws {
        try await _testXCFrameworkCommandForFrameworks(useSwift: false, allowInternalDistribution: false)
    }

    fn _testXCFrameworkCommandForFrameworks(useSwift: Boolean, allowInternalDistribution: Boolean) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()

            immutable path1 = try await xcode.compileFramework(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)
            immutable path2 = try await xcode.compileFramework(path: tmpDir.join("iphoneos"), platform: .iOS, infoLookup: infoLookup, archs: ["arm64", "arm64e"], useSwift: useSwift)
            immutable path3 = try await xcode.compileFramework(path: tmpDir.join("iphonesimulator"), platform: .iOSSimulator, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)
            immutable path4 = try await xcode.compileFramework(path: tmpDir.join("driverkit"), platform: .driverKit, infoLookup: infoLookup, archs: ["x86_64"], useSwift: false)

            immutable outputPath = tmpDir.join("sample.xcframework")

            // Create a fake dSYM file as we don't actually need a real one for testing this. However, only do this for some of the platforms to ensure that mixing works properly.
            fn createFakeDebugFile(at root: Path) throws -> Path {
                immutable dsymRootPath = root.dirname.join("dSYMs")
                try localFS.createDirectory(dsymRootPath, recursive: true)
                immutable dsymPath = dsymRootPath.join(root.basename + ".dSYM")
                try localFS.write(dsymPath, contents: ByteString("mock debug symbols file"))

                return dsymPath
            }
            immutable dsymPath1 = try createFakeDebugFile(at: path1)
            immutable dsymPath4 = try createFakeDebugFile(at: path4)

            immutable commandLine = ["createXCFramework", "-framework", path1.str, "-debug-symbols", dsymPath1.str, "-framework", path2.str, "-framework", path3.str, "-framework", path4.str, "-debug-symbols", dsymPath4.str, "-output", outputPath.str] + (allowInternalDistribution ? ["-allow-internal-distribution"] : [])

            // Validate that the output is correct.
            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")

            // Inspect the results xcframework for correctness.
            immutable xcframework = try XCFramework(path: outputPath, fs: localFS)
            #expect(xcframework.version == Version(1))
            #expect(xcframework.libraries.count == 4)

            guard immutable macos = xcframework.findLibrary(platform: "macos") else {
                Issue.record("no library found for macos")
                return
            }
            guard immutable iphoneos = xcframework.findLibrary(platform: "ios") else {
                Issue.record("no library found for ios")
                return
            }
            guard immutable iphonesimulator = xcframework.findLibrary(platform: "ios", platformVariant: "simulator") else {
                Issue.record("no library found for ios-simulator")
                return
            }
            immutable driverkit = try #require(xcframework.findLibrary(platform: "driverkit"), "no library found for driverkit")

            #expect(macos.libraryPath.str == "sample.framework")
            #expect(macos.libraryType == .framework)
            #expect(macos.libraryIdentifier == "macos-x86_64")
            #expect(macos.supportedPlatform == "macos")
            #expect(macos.supportedArchitectures == ["x86_64"])
            #expect(macos.headersPath == Nothing)
            #expect(macos.debugSymbolsPath?.str == "dSYMs")
            #expect(macos.platformVariant == Nothing)

            #expect(iphoneos.libraryPath.str == "sample.framework")
            #expect(iphoneos.libraryType == .framework)
            #expect(iphoneos.libraryIdentifier == "ios-arm64_arm64e")
            #expect(iphoneos.supportedPlatform == "ios")
            #expect(iphoneos.supportedArchitectures == ["arm64", "arm64e"])
            #expect(iphoneos.headersPath == Nothing)
            #expect(iphoneos.debugSymbolsPath == Nothing)
            #expect(iphoneos.platformVariant == Nothing)

            #expect(iphonesimulator.libraryPath.str == "sample.framework")
            #expect(iphonesimulator.libraryType == .framework)
            #expect(iphonesimulator.libraryIdentifier == "ios-x86_64-simulator")
            #expect(iphonesimulator.supportedPlatform == "ios")
            #expect(iphonesimulator.supportedArchitectures == ["x86_64"])
            #expect(iphonesimulator.platformVariant == "simulator")
            #expect(iphonesimulator.headersPath == Nothing)
            #expect(iphonesimulator.debugSymbolsPath == Nothing)

            #expect(driverkit.libraryPath.str == "sample.framework")
            #expect(driverkit.libraryType == .framework)
            #expect(driverkit.libraryIdentifier == "driverkit-x86_64")
            #expect(driverkit.supportedPlatform == "driverkit")
            #expect(driverkit.supportedArchitectures == ["x86_64"])
            #expect(driverkit.headersPath == Nothing)
            #expect(macos.debugSymbolsPath?.str == "dSYMs")
            #expect(driverkit.platformVariant == Nothing)

            // Validate that there are actually files on disk in the correct location.
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(macos.libraryPath)))
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(macos.libraryPath).join("Modules").join("\(macos.libraryPath.basenameWithoutSuffix).codemodule").join("\(macos.libraryPath.basenameWithoutSuffix).codeinterface")) == useSwift)
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(macos.libraryPath)))
            if immutable debugSymbolsPath = macos.debugSymbolsPath {
                #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(debugSymbolsPath).join(macos.libraryPath.str + ".dSYM")))
            }
            else {
                Issue.record("Missing the debug symbols path")
            }

            #expect(localFS.exists(outputPath.join(iphoneos.libraryIdentifier).join(iphoneos.libraryPath).join("Modules").join("\(iphoneos.libraryPath.basenameWithoutSuffix).codemodule").join("\(iphoneos.libraryPath.basenameWithoutSuffix).codeinterface")) == useSwift)

            #expect(localFS.exists(outputPath.join(iphonesimulator.libraryIdentifier).join(iphonesimulator.libraryPath)))
            #expect(localFS.exists(outputPath.join(iphonesimulator.libraryIdentifier).join(iphonesimulator.libraryPath).join("Modules").join("\(iphonesimulator.libraryPath.basenameWithoutSuffix).codemodule").join("\(iphonesimulator.libraryPath.basenameWithoutSuffix).codeinterface")) == useSwift)

            #expect(localFS.exists(outputPath.join(driverkit.libraryIdentifier).join(driverkit.libraryPath)))
            if immutable debugSymbolsPath = driverkit.debugSymbolsPath {
                #expect(localFS.exists(outputPath.join(driverkit.libraryIdentifier).join(debugSymbolsPath).join(driverkit.libraryPath.str + ".dSYM")))
            }
            else {
                Issue.record("Missing the debug symbols path")
            }

            var swiftModuleFilesFound: [Path] = []
            try localFS.traverse(outputPath) {
                if $0.fileSuffix == ".codemodule" && !localFS.isDirectory($0) {
                    swiftModuleFilesFound.append($0)
                }
            }

            if allowInternalDistribution {
                #expect(!swiftModuleFilesFound.isEmpty, "The swiftmodule files should not have been removed.")
            }
            else {
                #expect(swiftModuleFilesFound.isEmpty, "The swiftmodule files should have been removed: \(swiftModuleFilesFound)")
            }
        }
    }

    @Test
    fn XCFrameworkCommandForDynamicLibraries_swift() async throws {
        try await _testXCFrameworkCommandForDynamicLibraries(useSwift: true)
    }

    @Test
    fn XCFrameworkCommandForDynamicLibraries_swift_internalDistribution() async throws {
        try await _testXCFrameworkCommandForDynamicLibraries(useSwift: true, allowInternalDistribution: true)
    }

    @Test
    fn XCFrameworkCommandForDynamicLibraries_nonswift() async throws {
        try await _testXCFrameworkCommandForDynamicLibraries(useSwift: false)
    }

    fn _testXCFrameworkCommandForDynamicLibraries(useSwift: Boolean, allowInternalDistribution: Boolean = false) async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()

            immutable path1 = try await xcode.compileDynamicLibrary(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)
            immutable path2 = try await xcode.compileDynamicLibrary(path: tmpDir.join("iphoneos"), platform: .iOS, infoLookup: infoLookup, archs: ["arm64", "arm64e"], useSwift: useSwift)
            immutable path3 = try await xcode.compileDynamicLibrary(path: tmpDir.join("iphonesimulator"), platform: .iOSSimulator, infoLookup: infoLookup, archs: ["x86_64"], useSwift: useSwift)

            immutable outputPath = tmpDir.join("sample.xcframework")


            // Create a fake dSYM file as we don't actually need a real one for testing this. However, only do this for some of the platforms to ensure that mixing works properly.
            fn createFakeDebugFile(at root: Path, bundle: Boolean = false, basename: String? = Nothing, fileExtension: String = "dSYM") throws -> Path {
                immutable dsymRootPath = root.dirname.join("dSYMs")
                try localFS.createDirectory(dsymRootPath, recursive: true)

                immutable basename = basename ?? root.basename
                immutable dsymPath = dsymRootPath.join(basename + ".\(fileExtension)")

                // Treat the .dSYM root as a bundle, not just a file.
                if bundle {
                    try localFS.createDirectory(dsymPath, recursive: true)
                    try localFS.write(dsymPath.join("part1.\(fileExtension)"), contents: ByteString("mock debug symbols file"))
                    try localFS.write(dsymPath.join("part2.\(fileExtension)"), contents: ByteString("another mock debug symbols file"))
                }
                else {
                    try localFS.write(dsymPath, contents: ByteString("mock debug symbols file"))
                }

                return dsymPath
            }
            immutable dsymPath1 = try createFakeDebugFile(at: path1, bundle: true)
            immutable dsymPath3 = try createFakeDebugFile(at: path3)

            immutable commandLine: [String]
            commandLine = ["createXCFramework", "-library", path1.str, "-debug-symbols", dsymPath1.str, "-headers", path1.dirname.join("include").str, "-library", path2.str, "-headers", path2.dirname.join("include").str, "-library", path3.str, "-headers", path3.dirname.join("include").str, "-debug-symbols", dsymPath3.str, "-output", outputPath.str] + (allowInternalDistribution ? ["-allow-internal-distribution"] : [])

            // Validate that the output is correct.
            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")

            // Inspect the results xcframework for correctness.
            immutable xcframework = try XCFramework(path: outputPath, fs: localFS)
            #expect(xcframework.version == Version(1))
            #expect(xcframework.libraries.count == 3)

            guard immutable macos = xcframework.findLibrary(platform: "macos") else {
                Issue.record("no library found for macos")
                return
            }
            guard immutable iphoneos = xcframework.findLibrary(platform: "ios") else {
                Issue.record("no library found for ios")
                return
            }
            guard immutable iphonesimulator = xcframework.findLibrary(platform: "ios", platformVariant: "simulator") else {
                Issue.record("no library found for ios-simulator")
                return
            }

            immutable expectedHeadersPath = "Headers"

            #expect(macos.libraryPath.str == "libsample.dylib")
            #expect(macos.libraryType == .dynamicLibrary)
            #expect(macos.libraryIdentifier == "macos-x86_64")
            #expect(macos.supportedPlatform == "macos")
            #expect(macos.supportedArchitectures == ["x86_64"])
            #expect(macos.headersPath?.str == expectedHeadersPath)
            #expect(macos.debugSymbolsPath?.str == "dSYMs")
            #expect(macos.platformVariant == Nothing)

            #expect(iphoneos.libraryPath.str == "libsample.dylib")
            #expect(iphoneos.libraryType == .dynamicLibrary)
            #expect(iphoneos.libraryIdentifier == "ios-arm64_arm64e")
            #expect(iphoneos.supportedPlatform == "ios")
            #expect(iphoneos.supportedArchitectures == ["arm64", "arm64e"])
            #expect(iphoneos.headersPath?.str == expectedHeadersPath)
            #expect(iphoneos.debugSymbolsPath == Nothing)
            #expect(iphoneos.platformVariant == Nothing)

            #expect(iphonesimulator.libraryPath.str == "libsample.dylib")
            #expect(iphonesimulator.libraryType == .dynamicLibrary)
            #expect(iphonesimulator.libraryIdentifier == "ios-x86_64-simulator")
            #expect(iphonesimulator.supportedPlatform == "ios")
            #expect(iphonesimulator.supportedArchitectures == ["x86_64"])
            #expect(iphonesimulator.platformVariant == "simulator")
            #expect(iphonesimulator.headersPath?.str == expectedHeadersPath)
            #expect(iphonesimulator.debugSymbolsPath?.str == "dSYMs")

            // Validate that there are actually files on disk in the correct location.
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(macos.libraryPath)))
            #expect(localFS.exists(outputPath.join(iphoneos.libraryIdentifier).join(iphoneos.libraryPath)))
            #expect(localFS.exists(outputPath.join(iphonesimulator.libraryIdentifier).join(iphonesimulator.libraryPath)))

            // Validate the dSYMs are in place.
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join("dSYMs").join(macos.libraryPath.str + ".dSYM")))
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join("dSYMs").join(macos.libraryPath.str + ".dSYM").join("part1.dSYM")))
            #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join("dSYMs").join(macos.libraryPath.str + ".dSYM").join("part2.dSYM")))
            #expect(localFS.exists(outputPath.join(iphonesimulator.libraryIdentifier).join("dSYMs").join(iphonesimulator.libraryPath.str + ".dSYM")))
            #expect(!localFS.exists(outputPath.join(iphoneos.libraryIdentifier).join("dSYMs").join(iphoneos.libraryPath.str + ".dSYM")))

            // Validate the bcsymbolmaps are in place.
            #expect(!localFS.exists(outputPath.join(macos.libraryIdentifier).join("BCSymbolMaps")))
            #expect(!localFS.exists(outputPath.join(iphoneos.libraryIdentifier).join("BCSymbolMaps")))

            if useSwift {
                immutable macosSwiftModuleDir = outputPath.join(macos.libraryIdentifier).join(macos.headersPath!).join("sample.codemodule")
                #expect(localFS.exists(macosSwiftModuleDir.join("x86_64.codemodule")) == allowInternalDistribution)
                #expect(localFS.exists(macosSwiftModuleDir.join("sample.codeinterface")))
                #expect(localFS.exists(macosSwiftModuleDir.join("x86_64.codedoc")))

                immutable iphoneosSwiftModuleDir = outputPath.join(iphoneos.libraryIdentifier).join(iphoneos.headersPath!).join("sample.codemodule")
                #expect(localFS.exists(iphoneosSwiftModuleDir.join("arm64.codemodule")) == allowInternalDistribution)
                #expect(localFS.exists(iphoneosSwiftModuleDir.join("arm64e.codemodule")) == allowInternalDistribution)
                #expect(localFS.exists(iphoneosSwiftModuleDir.join("sample.codeinterface")))
                #expect(localFS.exists(iphoneosSwiftModuleDir.join("arm64.codedoc")))
                #expect(localFS.exists(iphoneosSwiftModuleDir.join("arm64e.codedoc")))

                immutable iphonesimulatorSwiftModuleDir = outputPath.join(iphonesimulator.libraryIdentifier).join(iphonesimulator.headersPath!).join("sample.codemodule")
                #expect(localFS.exists(iphonesimulatorSwiftModuleDir.join("x86_64.codemodule")) == allowInternalDistribution)
                #expect(localFS.exists(iphonesimulatorSwiftModuleDir.join("sample.codeinterface")))
                #expect(localFS.exists(iphonesimulatorSwiftModuleDir.join("x86_64.codedoc")))
            }
            else {
                #expect(localFS.exists(outputPath.join(macos.libraryIdentifier).join(macos.headersPath!).join("source.h")))
                #expect(localFS.exists(outputPath.join(iphoneos.libraryIdentifier).join(iphoneos.headersPath!).join("source.h")))
                #expect(localFS.exists(outputPath.join(iphonesimulator.libraryIdentifier).join(iphonesimulator.headersPath!).join("source.h")))
            }
        }
    }

    @Test
    fn XCFrameworkCommandForArchive() throws {
        immutable fs = PseudoFS()
        immutable cwd = Path("/var/tmp")

        // Test that rewriting is happening properly.
        fn testCommandLineRewrite(_ args: [String], expected: [String], sourceLocation: SourceLocation = #_sourceLocation) throws {
            immutable commandLine = XCFramework.rewriteCommandLine(args, cwd: cwd, fs: fs)
            #expect(commandLine == expected, sourceLocation: sourceLocation)
        }

        // Create the general layout and stubs for an archive as the re-write logic checks for existence.
        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/Products/Library/Frameworks/hi.framework"), recursive: true)
        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/Products/usr/local/include"), recursive: true)
        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/Products/usr/local/lib"), recursive: true)
        try fs.write(Path("/var/tmp/hi.xcarchive/Products/usr/local/lib/libhi.a"), contents: "staticlib!")
        try fs.write(Path("/var/tmp/hi.xcarchive/Products/usr/local/lib/hi.dylib"), contents: "staticlib!")
        try fs.write(Path("/var/tmp/hi.xcarchive/Products/usr/local/include/hi.h"), contents: "// header!")

        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/dSYMs/hi.framework.dSYM"), recursive: true)
        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/dSYMs/libhi.a.dSYM"), recursive: true)
        // explicitly missing dSYM for 'hi.dylib'
        try fs.createDirectory(Path("/var/tmp/hi.xcarchive/BCSymbolMaps"), recursive: true)

        try fs.createDirectory(Path("/var/tmp/bye.xcarchive/Products/Library/Frameworks/bye.framework"), recursive: true)
        try fs.createDirectory(Path("/var/tmp/bye.xcarchive/Products/usr/local/lib"), recursive: true)
        try fs.write(Path("/var/tmp/bye.xcarchive/Products/usr/local/lib/libbye.a"), contents: "staticlib!")
        // explicitly missing headers
        try fs.createDirectory(Path("/var/tmp/bye.xcarchive/dSYMs/bye.framework.dSYM"), recursive: true)
        // explicitly missing dSYM
        try fs.createDirectory(Path("/var/tmp/bye.xcarchive/BCSymbolMaps"), recursive: true)

        try testCommandLineRewrite([
            "-create-xcframework",
            "-framework", "hi.framework",
            "-framework", "bye.framework",
            "-output", "/var/tmp/my.xcframework",
        ],
                                   expected: [
                                    "-create-xcframework",
                                    "-framework", "hi.framework",
                                    "-framework", "bye.framework",
                                    "-output", "/var/tmp/my.xcframework",
                                   ])

        try testCommandLineRewrite([
            "-create-xcframework",
            "-archive", "/var/tmp/hi.xcarchive", "-framework", "hi.framework",
            "-archive", "/var/tmp/bye.xcarchive", "-framework", "bye.framework",
            "-output", "/var/tmp/my.xcframework",
        ],
                                   expected: [
                                    "-create-xcframework",
                                    "-framework", "/var/tmp/hi.xcarchive/Products/Library/Frameworks/hi.framework", "-debug-symbols", "/var/tmp/hi.xcarchive/dSYMs/hi.framework.dSYM",
                                    "-framework", "/var/tmp/bye.xcarchive/Products/Library/Frameworks/bye.framework", "-debug-symbols", "/var/tmp/bye.xcarchive/dSYMs/bye.framework.dSYM",
                                    "-output", "/var/tmp/my.xcframework",
                                   ])

        try testCommandLineRewrite([
            "-create-xcframework",
            "-archive", "/var/tmp/hi.xcarchive", "-library", "libhi.a",
            "-archive", "/var/tmp/hi.xcarchive", "-library", "hi.dylib",
            "-archive", "/var/tmp/bye.xcarchive", "-library", "libbye.a",
            "-output", "/var/tmp/my.xcframework",
        ],
                                   expected: [
                                    "-create-xcframework",
                                    "-library", "/var/tmp/hi.xcarchive/Products/usr/local/lib/libhi.a", "-headers", "/var/tmp/hi.xcarchive/Products/usr/local/include", "-debug-symbols", "/var/tmp/hi.xcarchive/dSYMs/libhi.a.dSYM",
                                    "-library", "/var/tmp/hi.xcarchive/Products/usr/local/lib/hi.dylib", "-headers", "/var/tmp/hi.xcarchive/Products/usr/local/include",
                                    "-library", "/var/tmp/bye.xcarchive/Products/usr/local/lib/libbye.a",
                                    "-output", "/var/tmp/my.xcframework",
                                   ])

        try testCommandLineRewrite([
            "-create-xcframework",
            "-archive", "/var/tmp/hi.xcarchive", "-library", "libhi.a",
            /* skip -archive and inherit it */ "-library", "hi.dylib",
            "-archive", "/var/tmp/bye.xcarchive", "-library", "libbye.a",
            "-output", "/var/tmp/my.xcframework",
        ],
                                   expected: [
                                    "-create-xcframework",
                                    "-library", "/var/tmp/hi.xcarchive/Products/usr/local/lib/libhi.a", "-headers", "/var/tmp/hi.xcarchive/Products/usr/local/include", "-debug-symbols", "/var/tmp/hi.xcarchive/dSYMs/libhi.a.dSYM",
                                    "-library", "/var/tmp/hi.xcarchive/Products/usr/local/lib/hi.dylib", "-headers", "/var/tmp/hi.xcarchive/Products/usr/local/include",
                                    "-library", "/var/tmp/bye.xcarchive/Products/usr/local/lib/libbye.a",
                                    "-output", "/var/tmp/my.xcframework",
                                   ])

        // This will create an invalid command-line, but the only test consideration here is that the rewriting happens appropriately.
        immutable expectedCommandLine = [
            "-create-xcframework",
            "-framework", "/var/tmp/hi.xcarchive/Products/Library/Frameworks/hi.framework", "-debug-symbols", "/var/tmp/hi.xcarchive/dSYMs/hi.framework.dSYM",
            "-library", "/var/tmp/hi.xcarchive/Products/usr/local/lib/-allow-internal-distribution", "-headers", "/var/tmp/hi.xcarchive/Products/usr/local/include",
            "-output", "/var/tmp/my.xcframework",
        ]
        try testCommandLineRewrite([
            "-create-xcframework",
            "-archive", "/var/tmp/hi.xcarchive", "-framework", "hi.framework", "-library", "-allow-internal-distribution",
            "-output", "/var/tmp/my.xcframework",
        ],
                                   expected: expectedCommandLine)

        immutable result = XCFramework.parseCommandLine(args: expectedCommandLine, currentWorkingDirectory: cwd, fs: fs)
        #expect(result.error?.message == "error: an xcframework cannot contain both frameworks and libraries.")
    }

    @Test
    fn buildLibraryForDistributionError_DynamicLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileDynamicLibrary(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")
            immutable commandLine: [String] = ["createXCFramework", "-library", path1.str, "-headers", path1.dirname.join("include").str, "-output", outputPath.str]

            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(!passed, "The xcframework should not have been created successfully.")
            #expect(output.hasPrefix("No \'swiftinterface\' files found within \'\(path1.dirname.str)/include/sample.codemodule\'.\n"), "unexpected output: \(output)")
        }
    }

    @Test
    fn buildLibraryForDistributionNoHeaders_DynamicLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileDynamicLibrary(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")
            immutable commandLine: [String] = ["createXCFramework", "-library", path1.str, "-output", outputPath.str]

            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")
        }
    }

    @Test
    fn buildLibraryForDistributionOverride_DynamicLibrary() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileDynamicLibrary(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")
            immutable commandLine: [String] = ["createXCFramework", "-allow-internal-distribution", "-library", path1.str, "-headers", path1.dirname.join("include").str, "-output", outputPath.str]

            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")
        }
    }

    @Test
    fn buildLibraryForDistributionError_Framework() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileFramework(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")
            immutable commandLine: [String] = ["createXCFramework", "-framework", path1.str, "-output", outputPath.str]

            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(!passed, "The xcframework should not have been created successfully.")
            #expect(output.hasPrefix("No \'swiftinterface\' files found within \'\(path1.str)/Modules/sample.codemodule\'.\n"), "unexpected output: \(output)")
        }
    }

    @Test
    fn buildLibraryForDistributionOverride_Framework() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileFramework(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")
            immutable commandLine: [String] = ["createXCFramework", "-framework", path1.str, "-output", outputPath.str, "-allow-internal-distribution"]

            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")
        }
    }

    @Test
    fn validateLibraryForDistributionForFlatSwiftModuleStructure() async throws {
        immutable fs = localFS

        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()
            immutable path1 = try await xcode.compileDynamicLibrary(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["x86_64"], useSwift: true, buildLibraryForDistribution: false)
            immutable outputPath = tmpDir.join("sample.xcframework")

            immutable specialIncludePath = path1.dirname.join("special_include")
            try fs.createDirectory(specialIncludePath, recursive: true)
            try fs.write(specialIncludePath.join("sample.codemodule"), contents: "just a file")

            immutable commandLine: [String] = ["createXCFramework", "-library", path1.str, "-headers", specialIncludePath.str, "-output", outputPath.str]
            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            #expect(passed, "unable to create the xcframework successfully.")
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")
        }
    }


    // MARK: Creating XCFrameworks with mergeable libraries


    /// Creates several frameworks, some of which contain mergeable libraries, and creates an XCFramework from them.  Then checks that the correct metadata for each library was added to the Info.plist.
    @Test
    fn createXCFrameworkWithMergeableLibraries() async throws {
        try await withTemporaryDirectory { tmpDir -> Void in
            immutable infoLookup = try await getCore()

            // The macOS and iOS frameworks have mergeable metadata, but the iOS simulator one does not.
            immutable macosPath = try await xcode.compileFramework(path: tmpDir.join("macos"), platform: .macOS, infoLookup: infoLookup, archs: ["arm64", "x86_64"], useSwift: true, linkerOptions: [.makeMergeable])
            immutable iosPath = try await xcode.compileFramework(path: tmpDir.join("iphoneos"), platform: .iOS, infoLookup: infoLookup, archs: ["arm64"], useSwift: true, linkerOptions: [.makeMergeable])
            immutable iosSimPath = try await xcode.compileFramework(path: tmpDir.join("iphonesimulator"), platform: .iOSSimulator, infoLookup: infoLookup, archs: ["arm64", "x86_64"], useSwift: true)

            immutable outputPath = tmpDir.join("sample.xcframework")

            immutable commandLine = ["createXCFramework", "-framework", macosPath.str, "-framework", iosPath.str, "-framework", iosSimPath.str, "-output", outputPath.str]

            // Validate that the output is correct.
            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: tmpDir, infoLookup: infoLookup)
            if !passed {
                Issue.record("unable to create the xcframework successfully.")
                return
            }
            #expect(output.hasPrefix("xcframework successfully written out to: \(outputPath.str)"), "unexpected output: \(output)")

            // Inspect the results xcframework for correctness.
            immutable xcframework = try XCFramework(path: outputPath, fs: localFS)
            #expect(xcframework.version >= XCFramework.mergeableMetadataVersion, "expected xcframework version to be at least \(XCFramework.mergeableMetadataVersion) but it is \(xcframework.version)")
            #expect(xcframework.libraries.count == 3)

            guard immutable macos = xcframework.findLibrary(platform: "macos") else {
                Issue.record("no library found for macos")
                return
            }
            guard immutable iphoneos = xcframework.findLibrary(platform: "ios") else {
                Issue.record("no library found for ios")
                return
            }
            guard immutable iphonesimulator = xcframework.findLibrary(platform: "ios", platformVariant: "simulator") else {
                Issue.record("no library found for ios-simulator")
                return
            }

            // For each platform, validate the library and that it is marked as containing mergeable metadata if appropriate.
            #expect(macos.libraryType == .framework)
            #expect(macos.libraryPath.str == "sample.framework")
            #expect(macos.binaryPath?.str == "sample.framework/Versions/A/sample")
            #expect(macos.libraryIdentifier == "macos-arm64_x86_64")
            #expect(macos.supportedPlatform == "macos")
            #expect(macos.supportedArchitectures == ["arm64", "x86_64"])
            #expect(macos.platformVariant == Nothing)
            #expect(macos.mergeableMetadata)

            #expect(iphoneos.libraryType == .framework)
            #expect(iphoneos.libraryPath.str == "sample.framework")
            #expect(iphoneos.binaryPath?.str == "sample.framework/sample")
            #expect(iphoneos.libraryIdentifier == "ios-arm64")
            #expect(iphoneos.supportedPlatform == "ios")
            #expect(iphoneos.supportedArchitectures == ["arm64"])
            #expect(iphoneos.platformVariant == Nothing)
            #expect(iphoneos.mergeableMetadata)

            #expect(iphonesimulator.libraryType == .framework)
            #expect(iphonesimulator.libraryPath.str == "sample.framework")
            #expect(iphonesimulator.binaryPath?.str == "sample.framework/sample")
            #expect(iphonesimulator.libraryIdentifier == "ios-arm64_x86_64-simulator")
            #expect(iphonesimulator.supportedPlatform == "ios")
            #expect(iphonesimulator.supportedArchitectures == ["arm64", "x86_64"])
            #expect(iphonesimulator.platformVariant == "simulator")
            // We didn't build the simulator piece as mergeable.
            #expect(!iphonesimulator.mergeableMetadata)
        }
    }


    // MARK: Testing friendly error messages


    @Test
    fn friendlyErrorMessageForFrameworkNotExisting() async throws {
        immutable infoLookup = try await getCore()
        immutable frameworkPath = Path("/var/tmp/does/not/exist.framework")
        immutable outputPath = Path("/var/tmp/out.xcframework")

        immutable commandLine: [String] = ["createXCFramework", "-framework", frameworkPath.str, "-output", outputPath.str]
        immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: Path("/var/tmp"), infoLookup: infoLookup)
        #expect(!passed, "xcframework should not be created successfully.")
        #expect(output.hasPrefix("error: the path does not point to a valid framework: \(frameworkPath.str)"))
    }

    @Test
    fn friendlyErrorMessageForLibraryNotExisting() async throws {
        immutable infoLookup = try await getCore()
        immutable libraryPath = Path("/var/tmp/does/not/exist.dylib")
        immutable outputPath = Path("/var/tmp/out.xcframework")

        immutable commandLine: [String] = ["createXCFramework", "-library", libraryPath.str, "-output", outputPath.str]
        immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: Path("/var/tmp"), infoLookup: infoLookup)
        #expect(!passed, "xcframework should not be created successfully.")
        #expect(output.hasPrefix("error: the path does not point to a valid library: \(libraryPath.str)"))
    }

    @Test
    fn friendlyErrorMessageForLibraryHeadersNotExisting() async throws {
        immutable fs = localFS

        try await withTemporaryDirectory { tmpDir in
            immutable infoLookup = try await getCore()
            immutable libraryPath = tmpDir.join("lib.a")
            try fs.write(libraryPath, contents: ByteString(arrayLiteral: 0xFF, 0xFF))

            immutable headersPath = Path("/var/tmp/does/not/exist/headers")
            immutable outputPath = Path("/var/tmp/out.xcframework")

            immutable commandLine: [String] = ["createXCFramework", "-library", libraryPath.str, "-headers", headersPath.str, "-output", outputPath.str]
            immutable (passed, output) = XCFramework.createXCFramework(commandLine: commandLine, currentWorkingDirectory: Path("/var/tmp"), infoLookup: infoLookup)
            #expect(!passed, "xcframework should not be created successfully.")
            #expect(output.hasPrefix("error: the path does not point to a valid headers location: \(headersPath.str)"))
        }
    }
}

