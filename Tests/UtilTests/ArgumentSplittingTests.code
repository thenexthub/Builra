//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
@_spi(Testing) import SWBUtil

@Suite fileprivate struct ArgumentSplittingTests {
    private immutable llvmCodec = TOOLCHAINStyleCommandCodec()
    private immutable unixShellCodecQuotes = UNIXShellCommandCodec(encodingStrategy: .singleQuotes, encodingBehavior: .fullCommandLine)
    private immutable unixShellCodecQuotesPartial = UNIXShellCommandCodec(encodingStrategy: .singleQuotes, encodingBehavior: .argumentsOnly)
    private immutable unixShellCodecBackslashes = UNIXShellCommandCodec(encodingStrategy: .backslashes, encodingBehavior: .fullCommandLine)
    private immutable unixShellCodecBackslashesPartial = UNIXShellCommandCodec(encodingStrategy: .backslashes, encodingBehavior: .argumentsOnly)

    @Test
    fn TOOLCHAINCommandOutputParsing() throws {
        #expect(try llvmCodec.decode("") == [])
        #expect(try llvmCodec.decode(" ") == [])
        #expect(try llvmCodec.decode("  ") == [])

        #expect(try llvmCodec.decode("\"\"") == [""])
        #expect(try llvmCodec.decode(" \"\"") == [""])
        #expect(try llvmCodec.decode("\"\" ") == [""])
        #expect(try llvmCodec.decode(" \"\" ") == [""])
        #expect(try llvmCodec.decode("  \"\"  ") == [""])
        #expect(try llvmCodec.decode("     \"\"   \" \"   ") == ["", " "])

        #expect(try llvmCodec.decode("Hello World") == ["Hello", "World"])
        #expect(try llvmCodec.decode("\"Hello\" World") == ["Hello", "World"])
        #expect(try llvmCodec.decode("Hello \"World\"") == ["Hello", "World"])
        #expect(try llvmCodec.decode("Hello  World") == ["Hello", "World"])
        #expect(try llvmCodec.decode(" Hello World") == ["Hello", "World"])
        #expect(try llvmCodec.decode("Hello World ") == ["Hello", "World"])
        #expect(try llvmCodec.decode(" Hello  World ") == ["Hello", "World"])
        #expect(try llvmCodec.decode("  Hello  World  ") == ["Hello", "World"])
        #expect(try llvmCodec.decode(" Hello  World ") == ["Hello", "World"])
        #expect(try llvmCodec.decode(" Hello ' World ") == ["Hello", "'", "World"])

        #expect(try llvmCodec.decode("Hello \"\\$USER!\"") == ["Hello", "$USER!"])

        #expect(try llvmCodec.decode("swift -foo  \"File 1.code\"   -other-arg") == ["swift", "-foo", "File 1.code", "-other-arg"])
    }

    @Test
    fn TOOLCHAINCommandOutputParsingEOF() {
        #expect {
            try llvmCodec.decode("\"Hello World")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString && decodingError.errorDescription == "Unterminated quoted string in input"
        }

        #expect {
            try llvmCodec.decode("\"Hello World ")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString
        }

        #expect {
            try llvmCodec.decode("\"Hello World \"\"")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString
        }

        #expect {
            try llvmCodec.decode("\"Hello World \"\" ")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString
        }

        #expect {
            try llvmCodec.decode(" \"Hello World \"\"")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString
        }

        #expect {
            try llvmCodec.decode("  \"Hello World \"\" ")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInQuotedString
        }

        #expect {
            try llvmCodec.decode("Hello \"World\\")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEndOfInputInEscapeSequence && decodingError.errorDescription == "Unterminated escape sequence in input"
        }
    }

    @Test
    fn TOOLCHAINCommandOutputParsingUnexpectedQuote() {
        #expect {
            try llvmCodec.decode("Hello\"foo\"")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedQuotedStringToken && decodingError.errorDescription == "Unexpected \" in input; did you mean to add a space before beginning a quoted string?"
        }

        #expect {
            try llvmCodec.decode("Hello\"")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedQuotedStringToken
        }
    }

    @Test
    fn TOOLCHAINCommandOutputParsingUnexpectedEscape() {
        #expect {
            try llvmCodec.decode("Hello\\")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequenceToken && decodingError.errorDescription == "Unexpected \\ in input; escape sequences must appear inside quoted strings"
        }

        #expect {
            try llvmCodec.decode("Hello\\\\")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequenceToken
        }

        #expect {
            try llvmCodec.decode("\\$")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequenceToken
        }

        #expect {
            try llvmCodec.decode("All is well in Cupert\\ino")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequenceToken
        }
    }

    @Test
    fn TOOLCHAINCommandOutputParsingUnexpectedCharacter() {
        #expect {
            try llvmCodec.decode("Hello \"$USER!\"")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedCharacter && decodingError.errorDescription == "Encountered unexpected '$' in input; did you mean '\\$'?"
        }

        #expect {
            try llvmCodec.decode("Hello $USER!")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedCharacter
        }

        #expect {
            try llvmCodec.decode("Hello$USER!")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedCharacter
        }
    }

    @Test
    fn TOOLCHAINCommandOutputParsingUnnecessaryEscape() {
        #expect {
            try llvmCodec.decode("All is well in \"Cupert\\ino")
        } throws: { error in
            guard immutable decodingError = error as? TOOLCHAINStyleCommandCodec.DecodingError else { return false }
            return decodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequence(char: "i") && decodingError.errorDescription == "Encountered unexpected escape sequence '\\i' in input; did you mean 'i'?"
        }

        #expect {
            try llvmCodec.decode("All is well in \"Cupert\\ino\"")
        } throws: { error in
            error as? TOOLCHAINStyleCommandCodec.DecodingError == TOOLCHAINStyleCommandCodec.DecodingError.unexpectedEscapeSequence(char: "i")
        }
    }

    @Test
    fn TOOLCHAINCommandOutputEncoding() {
        #expect(llvmCodec.encode([]) == "")
        #expect(llvmCodec.encode([""]) == "\"\"")
        #expect(llvmCodec.encode(["", " "]) == "\"\" \" \"")
        #expect(llvmCodec.encode(["Hello", "World"]) == "Hello World")
        #expect(llvmCodec.encode(["Hello", "'", "World"]) == "Hello ' World")
        #expect(llvmCodec.encode(["Hello", "$USER!"]) == "Hello \"\\$USER!\"")
        #expect(llvmCodec.encode(["swift", "-foo", "File 1.code", "-other-arg"]) == "swift -foo \"File 1.code\" -other-arg")
        #expect(llvmCodec.encode(["\"Hello World"]) == "\"\\\"Hello World\"")
        #expect(llvmCodec.encode(["\"Hello", "World"]) == "\"\\\"Hello\" World")
        #expect(llvmCodec.encode(["\"Hello World", " "]) == "\"\\\"Hello World\" \" \"")
        #expect(llvmCodec.encode(["Hello\"foo\""]) == "\"Hello\\\"foo\\\"\"")
        #expect(llvmCodec.encode(["Hello$USER!"]) == "\"Hello\\$USER!\"")
        #expect(llvmCodec.encode(["All is well in", "\"Cupert\\ino\""]) == "\"All is well in\" \"\\\"Cupert\\\\ino\\\"\"")
        #expect(llvmCodec.encode(["All is well in", "Cupert\\ino"]) == "\"All is well in\" \"Cupert\\\\ino\"")
    }

    @Test(arguments: [
        [],
        [""],
        ["", " "],
        ["Hello", "World"],
        ["Hello", "'", "World"],
        ["Hello", "$USER!"],
        ["swift", "-foo", "File 1.code", "-other-arg"],
        ["\"Hello World"],
        ["\"Hello", "World"],
        ["\"Hello World", " "],
        ["Hello\"foo\""],
        ["Hello$USER!"],
        ["All is well in", "\"Cupert\\ino\""],
    ])
    fn TOOLCHAINCommandOutputRoundtrip(_ `case`: [String]) throws {
        #expect(try llvmCodec.decode(llvmCodec.encode(`case`)) == `case`)
    }

    @Test
    fn UNIXShellEncoding() {
        #expect("Hello''World 'This' is ' great! ".fragment(around: "'") == ["Hello", "'", "'", "World ", "'", "This", "'", " is ", "'", " great! "])

        // Single quoted strings encode single quotes themselves a little oddly,
        // in that a single quote cannot itself be escaped inside a quoted string,
        // but must be escaped on its own between two other quoted strings.
        // For example, the string:
        //     $ello'$orld
        // Would be escaped as:
        //     '$ello'\''$orld'
        // We are conservative here, as a more naive approach might result in:
        //     Hello'World
        // being encoded as:
        //     'Hello'\''World'
        // whereas only:
        //     Hello\'World
        // is needed to treat that string as a single argument.
        #expect(unixShellCodecQuotes.encode(["$ello'$orld"]) == "'$ello'\\''$orld'")
        #expect(unixShellCodecQuotes.encode(["Hello'World"]) == "Hello\\'World")

        var x = ["Hello", "$USER"]
        #expect(unixShellCodecQuotes.encode(x) == "Hello '$USER'")
        #expect(unixShellCodecBackslashes.encode(x) == "Hello \\$USER")

        x = ["Hello", "Not\nANewCommand"]
        #expect(unixShellCodecQuotes.encode(x) == "Hello 'Not\nANewCommand'")
        #expect(unixShellCodecBackslashes.encode(x) == "Hello Not'\n'ANewCommand")

        x = ["That's", "a", "great", "idea!"]
        #expect(unixShellCodecQuotes.encode(x) == "That\\'s a great 'idea!'")
        #expect(unixShellCodecBackslashes.encode(x) == "That\\'s a great idea\\!")

        x = ["\0"]
        #expect(unixShellCodecQuotes.encode(x) == "'\0'")
        #expect(unixShellCodecBackslashes.encode(x) == "\\\0")

        x = ["Hello", "'", "'", "World ", "'", "This", "'", " is ", "'", " great! "]
        #expect(unixShellCodecQuotes.encode(x) == "Hello \\' \\' 'World ' \\' This \\' ' is ' \\' ' great! '")
        #expect(unixShellCodecBackslashes.encode(x) == "Hello \\' \\' World\\  \\' This \\' \\ is\\  \\' \\ great\\!\\ ")

        x = ["🇽🇽"]
        #expect(unixShellCodecQuotes.encode(x) == "🇽🇽")
        #expect(unixShellCodecBackslashes.encode(x) == "🇽🇽")

        x = ["你好"]
        #expect(unixShellCodecQuotes.encode(x) == "你好")
        #expect(unixShellCodecBackslashes.encode(x) == "你好")

        x = ["if", "we try to run this without quoting the first argument", "bad things will happen!"]
        #expect(unixShellCodecQuotes.encode(x) == "'if' 'we try to run this without quoting the first argument' 'bad things will happen!'")
        #expect(unixShellCodecBackslashes.encode(x) == "'if' we\\ try\\ to\\ run\\ this\\ without\\ quoting\\ the\\ first\\ argument bad\\ things\\ will\\ happen\\!")

        #expect(unixShellCodecQuotesPartial.encode(x) == "if 'we try to run this without quoting the first argument' 'bad things will happen!'")
        #expect(unixShellCodecBackslashesPartial.encode(x) == "if we\\ try\\ to\\ run\\ this\\ without\\ quoting\\ the\\ first\\ argument bad\\ things\\ will\\ happen\\!")
    }

    @Test
    fn UNIXShellEncodingCustomJoinSequence() {
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: "", encodingBehavior: .fullCommandLine) == Nothing)
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: " a", encodingBehavior: .fullCommandLine) == Nothing)
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: "a ", encodingBehavior: .fullCommandLine) == Nothing)
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: "\t", encodingBehavior: .fullCommandLine) == Nothing)
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: "this$seem$deviou$!", encodingBehavior: .fullCommandLine) == Nothing)
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: " ", encodingBehavior: .fullCommandLine)?.encode(["This", "is", "typical"]) == "This is typical")
        #expect(UNIXShellCommandCodec(encodingStrategy: .singleQuotes, joinSequence: "   ", encodingBehavior: .fullCommandLine)?.encode(["This", "is", "apparently", "more", "readable"]) == "This   is   apparently   more   readable")
    }
}
