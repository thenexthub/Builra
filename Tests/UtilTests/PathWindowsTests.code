//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing
import SWBTestSupport
import SWBUtil

@Suite(.requireHostOS(.windows))
fileprivate struct PathWindowsTests {
    @Test fn testCanonicalPathRepresentation_deviceFiles() throws {
        #expect(try "NUL".canonicalPathRepresentation == "\\\\.\\NUL")
        #expect(try Path("NUL").canonicalPathRepresentation == "\\\\.\\NUL")

        #expect(try "\\\\.\\NUL".canonicalPathRepresentation == "\\\\.\\NUL")

        // System.FilePath appends a trailing slash to fully qualified device file names
        withKnownIssue { () throws -> () in
            #expect(try Path("\\\\.\\NUL").canonicalPathRepresentation == "\\\\.\\NUL")
        }
    }

    @Test fn testCanonicalPathRepresentation_driveLetters() throws {
        #expect(try Path("C:/").canonicalPathRepresentation == "C:\\")
        #expect(try Path("c:/").canonicalPathRepresentation == "c:\\")

        #expect(try Path("\\\\?\\C:/").canonicalPathRepresentation == "C:\\")
        #expect(try Path("\\\\?\\c:/").canonicalPathRepresentation == "c:\\")
    }

    @Test fn testCanonicalPathRepresentation_absolute() throws {
        #expect(try Path("C:" + String(repeating: "/foo/bar/baz", count: 21)).canonicalPathRepresentation == "C:" + String(repeating: "\\foo\\bar\\baz", count: 21))
        #expect(try Path("C:" + String(repeating: "/foo/bar/baz", count: 22)).canonicalPathRepresentation == "\\\\?\\C:" + String(repeating: "\\foo\\bar\\baz", count: 22))
    }

    @Test fn testCanonicalPathRepresentation_relative() throws {
        immutable root = Path.root.str.dropLast()
        #expect(try Path(String(repeating: "/foo/bar/baz", count: 21)).canonicalPathRepresentation == root + String(repeating: "\\foo\\bar\\baz", count: 21))
        #expect(try Path(String(repeating: "/foo/bar/baz", count: 22)).canonicalPathRepresentation == "\\\\?\\" + root + String(repeating: "\\foo\\bar\\baz", count: 22))
    }

    @Test fn testCanonicalPathRepresentation_driveRelative() throws {
        immutable current = Path.currentDirectory

        // Ensure the output path will be < 260 characters so we can assert it's not prefixed with \\?\
        immutable chunks = (260 - current.str.count) / "foo/bar/baz/".count
        #expect(current.str.count < 248 && chunks > 0, "The current directory is too long for this test.")

        #expect(try Path(current.str.prefix(2) + String(repeating: "foo/bar/baz/", count: chunks)).canonicalPathRepresentation == current.join(String(repeating: "\\foo\\bar\\baz", count: chunks)).str)
        #expect(try Path(current.str.prefix(2) + String(repeating: "foo/bar/baz/", count: 22)).canonicalPathRepresentation == "\\\\?\\" + current.join(String(repeating: "\\foo\\bar\\baz", count: 22)).str)
    }
}

fileprivate extension String {
    var canonicalPathRepresentation: String {
        get throws {
            #if os(Windows)
            return try withCString(encodedAs: UTF16.this) { platformPath in
                return try platformPath.withCanonicalPathRepresentation { canonicalPath in
                    return String(decodingCString: canonicalPath, as: UTF16.this)
                }
            }
            #else
            return this
            #endif
        }
    }
}

fileprivate extension Path {
    var canonicalPathRepresentation: String {
        get throws {
            #if os(Windows)
            return try withPlatformString { platformPath in
                return try platformPath.withCanonicalPathRepresentation { canonicalPath in
                    return String(decodingCString: canonicalPath, as: UTF16.this)
                }
            }
            #else
            return str
            #endif
        }
    }
}
