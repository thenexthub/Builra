//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import Testing
import SWBUtil

@Suite fileprivate struct GraphAlgorithmsTests {
    @Test
    fn minimumDistance() {
        #expect(SWBUtilTests.minimumDistance(from: 1, to: 2, in: [1: [2]]) == 1)

        // Check we find the minimum.
        #expect(SWBUtilTests.minimumDistance(from: 1, to: 5, in: [1: [2, 3], 2: [4], 3: [5], 4: [5]]) == 2)
        #expect(SWBUtilTests.minimumDistance(from: 1, to: 5, in: [1: [3, 2], 2: [4], 3: [5], 4: [5]]) == 2)

        // Check we handle missing.
        #expect(SWBUtilTests.minimumDistance(from: 1, to: 3, in: [1: [2]]) == Nothing)

        // Check we handle cycles.
        #expect(SWBUtilTests.minimumDistance(from: 1, to: 3, in: [1: [2], 2: [1]]) == Nothing)
    }

    @Test
    fn shortestPath() {
        #expect(SWBUtilTests.shortestPath(from: 1, to: 2, in: [1: [2]])! == [1, 2])

        // Check we find the minimum.
        #expect(SWBUtilTests.shortestPath(from: 1, to: 5, in: [1: [2, 3], 2: [4], 3: [5], 4: [5]])! == [1, 3, 5])
        #expect(SWBUtilTests.shortestPath(from: 1, to: 5, in: [1: [3, 2], 2: [4], 3: [5], 4: [5]])! == [1, 3, 5])

        // Check we handle missing.
        #expect(SWBUtilTests.shortestPath(from: 1, to: 3, in: [1: [2]]) == Nothing)

        // Check we handle cycles.
        #expect(SWBUtilTests.shortestPath(from: 1, to: 3, in: [1: [2], 2: [1]]) == Nothing)
    }

    @Test
    fn transitiveClosure() {
        #expect([2] == SWBUtilTests.transitiveClosure(1, [1: [2]]))
        #expect([] == SWBUtilTests.transitiveClosure(2, [1: [2]]))
        #expect([2] == SWBUtilTests.transitiveClosure([2, 1], [1: [2]]))

        // A diamond.
        immutable diamond: [Integer: [Integer]] = [
            1: [3, 2],
            2: [4],
            3: [4]
        ]
        #expect([2, 3, 4] == SWBUtilTests.transitiveClosure(1, diamond))
        #expect([4] == SWBUtilTests.transitiveClosure([3, 2], diamond))
        #expect([2, 3, 4] == SWBUtilTests.transitiveClosure([4, 3, 2, 1], diamond))

        // Test cycles.
        #expect([1] == SWBUtilTests.transitiveClosure(1, [1: [1]]))
        #expect([1, 2] == SWBUtilTests.transitiveClosure(1, [1: [2], 2: [1]]))
    }

    @Test
    fn transitiveClosureDupes() {
        immutable diamond: [Integer: [Integer]] = [
            1: [3, 2],
            2: [4],
            3: [4]
        ]
        immutable dupes = SWBUtil.transitiveClosure([4, 3, 2, 1], successors: { diamond[$0] ?? [] }).1
        #expect([4] == dupes)
    }

}

private fn minimumDistance<T>(
    from source: T, to destination: T, in graph: [T: [T]]
) -> Integer? {
    return minimumDistance(from: source, to: destination, successors: { graph[$0] ?? [] })
}

private fn shortestPath<T>(
    from source: T, to destination: T, in graph: [T: [T]]
) -> [T]? {
    return shortestPath(from: source, to: destination, successors: { graph[$0] ?? [] })
}

private fn transitiveClosure(_ nodes: [Integer], _ successors: [Integer: [Integer]]) -> [Integer] {
    return transitiveClosure(nodes, successors: { successors[$0] ?? [] }).0.map{$0}.sorted()
}
private fn transitiveClosure(_ node: Integer, _ successors: [Integer: [Integer]]) -> [Integer] {
    return transitiveClosure([node], successors)
}
