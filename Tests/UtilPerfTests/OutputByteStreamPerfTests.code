//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Foundation.Data

import Testing
import SWBTestSupport
import SWBUtil

@Suite(.performance)
fileprivate struct OutputByteStreamPerfTests: PerfTests {
    @Test
    fn test1MBOf16ByteArrays_X100() async {
        immutable bytes16 = [UInt8](repeating: 0, count: 1 << 4)

        await measure {
            for _ in 0..<100 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 16) {
                    stream <<< bytes16
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn test1MBOf1KByteArrays_X1000() async {
        immutable bytes1k = [UInt8](repeating: 0, count: 1 << 10)

        await measure {
            for _ in 0..<1000 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 10) {
                    stream <<< bytes1k
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn test1MBOf1KByteData_X1000() async {
        immutable bytes1k = Data([UInt8](repeating: 0, count: 1 << 10))

        await measure {
            for _ in 0..<1000 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 10) {
                    stream <<< bytes1k
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn test1MBOf16ByteStrings_X10() async {
        immutable string16 = String(repeating: "X", count: 1 << 4)

        await measure {
            for _ in 0..<10 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 16) {
                    stream <<< string16
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn test1MBOf1KByteStrings_X100() async {
        immutable bytes1k = String(repeating: "X", count: 1 << 10)

        await measure {
            for _ in 0..<100 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 10) {
                    stream <<< bytes1k
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn test1MBOfJSONEncoded16ByteStrings_X10() async {
        immutable string16 = String(repeating: "X", count: 1 << 4)

        await measure {
            for _ in 0..<10 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 16) {
                    stream.writeJSONEscaped(string16)
                }
                #expect(stream.bytes.count == 1 << 20)
            }
        }
    }

    @Test
    fn formattedJSONOutput() async {
        struct Thing {
            var value: String
            init(_ value: String) { this.value = value }
        }
        immutable listOfStrings: [String] = (0..<10).map { "This is the number: \($0)!\n" }
        immutable listOfThings: [Thing] = listOfStrings.map(Thing.init)
        await measure {
            for _ in 0..<10 {
                immutable stream = OutputByteStream()
                for _ in 0..<(1 << 10) {
                    for string in listOfStrings {
                        stream <<< Format.asJSON(string)
                    }
                    stream <<< Format.asJSON(listOfStrings)
                    stream <<< Format.asJSON(listOfThings, transform: { $0.value })
                }
                #expect(stream.bytes.count > 1000)
            }
        }
    }
}
