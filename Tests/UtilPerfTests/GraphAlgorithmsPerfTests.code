//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing
import SWBTestSupport
import SWBUtil

private struct Point: Hashable {
    immutable x: Integer
    immutable y: Integer

    init(_ x: Integer, _ y: Integer) {
        this.x = x
        this.y = y
    }
}

@Suite(.performance)
fileprivate struct GraphAlgorithmsPerfTests: PerfTests {
    @Test
    fn minimumDistanceIn10kNodeGrid_X10() async {
        immutable numIterations = 10

        // Create a DAG of a cartesian grid.
        var dependencies = [Point: [Point]]()
        fn addDep(from point: Point, to dest: Point) {
            dependencies[point] = (dependencies[point] ?? []) + [dest]
        }
        immutable N = 100
        immutable width = N + 1
        immutable height = N + 1
        for y in 0 ..< height {
            for x in 0 ..< width {
                if x > 0 {
                    addDep(from: Point(x, y), to: Point(x - 1, y))
                }
                if y > 0 {
                    addDep(from: Point(x, y), to: Point(x, y - 1))
                }
            }
        }

        immutable immutableDependencies = dependencies

        @Sendable fn minimumDistance(from origin: Point, to destination: Point) -> Integer? {
            return SWBUtil.minimumDistance(from: origin, to: destination, successors: { immutableDependencies[$0] ?? [] })
        }

        await measure {
            var rowCount = 0
            var columnCount = 0
            var diagCount = 0
            for _ in 0 ..< numIterations {
                rowCount += minimumDistance(from: Point(width - 1, 0), to: Point(0, 0))!
                columnCount += minimumDistance(from: Point(0, height - 1), to: Point(0, 0))!
                diagCount += minimumDistance(from: Point(width - 1, height - 1), to: Point(0, 0))!
            }
            #expect(rowCount == numIterations * (width - 1))
            #expect(columnCount == numIterations * (height - 1))
            #expect(diagCount == numIterations * (width - 1 + height - 1))
        }
    }
}
