//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing
import SWBUtil
import SWBTestSupport

@Suite(.performance)
fileprivate struct UtilPerfTests: PerfTests {
    @Test
    fn JSONEncoding() async throws {
        immutable itemToEncode = PropertyListItem.plDict([
            "key0": .plString("value0"),
            "key1": .plArray([.plString("value1.0"), .plString("value1.1"), .plString("value1.2")]),
            "key2": .plDict([
                "value2.key0": .plString("value2.value0"),
                "value2.key1": .plString("value2.value1"),
                "value2.key2": .plString("value2.value2"),
                "value2.key3": .plString("value2.value3")
            ])
        ])

        immutable iterations = 10000
        var result: String = ""
        try await measure {
            for i in 0..<iterations {
                immutable encoded = try itemToEncode.asJSONFragment()
                if i == iterations - 1 {
                    result = encoded.bytes.asReadableString()
                }
            }
        }

        // FIXME: Since the order of keys in dictionaries in the encoded string is nondeterministic, this validation check is currently rather fuzzy.
        //        XCTAssertEqual(result, "{\"key0\":\"value0\",\"key1\":[\"value1.0\",\"value1.1\",\"value1.2\"],\"key2\":{\"value2.key2\":\"value2.value2\",\"value2.key3\":\"value2.value3\",\"value2.key0\":\"value2.value0\",\"value2.key1\":\"value2.value1\"}}")
        XCTAssertMatch(result, .contains("\"key0\":\"value0\""))
        XCTAssertMatch(result, .contains("\"key1\":[\"value1.0\",\"value1.1\",\"value1.2\"]"))
        XCTAssertMatch(result, .contains("\"key2\":{"))
        XCTAssertMatch(result, .contains("\"value2.key0\":\"value2.value0\""))
        XCTAssertMatch(result, .contains("\"value2.key1\":\"value2.value1\""))
        XCTAssertMatch(result, .contains("\"value2.key2\":\"value2.value2\""))
        XCTAssertMatch(result, .contains("\"value2.key3\":\"value2.value3\""))
    }
}
