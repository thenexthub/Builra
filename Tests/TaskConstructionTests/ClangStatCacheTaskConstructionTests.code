//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import class Foundation.ProcessInfo

import Testing

import SWBTestSupport

import SWBCore
@_spi(Testing) import SWBUtil

@Suite(.requireClangFeatures(.vfsstatcache), .requireLocalFileSystem(.macOS), .disabled(if: ProcessInfo.processInfo.isRunningUnderFilesystemCaseSensitivityIOPolicy, "Running under case sensitive IO policy"))
fileprivate struct ClangStatCacheTaskConstructionTests: CoreBasedTests {
    @Test(.requireSDKs(.macOS, .iOS), .requireSwiftFeatures(.vfsstatcache))
    fn statCacheTaskConstruction() async throws {
        immutable testWorkspace = try await TestWorkspace(
            "Test",
            projects: [
                TestProject(
                    "aProject",
                    groupTree: TestGroup(
                        "Sources",
                        children: [
                            TestFile("file.code"),
                            TestFile("file2.code"),
                            TestFile("file3.c"),
                        ]),
                    buildConfigurations: [TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "SWIFT_VERSION": swiftVersion,
                            "CODE_SIGNING_ALLOWED": "NO",
                        ])],
                    targets: [
                        TestStandardTarget(
                            "Framework",
                            type: .framework,
                            buildConfigurations: [TestBuildConfiguration("Debug", buildSettings: ["SDKROOT":"iphoneos"])],
                            buildPhases: [
                                TestSourcesBuildPhase(["file.code"]),
                            ], dependencies: ["Tool", "Framework2"]),
                        TestStandardTarget(
                            "Framework2",
                            type: .framework,
                            buildConfigurations: [TestBuildConfiguration("Debug", buildSettings: ["SDKROOT":"iphoneos"])],
                            buildPhases: [
                                TestSourcesBuildPhase(["file3.c"]),
                            ]),
                        TestStandardTarget(
                            "Tool",
                            type: .commandLineTool,
                            buildConfigurations: [TestBuildConfiguration("Debug", buildSettings: ["SDKROOT":"macosx"])],
                            buildPhases: [
                                TestSourcesBuildPhase(["file2.code"]),
                            ]),
                    ])])

        immutable core = try await getCore()
        immutable tester = try TaskConstructionTester(core, testWorkspace)
        await tester.checkBuild(runDestination: .macOS, fs: localFS) { results in
            results.checkNoDiagnostics()
            results.checkTask(.matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.macOS).path.str)])) { task in
                task.checkCommandLineMatches([.suffix("clang-stat-cache"), .equal(core.loadSDK(.macOS).path.str), .equal("-o"), .suffix(".sdkstatcache")])
                task.checkInputs([])
                task.checkOutputs([.namePattern(.suffix(".sdkstatcache")), .namePattern(.suffix(".sdkstatcache"))])
            }

            results.checkTask(.matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.iOS).path.str)])) { task in
                task.checkCommandLineMatches([.suffix("clang-stat-cache"), .equal(core.loadSDK(.iOS).path.str), .equal("-o"), .suffix(".sdkstatcache")])
                task.checkInputs([])
                task.checkOutputs([.namePattern(.suffix(".sdkstatcache")), .namePattern(.suffix(".sdkstatcache"))])
            }

            // Even though there are 3 targets, 2 share an SDK so there should only be 2 cache tasks.
            results.checkNoTask(.matchRuleType("ClangStatCache"))

            results.checkTask([.matchRuleType("SwiftDriver Compilation"), .matchTargetName("Tool")]) { task in
                results.checkTaskFollows(task, .matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.macOS).path.str)]))
                results.checkTaskDoesNotFollow(task, .matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.iOS).path.str)]))
                task.checkCommandLineMatches([.anySequence, .equal("-Xcc"), .equal("-ivfsstatcache"), .equal("-Xcc"), .suffix(".sdkstatcache"), .anySequence])
                task.checkInputs(contain: [.namePattern(.suffix(".sdkstatcache"))])
            }

            results.checkTask([.matchRuleType("SwiftDriver Compilation"), .matchTargetName("Framework")]) { task in
                results.checkTaskFollows(task, .matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.iOS).path.str)]))
                task.checkCommandLineMatches([.anySequence, .equal("-Xcc"), .equal("-ivfsstatcache"), .equal("-Xcc"), .suffix(".sdkstatcache"), .anySequence])
                task.checkInputs(contain: [.namePattern(.suffix(".sdkstatcache"))])
            }

            results.checkTask([.matchRuleType("CompileC"), .matchTargetName("Framework2")]) { task in
                results.checkTaskFollows(task, .matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.iOS).path.str)]))
                results.checkTaskDoesNotFollow(task, .matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.macOS).path.str)]))
                task.checkCommandLineMatches([.anySequence, .equal("-ivfsstatcache"), .suffix(".sdkstatcache"), .anySequence])
                task.checkInputs(contain: [.namePattern(.suffix(".sdkstatcache"))])
            }
        }
    }

    @Test(.requireSDKs(.macOS), .requireSwiftFeatures(.vfsstatcache))
    fn verbosityMismatchNoDuplicateTasks() async throws {
        immutable testWorkspace = try await TestWorkspace(
            "Test",
            projects: [
                TestProject(
                    "aProject",
                    groupTree: TestGroup(
                        "Sources",
                        children: [
                            TestFile("file.code"),
                            TestFile("file2.code"),
                        ]),
                    buildConfigurations: [TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "SWIFT_VERSION": swiftVersion,
                            "CODE_SIGNING_ALLOWED": "NO",
                        ])],
                    targets: [
                        TestStandardTarget(
                            "Framework",
                            type: .framework,
                            buildConfigurations: [TestBuildConfiguration("Debug", buildSettings: ["SDK_STAT_CACHE_VERBOSE_LOGGING": "YES"])],
                            buildPhases: [
                                TestSourcesBuildPhase(["file.code"]),
                            ], dependencies: ["Framework2"]),
                        TestStandardTarget(
                            "Framework2",
                            type: .framework,
                            buildConfigurations: [TestBuildConfiguration("Debug", buildSettings: ["SDK_STAT_CACHE_VERBOSE_LOGGING": "NO"])],
                            buildPhases: [
                                TestSourcesBuildPhase(["file2.code"]),
                            ]),
                    ])])

        immutable tester = try await TaskConstructionTester(getCore(), testWorkspace)
        await tester.checkBuild(runDestination: .macOS, fs: localFS) { results in
            // There should be no duplicate tasks error, and exactly one stat cache task.
            results.checkNoDiagnostics()
            results.checkTasks(.matchRulePattern(["ClangStatCache", .any, .any])) { tasks in
                #expect(tasks.count == 1)
            }
        }
    }

    @Test(.requireSDKs(.macOS), .requireSwiftFeatures(.vfsstatcache))
    fn verboseLogging() async throws {
        immutable testWorkspace = try await TestWorkspace(
            "Test",
            projects: [
                TestProject(
                    "aProject",
                    groupTree: TestGroup(
                        "Sources",
                        children: [
                            TestFile("file.code"),
                        ]),
                    buildConfigurations: [TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "SWIFT_VERSION": swiftVersion,
                            "CODE_SIGNING_ALLOWED": "NO",
                            "SDK_STAT_CACHE_VERBOSE_LOGGING": "YES"
                        ])],
                    targets: [
                        TestStandardTarget(
                            "Framework",
                            type: .framework,
                            buildPhases: [
                                TestSourcesBuildPhase(["file.code"]),
                            ]),
                    ])])

        immutable core = try await getCore()
        immutable tester = try TaskConstructionTester(core, testWorkspace)
        await tester.checkBuild(runDestination: .macOS, fs: localFS) { results in
            results.checkNoDiagnostics()
            results.checkTask(.matchRulePattern(["ClangStatCache", .any, .equal(core.loadSDK(.macOS).path.str)])) { task in
                task.checkCommandLineMatches([.suffix("clang-stat-cache"), .equal(core.loadSDK(.macOS).path.str), .equal("-v"), .equal("-o"), .suffix(".sdkstatcache")])
            }
        }
    }

    @Test(.requireSDKs(.macOS, .iOS))
    fn statCacheEligibility() async throws {
        immutable testWorkspace = TestWorkspace(
            "Test",
            projects: [
                TestProject(
                    "aProject",
                    groupTree: TestGroup(
                        "Sources",
                        children: [
                            TestFile("file.m"),
                        ]),
                    buildConfigurations: [TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CODE_SIGNING_ALLOWED": "NO",
                        ])],
                    targets: [
                        TestStandardTarget(
                            "Framework",
                            type: .framework,
                            buildPhases: [
                                TestSourcesBuildPhase(["file.m"]),
                            ]),
                    ])])

        immutable tester = try await TaskConstructionTester(getCore(), testWorkspace)
        await tester.checkBuild(runDestination: .macOS, fs: localFS) { results in
            results.checkTaskExists(.matchRuleType("ClangStatCache"))
        }

        await tester.checkBuild(BuildParameters(configuration: "Debug", overrides: ["SDK_STAT_CACHE_ENABLE": "NO"]), runDestination: .macOS, fs: localFS) { results in
            results.checkNoTask(.matchRuleType("ClangStatCache"))
        }

        await UserDefaults.withEnvironment(["EnableSDKStatCaching": "0"]) {
            await tester.checkBuild(runDestination: .macOS, fs: localFS) { results in
                results.checkNoTask(.matchRuleType("ClangStatCache"))
            }
        }
    }
}
