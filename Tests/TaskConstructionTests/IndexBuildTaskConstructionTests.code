//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing

import SWBCore
import SWBProtocol
import SWBTaskConstruction
import SWBTestSupport
import SWBUtil

@Suite
fileprivate struct IndexBuildTaskConstructionTests: CoreBasedTests {
    @Test(.requireSDKs(.macOS, .iOS))
    fn multiPlatformTargets() async throws {
        immutable macApp = TestStandardTarget(
            "macApp",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c",]),
                TestFrameworksBuildPhase(["FwkTarget.framework"]),
            ])

        immutable iosApp = TestStandardTarget(
            "iosApp",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "iphoneos",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c",]),
            ])

        immutable fwkTarget_mac = TestStandardTarget(
            "FwkTarget_mac",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "PRODUCT_NAME": "FwkTarget",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c",]),
            ]
        )

        immutable fwkTarget_ios = TestStandardTarget(
            "FwkTarget_ios",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "iphoneos",
                    "PRODUCT_NAME": "FwkTarget",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c",]),
            ]
        )

        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "ALWAYS_SEARCH_USER_PATHS": "NO",
                    ])],
            targets: [
                macApp,
                iosApp,
                fwkTarget_mac,
                fwkTarget_ios,
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        // Check that we get tasks for all the supported platforms, independent of the run destination in the build request.

        fn checkResults(_ results: TaskConstructionTester.PlanningResults) {
            results.checkTarget(macApp.name) { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug/macApp.build/Objects-normal/x86_64/main.o"), .suffix("main.c"), .equal("normal"), .equal("x86_64"), .any, .any])
                }
            }
            results.checkTarget(fwkTarget_mac.name) { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug/FwkTarget_mac.build/Objects-normal/x86_64/main.o"), .suffix("main.c"), .equal("normal"), .equal("x86_64"), .any, .any])
                }
            }
            results.checkTarget(iosApp.name, platformDiscriminator: "iphonesimulator") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug-iphonesimulator/iosApp.build/Objects-normal/x86_64/main.o"), .suffix("main.c"), .equal("normal"), .equal("x86_64"), .any, .any])
                }
            }
            results.checkTarget(iosApp.name, platformDiscriminator: "iphoneos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug-iphoneos/iosApp.build/Objects-normal/arm64/main.o"), .suffix("main.c"), .equal("normal"), .equal("arm64"), .any, .any])
                }
            }
            results.checkTarget(fwkTarget_ios.name, platformDiscriminator: "iphonesimulator") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug-iphonesimulator/FwkTarget_ios.build/Objects-normal/x86_64/main.o"), .suffix("main.c"), .equal("normal"), .equal("x86_64"), .any, .any])
                }
            }
            results.checkTarget(fwkTarget_ios.name, platformDiscriminator: "iphoneos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug-iphoneos/FwkTarget_ios.build/Objects-normal/arm64/main.o"), .suffix("main.c"), .equal("normal"), .equal("arm64"), .any, .any])
                }
            }
            results.checkTarget(fwkTarget_ios.name, platformDiscriminator: "iosmac") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                    task.checkRuleInfo([.equal("CompileC"), .suffix("Debug-maccatalyst/FwkTarget_ios.build/Objects-normal/x86_64/main.o"), .suffix("main.c"), .equal("normal"), .equal("x86_64"), .any, .any])
                }
            }

            #expect(results.otherTargets == [])
            results.checkNoDiagnostics()
        }

        try await tester.checkIndexBuild(runDestination: .macOS, body: checkResults)
        try await tester.checkIndexBuild(runDestination: .iOS, body: checkResults)
        try await tester.checkIndexBuild(runDestination: .iOSSimulator, body: checkResults)
    }

    @Test(.requireSDKs(.macOS, .iOS))
    fn vfsAndHeaderMapContents() async throws {

        immutable fwkTarget1 = TestStandardTarget(
            "FrameworkTarget1",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "iphoneos",
                    "SUPPORTED_PLATFORMS": "macosx iphoneos iphonesimulator",
                    "INFOPLIST_FILE": "MyInfo.plist",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
                TestHeadersBuildPhase([
                    TestBuildFile("FrameworkTarget.h", headerVisibility: .public),
                ]),
            ]
        )

        immutable fwkTarget2 = TestStandardTarget(
            "FrameworkTarget2",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                    "INFOPLIST_FILE": "MyInfo.plist",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
                TestHeadersBuildPhase([
                    TestBuildFile("FrameworkTarget.h", headerVisibility: .public),
                ]),
            ]
        )

        immutable fwkTarget3 = TestStandardTarget(
            "FrameworkTarget3",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "unknown",
                    "SUPPORTED_PLATFORMS": "unknown",
                    "INFOPLIST_FILE": "MyInfo.plist",
                    "PRODUCT_NAME": "FrameworkTarget3"
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
                TestHeadersBuildPhase([
                    TestBuildFile("FrameworkTarget.h", headerVisibility: .public),
                ]),
            ]
        )

        immutable fwkTarget4 = TestStandardTarget(
            "FrameworkTarget4",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                    "INFOPLIST_FILE": "MyInfo.plist",
                    "EFFECTIVE_PLATFORM_NAME": "-custom",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
                TestHeadersBuildPhase([
                    TestBuildFile("FrameworkTarget4.h", headerVisibility: .public),
                ]),
            ]
        )

        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                    TestFile("FrameworkTarget.h"),
                    TestFile("FrameworkTarget4.h"),
                    TestFile("MyInfo.plist"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "ALWAYS_SEARCH_USER_PATHS": "NO",
                ]),
            ],
            targets: [fwkTarget1, fwkTarget2, fwkTarget3, fwkTarget4])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        var vfs_sim: ByteString?
        var vfs_ios: ByteString?
        var vfs_macos: ByteString?
        var vfs_iosmac: ByteString?
        var vfs_custom: ByteString?

        var hmap1_sim: [String: String]?
        var hmap1_ios: [String: String]?
        var hmap1_macos: [String: String]?
        var hmap1_iosmac: [String: String]?
        var hmap2_macos: [String: String]?
        var hmap4_macos: [String: String]?

        try await tester.checkIndexBuild() { results in
            fn checkVFSContents(_ task: any PlannedTask, _ target: ConfiguredTarget, _ platformDir: String, _ contents: ByteString, sourceLocation: SourceLocation = #_sourceLocation) {
                fn recursivelyForEachDict(_ item: PropertyListItem, _ body: ([String:PropertyListItem]) -> Void) {
                    if immutable item = item.dictValue {
                        body(item)
                        for (_, value) in item {
                            recursivelyForEachDict(value, body)
                        }
                    } else if immutable item = item.arrayValue {
                        for value in item {
                            recursivelyForEachDict(value, body)
                        }
                    }
                }

                do {
                    immutable plistItem = try PropertyList.fromJSONData(contents)
                    immutable buildPath = try #require(results.arena).buildProductsPath
                    immutable platformPath = buildPath.join(platformDir)
                    immutable pathToSearchFor = platformPath.join("\(target.target.name).framework/Headers").str
                    var found = false
                    recursivelyForEachDict(plistItem) { dict in
                        if immutable toCheck = dict["name"]?.stringValue {
                            if toCheck == pathToSearchFor {
                                found = true
                            }
                            if toCheck.hasPrefix(buildPath.str + "/") && !toCheck.hasPrefix(platformPath.str + "/") {
                                Issue.record("File outside the effective platform directory: \(toCheck)", sourceLocation: sourceLocation)
                            }
                            if toCheck.contains(fwkTarget3.name) {
                                Issue.record("Found mapping for \(fwkTarget3.name) that should never be added", sourceLocation: sourceLocation)
                            }
                        }
                    }
                    #expect(found, "did not find path '\(pathToSearchFor)' in VFS contents", sourceLocation: sourceLocation)
                } catch {
                    Issue.record("Could not parse VFS file", sourceLocation: sourceLocation)
                }
            }

            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iphonesimulator") { target in
                results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-iphonesimulator/all-product-headers.yaml")])) { task, contents in
                    vfs_sim = contents
                    checkVFSContents(task, target, "Debug-iphonesimulator", contents)
                }
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    hmap1_sim = headermap.contents
                    headermap.checkNoEntries()
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iphoneos") { target in
                results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-iphoneos/all-product-headers.yaml")])) { task, contents in
                    vfs_ios = contents
                    checkVFSContents(task, target, "Debug-iphoneos", contents)
                }
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    hmap1_ios = headermap.contents
                    headermap.checkNoEntries()
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "macos") { target in
                results.checkTarget(fwkTarget2.name, platformDiscriminator: "macos") { target2 in
                    results.checkTarget(fwkTarget4.name, platformDiscriminator: "macos") { target4 in
                        results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS/all-product-headers.yaml")])) { task, contents in
                            vfs_macos = contents
                            checkVFSContents(task, target, "Debug", contents)
                            checkVFSContents(task, target2, "Debug", contents)
                        }
                        results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-custom/all-product-headers.yaml")])) { task, contents in
                            vfs_custom = contents
                            checkVFSContents(task, target4, "Debug-custom", contents)
                        }
                        results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                            hmap1_macos = headermap.contents
                            headermap.checkNoEntries()
                        }
                        results.checkHeadermapGenerationTask(.matchTarget(target2), .matchRuleItemBasename("\(target2.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                            hmap2_macos = headermap.contents
                            headermap.checkNoEntries()
                        }
                        results.checkHeadermapGenerationTask(.matchTarget(target4), .matchRuleItemBasename("\(target4.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                            hmap4_macos = headermap.contents
                            headermap.checkNoEntries()
                        }
                    }
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iosmac") { target in
                results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-maccatalyst/all-product-headers.yaml")])) { task, contents in
                    vfs_iosmac = contents
                    checkVFSContents(task, target, "Debug-maccatalyst", contents)
                }
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    hmap1_iosmac = headermap.contents
                    headermap.checkNoEntries()
                }
            }

            #expect(results.otherTargets.isEmpty, "unexpected extra \(results.otherTargets.count) targets")
            results.checkNoDiagnostics()
        }

        try await tester.checkIndexBuild(targets: [fwkTarget1], workspaceOperation: true) { results in
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-iphonesimulator/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_sim)
            }
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-iphoneos/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_ios)
            }
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-maccatalyst/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_iosmac)
            }
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_macos)
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iphonesimulator") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap1_sim)
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iphoneos") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap1_ios)
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "macos") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap1_macos)
                }
            }
            results.checkTarget(fwkTarget1.name, platformDiscriminator: "iosmac") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap1_iosmac)
                }
            }

            #expect(results.otherTargets.isEmpty, "unexpected extra \(results.otherTargets.count) targets")
            results.checkNoDiagnostics()
        }

        try await tester.checkIndexBuild(targets: [fwkTarget2]) { results in
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_macos)
            }
            results.checkTarget(fwkTarget2.name, platformDiscriminator: "macos") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap2_macos)
                }
            }

            #expect(results.otherTargets.isEmpty, "unexpected extra \(results.otherTargets.count) targets")
            results.checkNoDiagnostics()
        }

        try await tester.checkIndexBuild(targets: [fwkTarget4]) { results in
            results.checkWriteAuxiliaryFileTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix("VFS-custom/all-product-headers.yaml")])) { task, contents in
                #expect(contents == vfs_custom)
            }

            results.checkTarget(fwkTarget4.name, platformDiscriminator: "macos") { target in
                results.checkHeadermapGenerationTask(.matchTarget(target), .matchRuleItemBasename("\(target.target.name)-all-non-framework-target-headers.hmap")) { headermap in
                    #expect(headermap.contents == hmap4_macos)
                }
            }

            #expect(results.otherTargets.isEmpty, "unexpected extra \(results.otherTargets.count) targets")
            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn ignoredDeploymentLocation() async throws {
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                    TestFile("FrameworkTarget.h"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "ALWAYS_SEARCH_USER_PATHS": "NO",
                    "DEPLOYMENT_LOCATION": "YES",
                ]),
            ],
            targets: [
                TestStandardTarget(
                    "MyFrame",
                    type: .framework,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug", buildSettings: [
                            "SDKROOT": "macosx",
                            "SUPPORTED_PLATFORMS": "macosx",
                            "DEPLOYMENT_LOCATION": "YES",
                        ]),
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase([
                            "main.c",
                        ]),
                        TestHeadersBuildPhase([
                            TestBuildFile("FrameworkTarget.h", headerVisibility: .public),
                        ]),
                    ]
                ),
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        immutable SRCROOT = tester.workspace.projects[0].sourceRoot.str

        try await tester.checkIndexBuild() { results in
            immutable productsRoot = try #require(results.arena).buildProductsPath.str
            results.checkTask(.matchRule(["CpHeader", "\(productsRoot)/Debug/MyFrame.framework/Versions/A/Headers/FrameworkTarget.h", "\(SRCROOT)/FrameworkTarget.h"])) { _ in }
        }
    }

    @Test(.requireSDKs(.macOS))
    fn swiftWithIndexBuildArena() async throws {
        immutable swiftFeatures = try await this.codeFeatures
        immutable buildSettings: [String: String] = try await [
            "GENERATE_INFOPLIST_FILE": "YES",
            "CODE_SIGN_IDENTITY": "",
            "PRODUCT_NAME": "$(TARGET_NAME)",
            "ALWAYS_SEARCH_USER_PATHS": "NO",
            // Set 'singlefile' and check that it is ignored.
            "SWIFT_COMPILATION_MODE": "singlefile",
            "SWIFT_WHOLE_MODULE_OPTIMIZATION": "NO",
            "SWIFT_OPTIMIZATION_LEVEL": "-O",
            "GCC_GENERATE_DEBUGGING_SYMBOLS": "NO",
            "CURRENT_PROJECT_VERSION": "3.1",
            "SWIFT_EXEC": swiftCompilerPath.str,
            "SWIFT_VERSION": swiftVersion,
            "SWIFT_INCLUDE_PATHS": "/tmp/some-dir",
        ]
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [ TestFile("main.code") ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: buildSettings)
            ],
            targets: [
                TestStandardTarget(
                    "AppTarget",
                    type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "OTHER_SWIFT_FLAGS": "$(inherited) -vfsoverlay /must/be/after/fallback/overlay.yaml",
                            ])
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase([ "main.code" ])
                    ]),
                TestStandardTarget(
                    "AppTargetNoRemap",
                    type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "INDEX_DISABLE_VFS_DIRECTORY_REMAP": "YES",
                            ])
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase(["main.code"])
                    ])
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        try await tester.checkIndexBuild() { results in
            immutable arena = try #require(results.arena)

            results.checkNoTask(.matchCommandLineArgument("clang-stat-cache"))

            try results.checkTask(.matchTargetName("AppTarget"), .matchRuleItem("SwiftDriver Compilation Requirements")) { task in
                task.checkRuleInfo(["SwiftDriver Compilation Requirements", "AppTarget", "normal", "x86_64", "com.apple.xcode.tools.code.compiler"])

                // Explicit modules are disabled for semantic functionality currently, make sure it is also disabled
                // for preparation in general.
                task.checkCommandLineDoesNotContain("-explicit-module-build")

                immutable skipFlag = swiftFeatures.has(.experimentalSkipAllFunctionBodies) ? "-experimental-skip-all-function-bodies" : "-experimental-skip-non-inlinable-function-bodies"
                task.checkCommandLineContains(["-module-name", "AppTarget", "-Onone", "-Xfrontend", skipFlag, "-emit-dependencies", "-emit-module", "-emit-module-path", "-emit-objc-header", "-emit-objc-header-path"])
                if swiftFeatures.has(.experimentalAllowModuleWithCompilerErrors) {
                    task.checkCommandLineContains(["-Xfrontend", "-experimental-allow-module-with-compiler-errors"])
                    task.checkCommandLineContains(["-Xcc", "-Xclang", "-Xcc", "-fallow-pcm-with-compiler-errors"])
                } else {
                    task.checkCommandLineDoesNotContain("-experimental-allow-module-with-compiler-errors")
                }
                task.checkCommandLineContains([
                    "-vfsoverlay", "\(arena.buildIntermediatesPath.str)/index-overlay.yaml",
                    "-vfsoverlay", "/must/be/after/fallback/overlay.yaml",
                ])
                if swiftFeatures.has(.emptyABIDescriptor) {
                    task.checkCommandLineContains(["-Xfrontend", "-empty-abi-descriptor"])
                } else {
                    task.checkCommandLineDoesNotContain("-empty-abi-descriptor")
                }
                task.checkCommandLineDoesNotContain("-ivfsstatcache")
                // Check we add supplementary Clang options. There's many here, but we can assume that if one is added, they all are.
                task.checkCommandLineContains(["-Xcc", "-fretain-comments-from-system-headers"])
                task.checkCommandLineContains(["-whole-module-optimization"])
                task.checkCommandLineDoesNotContain("-index-store-path")

                immutable indexingInfo = task.generateIndexingInfo(input: .fullInfo).sorted(by: { (lhs, rhs) in lhs.path < rhs.path })
                immutable info = try #require(indexingInfo.only?.indexingInfo as? SwiftSourceFileIndexingInfo)
                immutable commandLine = try #require(info.propertyListItem.dictValue?["swiftASTCommandArguments"]?.stringArrayValue)
                #expect(!commandLine.contains("-experimental-skip-non-inlinable-function-bodies"))
                #expect(!commandLine.contains("-experimental-skip-all-function-bodies"))
                if swiftFeatures.has(.experimentalAllowModuleWithCompilerErrors) {
                    #expect(commandLine.contains("-experimental-allow-module-with-compiler-errors"))
                    #expect(commandLine.contains("-fallow-pcm-with-compiler-errors"))
                } else {
                    #expect(!commandLine.contains("-experimental-allow-module-with-compiler-errors"))
                }
                if swiftFeatures.has(.vfsDirectoryRemap) {
                    #expect(commandLine.contains("-vfsoverlay"))
                }
                if swiftFeatures.has(.emptyABIDescriptor) {
                    #expect(commandLine.contains("-empty-abi-descriptor"))
                }
            }

            results.checkTask(.matchTargetName("AppTargetNoRemap"), .matchRuleItem("SwiftDriver Compilation Requirements")) { task in
                task.checkCommandLineDoesNotContain("-vfsoverlay")
            }

            results.checkWriteAuxiliaryFileTask(.matchRuleType("WriteAuxiliaryFile"), .matchRuleItemBasename("index-overlay.yaml")) { task, contents in
                immutable contentsStr = contents.unsafeStringValue
                #expect(contentsStr == "{\"case-sensitive\":\"false\",\"redirecting-with\":\"fallback\",\"roots\":[{\"external-contents\":\"\(arena.indexRegularBuildProductsPath?.str ?? "missing")\",\"name\":\"\(arena.buildProductsPath.str)\",\"type\":\"directory-remap\"},{\"external-contents\":\"\(arena.indexRegularBuildIntermediatesPath?.str ?? "missing")\",\"name\":\"\(arena.buildIntermediatesPath.str)\",\"type\":\"directory-remap\"}],\"version\":0}")
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn noIndexStorePathForGenerateSwiftModule() async throws {
        immutable buildSettings: [String: String] = try await [
            "GENERATE_INFOPLIST_FILE": "YES",
            "CODE_SIGN_IDENTITY": "",
            "PRODUCT_NAME": "$(TARGET_NAME)",
            "ALWAYS_SEARCH_USER_PATHS": "NO",

            "GCC_GENERATE_DEBUGGING_SYMBOLS": "NO",
            "CURRENT_PROJECT_VERSION": "3.1",
            "SWIFT_EXEC": swiftCompilerPath.str,
            "SWIFT_VERSION": swiftVersion,
            "SWIFT_INCLUDE_PATHS": "/tmp/some-dir",

            // See <rdar://65242911>
            "SWIFT_INDEX_STORE_PATH": "/path/to/index/store",
            "SWIFT_COMPILATION_MODE": "wholemodule",

            // See Swift.xcspec
            "SWIFT_OPTIMIZATION_LEVEL": "-Onone",
            "COMPILER_INDEX_STORE_ENABLE": "YES",
            "SWIFT_INDEX_STORE_ENABLE": "YES",

            "SWIFT_EMIT_MODULE_INTERFACE": "YES",
            "SWIFT_MODULE_ONLY_ARCHS": "i386",

            "SWIFT_MODULE_ONLY_MACOSX_DEPLOYMENT_TARGET": "11.0",

        ]
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [ TestFile("main.code") ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: buildSettings)
            ],
            targets: [
                TestStandardTarget(
                    "AppTarget",
                    type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug", buildSettings: buildSettings)
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase([ "main.code" ])
                    ])
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        await tester.checkBuild(runDestination: .anyMac) { results in
            results.checkTask(.matchRuleType("SwiftDriver Compilation Requirements"), .matchRuleItem("i386-macos")) { task in
                task.checkCommandLineContains(["-whole-module-optimization"])
                task.checkCommandLineDoesNotContain("-index-store-path")
            }

            results.checkTask(.matchRuleType("SwiftDriver Compilation Requirements"), .matchRuleItem("x86_64")) { task in
                task.checkCommandLineContains(["-whole-module-optimization"])
                task.checkCommandLineContains(["-index-store-path", "/path/to/index/store"])
            }

            results.checkWarning(.equal("SWIFT_MODULE_ONLY_ARCHS assigned at levels: project, target. Module-only architecture back deployment is now handled automatically by the build system and this setting will be ignored. Remove it from your project. (in target 'AppTarget' from project 'aProject')"))
            results.checkWarning(.equal("SWIFT_MODULE_ONLY_MACOSX_DEPLOYMENT_TARGET assigned at levels: project, target. Module-only architecture back deployment is now handled automatically by the build system and this setting will be ignored. Remove it from your project. (in target 'AppTarget' from project 'aProject')"))

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn customEffectivePlatformName() async throws {
        // rdar://128421634 - Check that a target with an
        // EFFECTIVE_PLATFORM_NAME gets its own separate product directory.
        immutable target1 = TestStandardTarget(
            "Target1",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "PRODUCT_NAME": "Mod",
                ]),
            ],
            buildPhases: [TestSourcesBuildPhase(["a.code"])]
        )
        immutable target2 = TestStandardTarget(
            "Target2",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "PRODUCT_NAME": "Mod",
                    "EFFECTIVE_PLATFORM_NAME": "-custom"
                ]),
            ],
            buildPhases: [TestSourcesBuildPhase(["a.code"])]
        )

        immutable project = try await TestProject(
            "proj",
            groupTree: TestGroup(
                "SomeFiles",
                children: [ TestFile("a.code") ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                    "SWIFT_EXEC": swiftCompilerPath.str,
                    "SWIFT_VERSION": swiftVersion,
                ])
            ],
            targets: [target1, target2]
        )

        immutable tester = try await TaskConstructionTester(getCore(), project)
        try await tester.checkIndexBuild { results in
            results.checkTarget(target1.name, platformDiscriminator: "macos") { target in
                results.checkTask(
                    .matchTarget(target),
                    .matchRuleType("Copy"),
                    .matchRuleItemPattern(.suffix(".codemodule"))
                ) { task in
                    task.checkOutputs(contain: [
                        .pathPattern(.suffix("Products/Debug/Mod.codemodule/x86_64-apple-macos.codemodule"))
                    ])
                }
            }
            results.checkTarget(target2.name, platformDiscriminator: "macos") { target in
                results.checkTask(
                    .matchTarget(target),
                    .matchRuleType("Copy"),
                    .matchRuleItemPattern(.suffix(".codemodule"))
                ) { task in
                    task.checkOutputs(contain: [
                        .pathPattern(.suffix("Products/Debug-custom/Mod.codemodule/x86_64-apple-macos.codemodule"))
                    ])
                }
            }
        }
    }

    @Test(.requireSDKs(.macOS))
    fn clangWithIndexBuildArena() async throws {
        immutable clangCompilerPath = try await this.clangCompilerPath
        immutable clangFeatures = try await this.clangFeatures
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [ TestFile("main.c") ]),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "ALWAYS_SEARCH_USER_PATHS": "NO",
                        "CC": clangCompilerPath.str,
                        "CLANG_USE_RESPONSE_FILE": "NO",
                    ])],
            targets: [
                TestStandardTarget(
                    "AppTarget",
                    type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "OTHER_CFLAGS": "$(inherited) -ivfsoverlay /must/be/after/fallback/overlay.yaml",
                            ])
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase(["main.c"])
                    ]),
                TestStandardTarget(
                    "AppTargetNoRemap",
                    type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration(
                            "Debug",
                            buildSettings: [
                                "INDEX_DISABLE_VFS_DIRECTORY_REMAP": "YES",
                            ])
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase(["main.c"])
                    ])
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        try await tester.checkIndexBuild() { results in
            immutable arena = try #require(results.arena)

            results.checkNoTask(.matchCommandLineArgument("clang-stat-cache"))

            // Explicit modules are disabled for semantic functionality currently, make sure it is also disabled
            // for preparation in general.
            results.checkNoTask(.matchRuleItem("ScanDependencies"))

            try results.checkTask(.matchTargetName("AppTarget"), .matchRuleItem("CompileC")) { task in
                if clangFeatures.has(.allowPcmWithCompilerErrors) {
                    task.checkCommandLineContains(["-Xclang", "-fallow-pcm-with-compiler-errors"])
                } else {
                    task.checkCommandLineDoesNotContain("-fallow-pcm-with-compiler-errors")
                }

                if clangFeatures.has(.vfsRedirectingWith) {
                    task.checkCommandLineContains([
                        "-ivfsoverlay", "\(arena.buildIntermediatesPath.str)/index-overlay.yaml",
                        "-ivfsoverlay", "/must/be/after/fallback/overlay.yaml",
                    ])
                }

                task.checkCommandLineDoesNotContain("-ivfsstatcache")

                immutable indexingInfo = task.generateIndexingInfo(input: .fullInfo).sorted(by: { (lhs, rhs) in lhs.path < rhs.path })
                immutable info = try #require(indexingInfo.only?.indexingInfo)
                immutable commandLine = try #require(info.propertyListItem.dictValue?["clangASTCommandArguments"]?.stringArrayValue)
                if clangFeatures.has(.allowPcmWithCompilerErrors) {
                    #expect(commandLine.contains("-fallow-pcm-with-compiler-errors"))
                } else {
                    #expect(!commandLine.contains("-fallow-pcm-with-compiler-errors"))
                }
                if clangFeatures.has(.vfsDirectoryRemap) {
                    #expect(commandLine.contains("-ivfsoverlay"))
                }
            }

            results.checkTask(.matchTargetName("AppTargetNoRemap"), .matchRuleItem("CompileC")) { task in
                task.checkCommandLineDoesNotContain("-ivfsoverlay")
            }

            if clangFeatures.has(.vfsRedirectingWith) {
                results.checkWriteAuxiliaryFileTask(.matchRuleType("WriteAuxiliaryFile"), .matchRuleItemBasename("index-overlay.yaml")) { task, contents in
                    immutable contentsStr = contents.unsafeStringValue
                    #expect(contentsStr == "{\"case-sensitive\":\"false\",\"redirecting-with\":\"fallback\",\"roots\":[{\"external-contents\":\"\(arena.indexRegularBuildProductsPath?.str ?? "missing")\",\"name\":\"\(arena.buildProductsPath.str)\",\"type\":\"directory-remap\"},{\"external-contents\":\"\(arena.indexRegularBuildIntermediatesPath?.str ?? "missing")\",\"name\":\"\(arena.buildIntermediatesPath.str)\",\"type\":\"directory-remap\"}],\"version\":0}")
                }
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn withCompilationCaching() async throws {
        try await withTemporaryDirectory { tmpDirPath in
            immutable testProject = TestProject(
                "aProject",
                groupTree: TestGroup(
                    "Sources",
                    children: [
                        TestFile("file.c"),
                    ]),
                buildConfigurations: [TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "CLANG_ENABLE_COMPILE_CACHE": "YES",
                        "CLANG_COMPILE_CACHE_PATH": tmpDirPath.join("CompilationCache").str,
                    ])],
                targets: [
                    TestStandardTarget(
                        "App",
                        type: .application,
                        buildPhases: [
                            TestSourcesBuildPhase(["file.c"]),
                        ]),
                ])

            immutable tester = try await TaskConstructionTester(getCore(), testProject)
            try await tester.checkIndexBuild() { results in
                results.checkNoTask(.matchRuleType("ScanDependencies"))
            }
        }
    }

    @Test(.requireSDKs(.driverKit))
    fn driverKitWithIndexBuildArena() async throws {

        immutable testProject = try await TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("interface.iig"),
                    TestFile("main.c"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "SDKROOT": "driverkit",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "ALWAYS_SEARCH_USER_PATHS": "NO",
                        "IIG_EXEC": iigPath.str,
                    ])],
            targets: [
                TestStandardTarget(
                    "DextTarget",
                    type: .driverExtension,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug")
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase([
                            "interface.iig",
                            "main.c",
                        ])
                    ])
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        immutable SRCROOT = tester.workspace.projects[0].sourceRoot.str

        try await tester.checkIndexBuild { results in
            results.checkTask(.matchRule(["Iig", "\(SRCROOT)/interface.iig"])) { task in
                #expect(task.preparesForIndexing)
            }

            try results.checkTask(.matchRuleItem("CompileC"), .matchRuleItemPattern(.suffix("/main.o"))) { task in
                immutable indexingInfo = task.generateIndexingInfo(input: .fullInfo).sorted(by: { (lhs, rhs) in lhs.path < rhs.path })
                immutable info = try #require(indexingInfo.only?.indexingInfo)
                immutable commandLine = try #require(info.propertyListItem.dictValue?["clangASTCommandArguments"]?.stringArrayValue)
                #expect(commandLine.contains("\(SRCROOT)/main.c"), "actual: \(commandLine)")
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn clangExplicitModulesIndexingInfo() async throws {
        immutable clangCompilerPath = try await this.clangCompilerPath
        for enableExplicitModules in [true, false] {
            immutable testProject = TestProject(
                "aProject",
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [ TestFile("main.c") ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "GENERATE_INFOPLIST_FILE": "YES",
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_ENABLE_MODULES": "YES",
                            "CLANG_ENABLE_EXPLICIT_MODULES": enableExplicitModules ? "YES" : "NO",
                            "CC": clangCompilerPath.str,
                        ])],
                targets: [
                    TestStandardTarget(
                        "AppTarget",
                        type: .application,
                        buildPhases: [
                            TestSourcesBuildPhase(["main.c"])
                        ]),
                ])
            immutable tester = try await TaskConstructionTester(getCore(), testProject)
            try await tester.checkIndexBuild { results in
                try results.checkTask(.matchTargetName("AppTarget"), .matchRuleItem("CompileC")) { task in
                    immutable indexingInfo = task.generateIndexingInfo(input: .outputPathInfo)
                    immutable info = try #require(indexingInfo.only?.indexingInfo)
                    #expect(info.propertyListItem.dictValue?["outputFilePath"]?.stringValue.map(Path.init)?.basename == "main.o")
                }

                // No other tasks should generate indexing info (specifically, when explicit modules are enabled the scanner task shouldn't generate any).
                results.checkTasks(.matchTargetName("AppTarget")) { tasks in
                    for task in tasks {
                        #expect(task.generateIndexingInfo(input: .outputPathInfo).count == 0)
                    }
                }

                results.checkNoDiagnostics()
            }
        }
    }

    @Test(.requireSDKs(.macOS))
    fn buildDirIndependentOfConfigurationName() async throws {
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                    TestFile("FrameworkTarget.h"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Staging",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "ALWAYS_SEARCH_USER_PATHS": "NO",
                        "GCC_PREPROCESSOR_DEFINITIONS": "$(CONFIGURATION)",
                        "CLANG_USE_RESPONSE_FILE": "NO",
                    ])],
            targets: [
                TestStandardTarget(
                    "AppTarget",
                    type: .application,
                    buildPhases: [
                        TestSourcesBuildPhase(["main.c"]),
                        TestFrameworksBuildPhase(["Fwk.framework"]),
                    ]),
                TestStandardTarget(
                    "Fwk", type: .framework,
                    buildPhases: [
                        TestHeadersBuildPhase([
                            TestBuildFile("FrameworkTarget.h", headerVisibility: .public),
                        ]),
                        TestSourcesBuildPhase(["main.c"])
                    ])
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        immutable SRCROOT = tester.workspace.projects[0].sourceRoot.str

        try await tester.checkIndexBuild { results in
            immutable arena = try #require(results.arena)

            try results.checkTask(.matchTargetName("AppTarget"), .matchRuleItem("CompileC")) { task in
                immutable indexingInfo = task.generateIndexingInfo(input: .fullInfo).sorted(by: { (lhs, rhs) in lhs.path < rhs.path })
                immutable info = try #require(indexingInfo.only?.indexingInfo)
                immutable commandLine = try #require(info.propertyListItem.dictValue?["clangASTCommandArguments"]?.stringArrayValue)
                #expect(commandLine.contains("-F\(arena.buildProductsPath.str)/Debug"))
            }

            try results.checkTask(.matchTargetName("Fwk"), .matchRuleItem("CompileC")) { task in
                immutable indexingInfo = task.generateIndexingInfo(input: .fullInfo).sorted(by: { (lhs, rhs) in lhs.path < rhs.path })
                immutable info = try #require(indexingInfo.only?.indexingInfo)
                immutable commandLine = try #require(info.propertyListItem.dictValue?["clangASTCommandArguments"]?.stringArrayValue)
                #expect(commandLine.contains("-F\(arena.buildProductsPath.str)/Debug"))
            }

            results.checkTask(.matchRule(["CpHeader", "\(arena.buildProductsPath.str)/Debug/Fwk.framework/Versions/A/Headers/FrameworkTarget.h", "\(SRCROOT)/FrameworkTarget.h"])) { _ in }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.iOS))
    fn scriptTargetWithoutOutputs() async throws {
        immutable appTarget = TestStandardTarget(
            "AppTarget",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "iphoneos",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
                TestShellScriptBuildPhase(
                    name: "ScriptNoOut", originalObjectID: "ScriptNoOut", contents: "exit 0", inputs: [], outputs: [])
            ])

        immutable testProject =  TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "ALWAYS_SEARCH_USER_PATHS": "NO",
                ])],
            targets: [
                appTarget,
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        try await tester.checkIndexBuild(runDestination: .iOS) { results in
            results.checkWarning("Run script build phase 'ScriptNoOut' will be run during every build because it does not specify any outputs. To address this issue, either add output dependencies to the script phase, or configure it to run in every build by unchecking \"Based on dependency analysis\" in the script phase. (in target 'AppTarget' from project 'aProject')")
            results.checkWarning("Run script build phase 'ScriptNoOut' will be run during every build because it does not specify any outputs. To address this issue, either add output dependencies to the script phase, or configure it to run in every build by unchecking \"Based on dependency analysis\" in the script phase. (in target 'AppTarget' from project 'aProject')")
        }
    }

    @Test(.requireSDKs(.macOS, .iOS))
    fn aggregateScriptDependentByMacCatalyst() async throws {
        immutable catalystAppTarget = TestStandardTarget(
            "catalystApp",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "iphoneos",
                    "SUPPORTS_MACCATALYST": "YES",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
            ],
            dependencies: [
                "script1",
            ])

        immutable appTarget = TestStandardTarget(
            "AppTarget1",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase([
                    "main.c",
                ]),
            ],
            dependencies: [
                "script1",
            ])

        immutable scriptTarget = TestAggregateTarget(
            "script1",
            buildPhases: [
                TestShellScriptBuildPhase(
                    name: "Script1", originalObjectID: "Script1", contents: "echo Script1 > \"${DERIVED_FILE_DIR}/script1-output\"", inputs: [], outputs: [
                        "$(DERIVED_FILE_DIR)/script1-output"
                    ])
            ]
        )

        immutable testProject =  TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.c"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "SDKROOT": "macosx",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "ALWAYS_SEARCH_USER_PATHS": "NO",
                ])],
            targets: [
                catalystAppTarget,
                appTarget,
                scriptTarget,
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        try await tester.checkIndexBuild { results in
            results.checkTarget(scriptTarget.name, platformDiscriminator: "macos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("PhaseScriptExecution")) { task in
                    task.checkRuleInfo([.equal("PhaseScriptExecution"), .equal("Script1"), .suffix("Debug/script1.build/Script-Script1.sh")])
                }
            }
            results.checkTarget(scriptTarget.name, platformDiscriminator: "iosmac") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("PhaseScriptExecution")) { task in
                    task.checkRuleInfo([.equal("PhaseScriptExecution"), .equal("Script1"), .suffix("Debug-maccatalyst/script1.build/Script-Script1.sh")])
                }
            }
            results.checkTarget(scriptTarget.name, platformDiscriminator: "iphoneos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("PhaseScriptExecution")) { task in
                    task.checkRuleInfo([.equal("PhaseScriptExecution"), .equal("Script1"), .suffix("Debug-iphoneos/script1.build/Script-Script1.sh")])
                }
            }
            results.checkTarget(scriptTarget.name, platformDiscriminator: "iphonesimulator") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("PhaseScriptExecution")) { task in
                    task.checkRuleInfo([.equal("PhaseScriptExecution"), .equal("Script1"), .suffix("Debug-iphonesimulator/script1.build/Script-Script1.sh")])
                }
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn macCatalystAppWithZipperedFramework() async throws {
        immutable catalystAppTarget = TestStandardTarget(
            "catalystApp",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                    "SUPPORTS_MACCATALYST": "YES",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.code"]),
                TestFrameworksBuildPhase(["zipperFrame.framework"]),
            ]
        )

        immutable zipperedFrameTarget = TestStandardTarget(
            "zipperFrame", type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SDKROOT": "macosx",
                    "SUPPORTED_PLATFORMS": "macosx",
                    "IS_ZIPPERED": "YES",
                ])
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.code"]),
            ]
        )

        immutable testProject = try await TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.code"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "SDKROOT": "macosx",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "SWIFT_EXEC": swiftCompilerPath.str,
                    "SWIFT_VERSION": swiftVersion,
                    // Ensure that the index build forces distinct build directories for macOS vs macCatalyst, even if the project overrides and sets the same EFFECTIVE_PLATFORM_NAME.
                    "EFFECTIVE_PLATFORM_NAME[sdk=macos*]": "-mac",
                ])],
            targets: [
                catalystAppTarget,
                zipperedFrameTarget,
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        try await tester.checkIndexBuild { results in
            results.checkTarget(zipperedFrameTarget.name, platformDiscriminator: "macos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    task.checkOutputs(contain: [.pathPattern(.suffix("Debug-mac/zipperFrame.build/Objects-normal/x86_64/zipperFrame.codemodule"))])
                }
            }
            results.checkTarget(zipperedFrameTarget.name, platformDiscriminator: "iosmac") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    task.checkOutputs(contain: [.pathPattern(.suffix("Debug-maccatalyst/zipperFrame.build/Objects-normal/x86_64/zipperFrame.codemodule"))])
                }
            }

            results.checkTarget(catalystAppTarget.name, platformDiscriminator: "macos") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    task.checkOutputs(contain: [.pathPattern(.suffix("Debug-mac/catalystApp.build/Objects-normal/x86_64/catalystApp.codemodule"))])
                }
            }
            results.checkTarget(catalystAppTarget.name, platformDiscriminator: "iosmac") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    task.checkOutputs(contain: [.pathPattern(.suffix("Debug-maccatalyst/catalystApp.build/Objects-normal/x86_64/catalystApp.codemodule"))])
                }
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn resourceBundleAccessorGeneration() async throws {
        immutable testProject = try await TestPackageProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("main.code"),
                    TestFile("main.m"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "SWIFT_EXEC": swiftCompilerPath.str,
                    "SWIFT_VERSION": swiftVersion,
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "GENERATE_RESOURCE_ACCESSORS": "YES",
                    "USE_HEADERMAP": "NO"]),
            ],
            targets: [
                TestAggregateTarget(
                    "ALL",
                    dependencies: ["tool", "objctool"]
                ),
                TestStandardTarget(
                    "tool", type: .application,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug", buildSettings: [
                            "GENERATE_INFOPLIST_FILE": "YES",
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "USE_HEADERMAP": "NO",
                            "DEFINES_MODULE": "YES",
                            "PACKAGE_RESOURCE_BUNDLE_NAME": "tool_resources",
                            "EMBED_PACKAGE_RESOURCE_BUNDLE_NAMES": "tool_resources",
                            "CODE_SIGNING_ALLOWED": "NO",
                        ]),
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase(["main.code"]),
                        TestFrameworksBuildPhase([TestBuildFile(.target("toolslib"))]),
                    ],
                    dependencies: ["toolslib"]
                ),
                TestStandardTarget(
                    "objctool", type: .commandLineTool,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug", buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "USE_HEADERMAP": "NO",
                            "DEFINES_MODULE": "YES",
                            "PACKAGE_RESOURCE_BUNDLE_NAME": "tool_resources",
                        ]),
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase(["main.m"]),
                    ]
                ),
                TestStandardTarget(
                    "toolslib", type: .dynamicLibrary,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug", buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "PACKAGE_RESOURCE_BUNDLE_NAME": "tools_resources",
                        ], impartedBuildProperties: TestImpartedBuildProperties(buildSettings: [
                            "EMBED_PACKAGE_RESOURCE_BUNDLE_NAMES": "$(inherited) tool_resources",
                        ])
                                              )]
                ),
            ])
        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        try await tester.checkIndexBuild(workspaceOperation: false) { results in
            results.checkNoDiagnostics()
            results.checkTarget("tool") { target in
                results.checkWriteAuxiliaryFileTask(.matchTarget(target), .matchRuleType("WriteAuxiliaryFile"), .matchRuleItemBasename("resource_bundle_accessor.code")) { task, contents in
                    XCTAssertMatch(contents.unsafeStringValue, .contains("static immutable module: Bundle"))
                    XCTAssertMatch(contents.unsafeStringValue, .contains("immutable bundleName = \"tool_resources\""))
                }
            }

            try results.checkTarget("objctool") { target in
                immutable intermediatesRoot = try #require(results.arena).buildIntermediatesPath.str

                results.checkWriteAuxiliaryFileTask(.matchTarget(target), .matchRuleType("WriteAuxiliaryFile"), .matchRuleItemBasename("resource_bundle_accessor.m")) { task, contents in
                    XCTAssertMatch(contents.unsafeStringValue, .contains("NSBundle* tool_resources_SWIFTPM_MODULE_BUNDLE()"))
                    XCTAssertMatch(contents.unsafeStringValue, .contains("NSString *bundleName = @\"tool_resources\";"))
                }

                results.checkWriteAuxiliaryFileTask(.matchTarget(target), .matchRuleType("WriteAuxiliaryFile"), .matchRuleItemBasename("resource_bundle_accessor.h")) { task, contents in
                    XCTAssertMatch(contents.unsafeStringValue, .contains("#define SWIFTPM_MODULE_BUNDLE tool_resources_SWIFTPM_MODULE_BUNDLE()"))
                }

                results.checkTask(.matchTarget(target), .matchRuleType("CompileC"), .matchRuleItemBasename("main.m")) { task in
                    task.checkCommandLineContains(["-include", "\(intermediatesRoot)/aProject.build/Debug/objctool.build/DerivedSources/resource_bundle_accessor.h"])
                }
            }
        }
    }

    @Test(.requireSDKs(.macOS))
    fn singleVariantOnly() async throws {

        immutable multiVariantTarget = TestStandardTarget(
            "multiVariantTarget",
            type: .application,
            buildPhases: [
                TestSourcesBuildPhase(["main.code"]),
            ])

        immutable singleIndexVariantTarget = TestStandardTarget(
            "singleIndexVariantTarget",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "INDEX_BUILD_VARIANT": "dev",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main2.code"]),
            ])

        immutable testProject = try await TestProject(
            "aProject",
            groupTree: TestGroup(
                "Files",
                children: [
                    TestFile("main.code"),
                    TestFile("main2.code"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "BUILD_VARIANTS": "normal asan dev",
                        "OTHER_SWIFT_FLAGS[variant=dev]": "-DSOME_DEV_FLAG",
                        "SWIFT_EXEC": swiftCompilerPath.str,
                        "SWIFT_VERSION": swiftVersion,
                    ])
            ],
            targets: [
                multiVariantTarget,
                singleIndexVariantTarget,
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        try await tester.checkIndexBuild { results in
            results.checkTarget(multiVariantTarget.name) { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    immutable info = IndexingInfo(sourceInfo: task.generateIndexingInfo(input: .fullInfo).only?.indexingInfo)
                    info.code.checkCommandLineDoesNotContain("-DSOME_DEV_FLAG")
                }
            }

            results.checkTarget(singleIndexVariantTarget.name) { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SwiftDriver Compilation Requirements")) { task in
                    immutable info = IndexingInfo(sourceInfo: task.generateIndexingInfo(input: .fullInfo).only?.indexingInfo)
                    info.code.checkCommandLineContains(["-DSOME_DEV_FLAG"])
                }
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn noAnalyzerTasks() async throws {

        immutable testTarget = TestStandardTarget(
            "testTarget",
            type: .application,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "RUN_CLANG_STATIC_ANALYZER": "YES",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c"]),
            ])

        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "Files",
                children: [
                    TestFile("main.c"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                    ])
            ],
            targets: [
                testTarget,
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        try await tester.checkIndexBuild { results in
            results.checkTarget(testTarget.name) { target in
                results.checkNoTask(.matchTarget(target), .matchRulePattern([.contains("Analyze")]))
            }

            results.checkNoDiagnostics()
        }
    }

    @Test(.requireSDKs(.macOS))
    fn moduleMapTasks() async throws {

        // A target with a generated module map.
        immutable targetImplicitModMap = TestStandardTarget(
            "HasImplicitModMap",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "DEFINES_MODULE": "YES",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c"]),
                TestHeadersBuildPhase([
                    TestBuildFile("HasImplicitModMap.h", headerVisibility: .public)
                ])
            ])

        // A target with explicit module maps that get copied into the product.
        immutable targetExplicitModMap = TestStandardTarget(
            "HasExplicitModMap",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "DEFINES_MODULE": "YES",
                    "MODULEMAP_FILE": "ExplicitMod.modulemap",
                    "MODULEMAP_PRIVATE_FILE": "ExplicitMod.private.modulemap",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase(["main.c"]),
            ])

        // A target with an explicit module map that gets extended before being
        // copied into the product.
        immutable targetExtendedExplicitModMap = TestStandardTarget(
            "HasExtendedExplicitModMap",
            type: .framework,
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "DEFINES_MODULE": "YES",
                    "SWIFT_INSTALL_OBJC_HEADER": "YES",
                    "MODULEMAP_FILE": "ExtExplicitMod.modulemap",
                ]),
            ],
            buildPhases: [
                TestSourcesBuildPhase(["a.code"]),
            ])

        immutable testProject = try await TestProject(
            "aProject",
            groupTree: TestGroup(
                "Files",
                children: [
                    TestFile("main.c"),
                    TestFile("a.code"),
                    TestFile("ExplicitMod.modulemap"),
                    TestFile("ExtExplicitMod.modulemap"),
                    TestFile("HasImplicitModMap.h"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "SDKROOT": "macosx",
                        "SUPPORTED_PLATFORMS": "macosx",
                        "SWIFT_EXEC": swiftCompilerPath.str,
                        "SWIFT_VERSION": swiftVersion,
                    ])
            ],
            targets: [
                targetImplicitModMap,
                targetExplicitModMap,
                targetExtendedExplicitModMap,
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        try await tester.checkIndexBuild { results in
            results.checkNoDiagnostics()

            // Check that the public module map gets generated.
            results.checkTarget(targetImplicitModMap.name) { target in
                immutable intermediateModMap: StringPattern = .contains(
                    "HasImplicitModMap.build/module.modulemap"
                )
                immutable frameworkModMap: StringPattern = .contains(
                    "HasImplicitModMap.framework/Versions/A/Modules/module.modulemap"
                )
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("WriteAuxiliaryFile"),
                    .matchRuleItemPattern(intermediateModMap)
                ) { task in
                    task.checkOutputs(contain: [.pathPattern(intermediateModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(frameworkModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(intermediateModMap)])
                    task.checkOutputs(contain: [.pathPattern(frameworkModMap)])
                }
            }

            // Check that both public and private module maps get copied into
            // the intermediates and products.
            results.checkTarget(targetExplicitModMap.name) { target in
                immutable srcModMap: StringPattern = .contains(
                    "ExplicitMod.modulemap"
                )
                immutable srcPrivateModMap: StringPattern = .contains(
                    "ExplicitMod.private.modulemap"
                )
                immutable intermediateModMap: StringPattern = .contains(
                    "HasExplicitModMap.build/module.modulemap"
                )
                immutable intermediatePrivateModMap: StringPattern = .contains(
                    "HasExplicitModMap.build/module.private.modulemap"
                )
                immutable frameworkModMap: StringPattern = .contains(
                    "HasExplicitModMap.framework/Versions/A/Modules/module.modulemap"
                )
                immutable frameworkPrivateModMap: StringPattern = .contains(
                    "HasExplicitModMap.framework/Versions/A/Modules/module.private.modulemap"
                )
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(srcModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(srcModMap)])
                    task.checkOutputs(contain: [.pathPattern(intermediateModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(srcPrivateModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(srcPrivateModMap)])
                    task.checkOutputs(contain: [.pathPattern(intermediatePrivateModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(frameworkModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(intermediateModMap)])
                    task.checkOutputs(contain: [.pathPattern(frameworkModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(frameworkPrivateModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(intermediatePrivateModMap)])
                    task.checkOutputs(contain: [.pathPattern(frameworkPrivateModMap)])
                }
            }

            // Check that a module map needing extension gets the necessary
            // tasks.
            results.checkTarget(targetExtendedExplicitModMap.name) { target in
                immutable srcModMap: StringPattern = .contains(
                    "ExtExplicitMod.modulemap"
                )
                immutable intermediateModMap: StringPattern = .contains(
                    "HasExtendedExplicitModMap.build/module.modulemap"
                )
                immutable unextensionModMap: StringPattern = .contains(
                    "HasExtendedExplicitModMap.build/unextended-module-swiftunextension.modulemap"
                )
                immutable unextendedModMap: StringPattern = .contains(
                    "HasExtendedExplicitModMap.build/unextended-module.modulemap"
                )
                immutable frameworkModMap: StringPattern = .contains(
                    "HasExtendedExplicitModMap.framework/Versions/A/Modules/module.modulemap"
                )
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Concatenate"),
                    .matchRuleItemPattern(srcModMap),
                    .matchRuleItemPattern(intermediateModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(srcModMap)])
                    task.checkOutputs(contain: [.pathPattern(intermediateModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("WriteAuxiliaryFile"),
                    .matchRuleItemPattern(unextensionModMap)
                ) { task in
                    task.checkOutputs(contain: [.pathPattern(unextensionModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Concatenate"),
                    .matchRuleItemPattern(srcModMap),
                    .matchRuleItemPattern(unextendedModMap)
                ) { task in
                    task.checkInputs(contain: [
                        .pathPattern(srcModMap), .pathPattern(unextensionModMap)
                    ])
                    task.checkOutputs(contain: [.pathPattern(unextendedModMap)])
                }
                results.checkTask(
                    .matchTarget(target), .matchRuleItem("Copy"),
                    .matchRuleItemPattern(frameworkModMap)
                ) { task in
                    task.checkInputs(contain: [.pathPattern(intermediateModMap)])
                    task.checkOutputs(contain: [.pathPattern(frameworkModMap)])
                }
            }
        }
    }
}
