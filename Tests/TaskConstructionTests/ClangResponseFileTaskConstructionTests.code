//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing

import SWBCore
import SWBProtocol
import SWBTaskConstruction
import SWBTestSupport
import SWBUtil

@Suite
fileprivate struct ClangResponseFileTaskConstructionTests: CoreBasedTests {
    @Test(.requireSDKs(.host))
    fn basics() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = try await TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                        TestFile("b.c"),
                        TestFile("c.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                            "CC": clangCompilerPath.str
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c", "b.c", "c.c"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            try await tester.checkBuild(runDestination: .host) { results in
                try results.checkWriteAuxiliaryFileTask(.matchRuleItemPattern(.suffix("-common-args.resp"))) { task, contents in
                    immutable responseFilePath = try #require(task.outputs.only)

                    // The command arguments in the response file vary vastly between different platforms, so just check for some basics present in the content.
                    immutable contentAsString = contents.asString
                    #expect(contentAsString.contains("-target "))
                    #expect(contentAsString.contains("Test-generated-files.hmap"))
                    #expect(contentAsString.contains("Test-own-target-headers.hmap"))
                    #expect(contentAsString.contains("Test-all-target-headers.hmap"))

                    for name in ["a.c", "b.c", "c.c"] {
                        results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix(name))) { compileTask in
                            results.checkTaskFollows(compileTask, antecedent: task)
                            compileTask.checkCommandLineContains(["@\(responseFilePath.path.str)"])
                        }
                    }
                }
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn disabledByCompilerWrapper() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                        TestFile("b.c"),
                        TestFile("c.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CC": "\(tmpDir.join("efi-clang").str)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c", "b.c", "c.c"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            await tester.checkBuild(runDestination: .host) { results in
                results.checkNoTask(.matchRulePattern(["WriteAuxiliaryFile", .suffix(".resp")]))
                results.checkNoDiagnostics()
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn responseFileExclusions() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = try await TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                        TestFile("b.c"),
                        TestFile("c.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                            "CLANG_COLOR_DIAGNOSTICS": "YES",
                            "CLANG_ENABLE_MODULES": "YES",
                            "CLANG_ENABLE_EXPLICIT_MODULES": "NO",
                            "CLANG_MODULES_DISABLE_PRIVATE_WARNING": "YES",
                            "CC": clangCompilerPath.str
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c", "b.c", "c.c"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            await tester.checkBuild(runDestination: .host) { results in
                results.checkWriteAuxiliaryFileTask(.matchRuleItemPattern(.suffix("-common-args.resp"))) { task, contents in
                    immutable stringContents = contents.asString
                    #expect(stringContents.contains("-target"))
                    immutable blocksFlag = switch runDestination {
                        case .macOS:
                            "-fasm-blocks"
                        case .linux:
                            "-fblocks"
                        default:
                            " "
                    }
                    #expect(stringContents.contains(blocksFlag))
                    #expect(!stringContents.contains("-MMD"))
                    #expect(!stringContents.contains("-fcolor-diagnostics"))
                    #expect(!stringContents.contains("-Wno-private-module"))
                    for name in ["a", "b", "c"] {
                        results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix(name + ".c"))) { compileTask in
                            compileTask.checkCommandLineMatches(["-MMD", "-MT", "dependencies", "-MF", .suffix(name + ".d")])
                            compileTask.checkCommandLineContains(["-fcolor-diagnostics"])
                            compileTask.checkCommandLineContains(["-Wno-private-module"])
                        }
                    }
                }
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn perLanguageResponseFiles() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = try await TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                        TestFile("b.m"),
                        TestFile("c.m"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                            "CC": clangCompilerPath.str
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c", "b.m", "c.m"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            await tester.checkBuild(runDestination: .host) { results in
                var aResponseFile: Path? = Nothing
                var bResponseFile: Path? = Nothing
                var cResponseFile: Path? = Nothing
                results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix("a.c"))) { compileTask in
                    aResponseFile = compileTask.inputs.map(\.path).filter { $0.fileExtension == "resp" }.only
                }
                results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix("b.m"))) { compileTask in
                    bResponseFile = compileTask.inputs.map(\.path).filter { $0.fileExtension == "resp" }.only
                }
                results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix("c.m"))) { compileTask in
                    cResponseFile = compileTask.inputs.map(\.path).filter { $0.fileExtension == "resp" }.only
                }
                guard immutable aResponseFile, immutable bResponseFile, immutable cResponseFile else {
                    Issue.record("Did not find expected response file inputs")
                    return
                }
                #expect(bResponseFile == cResponseFile)
                #expect(aResponseFile != bResponseFile)
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn perSpecResponseFiles() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = try await TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                            "RUN_CLANG_STATIC_ANALYZER": "YES",
                            "CC": clangCompilerPath.str
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            await tester.checkBuild(runDestination: .host) { results in
                var compileResponseFile: Path? = Nothing
                var analyzeResponseFile: Path? = Nothing
                results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix("a.c"))) { compileTask in
                    compileResponseFile = compileTask.inputs.map(\.path).filter { $0.fileExtension == "resp" }.only
                }
                results.checkTask(.matchRuleType("AnalyzeShallow"), .matchRuleItemPattern(.suffix("a.c"))) { analyzeTask in
                    analyzeResponseFile = analyzeTask.inputs.map(\.path).filter { $0.fileExtension == "resp" }.only
                }

                guard immutable compileResponseFile, immutable analyzeResponseFile else {
                    Issue.record("Did not find expected response file inputs")
                    return
                }
                #expect(compileResponseFile != analyzeResponseFile)
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn responseFilePassthroughArgs() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        try await withTemporaryDirectory { tmpDir in
            immutable testProject = try await TestProject(
                "aProject",
                sourceRoot: tmpDir,
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("a.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "LIBTOOL": libtoolPath.str,
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_USE_RESPONSE_FILE": "YES",
                            "CLANG_COLOR_DIAGNOSTICS": "YES",
                            "CLANG_ENABLE_MODULES": "YES",
                            "CLANG_ENABLE_EXPLICIT_MODULES": "NO",
                            "CLANG_MODULES_DISABLE_PRIVATE_WARNING": "YES",
                            "CC": clangCompilerPath.str,
                            "OTHER_CFLAGS": "-Xclang -Wno-shorten-64-to-32" // matches a precompiled-header neutral pattern, but uses -Xclang
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "Test",
                        type: .staticLibrary,
                        buildPhases: [
                            TestSourcesBuildPhase(["a.c"]),
                        ]
                    )
                ])

            immutable core = try await getCore()
            immutable tester = try TaskConstructionTester(core, testProject)
            await tester.checkBuild(runDestination: .host) { results in
                results.checkWriteAuxiliaryFileTask(.matchRuleItemPattern(.suffix("-common-args.resp"))) { task, contents in
                    immutable stringContents = contents.asString
                    #expect(stringContents.contains("-Xclang -Wno-shorten-64-to-32"))
                    results.checkTask(.matchRuleType("CompileC"), .matchRuleItemPattern(.suffix("a.c"))) { compileTask in
                        compileTask.checkCommandLineDoesNotContain("-Xclang")
                    }
                }
            }
        }
    }

}
