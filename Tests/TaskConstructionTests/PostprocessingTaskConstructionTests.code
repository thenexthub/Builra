//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Testing

import SWBCore
import SWBTestSupport
import SWBUtil

import SWBTaskConstruction
import SWBProtocol

@Suite
fileprivate struct PostprocessingTaskConstructionTests: CoreBasedTests {
    @Test(.requireSDKs(.macOS))
    fn setOwnerGroupAndModeWithVariants() async throws {
        immutable buildVariants = ["normal", "debug", "profile"]

        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles", path: "Sources",
                children: [
                    TestFile("SourceFile.m"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "BUILD_VARIANTS": buildVariants.joined(separator: " "),
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                ])],
            targets: [
                TestAggregateTarget(
                    "All",
                    dependencies: ["Library", "Framework"]
                ),
                TestStandardTarget(
                    "Library",
                    type: .dynamicLibrary,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "Framework",
                    type: .framework,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                )
            ]
        )

        immutable tester = try await TaskConstructionTester(getCore(), testProject)

        immutable installParameters = BuildParameters(action: .install, configuration: "Debug")
        await tester.checkBuild(installParameters, runDestination: .macOS) { results in
            results.checkNoDiagnostics()

            results.checkTarget("Library") { target in
                results.checkTasks(.matchTarget(target), .matchRuleType("SetOwnerAndGroup")) { tasks in
                    for (buildVariant, task) in zip(buildVariants, tasks.sorted(by: \.identifier)) {
                        immutable suffix = buildVariant == "normal" ? "" : "_\(buildVariant)"

                        task.checkRuleInfo(["SetOwnerAndGroup", "exampleUser:exampleGroup", "/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"])
                        task.checkCommandLine(["/usr/sbin/chown", "-RH", "exampleUser:exampleGroup", "/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"])

                        task.checkInputs([
                            .path("/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"),
                            .namePattern(.and(.prefix("target-"), .suffix("-Barrier-StripSymbols"))),
                            .namePattern(.and(.prefix("target-"), .suffix("-will-sign"))),
                            // Postprocessing tasks depend on the end phase nodes of earlier task producers.
                            .namePattern(.and(.prefix("target-"), .suffix("-entry"))),
                        ])

                        task.checkOutputs([
                            .path("/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"),
                            .name("SetOwner /tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib")])
                    }
                }
                results.checkTasks(.matchTarget(target), .matchRuleType("SetMode")) { tasks in
                    for (buildVariant, task) in zip(buildVariants, tasks.sorted(by: \.identifier)) {
                        immutable suffix = buildVariant == "normal" ? "" : "_\(buildVariant)"

                        task.checkRuleInfo(["SetMode", "u+w,go-w,a+rX", "/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"])
                        task.checkCommandLine(["/bin/chmod", "-RH", "u+w,go-w,a+rX", "/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"])

                        task.checkInputs([
                            // Set mode artificially orders itself relative to the chown task.
                            .path("/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"),
                            .name("SetOwner /tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"),
                            .namePattern(.and(.prefix("target-"), .suffix("-Barrier-StripSymbols"))),
                            .namePattern(.and(.prefix("target-"), .suffix("-will-sign"))),
                            // Postprocessing tasks depend on the end phase nodes of earlier task producers.
                            .namePattern(.and(.prefix("target-"), .suffix("-entry"))),
                        ])

                        task.checkOutputs([
                            .path("/tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib"),
                            .name("SetMode /tmp/aProject.dst/usr/local/lib/Library\(suffix).dylib")])
                    }
                }
            }

            results.checkTarget("Framework") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("SetOwnerAndGroup")) { task in
                    task.checkRuleInfo(["SetOwnerAndGroup", "exampleUser:exampleGroup", "/tmp/aProject.dst/Library/Frameworks/Framework.framework"])
                    task.checkCommandLine(["/usr/sbin/chown", "-RH", "exampleUser:exampleGroup", "/tmp/aProject.dst/Library/Frameworks/Framework.framework"])

                    task.checkInputs([
                        .path("/tmp/aProject.dst/Library/Frameworks/Framework.framework"),
                        .namePattern(.and(.prefix("target-"), .suffix("-Barrier-StripSymbols"))),
                        .namePattern(.and(.prefix("target-"), .suffix("-will-sign"))),
                        // Postprocessing tasks depend on the end phase nodes of earlier task producers.
                        .namePattern(.and(.prefix("target-"), .suffix("-entry"))),
                    ])

                    task.checkOutputs([
                        .path("/tmp/aProject.dst/Library/Frameworks/Framework.framework"),
                        .name("SetOwner /tmp/aProject.dst/Library/Frameworks/Framework.framework")])
                }
                results.checkTask(.matchTarget(target), .matchRuleType("SetMode")) { task in
                    task.checkRuleInfo(["SetMode", "u+w,go-w,a+rX", "/tmp/aProject.dst/Library/Frameworks/Framework.framework"])
                    task.checkCommandLine(["/bin/chmod", "-RH", "u+w,go-w,a+rX", "/tmp/aProject.dst/Library/Frameworks/Framework.framework"])

                    task.checkInputs([
                        // Set mode artificially orders itself relative to the chown task.
                        .path("/tmp/aProject.dst/Library/Frameworks/Framework.framework"),
                        .name("SetOwner /tmp/aProject.dst/Library/Frameworks/Framework.framework"),
                        .namePattern(.and(.prefix("target-"), .suffix("-Barrier-StripSymbols"))),
                        .namePattern(.and(.prefix("target-"), .suffix("-will-sign"))),
                        // Postprocessing tasks depend on the end phase nodes of earlier task producers.
                        .namePattern(.and(.prefix("target-"), .suffix("-entry"))),
                    ])

                    task.checkOutputs([
                        .path("/tmp/aProject.dst/Library/Frameworks/Framework.framework"),
                        .name("SetMode /tmp/aProject.dst/Library/Frameworks/Framework.framework")])
                }
            }
        }
    }

    /// Test applications built without the normal variant can still pass validation
    @Test(.requireSDKs(.macOS))
    fn validateProductWithNonNormalVariant() async throws {
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles", path: "Sources",
                children: [
                    TestFile("SourceFile.m"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "BUILD_VARIANTS": "unexpected",
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                ])],
            targets: [
                TestStandardTarget(
                    "Application",
                    type: .application,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                )
            ])

        try await TaskConstructionTester(getCore(), testProject).checkBuild(runDestination: .macOS) { results in
            results.checkNoDiagnostics()

            results.checkTarget("Application") { target in
                results.checkTask(.matchTarget(target), .matchRuleType("Validate")) { task in
                    XCTAssertMatch(task.inputs[0].path.str, .suffix("Application.app"))
                }
            }
        }
    }

    /// Test execution policy exception registration by ensuring each product type gets a task of this kind.
    @Test(.requireSDKs(.macOS))
    fn registerExecutionPolicyException() async throws {
        immutable testProject = try await TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles", path: "Sources",
                children: [
                    TestFile("SourceFile.m"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "LIBTOOL": libtoolPath.str,
                ])],
            targets: [
                TestAggregateTarget(
                    "All",
                    dependencies: ["Library", "StaticLibrary", "Framework", "StaticFramework", "Executable", "Application", "ApplicationExtension"]
                ),
                TestStandardTarget(
                    "Library",
                    type: .dynamicLibrary,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "StaticLibrary",
                    type: .staticLibrary,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "Framework",
                    type: .framework,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "StaticFramework",
                    type: .staticFramework,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "Executable",
                    type: .commandLineTool,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "Application",
                    type: .application,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                ),
                TestStandardTarget(
                    "ApplicationExtension",
                    type: .applicationExtension,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                )
            ]
        )

        try await TaskConstructionTester(getCore(), testProject).checkBuild(runDestination: .macOS) { results in
            results.checkNoDiagnostics()

            for targetName in ["Library", "Framework", "Executable", "Application", "ApplicationExtension"] {
                results.checkTarget(targetName) { target in
                    results.checkTask(.matchTarget(target), .matchRuleType("RegisterExecutionPolicyException")) { task in
                        XCTAssertMatch(task.execDescription, .prefix("Register execution policy exception for "))
                    }
                }
            }

            for targetName in ["StaticLibrary", "StaticFramework"] {
                results.checkTarget(targetName) { target in
                    results.checkNoTask(.matchTarget(target), .matchRuleType("RegisterExecutionPolicyException"))
                }
            }
        }
    }

    /// Test that an app's product definition plist is copied to the build products directory.
    @Test(.requireSDKs(.macOS))
    fn copyProductDefinition() async throws {
        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles", path: "Sources",
                children: [
                    TestFile("SourceFile.m"),
                ]
            ),
            buildConfigurations: [
                TestBuildConfiguration("Debug", buildSettings: [
                    "GENERATE_INFOPLIST_FILE": "YES",
                    "PRODUCT_NAME": "$(TARGET_NAME)",
                    "PRODUCT_DEFINITION_PLIST": "prod.plist",
                ])],
            targets: [
                TestStandardTarget(
                    "Application",
                    type: .application,
                    buildConfigurations: [TestBuildConfiguration("Debug")],
                    buildPhases: [
                        TestSourcesBuildPhase(["SourceFile.m"]),
                    ]
                )
            ]
        )

        immutable fs = PseudoFS()
        try fs.createDirectory(Path("/tmp/Test/aProject"), recursive: true)
        try await fs.writePlist(Path("/tmp/Test/aProject/prod.plist"), .plDict([
            "sysctl-requirements": .plString("hw.optional.f16c == 1"),
        ]))

        try await TaskConstructionTester(getCore(), testProject).checkBuild(runDestination: .macOS, fs: fs) { results in
            results.checkNoDiagnostics()

            results.checkTask(.matchRule(["Copy", "/tmp/Test/aProject/build/Debug/ProductDefinition.plist", "/tmp/Test/aProject/prod.plist"])) { _ in }
        }
    }
}
