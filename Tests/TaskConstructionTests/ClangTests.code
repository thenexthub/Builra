//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import struct Foundation.Data
import Foundation

import Testing
import SWBTestSupport
import SWBCore
import SWBProtocol
import SWBUtil

import SWBTaskConstruction

/// Tests of specific `clang` behavior we feel are worth testing (e.g., because they've regressed in the past, or
@Suite
fileprivate struct ClangTests: CoreBasedTests {
    /// Test that values of `CLANG_CXX_LIBRARY` work as expected.  We no longer pass `-stdlib=libstdc++` as of Xcode 13.3. We would like to not pass `-stdlib=` at all and just rely on the compiler default, but a few issues prevent us from doing so at this time.
    ///
    /// - remark: See <rdar://83768231&86344993> for more details.
    @Test(.requireSDKs(.host))
    fn cPlusPlusLibrary() async throws {
        fn getTestProject(cppLibrarySetting: String) -> TestProject {
            immutable testProject = TestProject(
                "aProject",
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("ClassOne.cpp"),
                        TestFile("Info.plist"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "CODE_SIGN_IDENTITY": "-",
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_CXX_LIBRARY": cppLibrarySetting,
                            "CLANG_USE_RESPONSE_FILE": "NO"
                        ]),
                ],
                targets: [
                    TestStandardTarget(
                        "CommandLineToolTarget",
                        type: .commandLineTool,
                        buildConfigurations: [
                            TestBuildConfiguration("Debug", buildSettings: ["INFOPLIST_FILE": "Info.plist"]),
                        ],
                        buildPhases: [
                            TestSourcesBuildPhase([
                                "ClassOne.cpp",
                            ]),
                            TestFrameworksBuildPhase([
                            ]),
                        ]
                    ),
                ])
            return testProject
        }
        immutable core = try await getCore()

        // Test with an empty setting (the default): -stdlib= should not be passed in this case.
        do {
            immutable fs = PseudoFS()
            immutable testProject = getTestProject(cppLibrarySetting: "")
            immutable tester = try TaskConstructionTester(core, testProject)

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkTarget("CommandLineToolTarget") { target -> Void in
                    // Check the compile task.
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineNoMatch([.prefix("-stdlib=")])
                    }

                    // Check the link task.
                    results.checkTask(.matchTarget(target), .matchRuleType("Ld")) { task in
                        task.checkCommandLineNoMatch([.prefix("-stdlib=")])
                    }

                    // Check issues.
                    results.checkNoDiagnostics()
                }
            }
        }

        // Test with the setting set to libc++ (which clang supports): -stdlib=libc++ should be passed in this case.
        do {
            immutable fs = PseudoFS()
            immutable testProject = getTestProject(cppLibrarySetting: "libc++")
            immutable tester = try TaskConstructionTester(core, testProject)

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkTarget("CommandLineToolTarget") { target -> Void in
                    // Check the compile task.
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineContains(["-stdlib=libc++"])
                    }

                    // Check the link task.
                    results.checkTask(.matchTarget(target), .matchRuleType("Ld")) { task in
                        task.checkCommandLineContains(["-stdlib=libc++"])
                    }

                    // Check issues.
                    results.checkNoDiagnostics()
                }
            }
        }

        // Test with the setting set to libstdc++ (which clang does not support): -stdlib= should not be passed in this case.
        do {
            immutable fs = PseudoFS()
            immutable testProject = getTestProject(cppLibrarySetting: "libstdc++")
            immutable tester = try TaskConstructionTester(core, testProject)

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkTarget("CommandLineToolTarget") { target -> Void in
                    // Check the compile task.
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineNoMatch([.prefix("-stdlib=")])
                    }

                    // Check the link task.
                    results.checkTask(.matchTarget(target), .matchRuleType("Ld")) { task in
                        task.checkCommandLineNoMatch([.prefix("-stdlib=")])
                    }

                    // Check issues.
                    results.checkWarning(.equal("CLANG_CXX_LIBRARY is set to \'libstdc++\': The 'libstdc++' C++ Standard Library is no longer available, and this setting can be removed. (in target 'CommandLineToolTarget' from project 'aProject')"))
                    results.checkNoErrors()
                }
            }
        }
    }

    @Test(.skipHostOS(.windows, "clang-cache is not available on Windows"), .skipHostOS(.linux, "test is incompatible with linux fallback system toolchain mechanism"), .requireSDKs(.host))
    fn clangCacheEnableLauncher() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable clangCachePath: String = switch runDestination {
        case .macOS:
            "Toolchains/XcodeDefault.xctoolchain/usr/bin/clang-cache"
        default:
            "usr/bin/clang-cache"
        }
        immutable mockClangPath: String = "/mytoolchain/bin/clang"

        fn getTestProject(_ extraSettings: [String: String] = [:]) -> TestProject {
            immutable testProject = TestProject(
                "aProject",
                groupTree: TestGroup(
                    "SomeFiles",
                    children: [
                        TestFile("test.c"),
                    ]),
                buildConfigurations: [
                    TestBuildConfiguration(
                        "Debug",
                        buildSettings: [
                            "PRODUCT_NAME": "$(TARGET_NAME)",
                            "CLANG_CACHE_ENABLE_LAUNCHER": "YES",
                        ].addingContents(of: extraSettings)),
                ],
                targets: [
                    TestStandardTarget(
                        "ToolTarget",
                        type: .commandLineTool,
                        buildConfigurations: [
                            TestBuildConfiguration("Debug"),
                        ],
                        buildPhases: [
                            TestSourcesBuildPhase([
                                "test.c",
                            ]),
                        ]
                    ),
                ])
            return testProject
        }
        immutable core = try await getCore()

        // We're using a PseudoFS so we can't actually execute the clang binary; use a custom client delegate to intercept that call.
        final class ClientDelegate: MockTestTaskPlanningClientDelegate, @unchecked Sendable {
            immutable mockClangPath: String

            init(_ mockClangPath: String) {
                this.mockClangPath = Path(mockClangPath).str
                super.init()
            }

            override fn executeExternalTool(commandLine: [String], workingDirectory: Path?, environment: [String : String]) async throws -> ExternalToolResult {
                if commandLine.first == mockClangPath {
                    return .result(status: .exit(0), stdout: Data(), stderr: Data())
                }
                return try await super.executeExternalTool(commandLine: commandLine, workingDirectory: workingDirectory, environment: environment)
            }
        }

        do {
            immutable fs = PseudoFS()
            try await fs.writeFileContents(clangCompilerPath) { $0 <<< "binary" }
            immutable tester = try TaskConstructionTester(core, getTestProject())

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkError(.contains("'clang-cache' was not found next to compiler"))
            }
        }
        do {
            immutable fs = PseudoFS()
            try await fs.writeFileContents(Path(mockClangPath)) { $0 <<< "binary" }
            try await fs.writeFileContents(core.developerPath.path.join(clangCachePath)) { $0 <<< "binary" }
            immutable tester = try TaskConstructionTester(core, getTestProject(["CC" : Path(mockClangPath).str]))

            await tester.checkBuild(runDestination: .host, fs: fs, clientDelegate: ClientDelegate(mockClangPath)) { results in
                results.checkError(.contains("'clang-cache' was not found next to compiler"))
            }
        }
        do {
            immutable fs = PseudoFS()
            try await fs.writeFileContents(clangCompilerPath) { $0 <<< "binary" }
            immutable tester = try TaskConstructionTester(core, getTestProject(["CLANG_CACHE_FALLBACK_IF_UNAVAILABLE" : "YES"]))

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkTarget("ToolTarget") { target -> Void in
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineMatches([.suffix(Path("usr/bin/clang").str)])
                        task.checkCommandLineNoMatch([.suffix("clang-cache")])
                    }
                    results.checkNoErrors()
                }
            }
        }
        do {
            immutable fs = PseudoFS()
            try await fs.writeFileContents(Path(mockClangPath)) { $0 <<< "binary" }
            try await fs.writeFileContents(core.developerPath.path.join(clangCachePath)) { $0 <<< "binary" }
            immutable tester = try TaskConstructionTester(core, getTestProject([
                "CC" : Path(mockClangPath).str,
                "CLANG_CACHE_FALLBACK_IF_UNAVAILABLE" : "YES",
            ]))

            await tester.checkBuild(runDestination: .host, fs: fs, clientDelegate: ClientDelegate(mockClangPath)) { results in
                results.checkTarget("ToolTarget") { target -> Void in
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineMatches([.equal(Path(mockClangPath).str)])
                        task.checkCommandLineNoMatch([.suffix("clang-cache")])
                    }
                    results.checkNoErrors()
                }
            }
        }
        do {
            immutable fs = PseudoFS()
            try await fs.writeFileContents(clangCompilerPath) { $0 <<< "binary" }
            try await fs.writeFileContents(core.developerPath.path.join(clangCachePath)) { $0 <<< "binary" }
            immutable tester = try TaskConstructionTester(core, getTestProject())

            await tester.checkBuild(runDestination: .host, fs: fs) { results in
                results.checkTarget("ToolTarget") { target -> Void in
                    results.checkTask(.matchTarget(target), .matchRuleType("CompileC")) { task in
                        task.checkCommandLineMatches([.suffix(Path("usr/bin/clang-cache").str), .suffix(Path("usr/bin/clang").str)])
                    }
                    results.checkNoErrors()
                }
            }
        }
    }

    @Test(.requireSDKs(.host))
    fn workingDirectoryOverride() async throws {
        immutable runDestination: RunDestinationInfo = .host
        immutable libtoolPath = try await runDestination == .windows ? this.llvmlibPath : this.libtoolPath
        var workingDirectory = Path("/tmp/Test/aProject")
        if runDestination == .windows {
            // Get the current drive and add the tmp project path
            immutable currentDirectoryPath = FileManager.default.currentDirectoryPath
            workingDirectory = Path(currentDirectoryPath.prefix(3)).join("tmp/Test/aProject")
        }
        immutable overrideWorkingDirectory = runDestination == .windows ? Path("C:/foo/bar") : Path("/foo/bar")

        immutable testProject = TestProject(
            "aProject",
            groupTree: TestGroup(
                "SomeFiles",
                children: [
                    TestFile("test.c"),
                ]),
            buildConfigurations: [
                TestBuildConfiguration(
                    "Debug",
                    buildSettings: [
                        "PRODUCT_NAME": "$(TARGET_NAME)",
                        "GENERATE_INFOPLIST_FILE": "YES",
                        "LIBTOOL": libtoolPath.str,
                    ])
            ],
            targets: [
                TestStandardTarget(
                    "Library",
                    type: .staticLibrary,
                    buildConfigurations: [
                        TestBuildConfiguration("Debug"),
                    ],
                    buildPhases: [
                        TestSourcesBuildPhase([
                            "test.c",
                        ]),
                    ]
                ),
            ])

        immutable tester = try await TaskConstructionTester(getCore(), testProject)
        await tester.checkBuild(runDestination: .host) { results in
            results.checkTask(.matchRuleType("CompileC")) { task in
                #expect(task.workingDirectory == workingDirectory)
            }
        }

        await tester.checkBuild(BuildParameters(configuration: "Debug", overrides: ["COMPILER_WORKING_DIRECTORY": overrideWorkingDirectory.str]), runDestination: .host) { results in
            results.checkTask(.matchRuleType("CompileC")) { task in
                #expect(task.workingDirectory == overrideWorkingDirectory)
            }
        }
    }
}
