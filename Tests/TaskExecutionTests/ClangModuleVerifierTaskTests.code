//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBCore
import SWBTaskExecution
import SWBTestSupport
import SWBUtil
import Testing

@Suite
fileprivate struct ClangModuleVerifierTaskTests: CoreBasedTests {
    fn generateInput(fs: any FSProxy, commandLine: [String]) async throws -> (CommandResult, MockTaskOutputDelegate) {
        immutable action = ClangModuleVerifierInputGeneratorTaskAction()
        immutable task = Task(forTarget: Nothing, ruleInfo: [], commandLine: commandLine, workingDirectory: .root, outputs: [], action: action, execDescription: "Generate Module Verifier Input")
        immutable executionDelegate = try await MockExecutionDelegate(fs: fs, core: getCore())
        immutable outputDelegate = MockTaskOutputDelegate()
        immutable result = await action.performTaskAction(
            task,
            dynamicExecutionDelegate: MockDynamicTaskExecutionDelegate(),
            executionDelegate: executionDelegate,
            clientDelegate: MockTaskExecutionClientDelegate(),
            outputDelegate: outputDelegate
        )
        return (result, outputDelegate)
    }

    @Test
    fn inputGenerationCommandLineErrors() async throws {
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: [])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: no input framework specified"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: no input framework specified"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--asdf"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: unknown argument '--asdf'"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing required argument --language"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing argument to --language"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "rust"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: unrecognized language 'rust'"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing required argument --main-output"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c", "--main-output"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing argument to --main-output"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c", "--main-output", "/m"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing required argument --header-output"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c", "--main-output", "/m", "--header-output"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing argument to --header-output"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c", "--main-output", "/m", "--header-output", "/h"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing required argument --module-map-output"])
        }
        do {
            immutable (result, outputDelegate) = try await generateInput(fs: PseudoFS(), commandLine: ["exe", "/foo.framework", "--language", "c", "--main-output", "/m", "--header-output", "/h", "--module-map-output"])
            #expect(result == .failed)
            #expect(outputDelegate.errors == ["error: missing argument to --module-map-output"])
        }
    }

    @Test
    fn inputGenerationBasic() async throws {
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.write(tmp.join("A.framework/Headers/A.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Headers/B.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Modules/module.modulemap"), contents: """
            framework module A {
                umbrella header "A.h"
            }
            """)

            do {
                immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                    "exe",
                    tmp.join("A.framework").str,
                    "--language", "c",
                    "--main-output", tmp.join("Test.c").str,
                    "--header-output", tmp.join("Test.h").str,
                    "--module-map-output", tmp.join("Test.modulemap").str
                ])

                #expect(result == .succeeded)
                #expect(outputDelegate.messages == [])

                #expect(try localFS.read(tmp.join("Test.c")) == """
                #include <Test/Test.h>
                """)
                #expect(try localFS.read(tmp.join("Test.h")) == """
                #include <A/A.h>
                #include <A/B.h>

                """)
                #expect(try localFS.read(tmp.join("Test.modulemap")) == """
                framework module Test {
                    umbrella header "Test.h"

                    export *
                    module * { export * }
                }
                """)
            }
            do {
                immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                    "exe",
                    tmp.join("A.framework").str,
                    "--language", "objective-c++",
                    "--main-output", tmp.join("Test.c").str,
                    "--header-output", tmp.join("Test.h").str,
                    "--module-map-output", tmp.join("Test.modulemap").str
                ])

                #expect(result == .succeeded)
                #expect(outputDelegate.messages == [])

                #expect(try localFS.read(tmp.join("Test.c")) == """
                #import <Test/Test.h>
                """)
                #expect(try localFS.read(tmp.join("Test.h")) == """
                #import <A/A.h>
                #import <A/B.h>

                """)
                #expect(try localFS.read(tmp.join("Test.modulemap")) == """
                framework module Test {
                    umbrella header "Test.h"

                    export *
                    module * { export * }
                }
                """)
            }
        }
    }

    @Test
    fn inputGenerationPrivate() async throws {
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/PrivateHeaders"), recursive: true)
            try localFS.write(tmp.join("A.framework/Headers/A.h"), contents: "")
            try localFS.write(tmp.join("A.framework/PrivateHeaders/B.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Modules/module.modulemap"), contents: """
            framework module A {
                header "A.h"
            }
            """)
            try localFS.write(tmp.join("A.framework/Modules/module.private.modulemap"), contents: """
            framework module A_Private {
                header "B.h"
            }
            """)

            immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                "exe",
                tmp.join("A.framework").str,
                "--language", "c",
                "--main-output", tmp.join("Test.c").str,
                "--header-output", tmp.join("Test.h").str,
                "--module-map-output", tmp.join("Test.modulemap").str
            ])

            #expect(result == .succeeded)
            #expect(outputDelegate.messages == [])

            #expect(try localFS.read(tmp.join("Test.c")) == """
            #include <Test/Test.h>
            """)
            #expect(try localFS.read(tmp.join("Test.h")) == """
            #include <A/A.h>

            // Private
            #include <A/B.h>

            """)
            #expect(try localFS.read(tmp.join("Test.modulemap")) == """
            framework module Test {
                umbrella header "Test.h"

                export *
                module * { export * }
            }
            """)
        }
    }

    @Test
    fn inputGenerationNoPrivateMap() async throws {
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/PrivateHeaders"), recursive: true)
            try localFS.write(tmp.join("A.framework/Headers/A.h"), contents: "")
            try localFS.write(tmp.join("A.framework/PrivateHeaders/B.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Modules/module.modulemap"), contents: """
            framework module A {
                header "A.h"
            }
            """)

            immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                "exe",
                tmp.join("A.framework").str,
                "--language", "c",
                "--main-output", tmp.join("Test.c").str,
                "--header-output", tmp.join("Test.h").str,
                "--module-map-output", tmp.join("Test.modulemap").str
            ])

            #expect(result == .succeeded)
            #expect(try localFS.read(tmp.join("Test.h")) == """
                #include <A/A.h>

                """)
            #expect(outputDelegate.warnings == [
                "warning: \(tmp.join("A.framework/Modules/module.private.modulemap").str): module map is missing; there are private headers but no module map"
            ])
        }
    }

    @Test
    fn inputGenerationNoPublicMap() async throws {
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/PrivateHeaders"), recursive: true)
            try localFS.write(tmp.join("A.framework/Headers/A.h"), contents: "")
            try localFS.write(tmp.join("A.framework/PrivateHeaders/B.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Modules/module.private.modulemap"), contents: """
                framework module A_Private {
                  header "B.h"
                }
                """)

            immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                "exe",
                tmp.join("A.framework").str,
                "--language", "c",
                "--main-output", tmp.join("Test.c").str,
                "--header-output", tmp.join("Test.h").str,
                "--module-map-output", tmp.join("Test.modulemap").str
            ])

            #expect(result == .succeeded)
            #expect(try localFS.read(tmp.join("Test.h")) == """
                // Private
                #include <A/B.h>

                """)
            #expect(outputDelegate.warnings == [
                "warning: \(tmp.join("A.framework/Modules/module.modulemap").str): module map is missing; there are public headers but no module map"
            ])
        }
    }

    @Test
    fn moduleMapFileVerifier() async throws {
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/PrivateHeaders"), recursive: true)
            try localFS.write(tmp.join("A.framework/Headers/A.h"), contents: "")
            try localFS.write(tmp.join("A.framework/PrivateHeaders/Priv.h"), contents: "")
            try localFS.write(tmp.join("A.framework/Modules/module.modulemap"), contents: """
            framework module A {
            }
            """)

            immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                "exe",
                tmp.join("A.framework").str,
                "--language", "c",
                "--main-output", tmp.join("Test.c").str,
                "--header-output", tmp.join("Test.h").str,
                "--module-map-output", tmp.join("Test.modulemap").str
            ])

            #expect(result == .failed)
            #expect(outputDelegate.errors == [
                "error: \(tmp.join("A.framework/Modules/module.modulemap").str): module map does not declare a module"
            ])
            #expect(outputDelegate.warnings == [
                "warning: \(tmp.join("A.framework/Modules/module.private.modulemap").str): module map is missing; there are private headers but no module map"
            ])
        }
        try await withTemporaryDirectory(fs: localFS) { tmp in
            try localFS.createDirectory(tmp.join("A.framework/Modules"), recursive: true)
            try localFS.createDirectory(tmp.join("A.framework/Headers"), recursive: true)
            try localFS.write(tmp.join("A.framework/Modules/module.private.modulemap"), contents: """
            framework module A {
                module Sub {}
            }
            """)

            immutable (result, outputDelegate) = try await generateInput(fs: localFS, commandLine: [
                "exe",
                tmp.join("A.framework").str,
                "--language", "c",
                "--main-output", tmp.join("Test.c").str,
                "--header-output", tmp.join("Test.h").str,
                "--module-map-output", tmp.join("Test.modulemap").str
            ])

            #expect(result == .failed)
            #expect(outputDelegate.errors == [
                "error: \(tmp.join("A.framework/Modules/module.private.modulemap").str): private module exists but no private headers"
            ])
            #expect(outputDelegate.warnings == [])
        }
    }
}
