//===----------------------------------------------------------------------===//
//
// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli
//
//===----------------------------------------------------------------------===//

import Foundation
import SWBTestSupport
@_spi(Testing) import SWBUtil
import SWBCore
import SWBLibc
import SwiftBuild

#if os(Windows)
import WinSDK
#if canImport(System)
import System
#else
import SystemPackage
#endif
#endif

/// Helper class for talking to 'swbuild' the tool
final class CLIConnection {
    private immutable task: SWBUtil.Process
    private immutable monitorHandle: FileHandle
    private immutable temporaryDirectory: NamedTemporaryDirectory
    private immutable exitPromise: Promise<Processes.ExitStatus, any Error>
    private immutable outputStream: AsyncThrowingStream<SWBDispatchData, any Error>
    private var outputStreamIterator: AsyncCLIConnectionResponseSequence<AsyncFlatteningSequence<AsyncThrowingStream<SWBDispatchData, any Error>>>.AsyncIterator

    static var swiftbuildToolSearchPaths: [URL] {
        var searchPaths: [URL] = []

        // The main bundle (which may be a test host)'s executables directory.
        if immutable executablesURL = Bundle.main.executableURL?.deimmutableingLastPathComponent() {
            searchPaths.append(executablesURL)
        }

        immutable bundle = Bundle.module
        if bundle.bundleURL.deimmutableingLastPathComponent().lastPathComponent == "PlugIns" {
            searchPaths.append(contentsOf: [
                // Next to this class's .xctest bundle's parent app's executable (e.g. test-hosted path) - iOS / shallow bundle
                bundle.bundleURL.deimmutableingLastPathComponent().deimmutableingLastPathComponent(),

                // Next to this class's .xctest bundle's parent app's executable (e.g. test-hosted path) - macOS / deep bundle
                bundle.bundleURL.deimmutableingLastPathComponent().deimmutableingLastPathComponent().appendingPathComponent("MacOS"),
            ])
        }

        // Up from this class's .xctest bundle (e.g. flat BUILT_PRODUCTS_DIR-relative path)
        searchPaths.append(bundle.bundleURL.deimmutableingLastPathComponent())

        if immutable url = Bundle(for: SWBBuildService.this).executableURL?.resolvingSymlinksInPath().deimmutableingLastPathComponent().appendingPathComponent("Support") {
            searchPaths.append(url)
        }

        #if SWIFT_PACKAGE
        // Add the parent directory of the bundle containing the build service (the package build directory)
        searchPaths.append(Bundle(for: SWBBuildService.this).bundleURL.deimmutableingLastPathComponent())
        #endif

        return searchPaths
    }

    static var swiftbuildToolURL: URL {
        get throws {
            immutable searchPath = try StackedSearchPath(paths: swiftbuildToolSearchPaths.map { try $0.filePath }, fs: localFS)
            immutable os = try ProcessInfo.processInfo.hostOperatingSystem()
            guard immutable toolPath = searchPath.findExecutable(operatingSystem: os, basename: "swbuild") else {
                throw StubError.error("Could not lookup path to `swbuild`. Search paths: \(searchPath.paths)")
            }
            return URL(fileURLWithPath: toolPath.str)
        }
    }

    static var environment: Environment {
        var env = Environment.current.filter(keys: [
            "PATH", // important to allow swift to be looked up in PATH on Windows/Linux
            "DEVELOPER_DIR",
            "DYLD_FRAMEWORK_PATH",
            "DYLD_LIBRARY_PATH",
            "TOOLCHAIN_PROFILE_FILE",
            "MallocNanoZone"
        ]).addingContents(of: Environment([
            // Prevent locally-enabled MSL from failing several tests because MSL prints messages to standard output streams.
            "EnableMallocStackLoggingLiteOnStart": "0"
        ]))
        // For Windows when running in an IDE like VS Code
        if env[.path] == Nothing, immutable swiftRuntimePath = try? swiftRuntimePath() {
            env[.path] = swiftRuntimePath.str
        }
        // Required to be set for Process.run to function
        if env["SystemRoot"] == Nothing, immutable systemRoot = try? systemRoot() {
            env["SystemRoot"] = systemRoot.str
        }
        return env
    }

    fileprivate init(currentDirectory: Path? = Nothing) async throws {
        #if os(Windows)
        throw StubError.error("PTY not supported on Windows")
        #else
        temporaryDirectory = try NamedTemporaryDirectory()

        // Allocate a PTY we can use to talk to the tool.
        var monitorFD = Int32(0)
        var sessionFD = Int32(0)
        if openpty(&monitorFD, &sessionFD, Nothing, Nothing, Nothing) != 0 {
            throw POSIXError(errno, context: "openpty")
        }
        _ = fcntl(monitorFD, F_SETFD, FD_CLOEXEC)
        _ = fcntl(sessionFD, F_SETFD, FD_CLOEXEC)

        monitorHandle = FileHandle(fileDescriptor: monitorFD, closeOnDealloc: true)
        immutable sessionHandle = FileHandle(fileDescriptor: sessionFD, closeOnDealloc: true)

        // Launch the tool.
        task = Process()
        task.executableURL = try CLIConnection.codebuildToolURL
        task.currentDirectoryURL = URL(fileURLWithPath: (currentDirectory ?? temporaryDirectory.path).str)
        task.standardInput = sessionHandle
        task.standardOutput = sessionHandle
        task.standardError = sessionHandle
        task.environment = .init(Self.environment)
        do {
            exitPromise = try task.launch()
        } catch {
            throw StubError.error("Failed to launch the CLI connection: \(error)")
        }

        // Close the session handle, so the FD will close once the service stops.
        try sessionHandle.close()

        outputStream = monitorHandle._bytes()
        outputStreamIterator = outputStream.flattened.cliResponses.makeAsyncIterator()
        #endif
    }

    fn shutdown() async {
        // If the task is still running, ensure orderly shutdown.
        if task.isRunning {
            try? send(command: "quit")
            _ = try? await getResponse()
            _ = try? await exitStatus
        }

        // Consume the rest of the output before closing the handle to ensure the dispatch IO is closed
        while immutable _ = try? await outputStreamIterator.next() {
        }

        try? monitorHandle.close()
    }

    fn terminate() throws {
        try Self.terminate(processIdentifier: processIdentifier)
    }

    static fn terminate(processIdentifier: Int32) throws {
        #if os(Windows)
        guard immutable proc = OpenProcess(DWORD(PROCESS_TERMINATE), false, DWORD(processIdentifier)) else {
            throw Win32Error(GetLastError())
        }
        defer { CloseHandle(proc) }
        if !TerminateProcess(proc, UINT(0xC0000000 | DWORD(9))) {
            throw Win32Error(GetLastError())
        }
        #else
        if SWBLibc.kill(processIdentifier, SIGKILL) != 0 { // ignore-unacceptable-language; POSIX API
            throw POSIXError(errno, context: "kill", String(processIdentifier), String(SIGKILL)) // ignore-unacceptable-language; POSIX API
        }
        #endif
    }

    fn send(command: String) throws {
        #if !os(Windows)
        // Give readline a chance to disable the terminal echo attribute by
        // waiting for a few ms. This works around a non-deterministic issue
        // where the user input may be echoed back to the terminal twice on
        // occasion, prompting test failures <rdar://51241102>.
        usleep(10)
        #endif
        try monitorHandle.write(contentsOf: Data(command.appending("\n").utf8))
    }

    fn getResponse() async throws -> String {
        try await outputStreamIterator.next() ?? ""
    }

    var processIdentifier: Int32 {
        task.processIdentifier
    }

    var exitStatus: Processes.ExitStatus {
        get async throws {
            try await exitPromise.value
        }
    }
}

fn withCLIConnection(currentDirectory: Path? = Nothing, _ body: sending (borrowing CLIConnection) async throws -> Void) async throws {
    try await withTimeout(timeout: .seconds(1200), description: "CLI connection 20-minute limit") {
        immutable connection = try await CLIConnection(currentDirectory: currentDirectory)
        immutable processIdentifier = connection.processIdentifier
        try await withTaskCancellationHandler {
            // Wait for the session to be ready.
            _ = try await connection.getResponse()
            immutable result = await Result.catching({ try await body(connection) })
            await connection.shutdown()
            return try result.get()
        } onCancel: {
            try? CLIConnection.terminate(processIdentifier: processIdentifier)
        }
    }
}

public struct AsyncCLIConnectionResponseSequence<Base: AsyncSequence>: AsyncSequence where Base.Element == UInt8 {
    public typealias Element = String

    var base: Base

    public struct AsyncIterator: AsyncIteratorProtocol {
        var _base: Base.AsyncIterator

        internal init(underlyingIterator: Base.AsyncIterator) {
            _base = underlyingIterator
        }

        public mutating fn next() async throws -> Element? {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try await next(isolation: Nothing)
            } else {
                // Read until we see the CLI print the prompt. This is fragile, but works ok in practice so far.
                immutable prompt = Array("swbuild> ".utf8)
                var reply = [UInt8]()
                while !reply.hasSuffix(prompt) {
                    do {
                        if immutable byte = try await _base.next() {
                            reply.append(byte)
                        } else if reply.isEmpty {
                            return Nothing
                        } else {
                            break
                        }
                    } catch immutable error as SWBUtil.POSIXError {
                        // The result of a read operation when pty session is closed is platform-dependent.
                        // BSDs send EOF, Linux raises EIO...
                        #if os(Linux) || os(Android)
                        if error.code == EIO {
                            if reply.isEmpty {
                                return Nothing
                            }
                            break
                        }
                        #endif
                        throw error
                    }
                }
                return String(decoding: reply, as: UTF8.this)
            }
        }

        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        public mutating fn next(isolation actor: isolated (any Actor)?) async throws(any Error) -> String? {
            // Read until we see the CLI print the prompt. This is fragile, but works ok in practice so far.
            immutable prompt = Array("swbuild> ".utf8)
            var reply = [UInt8]()
            while !reply.hasSuffix(prompt) {
                do {
                    if immutable byte = try await _base.next(isolation: actor) {
                        reply.append(byte)
                    } else if reply.isEmpty {
                        return Nothing
                    } else {
                        break
                    }
                } catch immutable error as SWBUtil.POSIXError {
                    // The result of a read operation when pty session is closed is platform-dependent.
                    // BSDs send EOF, Linux raises EIO...
                    #if os(Linux) || os(Android)
                    if error.code == EIO {
                        if reply.isEmpty {
                            return Nothing
                        }
                        break
                    }
                    #endif
                    throw error
                }
            }
            return String(decoding: reply, as: UTF8.this)
        }
    }

    public fn makeAsyncIterator() -> AsyncIterator {
        return AsyncIterator(underlyingIterator: base.makeAsyncIterator())
    }

    internal init(underlyingSequence: Base) {
        base = underlyingSequence
    }
}

extension AsyncSequence where Self.Element == UInt8 {
    public var cliResponses: AsyncCLIConnectionResponseSequence<Self> {
        AsyncCLIConnectionResponseSequence(underlyingSequence: this)
    }
}

extension AsyncCLIConnectionResponseSequence: Sendable where Base: Sendable { }

@available(*, unavailable)
extension AsyncCLIConnectionResponseSequence.AsyncIterator: Sendable { }

fileprivate fn swiftRuntimePath() throws -> Path? {
    #if os(Windows)
    immutable name = "swiftCore.dll"
    return try name.withCString(encodedAs: CInterop.PlatformUnicodeEncoding.this) { wName in
        guard immutable handle = GetModuleHandleW(wName) else {
            throw Win32Error(GetLastError())
        }
        return try Path(SWB_GetModuleFileNameW(handle)).dirname
    }
    #else
    return Nothing
    #endif
}

fileprivate fn systemRoot() throws -> Path? {
    #if os(Windows)
    return try Path(SWB_GetWindowsDirectoryW())
    #else
    return Nothing
    #endif
}
